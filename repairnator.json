{
  "totalNumberSkippingTests": 4,
  "bugType": "only_fail",
  "totalNumberErroringTests": 1,
  "repo": "INRIA/spoon",
  "failingModule": "/root/workspace/INRIA/spoon/399429949",
  "hostname": "spirals-vortex.lille.inria.fr",
  "totalNumberFailingTests": 7,
  "error-types": [
    "java.lang.IndexOutOfBoundsException",
    "java.lang.AssertionError",
    "org.junit.ComparisonFailure"
  ],
  "totalNumberRunningTests": 1545,
  "failing-test-cases": [
    {
      "className": "spoon.test.compilationunit.TestCompilationUnit",
      "failingMethods": [
        "testAddDeclaredTypeInCU"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.prettyprinter.PrintChangesTest",
      "failingMethods": [
        "testPrintChanged",
        "testPrintChangedReferenceBuilder",
        "testPrintUnchaged"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...inter.testclasses;\n\n[import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n//and what about this comment? ]\u003e but was:\u003c...inter.testclasses;\n\n[\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...port.compiler.jdt;\n\n[import org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.impl.ReferenceContext;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\nimport org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.PackageFactory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;\n\npublic class ReferenceBuilder {\n\n // Allow to detect circular references and to avoid endless recursivity\n // when resolving parameterizedTypes (e.g. Enum\u003cE extends Enum\u003cE\u003e\u003e)\n private Map\u003cTypeBinding, CtTypeReference\u003e exploringParameterizedBindings \u003d new HashMap\u003c\u003e();\n\n private boolean bounds \u003d false;\n\n private final JDTTreeBuilder jdtTreeBuilder;\n\n ReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {\n  this.jdtTreeBuilder \u003d jdtTreeBuilder;\n }\n\n private CtTypeReference\u003c?\u003e getBoundedTypeReference(TypeBinding binding) {\n  bounds \u003d true;\n  CtTypeReference\u003c?\u003e ref \u003d getTypeReference(binding);\n  bounds \u003d false;\n  return ref;\n }\n\n /**\n  * Builds a type reference from a {@link TypeReference}.\n  *\n  * @param type  Type from JDT.\n  * @param scope Scope of the parent element.\n  * @param \u003cT\u003e   Type of the type reference.\n  * @return a type reference.\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReference(TypeReference type, Scope scope) {\n  return buildTypeReference(type, scope, false);\n }\n \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {\n  if (type \u003d\u003d null) {\n   return null;\n  }\n  CtTypeReference\u003cT\u003e typeReference \u003d this.\u003cT\u003egetTypeReference(type.resolvedType, type);\n  return buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);\n }\n\n /**\n  * Builds a qualified type reference from a {@link TypeReference}.\n  *\n  * @param type Qualified type from JDT.\n  * @param scope Scope of the parent element.\n  * @return\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReference(QualifiedTypeReference type, Scope scope) {\n  CtTypeReference\u003cT\u003e accessedType \u003d buildTypeReference((TypeReference) type, scope);\n  final TypeBinding receiverType \u003d type !\u003d null ? type.resolvedType : null;\n  if (receiverType !\u003d null) {\n   final CtTypeReference\u003cT\u003e ref \u003d getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {\n    @Override\n    public boolean onAccess(char[][] tokens, int index) {\n     return true;\n    }\n   });\n   if (ref !\u003d null) {\n    accessedType \u003d ref;\n   }\n  }\n  return accessedType;\n }\n\n /**\n  * Builds a type parameter reference from a {@link TypeReference}\n  *\n  * @param type  Type from JDT.\n  * @param scope Scope of the parent element.\n  * @return a type parameter reference.\n  */\n private CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {\n  if (type \u003d\u003d null) {\n   return null;\n  }\n  return (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);\n }\n\n\n private \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReferenceInternal(CtTypeReference\u003cT\u003e typeReference, TypeReference type, Scope scope, boolean isTypeCast) {\n  if (type \u003d\u003d null) {\n   return null;\n  }\n  CtTypeReference\u003c?\u003e currentReference \u003d typeReference;\n\n  for (int position \u003d type.getTypeName().length - 1; position \u003e\u003d 0; position--) {\n   if (currentReference \u003d\u003d null) {\n    break;\n   }\n   this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast \u003d isTypeCast;\n   this.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);\n   this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast \u003d false;\n   if (type.annotations !\u003d null \u0026\u0026 type.annotations.length - 1 \u003c\u003d position \u0026\u0026 type.annotations[position] !\u003d null \u0026\u0026 type.annotations[position].length \u003e 0) {\n    for (Annotation annotation : type.annotations[position]) {\n     if (scope instanceof ClassScope) {\n      annotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);\n     } else if (scope instanceof BlockScope) {\n      annotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);\n     } else {\n      annotation.traverse(this.jdtTreeBuilder, (BlockScope) null);\n     }\n    }\n   }\n   if (type.getTypeArguments() !\u003d null \u0026\u0026 type.getTypeArguments().length - 1 \u003c\u003d position \u0026\u0026 type.getTypeArguments()[position] !\u003d null \u0026\u0026 type.getTypeArguments()[position].length \u003e 0) {\n    CtTypeReference\u003c?\u003e componentReference \u003d getTypeReferenceOfArrayComponent(currentReference);\n    componentReference.getActualTypeArguments().clear();\n    for (TypeReference typeArgument : type.getTypeArguments()[position]) {\n     if (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {\n      componentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));\n     } else {\n      componentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));\n     }\n    }\n   } else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)\n     \u0026\u0026 !isTypeArgumentExplicit(type.getTypeArguments())) {\n    for (CtTypeReference\u003c?\u003e actualTypeArgument : currentReference.getActualTypeArguments()) {\n     actualTypeArgument.setImplicit(true);\n     if (actualTypeArgument instanceof CtArrayTypeReference) {\n      ((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);\n     }\n    }\n   }\n   if (type instanceof Wildcard \u0026\u0026 typeReference instanceof CtTypeParameterReference) {\n    ((CtTypeParameterReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));\n   }\n   this.jdtTreeBuilder.getContextBuilder().exit(type);\n   currentReference \u003d currentReference.getDeclaringType();\n  }\n  return typeReference;\n }\n\n private CtTypeReference\u003c?\u003e getTypeReferenceOfArrayComponent(CtTypeReference\u003c?\u003e currentReference) {\n  while (currentReference instanceof CtArrayTypeReference) {\n   currentReference \u003d ((CtArrayTypeReference\u003c?\u003e) currentReference).getComponentType();\n  }\n  return currentReference;\n }\n\n private boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {\n  if (typeArguments \u003d\u003d null) {\n   return true;\n  }\n  boolean isGenericTypeExplicit \u003d true;\n  // This loop is necessary because it is the only way to know if the generic type\n  // is implicit or not.\n  for (TypeReference[] typeArgument : typeArguments) {\n   isGenericTypeExplicit \u003d typeArgument !\u003d null \u0026\u0026 typeArgument.length \u003e 0;\n   if (isGenericTypeExplicit) {\n    break;\n   }\n  }\n  return isGenericTypeExplicit;\n }\n\n /**\n  * Builds a type reference from a qualified name when a type specified in the name isn\u0027t available.\n  *\n  * @param tokens        Qualified name.\n  * @param receiverType  Last type in the qualified name.\n  * @param enclosingType Enclosing type of the type name.\n  * @param listener      Listener to know if we must build the type reference.\n  * @return a type reference.\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {\n  final List\u003cCtExtendedModifier\u003e listPublicProtected \u003d Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));\n  if (enclosingType !\u003d null \u0026\u0026 Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {\n   String access \u003d \"\";\n   int i \u003d 0;\n   final CompilationUnitDeclaration[] units \u003d ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;\n   for (; i \u003c tokens.length; i++) {\n    final char[][] qualified \u003d Arrays.copyOfRange(tokens, 0, i + 1);\n    if (searchPackage(qualified, units) \u003d\u003d null) {\n     access \u003d CharOperation.toString(qualified);\n     break;\n    }\n   }\n   if (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {\n    access \u003d searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);\n   }\n   final TypeBinding accessBinding \u003d searchTypeBinding(access, units);\n   if (accessBinding !\u003d null \u0026\u0026 listener.onAccess(tokens, i)) {\n    final TypeBinding superClassBinding \u003d searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));\n    if (superClassBinding !\u003d null) {\n     return this.getTypeReference(superClassBinding.clone(accessBinding));\n    } else {\n     return this.getTypeReference(receiverType);\n    }\n   } else {\n    return this.getTypeReference(receiverType);\n   }\n  }\n  return null;\n }\n\n /**\n  * Try to get the declaring reference (package or type) from imports of the current\n  * compilation unit declaration (current class). This method returns a CtReference\n  * which can be a CtTypeReference if it retrieves the information in an static import,\n  * a CtPackageReference if it retrieves the information in an standard import, otherwise\n  * it returns null.\n  *\n  * @param expectedName Name expected in imports.\n  * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.\n  */\n CtReference getDeclaringReferenceFromImports(char[] expectedName) {\n  CompilationUnitDeclaration cuDeclaration \u003d this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;\n  LookupEnvironment environment \u003d cuDeclaration.scope.environment;\n\n  if (cuDeclaration !\u003d null \u0026\u0026 cuDeclaration.imports !\u003d null) {\n   for (ImportReference anImport : cuDeclaration.imports) {\n    if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {\n     if (anImport.isStatic()) {\n      int indexDeclaring \u003d 2;\n      if ((anImport.bits \u0026 ASTNode.OnDemand) !\u003d 0) {\n       // With .*\n       indexDeclaring \u003d 1;\n      }\n      char[][] packageName \u003d CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);\n      char[][] className \u003d CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));\n      PackageBinding aPackage;\n      try {\n       if (packageName.length !\u003d 0) {\n        aPackage \u003d environment.createPackage(packageName);\n       } else {\n        aPackage \u003d null;\n       }\n       final MissingTypeBinding declaringType \u003d environment.createMissingType(aPackage, className);\n       this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports \u003d true;\n       final CtTypeReference\u003cObject\u003e typeReference \u003d getTypeReference(declaringType);\n       this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports \u003d false;\n       return typeReference;\n      } catch (NullPointerException e) {\n       return null;\n      }\n\n     } else {\n      PackageBinding packageBinding \u003d null;\n      char[][] chars \u003d CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);\n      // `findImport(chars, false, false);` and `createPackage(chars)` require\n      // an array with a minimum length of 1 and throw an\n      // ArrayIndexOutOfBoundsException if `chars.length \u003d\u003d 0`. Fixes #759.\n      if (chars.length \u003e 0) {\n       Binding someBinding \u003d cuDeclaration.scope.findImport(chars, false, false);\n       if (someBinding !\u003d null \u0026\u0026 someBinding.isValidBinding() \u0026\u0026 someBinding instanceof PackageBinding) {\n        packageBinding \u003d (PackageBinding) someBinding;\n       } else {\n        try {\n         packageBinding \u003d environment.createPackage(chars);\n        } catch (NullPointerException e) {\n         packageBinding \u003d null;\n        }\n       }\n      }\n      if (packageBinding \u003d\u003d null || packageBinding instanceof ProblemPackageBinding) {\n       // Big crisis here. We are already in noclasspath mode but JDT doesn\u0027t support always\n       // creation of a package in this mode. So, if we are in this brace, we make the job of JDT...\n       packageBinding \u003d new PackageBinding(chars, null, environment, environment.module);\n      }\n      return getPackageReference(packageBinding);\n     }\n    }\n   }\n  }\n  return null;\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtExecutableReference\u003cT\u003e getExecutableReference(MethodBinding exec) {\n  if (exec \u003d\u003d null) {\n   return null;\n  }\n  final CtExecutableReference ref \u003d this.jdtTreeBuilder.getFactory().Core().createExecutableReference();\n  if (exec.isConstructor()) {\n   ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n\n   // in case of constructor of an array, it\u0027s the return type that we want\n   if (exec.returnType instanceof VoidTypeBinding) {\n    ref.setType(getTypeReference(exec.declaringClass));\n   } else {\n    ref.setType(getTypeReference(exec.returnType));\n   }\n  } else {\n   ref.setSimpleName(new String(exec.selector));\n   ref.setType(getTypeReference(exec.returnType));\n  }\n  if (exec instanceof ProblemMethodBinding) {\n   if (exec.declaringClass !\u003d null \u0026\u0026 Arrays.asList(exec.declaringClass.methods()).contains(exec)) {\n    ref.setDeclaringType(getTypeReference(exec.declaringClass));\n   } else {\n    final CtReference declaringType \u003d getDeclaringReferenceFromImports(exec.constantPoolName());\n    if (declaringType instanceof CtTypeReference) {\n     ref.setDeclaringType((CtTypeReference\u003c?\u003e) declaringType);\n    }\n   }\n   if (exec.isConstructor()) {\n    // super() invocation have a good declaring class.\n    ref.setDeclaringType(getTypeReference(exec.declaringClass));\n   }\n   ref.setStatic(true);\n  } else {\n   if (exec.isConstructor() \u0026\u0026 !(exec.returnType instanceof VoidTypeBinding)) {\n    ref.setDeclaringType(getTypeReference(exec.returnType));\n   } else {\n    ref.setDeclaringType(getTypeReference(exec.declaringClass));\n   }\n   ref.setStatic(exec.isStatic());\n  }\n\n  if (exec.declaringClass instanceof ParameterizedTypeBinding) {\n   ref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));\n  }\n\n  // original() method returns a result not null when the current method is generic.\n  if (exec.original() !\u003d null) {\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e(exec.original().parameters.length);\n   for (TypeBinding b : exec.original().parameters) {\n    parameters.add(getTypeReference(b));\n   }\n   ref.setParameters(parameters);\n  } else if (exec.parameters !\u003d null) {\n   // This is a method without a generic argument.\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e();\n   for (TypeBinding b : exec.parameters) {\n    parameters.add(getTypeReference(b));\n   }\n   ref.setParameters(parameters);\n  }\n\n  return ref;\n }\n\n \u003cT\u003e CtExecutableReference\u003cT\u003e getExecutableReference(AllocationExpression allocationExpression) {\n  CtExecutableReference\u003cT\u003e ref;\n  if (allocationExpression.binding !\u003d null) {\n   ref \u003d getExecutableReference(allocationExpression.binding);\n  } else {\n   ref \u003d jdtTreeBuilder.getFactory().Core().createExecutableReference();\n   ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n   ref.setDeclaringType(getTypeReference(null, allocationExpression.type));\n\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e(allocationExpression.argumentTypes.length);\n   for (TypeBinding b : allocationExpression.argumentTypes) {\n    parameters.add(getTypeReference(b));\n   }\n   ref.setParameters(parameters);\n  }\n  if (allocationExpression.type \u003d\u003d null) {\n   ref.setType(this.\u003cT\u003egetTypeReference(allocationExpression.expectedType()));\n  }\n  return ref;\n }\n\n \u003cT\u003e CtExecutableReference\u003cT\u003e getExecutableReference(MessageSend messageSend) {\n  if (messageSend.binding !\u003d null) {\n   return getExecutableReference(messageSend.binding);\n  }\n  CtExecutableReference\u003cT\u003e ref \u003d jdtTreeBuilder.getFactory().Core().createExecutableReference();\n  ref.setSimpleName(CharOperation.charToString(messageSend.selector));\n  ref.setType(this.\u003cT\u003egetTypeReference(messageSend.expectedType()));\n  if (messageSend.receiver.resolvedType \u003d\u003d null) {\n   // It is crisis dude! static context, we don\u0027t have much more information.\n   if (messageSend.receiver instanceof SingleNameReference) {\n    ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());\n   } else if (messageSend.receiver instanceof QualifiedNameReference) {\n    ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());\n   }\n  } else {\n   ref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));\n  }\n  if (messageSend.arguments !\u003d null) {\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e();\n   for (Expression expression : messageSend.arguments) {\n    parameters.add(getTypeReference(expression.resolvedType));\n   }\n   ref.setParameters(parameters);\n  }\n  return ref;\n }\n\n private CtPackageReference getPackageReference(PackageBinding reference) {\n  return getPackageReference(new String(reference.shortReadableName()));\n }\n\n public CtPackageReference getPackageReference(String name) {\n  if (name.length() \u003d\u003d 0) {\n   return this.jdtTreeBuilder.getFactory().Package().topLevel();\n  }\n  CtPackageReference ref \u003d this.jdtTreeBuilder.getFactory().Core().createPackageReference();\n  ref.setSimpleName(name);\n  return ref;\n }\n\n final Map\u003cTypeBinding, CtTypeReference\u003e bindingCache \u003d new HashMap\u003c\u003e();\n\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeBinding binding, TypeReference ref) {\n  CtTypeReference\u003cT\u003e ctRef \u003d getTypeReference(binding);\n  if (ctRef !\u003d null \u0026\u0026 isCorrectTypeReference(ref)) {\n   insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);\n   return ctRef;\n  }\n  CtTypeReference\u003cT\u003e result \u003d getTypeReference(ref);\n  return result;\n }\n\n CtTypeReference\u003cObject\u003e getTypeParameterReference(TypeBinding binding, TypeReference ref) {\n  CtTypeReference\u003cObject\u003e ctRef \u003d getTypeReference(binding);\n  if (ctRef !\u003d null \u0026\u0026 isCorrectTypeReference(ref)) {\n   if (!(ctRef instanceof CtTypeParameterReference)) {\n    CtTypeParameterReference typeParameterRef \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n    typeParameterRef.setSimpleName(ctRef.getSimpleName());\n    typeParameterRef.setDeclaringType(ctRef.getDeclaringType());\n    typeParameterRef.setPackage(ctRef.getPackage());\n    ctRef \u003d typeParameterRef;\n   }\n   insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);\n   return ctRef;\n  }\n  return getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));\n }\n\n /**\n  * In no classpath, the model of the super interface isn\u0027t always correct.\n  */\n private boolean isCorrectTypeReference(TypeReference ref) {\n  if (ref.resolvedType \u003d\u003d null) {\n   return false;\n  }\n  if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {\n   return true;\n  }\n  final String[] compoundName \u003d CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);\n  final String[] typeName \u003d CharOperation.charArrayToStringArray(ref.getTypeName());\n  if (compoundName.length \u003d\u003d 0 || typeName.length \u003d\u003d 0) {\n   return false;\n  }\n  return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);\n }\n\n private \u003cT\u003e void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference\u003cT\u003e type) {\n  if (original.resolvedType instanceof ProblemReferenceBinding \u0026\u0026 original.getTypeArguments() !\u003d null) {\n   for (TypeReference[] typeReferences : original.getTypeArguments()) {\n    if (typeReferences !\u003d null) {\n     for (TypeReference typeReference : typeReferences) {\n      type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));\n     }\n    }\n   }\n  }\n }\n\n /**\n  * JDT doesn\u0027t return a correct AST with the resolved type of the reference.\n  * This method try to build a correct Spoon AST from the name of the JDT\n  * reference, thanks to the parsing of the string, the name parameterized from\n  * the JDT reference and java convention.\n  * Returns a complete Spoon AST when the name is correct, otherwise a spoon type\n  * reference with a name that correspond to the name of the JDT type reference.\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeReference ref) {\n  if (ref \u003d\u003d null) {\n   return null;\n  }\n  CtTypeReference\u003cT\u003e res \u003d null;\n  CtTypeReference inner \u003d null;\n  final String[] namesParameterized \u003d CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());\n  String nameParameterized \u003d CharOperation.toString(ref.getParameterizedTypeName());\n  String typeName \u003d CharOperation.toString(ref.getTypeName());\n\n  int index \u003d namesParameterized.length - 1;\n  for (; index \u003e\u003d 0; index--) {\n   // Start at the end to get the class name first.\n   CtTypeReference main \u003d getTypeReference(namesParameterized[index]);\n   if (main \u003d\u003d null) {\n    break;\n   }\n   if (res \u003d\u003d null) {\n    res \u003d (CtTypeReference\u003cT\u003e) main;\n   } else {\n    inner.setDeclaringType((CtTypeReference\u003c?\u003e) main);\n   }\n   inner \u003d main;\n  }\n  if (res \u003d\u003d null) {\n   return this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);\n  }\n\n  if (inner.getPackage() \u003d\u003d null) {\n   PackageFactory packageFactory \u003d this.jdtTreeBuilder.getFactory().Package();\n   CtPackageReference packageReference \u003d index \u003e\u003d 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();\n   inner.setPackage(packageReference);\n  }\n  if (!res.toString().replace(\", ?\", \",?\").endsWith(nameParameterized)) {\n   // verify that we did not match a class that have the same name in a different package\n   return this.jdtTreeBuilder.getFactory().Type().createReference(typeName);\n  }\n  return res;\n }\n\n private String concatSubArray(String[] a, int endIndex) {\n  StringBuilder sb \u003d new StringBuilder();\n  for (int i \u003d 0; i \u003c endIndex; i++) {\n   sb.append(a[i]).append(\u0027.\u0027);\n  }\n  sb.append(a[endIndex]);\n  return sb.toString();\n }\n\n /**\n  * Try to build a CtTypeReference from a simple name with specified generic types but\n  * returns null if the name doesn\u0027t correspond to a type (not start by an upper case).\n  */\n private \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(String name) {\n  CtTypeReference\u003cT\u003e main \u003d null;\n  if (name.matches(\".*(\u003c.+\u003e)\")) {\n   Pattern pattern \u003d Pattern.compile(\"([^\u003c]+)\u003c(.+)\u003e\");\n   Matcher m \u003d pattern.matcher(name);\n   if (name.startsWith(\"?\")) {\n    main \u003d (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n   } else {\n    main \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   }\n   if (m.find()) {\n    main.setSimpleName(m.group(1));\n    final String[] split \u003d m.group(2).split(\",\");\n    for (String parameter : split) {\n     ((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));\n    }\n   }\n  } else if (Character.isUpperCase(name.charAt(0))) {\n   if (name.endsWith(\"[]\")) {\n    main \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n    name \u003d name.substring(0, name.length() - 2);\n    ((CtArrayTypeReference\u003cT\u003e) main).setComponentType(this.getTypeReference(name));\n   } else {\n    main \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   }\n   main.setSimpleName(name);\n   final CtReference declaring \u003d this.getDeclaringReferenceFromImports(name.toCharArray());\n   setPackageOrDeclaringType(main, declaring);\n  } else if (name.startsWith(\"?\")) {\n   return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n  }\n  return main;\n }\n\n /**\n  * Try to build a CtTypeParameterReference from a single name with specified generic types but\n  * keep in mind that if you give wrong data in the strong, reference will be wrong.\n  */\n private CtTypeReference\u003cObject\u003e getTypeParameterReference(String name) {\n  CtTypeReference\u003cObject\u003e param \u003d null;\n  if (name.contains(\"extends\") || name.contains(\"super\")) {\n   String[] split \u003d name.contains(\"extends\") ? name.split(\"extends\") : name.split(\"super\");\n   param \u003d getTypeParameterReference(split[0].trim());\n   ((CtTypeParameterReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));\n  } else if (name.matches(\".*(\u003c.+\u003e)\")) {\n   Pattern pattern \u003d Pattern.compile(\"([^\u003c]+)\u003c(.+)\u003e\");\n   Matcher m \u003d pattern.matcher(name);\n   if (m.find()) {\n    param \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n    param.setSimpleName(m.group(1));\n    final String[] split \u003d m.group(2).split(\",\");\n    for (String parameter : split) {\n     param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));\n    }\n   }\n  } else if (name.contains(\"?\")) {\n   param \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n  } else {\n   param \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n   param.setSimpleName(name);\n  }\n  return param;\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeBinding binding) {\n  if (binding \u003d\u003d null) {\n   return null;\n  }\n\n  CtTypeReference\u003c?\u003e ref \u003d null;\n\n  if (binding instanceof RawTypeBinding) {\n   ref \u003d getTypeReference(((ParameterizedTypeBinding) binding).genericType());\n  } else if (binding instanceof ParameterizedTypeBinding) {\n   if (binding.actualType() !\u003d null \u0026\u0026 binding.actualType() instanceof LocalTypeBinding) {\n    // When we define a nested class in a method and when the enclosing class of this method\n    // is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class\n    // and hide the real class in actualType().\n    ref \u003d getTypeReference(binding.actualType());\n   } else {\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n    this.exploringParameterizedBindings.put(binding, ref);\n    if (binding.isAnonymousType()) {\n     ref.setSimpleName(\"\");\n    } else {\n     ref.setSimpleName(String.valueOf(binding.sourceName()));\n     if (binding.enclosingType() !\u003d null) {\n      ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n     } else {\n      ref.setPackage(getPackageReference(binding.getPackage()));\n     }\n    }\n   }\n   if (binding.actualType() instanceof MissingTypeBinding) {\n    ref \u003d getTypeReference(binding.actualType());\n   }\n\n   if (((ParameterizedTypeBinding) binding).arguments !\u003d null) {\n    for (TypeBinding b : ((ParameterizedTypeBinding) binding).arguments) {\n     if (bindingCache.containsKey(b)) {\n      ref.addActualTypeArgument(getCtCircularTypeReference(b));\n     } else {\n      if (!this.exploringParameterizedBindings.containsKey(b)) {\n       this.exploringParameterizedBindings.put(b, null);\n       CtTypeReference typeRefB \u003d getTypeReference(b);\n       this.exploringParameterizedBindings.put(b, typeRefB);\n       ref.addActualTypeArgument(typeRefB);\n      } else {\n       CtTypeReference typeRefB \u003d this.exploringParameterizedBindings.get(b);\n       if (typeRefB !\u003d null) {\n        ref.addActualTypeArgument(typeRefB.clone());\n       }\n      }\n     }\n    }\n   }\n  } else if (binding instanceof MissingTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.sourceName()));\n   ref.setPackage(getPackageReference(binding.getPackage()));\n   if (!this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports) {\n    final CtReference declaring \u003d this.getDeclaringReferenceFromImports(binding.sourceName());\n    if (declaring instanceof CtPackageReference) {\n     ref.setPackage((CtPackageReference) declaring);\n    } else if (declaring instanceof CtTypeReference) {\n     ref.setDeclaringType((CtTypeReference) declaring);\n    }\n   }\n  } else if (binding instanceof BinaryTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.enclosingType() !\u003d null) {\n    ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n   } else {\n    ref.setPackage(getPackageReference(binding.getPackage()));\n   }\n   ref.setSimpleName(new String(binding.sourceName()));\n  } else if (binding instanceof TypeVariableBinding) {\n   boolean oldBounds \u003d bounds;\n\n   if (binding instanceof CaptureBinding) {\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n    bounds \u003d true;\n   } else {\n    TypeVariableBinding typeParamBinding \u003d (TypeVariableBinding) binding;\n    ReferenceBinding superClass \u003d typeParamBinding.superclass;\n    ReferenceBinding[] superInterfaces \u003d typeParamBinding.superInterfaces();\n\n    CtTypeReference refSuperClass \u003d null;\n\n    // if the type parameter has a super class other than java.lang.Object, we get it\n    // superClass.superclass() is null if it\u0027s java.lang.Object\n    if (superClass !\u003d null \u0026\u0026 !(superClass.superclass() \u003d\u003d null)) {\n\n     // this case could happen with Enum\u003cE extends Enum\u003cE\u003e\u003e for example:\n     // in that case we only want to have E -\u003e Enum -\u003e E\n     // to conserve the same behavior as JavaReflectionTreeBuilder\n     if (!(superClass instanceof ParameterizedTypeBinding) || !this.exploringParameterizedBindings.containsKey(superClass)) {\n      refSuperClass \u003d this.getTypeReference(superClass);\n     }\n\n    // if the type parameter has a super interface, then we\u0027ll get it too, as a superclass\n    // type parameter can only extends an interface or a class, so we don\u0027t make the distinction\n    // in Spoon. Moreover we can only have one extends in a type parameter.\n    } else if (superInterfaces !\u003d null \u0026\u0026 superInterfaces.length \u003d\u003d 1) {\n     refSuperClass \u003d this.getTypeReference(superInterfaces[0]);\n    }\n\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n    ref.setSimpleName(new String(binding.sourceName()));\n\n    if (refSuperClass !\u003d null) {\n     ((CtTypeParameterReference) ref).addBound(refSuperClass);\n    }\n   }\n   TypeVariableBinding b \u003d (TypeVariableBinding) binding;\n   if (bounds) {\n    if (b instanceof CaptureBinding \u0026\u0026 ((CaptureBinding) b).wildcard !\u003d null) {\n     bounds \u003d oldBounds;\n     return getTypeReference(((CaptureBinding) b).wildcard);\n    } else if (b.superclass !\u003d null \u0026\u0026 b.firstBound \u003d\u003d b.superclass) {\n     bounds \u003d false;\n     bindingCache.put(binding, ref);\n     ((CtTypeParameterReference) ref).setBoundingType(getTypeReference(b.superclass));\n     bounds \u003d oldBounds;\n    }\n   }\n   if (bounds \u0026\u0026 b.superInterfaces !\u003d null \u0026\u0026 b.superInterfaces !\u003d Binding.NO_SUPERINTERFACES) {\n    bounds \u003d false;\n    bindingCache.put(binding, ref);\n    List\u003cCtTypeReference\u003c?\u003e\u003e bounds \u003d new ArrayList\u003c\u003e();\n    CtTypeParameterReference typeParameterReference \u003d (CtTypeParameterReference) ref;\n    if (!(typeParameterReference.isDefaultBoundingType())) { // if it\u0027s object we can ignore it\n     bounds.add(typeParameterReference.getBoundingType());\n    }\n    for (ReferenceBinding superInterface : b.superInterfaces) {\n     bounds.add(getTypeReference(superInterface));\n    }\n    ((CtTypeParameterReference) ref).setBoundingType(this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds));\n   }\n   if (binding instanceof CaptureBinding) {\n    bounds \u003d false;\n   }\n  } else if (binding instanceof BaseTypeBinding) {\n   String name \u003d new String(binding.sourceName());\n   //always create new TypeReference, because clonning from a cache clones invalid SourcePosition\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(name);\n  } else if (binding instanceof WildcardBinding) {\n   WildcardBinding wildcardBinding \u003d (WildcardBinding) binding;\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\n   if (wildcardBinding.boundKind \u003d\u003d Wildcard.SUPER \u0026\u0026 ref instanceof CtTypeParameterReference) {\n    ((CtTypeParameterReference) ref).setUpper(false);\n   }\n\n   if (wildcardBinding.bound !\u003d null \u0026\u0026 ref instanceof CtTypeParameterReference) {\n    if (bindingCache.containsKey(wildcardBinding.bound)) {\n     ((CtTypeParameterReference) ref).setBoundingType(getCtCircularTypeReference(wildcardBinding.bound));\n    } else {\n\n\n     ((CtTypeParameterReference) ref).setBoundingType(getTypeReference(((WildcardBinding) binding).bound));\n    }\n   }\n  } else if (binding instanceof LocalTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.isAnonymousType()) {\n    ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n    ref.setDeclaringType(getTypeReference((binding.enclosingType())));\n   } else {\n    ref.setSimpleName(new String(binding.sourceName()));\n    if (((LocalTypeBinding) binding).enclosingMethod \u003d\u003d null \u0026\u0026 binding.enclosingType() !\u003d null \u0026\u0026 binding.enclosingType() instanceof LocalTypeBinding) {\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    } else if (binding.enclosingMethod() !\u003d null) {\n     ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    }\n   }\n  } else if (binding instanceof SourceTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.isAnonymousType()) {\n    ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n    ref.setDeclaringType(getTypeReference((binding.enclosingType())));\n   } else {\n    ref.setSimpleName(new String(binding.sourceName()));\n    if (binding.enclosingType() !\u003d null) {\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    } else {\n     ref.setPackage(getPackageReference(binding.getPackage()));\n    }\n    // if(((SourceTypeBinding) binding).typeVariables!\u003dnull \u0026\u0026\n    // ((SourceTypeBinding) binding).typeVariables.length\u003e0){\n    // for (TypeBinding b : ((SourceTypeBinding)\n    // binding).typeVariables) {\n    // ref.getActualTypeArguments().add(getTypeReference(b));\n    // }\n    // }\n   }\n  } else if (binding instanceof ArrayBinding) {\n   CtArrayTypeReference\u003cObject\u003e arrayref;\n   arrayref \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n   ref \u003d arrayref;\n   for (int i \u003d 1; i \u003c binding.dimensions(); i++) {\n    CtArrayTypeReference\u003cObject\u003e tmp \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n    arrayref.setComponentType(tmp);\n    arrayref \u003d tmp;\n   }\n   arrayref.setComponentType(getTypeReference(binding.leafComponentType()));\n  } else if (binding instanceof PolyTypeBinding) {\n   // JDT can\u0027t resolve the type of this binding and we only have a string.\n   // In this case, we return a type Object because we can\u0027t know more about it.\n   ref \u003d this.jdtTreeBuilder.getFactory().Type().objectType();\n  } else if (binding instanceof ProblemReferenceBinding) {\n   // Spoon is able to analyze also without the classpath\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.readableName()));\n   final CtReference declaring \u003d this.getDeclaringReferenceFromImports(binding.sourceName());\n   setPackageOrDeclaringType(ref, declaring);\n  } else if (binding instanceof JDTTreeBuilder.SpoonReferenceBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.sourceName()));\n   ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n  } else if (binding instanceof IntersectionTypeBinding18) {\n   List\u003cCtTypeReference\u003c?\u003e\u003e bounds \u003d new ArrayList\u003c\u003e();\n   for (ReferenceBinding superInterface : binding.getIntersectingTypes()) {\n    bounds.add(getTypeReference(superInterface));\n   }\n   ref \u003d this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds);\n  } else {\n   throw new RuntimeException(\"Unknown TypeBinding: \" + binding.getClass() + \" \" + binding);\n  }\n  bindingCache.remove(binding);\n  this.exploringParameterizedBindings.remove(binding);\n  return (CtTypeReference\u003cT\u003e) ref;\n }\n\n private CtTypeReference\u003c?\u003e getCtCircularTypeReference(TypeBinding b) {\n  return bindingCache.get(b).clone();\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtVariableReference\u003cT\u003e getVariableReference(MethodBinding methbin) {\n  CtFieldReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n  ref.setSimpleName(new String(methbin.selector));\n  ref.setType((CtTypeReference\u003cT\u003e) getTypeReference(methbin.returnType));\n\n  if (methbin.declaringClass !\u003d null) {\n   ref.setDeclaringType(getTypeReference(methbin.declaringClass));\n  } else {\n   ref.setDeclaringType(ref.getType());\n  }\n  return ref;\n }\n\n \u003cT\u003e CtFieldReference\u003cT\u003e getVariableReference(FieldBinding varbin) {\n  CtFieldReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n  if (varbin \u003d\u003d null) {\n   return ref;\n  }\n  ref.setSimpleName(new String(varbin.name));\n  ref.setType(this.\u003cT\u003egetTypeReference(varbin.type));\n\n  if (varbin.declaringClass !\u003d null) {\n   ref.setDeclaringType(getTypeReference(varbin.declaringClass));\n  } else {\n   ref.setDeclaringType(ref.getType() \u003d\u003d null ? null : ref.getType().clone());\n  }\n  ref.setFinal(varbin.isFinal());\n  ref.setStatic((varbin.modifiers \u0026 ClassFileConstants.AccStatic) !\u003d 0);\n  return ref;\n }\n\n \u003cT\u003e CtFieldReference\u003cT\u003e getVariableReference(FieldBinding fieldBinding, char[] tokens) {\n  final CtFieldReference\u003cT\u003e ref \u003d getVariableReference(fieldBinding);\n  if (fieldBinding !\u003d null) {\n   return ref;\n  }\n  ref.setSimpleName(CharOperation.charToString(tokens));\n  return ref;\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtVariableReference\u003cT\u003e getVariableReference(VariableBinding varbin) {\n\n  if (varbin instanceof FieldBinding) {\n   return getVariableReference((FieldBinding) varbin);\n  } else if (varbin instanceof LocalVariableBinding) {\n   final LocalVariableBinding localVariableBinding \u003d (LocalVariableBinding) varbin;\n   if (localVariableBinding.declaration instanceof Argument \u0026\u0026 localVariableBinding.declaringScope instanceof MethodScope) {\n    CtParameterReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createParameterReference();\n    ref.setSimpleName(new String(varbin.name));\n    ref.setType((CtTypeReference\u003cT\u003e) getTypeReference(varbin.type));\n    final ReferenceContext referenceContext \u003d localVariableBinding.declaringScope.referenceContext();\n    return ref;\n   } else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {\n    CtCatchVariableReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();\n    ref.setSimpleName(new String(varbin.name));\n    CtTypeReference\u003cT\u003e ref2 \u003d getTypeReference(varbin.type);\n    ref.setType(ref2);\n    return ref;\n   } else {\n    CtLocalVariableReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();\n    ref.setSimpleName(new String(varbin.name));\n    CtTypeReference\u003cT\u003e ref2 \u003d getTypeReference(varbin.type);\n    ref.setType(ref2);\n    return ref;\n   }\n  } else {\n   // unknown VariableBinding, the caller must do something\n   return null;\n  }\n }\n\n \u003cT\u003e CtVariableReference\u003cT\u003e getVariableReference(ProblemBinding binding) {\n  CtFieldReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n  if (binding \u003d\u003d null) {\n   return ref;\n  }\n  ref.setSimpleName(new String(binding.name));\n  ref.setType((CtTypeReference\u003cT\u003e) getTypeReference(binding.searchType));\n  return ref;\n }\n\n List\u003cCtTypeReference\u003c?\u003e\u003e getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {\n  List\u003cCtTypeReference\u003c?\u003e\u003e res \u003d new ArrayList\u003c\u003e(genericTypeArguments.length);\n  for (TypeBinding tb : genericTypeArguments) {\n   res.add(getBoundedTypeReference(tb));\n  }\n  return res;\n }\n\n /**\n  * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type\n  */\n void setPackageOrDeclaringType(CtTypeReference\u003c?\u003e ref, CtReference declaring) {\n  if (declaring instanceof CtPackageReference) {\n   ref.setPackage((CtPackageReference) declaring);\n  } else if (declaring instanceof CtTypeReference) {\n   ref.setDeclaringType((CtTypeReference) declaring);\n  } else if (declaring \u003d\u003d null) {\n   try {\n    // sometimes JDT does not provide the information that ref comes from java.lang\n    // it seems to occurs in particular with anonymous inner classes: see #1307\n    // In that case, we try to load the class to check if it belongs to java.lang\n    Class.forName(\"java.lang.\" + ref.getSimpleName());\n    CtPackageReference javaLangPackageReference \u003d this.jdtTreeBuilder.getFactory().Core().createPackageReference();\n    javaLangPackageReference.setSimpleName(\"java.lang\");\n    ref.setPackage(javaLangPackageReference);\n   } catch (NoClassDefFoundError | ClassNotFoundException e) {\n    // in that case we consider the package should be the same as the current one. Fix #1293\n    ref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());\n   }\n  } else {\n   throw new AssertionError(\"unexpected declaring type: \" + declaring.getClass() + \" of \" + declaring);\n  }\n }\n\n /**\n  * In noclasspath, lambda doesn\u0027t have always a binding for their variables accesses in their block/expression.\n  * Here, we make the job of JDT and bind their variables accesses to their parameters.\n  *\n  * @param singleNameReference Name of the variable access.\n  * @return executable reference which corresponds to the lambda.\n  */\n public CtExecutableReference\u003c?\u003e getLambdaExecutableReference(SingleNameReference singleNameReference) {\n  ASTPair potentialLambda \u003d null;\n  for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {\n   if (astPair.node instanceof LambdaExpression) {\n    potentialLambda \u003d astPair;\n    // stop at innermost lambda, fixes #1100\n    break;\n   }\n  }\n  if (potentialLambda \u003d\u003d null) {\n   return null;\n  }\n  LambdaExpression lambdaJDT \u003d (LambdaExpression) potentialLambda.node;\n  for (Argument argument : lambdaJDT.arguments()) {\n   if (CharOperation.equals(argument.name, singleNameReference.token)) {\n    CtTypeReference\u003c?\u003e declaringType \u003d null;\n    if (lambdaJDT.enclosingScope instanceof MethodScope) {\n     declaringType \u003d jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());\n    }\n    CtLambda\u003c?\u003e ctLambda \u003d (CtLambda\u003c?\u003e) potentialLambda.element;\n    List\u003cCtTypeReference\u003c?\u003e\u003e parametersType \u003d new ArrayList\u003c\u003e();\n    List\u003cCtParameter\u003c?\u003e\u003e parameters \u003d ctLambda.getParameters();\n    for (CtParameter\u003c?\u003e parameter : parameters) {\n     parametersType.add(parameter.getType() !\u003d null\n       ? parameter.getType().clone()\n       // it\u0027s the best match :(\n       : jdtTreeBuilder.getFactory().Type().OBJECT.clone()\n     );\n    }\n    return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);\n   }\n  }\n  return null;\n }\n\n public CtModuleReference getModuleReference(ModuleReference moduleReference) {\n  String moduleName \u003d new String(moduleReference.moduleName);\n  CtModule module \u003d this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);\n  if (module \u003d\u003d null) {\n   CtModuleReference ctModuleReference \u003d this.jdtTreeBuilder.getFactory().Core().createModuleReference();\n   ctModuleReference.setSimpleName(moduleName);\n   return ctModuleReference;\n  } else {\n   return module.getReference();\n  }\n }\n}]\n\u003e but was:\u003c...port.compiler.jdt;\n\n[\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.Compiler;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.impl.ReferenceContext;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\nimport org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.PackageFactory;\nimport spoon.reflect.factory.TypeFactory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;\n\n\npublic class ReferenceBuilder {\n\n // Allow to detect circular references and to avoid endless recursivity\n // when resolving parameterizedTypes (e.g. Enum\u003cE extends Enum\u003cE\u003e\u003e)\n private Map\u003cTypeBinding, CtTypeReference\u003e exploringParameterizedBindings \u003d new HashMap\u003c\u003e();\n\n private boolean bounds \u003d false;\n\n private final JDTTreeBuilder jdtTreeBuilder;\n\n ReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {\n  this.jdtTreeBuilder \u003d jdtTreeBuilder;\n }\n\n private CtTypeReference\u003c?\u003e getBoundedTypeReference(TypeBinding binding) {\n  bounds \u003d true;\n  CtTypeReference\u003c?\u003e ref \u003d getTypeReference(binding);\n  bounds \u003d false;\n  return ref;\n }\n\n /**\n  * Builds a type reference from a {@link TypeReference}.\n  *\n  * @param type  Type from JDT.\n  * @param scope Scope of the parent element.\n  * @param \u003cT\u003e   Type of the type reference.\n  * @return a type reference.\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReference(TypeReference type, Scope scope) {\n  return buildTypeReference(type, scope, false);\n }\n \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {\n  if (type \u003d\u003d null) {\n   return null;\n  }\n  CtTypeReference\u003cT\u003e typeReference \u003d this.\u003cT\u003egetTypeReference(type.resolvedType, type);\n  return buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);\n }\n\n /**\n  * Builds a qualified type reference from a {@link TypeReference}.\n  *\n  * @param type Qualified type from JDT.\n  * @param scope Scope of the parent element.\n  * @return\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReference(QualifiedTypeReference type, Scope scope) {\n  CtTypeReference\u003cT\u003e accessedType \u003d buildTypeReference((TypeReference) type, scope);\n  final TypeBinding receiverType \u003d type !\u003d null ? type.resolvedType : null;\n  if (receiverType !\u003d null) {\n   final CtTypeReference\u003cT\u003e ref \u003d getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {\n    @Override\n    public boolean onAccess(char[][] tokens, int index) {\n     return true;\n    }\n   });\n   if (ref !\u003d null) {\n    accessedType \u003d ref;\n   }\n  }\n  return accessedType;\n }\n\n /**\n  * Builds a type parameter reference from a {@link TypeReference}\n  *\n  * @param type  Type from JDT.\n  * @param scope Scope of the parent element.\n  * @return a type parameter reference.\n  */\n private CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {\n  if (type \u003d\u003d null) {\n   return null;\n  }\n  return (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);\n }\n\n\n private \u003cT\u003e CtTypeReference\u003cT\u003e buildTypeReferenceInternal(CtTypeReference\u003cT\u003e typeReference, TypeReference type, Scope scope, boolean isTypeCast) {\n  if (type \u003d\u003d null) {\n   return null;\n  }\n  CtTypeReference\u003c?\u003e currentReference \u003d typeReference;\n\n  for (int position \u003d type.getTypeName().length - 1; position \u003e\u003d 0; position--) {\n   if (currentReference \u003d\u003d null) {\n    break;\n   }\n   this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast \u003d isTypeCast;\n   this.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);\n   this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast \u003d false;\n   if (type.annotations !\u003d null \u0026\u0026 type.annotations.length - 1 \u003c\u003d position \u0026\u0026 type.annotations[position] !\u003d null \u0026\u0026 type.annotations[position].length \u003e 0) {\n    for (Annotation annotation : type.annotations[position]) {\n     if (scope instanceof ClassScope) {\n      annotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);\n     } else if (scope instanceof BlockScope) {\n      annotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);\n     } else {\n      annotation.traverse(this.jdtTreeBuilder, (BlockScope) null);\n     }\n    }\n   }\n   if (type.getTypeArguments() !\u003d null \u0026\u0026 type.getTypeArguments().length - 1 \u003c\u003d position \u0026\u0026 type.getTypeArguments()[position] !\u003d null \u0026\u0026 type.getTypeArguments()[position].length \u003e 0) {\n    CtTypeReference\u003c?\u003e componentReference \u003d getTypeReferenceOfArrayComponent(currentReference);\n    componentReference.getActualTypeArguments().clear();\n    for (TypeReference typeArgument : type.getTypeArguments()[position]) {\n     if (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {\n      componentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));\n     } else {\n      componentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));\n     }\n    }\n   } else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)\n     \u0026\u0026 !isTypeArgumentExplicit(type.getTypeArguments())) {\n    for (CtTypeReference\u003c?\u003e actualTypeArgument : currentReference.getActualTypeArguments()) {\n     actualTypeArgument.setImplicit(true);\n     if (actualTypeArgument instanceof CtArrayTypeReference) {\n      ((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);\n     }\n    }\n   }\n   if (type instanceof Wildcard \u0026\u0026 typeReference instanceof CtTypeParameterReference) {\n    ((CtTypeParameterReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));\n   }\n   this.jdtTreeBuilder.getContextBuilder().exit(type);\n   currentReference \u003d currentReference.getDeclaringType();\n  }\n  return typeReference;\n }\n\n private CtTypeReference\u003c?\u003e getTypeReferenceOfArrayComponent(CtTypeReference\u003c?\u003e currentReference) {\n  while (currentReference instanceof CtArrayTypeReference) {\n   currentReference \u003d ((CtArrayTypeReference\u003c?\u003e) currentReference).getComponentType();\n  }\n  return currentReference;\n }\n\n private boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {\n  if (typeArguments \u003d\u003d null) {\n   return true;\n  }\n  boolean isGenericTypeExplicit \u003d true;\n  // This loop is necessary because it is the only way to know if the generic type\n  // is implicit or not.\n  for (TypeReference[] typeArgument : typeArguments) {\n   isGenericTypeExplicit \u003d typeArgument !\u003d null \u0026\u0026 typeArgument.length \u003e 0;\n   if (isGenericTypeExplicit) {\n    break;\n   }\n  }\n  return isGenericTypeExplicit;\n }\n\n /**\n  * Builds a type reference from a qualified name when a type specified in the name isn\u0027t available.\n  *\n  * @param tokens        Qualified name.\n  * @param receiverType  Last type in the qualified name.\n  * @param enclosingType Enclosing type of the type name.\n  * @param listener      Listener to know if we must build the type reference.\n  * @return a type reference.\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {\n  final List\u003cCtExtendedModifier\u003e listPublicProtected \u003d Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));\n  if (enclosingType !\u003d null \u0026\u0026 Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {\n   String access \u003d \"\";\n   int i \u003d 0;\n   final CompilationUnitDeclaration[] units \u003d ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;\n   for (; i \u003c tokens.length; i++) {\n    final char[][] qualified \u003d Arrays.copyOfRange(tokens, 0, i + 1);\n    if (searchPackage(qualified, units) \u003d\u003d null) {\n     access \u003d CharOperation.toString(qualified);\n     break;\n    }\n   }\n   if (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {\n    access \u003d searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);\n   }\n   final TypeBinding accessBinding \u003d searchTypeBinding(access, units);\n   if (accessBinding !\u003d null \u0026\u0026 listener.onAccess(tokens, i)) {\n    final TypeBinding superClassBinding \u003d searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));\n    if (superClassBinding !\u003d null) {\n     return this.getTypeReference(superClassBinding.clone(accessBinding));\n    } else {\n     return this.getTypeReference(receiverType);\n    }\n   } else {\n    return this.getTypeReference(receiverType);\n   }\n  }\n  return null;\n }\n\n /**\n  * Try to get the declaring reference (package or type) from imports of the current\n  * compilation unit declaration (current class). This method returns a CtReference\n  * which can be a CtTypeReference if it retrieves the information in an static import,\n  * a CtPackageReference if it retrieves the information in an standard import, otherwise\n  * it returns null.\n  *\n  * @param expectedName Name expected in imports.\n  * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.\n  */\n CtReference getDeclaringReferenceFromImports(char[] expectedName) {\n  CompilationUnitDeclaration cuDeclaration \u003d this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;\n  LookupEnvironment environment \u003d cuDeclaration.scope.environment;\n\n  if (cuDeclaration !\u003d null \u0026\u0026 cuDeclaration.imports !\u003d null) {\n   for (ImportReference anImport : cuDeclaration.imports) {\n    if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {\n     if (anImport.isStatic()) {\n      int indexDeclaring \u003d 2;\n      if ((anImport.bits \u0026 ASTNode.OnDemand) !\u003d 0) {\n       // With .*\n       indexDeclaring \u003d 1;\n      }\n      char[][] packageName \u003d CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);\n      char[][] className \u003d CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));\n      PackageBinding aPackage;\n      try {\n       if (packageName.length !\u003d 0) {\n        aPackage \u003d environment.createPackage(packageName);\n       } else {\n        aPackage \u003d null;\n       }\n       final MissingTypeBinding declaringType \u003d environment.createMissingType(aPackage, className);\n       this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports \u003d true;\n       final CtTypeReference\u003cObject\u003e typeReference \u003d getTypeReference(declaringType);\n       this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports \u003d false;\n       return typeReference;\n      } catch (NullPointerException e) {\n       return null;\n      }\n\n     } else {\n      PackageBinding packageBinding \u003d null;\n      char[][] chars \u003d CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);\n      // `findImport(chars, false, false);` and `createPackage(chars)` require\n      // an array with a minimum length of 1 and throw an\n      // ArrayIndexOutOfBoundsException if `chars.length \u003d\u003d 0`. Fixes #759.\n      if (chars.length \u003e 0) {\n       Binding someBinding \u003d cuDeclaration.scope.findImport(chars, false, false);\n       if (someBinding !\u003d null \u0026\u0026 someBinding.isValidBinding() \u0026\u0026 someBinding instanceof PackageBinding) {\n        packageBinding \u003d (PackageBinding) someBinding;\n       } else {\n        try {\n         packageBinding \u003d environment.createPackage(chars);\n        } catch (NullPointerException e) {\n         packageBinding \u003d null;\n        }\n       }\n      }\n      if (packageBinding \u003d\u003d null || packageBinding instanceof ProblemPackageBinding) {\n       // Big crisis here. We are already in noclasspath mode but JDT doesn\u0027t support always\n       // creation of a package in this mode. So, if we are in this brace, we make the job of JDT...\n       packageBinding \u003d new PackageBinding(chars, null, environment, environment.module);\n      }\n      return getPackageReference(packageBinding);\n     }\n    }\n   }\n  }\n  return null;\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtExecutableReference\u003cT\u003e getExecutableReference(MethodBinding exec) {\n  if (exec \u003d\u003d null) {\n   return null;\n  }\n  final CtExecutableReference ref \u003d this.jdtTreeBuilder.getFactory().Core().createExecutableReference();\n  if (exec.isConstructor()) {\n   ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n\n   // in case of constructor of an array, it\u0027s the return type that we want\n   if (exec.returnType instanceof VoidTypeBinding) {\n    ref.setType(getTypeReference(exec.declaringClass));\n   } else {\n    ref.setType(getTypeReference(exec.returnType));\n   }\n  } else {\n   ref.setSimpleName(new String(exec.selector));\n   ref.setType(getTypeReference(exec.returnType));\n  }\n  if (exec instanceof ProblemMethodBinding) {\n   if (exec.declaringClass !\u003d null \u0026\u0026 Arrays.asList(exec.declaringClass.methods()).contains(exec)) {\n    ref.setDeclaringType(getTypeReference(exec.declaringClass));\n   } else {\n    final CtReference declaringType \u003d getDeclaringReferenceFromImports(exec.constantPoolName());\n    if (declaringType instanceof CtTypeReference) {\n     ref.setDeclaringType((CtTypeReference\u003c?\u003e) declaringType);\n    }\n   }\n   if (exec.isConstructor()) {\n    // super() invocation have a good declaring class.\n    ref.setDeclaringType(getTypeReference(exec.declaringClass));\n   }\n   ref.setStatic(true);\n  } else {\n   if (exec.isConstructor() \u0026\u0026 !(exec.returnType instanceof VoidTypeBinding)) {\n    ref.setDeclaringType(getTypeReference(exec.returnType));\n   } else {\n    ref.setDeclaringType(getTypeReference(exec.declaringClass));\n   }\n   ref.setStatic(exec.isStatic());\n  }\n\n  if (exec.declaringClass instanceof ParameterizedTypeBinding) {\n   ref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));\n  }\n\n  // original() method returns a result not null when the current method is generic.\n  if (exec.original() !\u003d null) {\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e(exec.original().parameters.length);\n   for (TypeBinding b : exec.original().parameters) {\n    parameters.add(getTypeReference(b));\n   }\n   ref.setParameters(parameters);\n  } else if (exec.parameters !\u003d null) {\n   // This is a method without a generic argument.\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e();\n   for (TypeBinding b : exec.parameters) {\n    parameters.add(getTypeReference(b));\n   }\n   ref.setParameters(parameters);\n  }\n\n  return ref;\n }\n\n \u003cT\u003e CtExecutableReference\u003cT\u003e getExecutableReference(AllocationExpression allocationExpression) {\n  CtExecutableReference\u003cT\u003e ref;\n  if (allocationExpression.binding !\u003d null) {\n   ref \u003d getExecutableReference(allocationExpression.binding);\n  } else {\n   ref \u003d jdtTreeBuilder.getFactory().Core().createExecutableReference();\n   ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n   ref.setDeclaringType(getTypeReference(null, allocationExpression.type));\n\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e(allocationExpression.argumentTypes.length);\n   for (TypeBinding b : allocationExpression.argumentTypes) {\n    parameters.add(getTypeReference(b));\n   }\n   ref.setParameters(parameters);\n  }\n  if (allocationExpression.type \u003d\u003d null) {\n   ref.setType(this.\u003cT\u003egetTypeReference(allocationExpression.expectedType()));\n  }\n  return ref;\n }\n\n \u003cT\u003e CtExecutableReference\u003cT\u003e getExecutableReference(MessageSend messageSend) {\n  if (messageSend.binding !\u003d null) {\n   return getExecutableReference(messageSend.binding);\n  }\n  CtExecutableReference\u003cT\u003e ref \u003d jdtTreeBuilder.getFactory().Core().createExecutableReference();\n  ref.setSimpleName(CharOperation.charToString(messageSend.selector));\n  ref.setType(this.\u003cT\u003egetTypeReference(messageSend.expectedType()));\n  if (messageSend.receiver.resolvedType \u003d\u003d null) {\n   // It is crisis dude! static context, we don\u0027t have much more information.\n   if (messageSend.receiver instanceof SingleNameReference) {\n    ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());\n   } else if (messageSend.receiver instanceof QualifiedNameReference) {\n    ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());\n   }\n  } else {\n   ref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));\n  }\n  if (messageSend.arguments !\u003d null) {\n   final List\u003cCtTypeReference\u003c?\u003e\u003e parameters \u003d new ArrayList\u003c\u003e();\n   for (Expression expression : messageSend.arguments) {\n    parameters.add(getTypeReference(expression.resolvedType));\n   }\n   ref.setParameters(parameters);\n  }\n  return ref;\n }\n\n private CtPackageReference getPackageReference(PackageBinding reference) {\n  return getPackageReference(new String(reference.shortReadableName()));\n }\n\n public CtPackageReference getPackageReference(String name) {\n  if (name.length() \u003d\u003d 0) {\n   return this.jdtTreeBuilder.getFactory().Package().topLevel();\n  }\n  CtPackageReference ref \u003d this.jdtTreeBuilder.getFactory().Core().createPackageReference();\n  ref.setSimpleName(name);\n  return ref;\n }\n\n final Map\u003cTypeBinding, CtTypeReference\u003e bindingCache \u003d new HashMap\u003c\u003e();\n\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeBinding binding, TypeReference ref) {\n  CtTypeReference\u003cT\u003e ctRef \u003d getTypeReference(binding);\n  if (ctRef !\u003d null \u0026\u0026 isCorrectTypeReference(ref)) {\n   insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);\n   return ctRef;\n  }\n  CtTypeReference\u003cT\u003e result \u003d getTypeReference(ref);\n  return result;\n }\n\n CtTypeReference\u003cObject\u003e getTypeParameterReference(TypeBinding binding, TypeReference ref) {\n  CtTypeReference\u003cObject\u003e ctRef \u003d getTypeReference(binding);\n  if (ctRef !\u003d null \u0026\u0026 isCorrectTypeReference(ref)) {\n   if (!(ctRef instanceof CtTypeParameterReference)) {\n    CtTypeParameterReference typeParameterRef \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n    typeParameterRef.setSimpleName(ctRef.getSimpleName());\n    typeParameterRef.setDeclaringType(ctRef.getDeclaringType());\n    typeParameterRef.setPackage(ctRef.getPackage());\n    ctRef \u003d typeParameterRef;\n   }\n   insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);\n   return ctRef;\n  }\n  return getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));\n }\n\n /**\n  * In no classpath, the model of the super interface isn\u0027t always correct.\n  */\n private boolean isCorrectTypeReference(TypeReference ref) {\n  if (ref.resolvedType \u003d\u003d null) {\n   return false;\n  }\n  if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {\n   return true;\n  }\n  final String[] compoundName \u003d CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);\n  final String[] typeName \u003d CharOperation.charArrayToStringArray(ref.getTypeName());\n  if (compoundName.length \u003d\u003d 0 || typeName.length \u003d\u003d 0) {\n   return false;\n  }\n  return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);\n }\n\n private \u003cT\u003e void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference\u003cT\u003e type) {\n  if (original.resolvedType instanceof ProblemReferenceBinding \u0026\u0026 original.getTypeArguments() !\u003d null) {\n   for (TypeReference[] typeReferences : original.getTypeArguments()) {\n    if (typeReferences !\u003d null) {\n     for (TypeReference typeReference : typeReferences) {\n      type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));\n     }\n    }\n   }\n  }\n }\n\n /**\n  * JDT doesn\u0027t return a correct AST with the resolved type of the reference.\n  * This method try to build a correct Spoon AST from the name of the JDT\n  * reference, thanks to the parsing of the string, the name parameterized from\n  * the JDT reference and java convention.\n  * Returns a complete Spoon AST when the name is correct, otherwise a spoon type\n  * reference with a name that correspond to the name of the JDT type reference.\n  */\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeReference ref) {\n  if (ref \u003d\u003d null) {\n   return null;\n  }\n  CtTypeReference\u003cT\u003e res \u003d null;\n  CtTypeReference inner \u003d null;\n  final String[] namesParameterized \u003d CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());\n  String nameParameterized \u003d CharOperation.toString(ref.getParameterizedTypeName());\n  String typeName \u003d CharOperation.toString(ref.getTypeName());\n\n  int index \u003d namesParameterized.length - 1;\n  for (; index \u003e\u003d 0; index--) {\n   // Start at the end to get the class name first.\n   CtTypeReference main \u003d getTypeReference(namesParameterized[index]);\n   if (main \u003d\u003d null) {\n    break;\n   }\n   if (res \u003d\u003d null) {\n    res \u003d (CtTypeReference\u003cT\u003e) main;\n   } else {\n    inner.setDeclaringType((CtTypeReference\u003c?\u003e) main);\n   }\n   inner \u003d main;\n  }\n  if (res \u003d\u003d null) {\n   return this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);\n  }\n\n  if (inner.getPackage() \u003d\u003d null) {\n   PackageFactory packageFactory \u003d this.jdtTreeBuilder.getFactory().Package();\n   CtPackageReference packageReference \u003d index \u003e\u003d 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();\n   inner.setPackage(packageReference);\n  }\n  if (!res.toString().replace(\", ?\", \",?\").endsWith(nameParameterized)) {\n   // verify that we did not match a class that have the same name in a different package\n   return this.jdtTreeBuilder.getFactory().Type().createReference(typeName);\n  }\n  return res;\n }\n\n private String concatSubArray(String[] a, int endIndex) {\n  StringBuilder sb \u003d new StringBuilder();\n  for (int i \u003d 0; i \u003c endIndex; i++) {\n   sb.append(a[i]).append(\u0027.\u0027);\n  }\n  sb.append(a[endIndex]);\n  return sb.toString();\n }\n\n /**\n  * Try to build a CtTypeReference from a simple name with specified generic types but\n  * returns null if the name doesn\u0027t correspond to a type (not start by an upper case).\n  */\n private \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(String name) {\n  CtTypeReference\u003cT\u003e main \u003d null;\n  if (name.matches(\".*(\u003c.+\u003e)\")) {\n   Pattern pattern \u003d Pattern.compile(\"([^\u003c]+)\u003c(.+)\u003e\");\n   Matcher m \u003d pattern.matcher(name);\n   if (name.startsWith(\"?\")) {\n    main \u003d (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n   } else {\n    main \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   }\n   if (m.find()) {\n    main.setSimpleName(m.group(1));\n    final String[] split \u003d m.group(2).split(\",\");\n    for (String parameter : split) {\n     ((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));\n    }\n   }\n  } else if (Character.isUpperCase(name.charAt(0))) {\n   if (name.endsWith(\"[]\")) {\n    main \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n    name \u003d name.substring(0, name.length() - 2);\n    ((CtArrayTypeReference\u003cT\u003e) main).setComponentType(this.getTypeReference(name));\n   } else {\n    main \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   }\n   main.setSimpleName(name);\n   final CtReference declaring \u003d this.getDeclaringReferenceFromImports(name.toCharArray());\n   setPackageOrDeclaringType(main, declaring);\n  } else if (name.startsWith(\"?\")) {\n   return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n  }\n  return main;\n }\n\n /**\n  * Try to build a CtTypeParameterReference from a single name with specified generic types but\n  * keep in mind that if you give wrong data in the strong, reference will be wrong.\n  */\n private CtTypeReference\u003cObject\u003e getTypeParameterReference(String name) {\n  CtTypeReference\u003cObject\u003e param \u003d null;\n  if (name.contains(\"extends\") || name.contains(\"super\")) {\n   String[] split \u003d name.contains(\"extends\") ? name.split(\"extends\") : name.split(\"super\");\n   param \u003d getTypeParameterReference(split[0].trim());\n   ((CtTypeParameterReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));\n  } else if (name.matches(\".*(\u003c.+\u003e)\")) {\n   Pattern pattern \u003d Pattern.compile(\"([^\u003c]+)\u003c(.+)\u003e\");\n   Matcher m \u003d pattern.matcher(name);\n   if (m.find()) {\n    param \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n    param.setSimpleName(m.group(1));\n    final String[] split \u003d m.group(2).split(\",\");\n    for (String parameter : split) {\n     param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));\n    }\n   }\n  } else if (name.contains(\"?\")) {\n   param \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n  } else {\n   param \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n   param.setSimpleName(name);\n  }\n  return param;\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeBinding binding) \n\n private CtTypeReference\u003c?\u003e getCtCircularTypeReference(TypeBinding b) {\n  return bindingCache.get(b).clone();\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtVariableReference\u003cT\u003e getVariableReference(MethodBinding methbin) {\n  CtFieldReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n  ref.setSimpleName(new String(methbin.selector));\n  ref.setType((CtTypeReference\u003cT\u003e) getTypeReference(methbin.returnType));\n\n  if (methbin.declaringClass !\u003d null) {\n   ref.setDeclaringType(getTypeReference(methbin.declaringClass));\n  } else {\n   ref.setDeclaringType(ref.getType());\n  }\n  return ref;\n }\n\n \u003cT\u003e CtFieldReference\u003cT\u003e getVariableReference(FieldBinding varbin) {\n  CtFieldReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n  if (varbin \u003d\u003d null) {\n   return ref;\n  }\n  ref.setSimpleName(new String(varbin.name));\n  ref.setType(this.\u003cT\u003egetTypeReference(varbin.type));\n\n  if (varbin.declaringClass !\u003d null) {\n   ref.setDeclaringType(getTypeReference(varbin.declaringClass));\n  } else {\n   ref.setDeclaringType(ref.getType() \u003d\u003d null ? null : ref.getType().clone());\n  }\n  ref.setFinal(varbin.isFinal());\n  ref.setStatic((varbin.modifiers \u0026 ClassFileConstants.AccStatic) !\u003d 0);\n  return ref;\n }\n\n \u003cT\u003e CtFieldReference\u003cT\u003e getVariableReference(FieldBinding fieldBinding, char[] tokens) {\n  final CtFieldReference\u003cT\u003e ref \u003d getVariableReference(fieldBinding);\n  if (fieldBinding !\u003d null) {\n   return ref;\n  }\n  ref.setSimpleName(CharOperation.charToString(tokens));\n  return ref;\n }\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtVariableReference\u003cT\u003e getVariableReference(VariableBinding varbin) {\n\n  if (varbin instanceof FieldBinding) {\n   return getVariableReference((FieldBinding) varbin);\n  } else if (varbin instanceof LocalVariableBinding) {\n   final LocalVariableBinding localVariableBinding \u003d (LocalVariableBinding) varbin;\n   if (localVariableBinding.declaration instanceof Argument \u0026\u0026 localVariableBinding.declaringScope instanceof MethodScope) {\n    CtParameterReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createParameterReference();\n    ref.setSimpleName(new String(varbin.name));\n    ref.setType((CtTypeReference\u003cT\u003e) getTypeReference(varbin.type));\n    final ReferenceContext referenceContext \u003d localVariableBinding.declaringScope.referenceContext();\n    return ref;\n   } else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {\n    CtCatchVariableReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();\n    ref.setSimpleName(new String(varbin.name));\n    CtTypeReference\u003cT\u003e ref2 \u003d getTypeReference(varbin.type);\n    ref.setType(ref2);\n    return ref;\n   } else {\n    CtLocalVariableReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();\n    ref.setSimpleName(new String(varbin.name));\n    CtTypeReference\u003cT\u003e ref2 \u003d getTypeReference(varbin.type);\n    ref.setType(ref2);\n    return ref;\n   }\n  } else {\n   // unknown VariableBinding, the caller must do something\n   return null;\n  }\n }\n\n \u003cT\u003e CtVariableReference\u003cT\u003e getVariableReference(ProblemBinding binding) {\n  CtFieldReference\u003cT\u003e ref \u003d this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n  if (binding \u003d\u003d null) {\n   return ref;\n  }\n  ref.setSimpleName(new String(binding.name));\n  ref.setType((CtTypeReference\u003cT\u003e) getTypeReference(binding.searchType));\n  return ref;\n }\n\n List\u003cCtTypeReference\u003c?\u003e\u003e getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {\n  List\u003cCtTypeReference\u003c?\u003e\u003e res \u003d new ArrayList\u003c\u003e(genericTypeArguments.length);\n  for (TypeBinding tb : genericTypeArguments) {\n   res.add(getBoundedTypeReference(tb));\n  }\n  return res;\n }\n\n /**\n  * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type\n  */\n void setPackageOrDeclaringType(CtTypeReference\u003c?\u003e ref, CtReference declaring) {\n  if (declaring instanceof CtPackageReference) {\n   ref.setPackage((CtPackageReference) declaring);\n  } else if (declaring instanceof CtTypeReference) {\n   ref.setDeclaringType((CtTypeReference) declaring);\n  } else if (declaring \u003d\u003d null) {\n   try {\n    // sometimes JDT does not provide the information that ref comes from java.lang\n    // it seems to occurs in particular with anonymous inner classes: see #1307\n    // In that case, we try to load the class to check if it belongs to java.lang\n    Class.forName(\"java.lang.\" + ref.getSimpleName());\n    CtPackageReference javaLangPackageReference \u003d this.jdtTreeBuilder.getFactory().Core().createPackageReference();\n    javaLangPackageReference.setSimpleName(\"java.lang\");\n    ref.setPackage(javaLangPackageReference);\n   } catch (NoClassDefFoundError | ClassNotFoundException e) {\n    // in that case we consider the package should be the same as the current one. Fix #1293\n    ref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());\n   }\n  } else {\n   throw new AssertionError(\"unexpected declaring type: \" + declaring.getClass() + \" of \" + declaring);\n  }\n }\n\n /**\n  * In noclasspath, lambda doesn\u0027t have always a binding for their variables accesses in their block/expression.\n  * Here, we make the job of JDT and bind their variables accesses to their parameters.\n  *\n  * @param singleNameReference Name of the variable access.\n  * @return executable reference which corresponds to the lambda.\n  */\n public CtExecutableReference\u003c?\u003e getLambdaExecutableReference(SingleNameReference singleNameReference) {\n  ASTPair potentialLambda \u003d null;\n  for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {\n   if (astPair.node instanceof LambdaExpression) {\n    potentialLambda \u003d astPair;\n    // stop at innermost lambda, fixes #1100\n    break;\n   }\n  }\n  if (potentialLambda \u003d\u003d null) {\n   return null;\n  }\n  LambdaExpression lambdaJDT \u003d (LambdaExpression) potentialLambda.node;\n  for (Argument argument : lambdaJDT.arguments()) {\n   if (CharOperation.equals(argument.name, singleNameReference.token)) {\n    CtTypeReference\u003c?\u003e declaringType \u003d null;\n    if (lambdaJDT.enclosingScope instanceof MethodScope) {\n     declaringType \u003d jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());\n    }\n    CtLambda\u003c?\u003e ctLambda \u003d (CtLambda\u003c?\u003e) potentialLambda.element;\n    List\u003cCtTypeReference\u003c?\u003e\u003e parametersType \u003d new ArrayList\u003c\u003e();\n    List\u003cCtParameter\u003c?\u003e\u003e parameters \u003d ctLambda.getParameters();\n    for (CtParameter\u003c?\u003e parameter : parameters) {\n     parametersType.add(parameter.getType() !\u003d null\n       ? parameter.getType().clone()\n       // it\u0027s the best match :(\n       : jdtTreeBuilder.getFactory().Type().OBJECT.clone()\n     );\n    }\n    return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);\n   }\n  }\n  return null;\n }\n\n public CtModuleReference getModuleReference(ModuleReference moduleReference) {\n  String moduleName \u003d new String(moduleReference.moduleName);\n  CtModule module \u003d this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);\n  if (module \u003d\u003d null) {\n   CtModuleReference ctModuleReference \u003d this.jdtTreeBuilder.getFactory().Core().createModuleReference();\n   ctModuleReference.setSimpleName(moduleName);\n   return ctModuleReference;\n  } else {\n   return module.getReference();\n  }\n }\n}\n]\n\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...inter.testclasses;\n\n[import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n//and what about this comment? ]\u003e but was:\u003c...inter.testclasses;\n\n[\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String modified \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n//and what about this comment? \n]\u003e",
          "isError": false
        }
      ],
      "nbFailures": 3,
      "nbErrors": 0
    },
    {
      "className": "spoon.MavenLauncherTest",
      "failingMethods": [
        "mavenLauncherTestMultiModulesAndVariables",
        "spoonMavenLauncherTest"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Content of classpath: ",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "expected:\u003c23\u003e but was:\u003c0\u003e",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.imports.ImportTest",
      "failingMethods": [
        "testmportInCu"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.prettyprinter.LinesTest",
      "failingMethods": [],
      "erroringMethods": [
        "testIdenticalPrettyPrinter"
      ],
      "failures": [
        {
          "failureName": "java.lang.IndexOutOfBoundsException",
          "failureDetail": "Index: 2, Size: 2",
          "isError": true
        }
      ],
      "nbFailures": 0,
      "nbErrors": 1
    }
  ]
}