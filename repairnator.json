{
  "bugType": "only_fail",
  "hostname": "spirals-repairnator",
  "repo": "INRIA/spoon",
  "metrics": {
    "FailureNames": [
      "java.lang.IndexOutOfBoundsException",
      "spoon.SpoonException",
      "java.lang.AssertionError",
      "org.junit.ComparisonFailure"
    ],
    "StepsDurationsInSeconds": {
      "CheckoutBuggyBuild": 6,
      "ComputeClasspath": 21,
      "ComputeTestDir": 0,
      "BuildProject": 173,
      "InitRepoToPush": 29,
      "ComputeSourceDir": 2,
      "AstorJMut": 38,
      "CloneRepository": 16,
      "CheckoutPatchedBuild": 0,
      "Nopol": 233,
      "NPEFix": 0,
      "TestProject": 956,
      "GatherTestInformation": 3,
      "CommitPatch": 42
    },
    "BugCommitUrl": "http://github.com/INRIA/spoon/commit/5c0fa1c2f70cdedbf84caaa1797939b9f0288351",
    "NbFailingTests": 7,
    "NbErroringTests": 8,
    "NbSkippingTests": 4,
    "NbRunningTests": 1547,
    "ReproductionDate": "Jul 9, 2018 10:17:36 PM",
    "BuggyBuildId": 401928806,
    "PatchedBuilId": 0,
    "BuggyBuildURL": "http://travis-ci.org/INRIA/spoon/builds/401928806",
    "BuggyBuildDate": "Jul 9, 2018 10:14:02 PM",
    "BugCommit": "5c0fa1c2f70cdedbf84caaa1797939b9f0288351",
    "PatchChangedFiles": 0,
    "PatchAddedLines": 0,
    "PatchDeletedLines": 0,
    "NbLibraries": 30,
    "NbFileApp": 624,
    "NbFileTests": 701,
    "NbCPU": 4,
    "FreeMemory": 1067504864,
    "TotalMemory": 1841299456,
    "AngelicValuesByTest": {
      "spoon/test/compilationunit/TestCompilationUnit": 0,
      "spoon/test/prettyprinter/PrintChangesTest": 0,
      "spoon/test/position/SourceFragmentTest": 0,
      "spoon/test/prettyprinter/LinesTest": 0,
      "spoon/MavenLauncherTest": 0,
      "spoon/test/imports/ImportTest": 0
    },
    "FreeMemoryByStep": {
      "CheckoutBuggyBuild": 137459616,
      "ComputeClasspath": 176831864,
      "ComputeTestDir": 176831864,
      "BuildProject": 123635592,
      "InitRepoToPush": 180779952,
      "ComputeSourceDir": 1056474728,
      "AstorJMut": 1154229632,
      "CloneRepository": 226571208,
      "CheckoutPatchedBuild": 1067504864,
      "Nopol": 659010336,
      "NPEFix": 659010336,
      "TestProject": 102578824,
      "GatherTestInformation": 314635504,
      "CommitPatch": 1067504864
    },
    "NbSucceedingTests": 1532
  },
  "failing-test-cases": [
    {
      "className": "spoon.test.compilationunit.TestCompilationUnit",
      "failingMethods": [
        "testAddDeclaredTypeInCU"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.prettyprinter.PrintChangesTest",
      "failingMethods": [
        "testPrintChanged",
        "testPrintChangedReferenceBuilder",
        "testPrintUnchaged"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...inter.testclasses;\n\n[import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n//and what about this comment? ]\u003e but was:\u003c...inter.testclasses;\n\n[\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n]\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...port.compiler.jdt;\n\n[import org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.impl.ReferenceContext;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\nimport org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.PackageFactory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;\n\npublic class ReferenceBuilder {\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeBinding binding) {\n  if (binding \u003d\u003d null) {\n   return null;\n  }\n\n  CtTypeReference\u003c?\u003e ref \u003d null;\n\n  if (binding instanceof RawTypeBinding) {\n   ref \u003d getTypeReference(((ParameterizedTypeBinding) binding).genericType());\n  } else if (binding instanceof ParameterizedTypeBinding) {\n   if (binding.actualType() !\u003d null \u0026\u0026 binding.actualType() instanceof LocalTypeBinding) {\n    // When we define a nested class in a method and when the enclosing class of this method\n    // is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class\n    // and hide the real class in actualType().\n    ref \u003d getTypeReference(binding.actualType());\n   } else {\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n    this.exploringParameterizedBindings.put(binding, ref);\n    if (binding.isAnonymousType()) {\n     ref.setSimpleName(\"\");\n    } else {\n     ref.setSimpleName(String.valueOf(binding.sourceName()));\n     if (binding.enclosingType() !\u003d null) {\n      ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n     } else {\n      ref.setPackage(getPackageReference(binding.getPackage()));\n     }\n    }\n   }\n   if (binding.actualType() instanceof MissingTypeBinding) {\n    ref \u003d getTypeReference(binding.actualType());\n   }\n\n   if (((ParameterizedTypeBinding) binding).arguments !\u003d null) {\n    for (TypeBinding b : ((ParameterizedTypeBinding) binding).arguments) {\n     if (bindingCache.containsKey(b)) {\n      ref.addActualTypeArgument(getCtCircularTypeReference(b));\n     } else {\n      if (!this.exploringParameterizedBindings.containsKey(b)) {\n       this.exploringParameterizedBindings.put(b, null);\n       CtTypeReference typeRefB \u003d getTypeReference(b);\n       this.exploringParameterizedBindings.put(b, typeRefB);\n       ref.addActualTypeArgument(typeRefB);\n      } else {\n       CtTypeReference typeRefB \u003d this.exploringParameterizedBindings.get(b);\n       if (typeRefB !\u003d null) {\n        ref.addActualTypeArgument(typeRefB.clone());\n       }\n      }\n     }\n    }\n   }\n  } else if (binding instanceof MissingTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.sourceName()));\n   ref.setPackage(getPackageReference(binding.getPackage()));\n   if (!this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports) {\n    final CtReference declaring \u003d this.getDeclaringReferenceFromImports(binding.sourceName());\n    if (declaring instanceof CtPackageReference) {\n     ref.setPackage((CtPackageReference) declaring);\n    } else if (declaring instanceof CtTypeReference) {\n     ref.setDeclaringType((CtTypeReference) declaring);\n    }\n   }\n  } else if (binding instanceof BinaryTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.enclosingType() !\u003d null) {\n    ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n   } else {\n    ref.setPackage(getPackageReference(binding.getPackage()));\n   }\n   ref.setSimpleName(new String(binding.sourceName()));\n  } else if (binding instanceof TypeVariableBinding) {\n   boolean oldBounds \u003d bounds;\n\n   if (binding instanceof CaptureBinding) {\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n    bounds \u003d true;\n   } else {\n    TypeVariableBinding typeParamBinding \u003d (TypeVariableBinding) binding;\n    ReferenceBinding superClass \u003d typeParamBinding.superclass;\n    ReferenceBinding[] superInterfaces \u003d typeParamBinding.superInterfaces();\n\n    CtTypeReference refSuperClass \u003d null;\n\n    // if the type parameter has a super class other than java.lang.Object, we get it\n    // superClass.superclass() is null if it\u0027s java.lang.Object\n    if (superClass !\u003d null \u0026\u0026 !(superClass.superclass() \u003d\u003d null)) {\n\n     // this case could happen with Enum\u003cE extends Enum\u003cE\u003e\u003e for example:\n     // in that case we only want to have E -\u003e Enum -\u003e E\n     // to conserve the same behavior as JavaReflectionTreeBuilder\n     if (!(superClass instanceof ParameterizedTypeBinding) || !this.exploringParameterizedBindings.containsKey(superClass)) {\n      refSuperClass \u003d this.getTypeReference(superClass);\n     }\n\n    // if the type parameter has a super interface, then we\u0027ll get it too, as a superclass\n    // type parameter can only extends an interface or a class, so we don\u0027t make the distinction\n    // in Spoon. Moreover we can only have one extends in a type parameter.\n    } else if (superInterfaces !\u003d null \u0026\u0026 superInterfaces.length \u003d\u003d 1) {\n     refSuperClass \u003d this.getTypeReference(superInterfaces[0]);\n    }\n\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n    ref.setSimpleName(new String(binding.sourceName()));\n\n    if (refSuperClass !\u003d null) {\n     ((CtTypeParameterReference) ref).addBound(refSuperClass);\n    }\n   }\n   TypeVariableBinding b \u003d (TypeVariableBinding) binding;\n   if (bounds) {\n    if (b instanceof CaptureBinding \u0026\u0026 ((CaptureBinding) b).wildcard !\u003d null) {\n     bounds \u003d oldBounds;\n     return getTypeReference(((CaptureBinding) b).wildcard);\n    } else if (b.superclass !\u003d null \u0026\u0026 b.firstBound \u003d\u003d b.superclass) {\n     bounds \u003d false;\n     bindingCache.put(binding, ref);\n     ((CtTypeParameterReference) ref).setBoundingType(getTypeReference(b.superclass));\n     bounds \u003d oldBounds;\n    }\n   }\n   if (bounds \u0026\u0026 b.superInterfaces !\u003d null \u0026\u0026 b.superInterfaces !\u003d Binding.NO_SUPERINTERFACES) {\n    bounds \u003d false;\n    bindingCache.put(binding, ref);\n    List\u003cCtTypeReference\u003c?\u003e\u003e bounds \u003d new ArrayList\u003c\u003e();\n    CtTypeParameterReference typeParameterReference \u003d (CtTypeParameterReference) ref;\n    if (!(typeParameterReference.isDefaultBoundingType())) { // if it\u0027s object we can ignore it\n     bounds.add(typeParameterReference.getBoundingType());\n    }\n    for (ReferenceBinding superInterface : b.superInterfaces) {\n     bounds.add(getTypeReference(superInterface));\n    }\n    ((CtTypeParameterReference) ref).setBoundingType(this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds));\n   }\n   if (binding instanceof CaptureBinding) {\n    bounds \u003d false;\n   }\n  } else if (binding instanceof BaseTypeBinding) {\n   String name \u003d new String(binding.sourceName());\n   //always create new TypeReference, because clonning from a cache clones invalid SourcePosition\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(name);\n  } else if (binding instanceof WildcardBinding) {\n   WildcardBinding wildcardBinding \u003d (WildcardBinding) binding;\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\n   if (wildcardBinding.boundKind \u003d\u003d Wildcard.SUPER \u0026\u0026 ref instanceof CtTypeParameterReference) {\n    ((CtTypeParameterReference) ref).setUpper(false);\n   }\n\n   if (wildcardBinding.bound !\u003d null \u0026\u0026 ref instanceof CtTypeParameterReference) {\n    if (bindingCache.containsKey(wildcardBinding.bound)) {\n     ((CtTypeParameterReference) ref).setBoundingType(getCtCircularTypeReference(wildcardBinding.bound));\n    } else {\n\n\n     ((CtTypeParameterReference) ref).setBoundingType(getTypeReference(((WildcardBinding) binding).bound));\n    }\n   }\n  } else if (binding instanceof LocalTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.isAnonymousType()) {\n    ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n    ref.setDeclaringType(getTypeReference((binding.enclosingType())));\n   } else {\n    ref.setSimpleName(new String(binding.sourceName()));\n    if (((LocalTypeBinding) binding).enclosingMethod \u003d\u003d null \u0026\u0026 binding.enclosingType() !\u003d null \u0026\u0026 binding.enclosingType() instanceof LocalTypeBinding) {\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    } else if (binding.enclosingMethod() !\u003d null) {\n     ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    }\n   }\n  } else if (binding instanceof SourceTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.isAnonymousType()) {\n    ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n    ref.setDeclaringType(getTypeReference((binding.enclosingType())));\n   } else {\n    ref.setSimpleName(new String(binding.sourceName()));\n    if (binding.enclosingType() !\u003d null) {\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    } else {\n     ref.setPackage(getPackageReference(binding.getPackage()));\n    }\n    // if(((SourceTypeBinding) binding).typeVariables!\u003dnull \u0026\u0026\n    // ((SourceTypeBinding) binding).typeVariables.length\u003e0){\n    // for (TypeBinding b : ((SourceTypeBinding)\n    // binding).typeVariables) {\n    // ref.getActualTypeArguments().add(getTypeReference(b));\n    // }\n    // }\n   }\n  } else if (binding instanceof ArrayBinding) {\n   CtArrayTypeReference\u003cObject\u003e arrayref;\n   arrayref \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n   ref \u003d arrayref;\n   for (int i \u003d 1; i \u003c binding.dimensions(); i++) {\n    CtArrayTypeReference\u003cObject\u003e tmp \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n    arrayref.setComponentType(tmp);\n    arrayref \u003d tmp;\n   }\n   arrayref.setComponentType(getTypeReference(binding.leafComponentType()));\n  } else if (binding instanceof PolyTypeBinding) {\n   // JDT can\u0027t resolve the type of this binding and we only have a string.\n   // In this case, we return a type Object because we can\u0027t know more about it.\n   ref \u003d this.jdtTreeBuilder.getFactory().Type().objectType();\n  } else if (binding instanceof ProblemReferenceBinding) {\n   // Spoon is able to analyze also without the classpath\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.readableName()));\n   final CtReference declaring \u003d this.getDeclaringReferenceFromImports(binding.sourceName());\n   setPackageOrDeclaringType(ref, declaring);\n  } else if (binding instanceof JDTTreeBuilder.SpoonReferenceBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.sourceName()));\n   ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n  } else if (binding instanceof IntersectionTypeBinding18) {\n   List\u003cCtTypeReference\u003c?\u003e\u003e bounds \u003d new ArrayList\u003c\u003e();\n   for (ReferenceBinding superInterface : binding.getIntersectingTypes()) {\n    bounds.add(getTypeReference(superInterface));\n   }\n   ref \u003d this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds);\n  } else {\n   throw new RuntimeException(\"Unknown TypeBinding: \" + binding.getClass() + \" \" + binding);\n  }\n  bindingCache.remove(binding);\n  this.exploringParameterizedBindings.remove(binding);\n  return (CtTypeReference\u003cT\u003e) ref;\n }\n}]\n\u003e but was:\u003c...port.compiler.jdt;\n\n[\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\n\n\npublic class ReferenceBuilder {\n\n @SuppressWarnings(\"unchecked\")\n \u003cT\u003e CtTypeReference\u003cT\u003e getTypeReference(TypeBinding binding) {\n  if (binding \u003d\u003d null) {\n   return null;\n  }\n\n  CtTypeReference\u003c?\u003e ref \u003d null;\n\n  // When we define a nested class in a method and when the enclosing class of this method\n// is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class\n// and hide the real class in actualType().\n// if the type parameter has a super class other than java.lang.Object, we get it\n// superClass.superclass() is null if it\u0027s java.lang.Object\n// this case could happen with Enum\u003cE extends Enum\u003cE\u003e\u003e for example:\n// in that case we only want to have E -\u003e Enum -\u003e E\n// to conserve the same behavior as JavaReflectionTreeBuilder\n// if the type parameter has a super interface, then we\u0027ll get it too, as a superclass\n// type parameter can only extends an interface or a class, so we don\u0027t make the distinction\n// in Spoon. Moreover we can only have one extends in a type parameter.\n// if it\u0027s object we can ignore it\n//always create new TypeReference, because clonning from a cache clones invalid SourcePosition\n// if(((SourceTypeBinding) binding).typeVariables!\u003dnull \u0026\u0026\n// ((SourceTypeBinding) binding).typeVariables.length\u003e0){\n// for (TypeBinding b : ((SourceTypeBinding)\n// binding).typeVariables) {\n// ref.getActualTypeArguments().add(getTypeReference(b));\n// }\n// }\n// JDT can\u0027t resolve the type of this binding and we only have a string.\n// In this case, we return a type Object because we can\u0027t know more about it.\n// Spoon is able to analyze also without the classpath\nif (binding instanceof RawTypeBinding) {\n   ref \u003d getTypeReference(((ParameterizedTypeBinding) binding).genericType());\n  }// When we define a nested class in a method and when the enclosing class of this method\n// is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class\n// and hide the real class in actualType().\n// if the type parameter has a super class other than java.lang.Object, we get it\n// superClass.superclass() is null if it\u0027s java.lang.Object\n// this case could happen with Enum\u003cE extends Enum\u003cE\u003e\u003e for example:\n// in that case we only want to have E -\u003e Enum -\u003e E\n// to conserve the same behavior as JavaReflectionTreeBuilder\n// if the type parameter has a super interface, then we\u0027ll get it too, as a superclass\n// type parameter can only extends an interface or a class, so we don\u0027t make the distinction\n// in Spoon. Moreover we can only have one extends in a type parameter.\n// if it\u0027s object we can ignore it\n//always create new TypeReference, because clonning from a cache clones invalid SourcePosition\n// if(((SourceTypeBinding) binding).typeVariables!\u003dnull \u0026\u0026\n// ((SourceTypeBinding) binding).typeVariables.length\u003e0){\n// for (TypeBinding b : ((SourceTypeBinding)\n// binding).typeVariables) {\n// ref.getActualTypeArguments().add(getTypeReference(b));\n// }\n// }\n// JDT can\u0027t resolve the type of this binding and we only have a string.\n// In this case, we return a type Object because we can\u0027t know more about it.\n// Spoon is able to analyze also without the classpath\nelseif (binding instanceof ParameterizedTypeBinding) {\n   if (binding.actualType() !\u003d null \u0026\u0026 binding.actualType() instanceof LocalTypeBinding) {\n    // When we define a nested class in a method and when the enclosing class of this method\n    // is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class\n    // and hide the real class in actualType().\n    ref \u003d getTypeReference(binding.actualType());\n   } else {\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n    this.exploringParameterizedBindings.put(binding, ref);\n    if (binding.isAnonymousType()) {\n     ref.setSimpleName(\"\");\n    } else {\n     ref.setSimpleName(String.valueOf(binding.sourceName()));\n     if (binding.enclosingType() !\u003d null) {\n      ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n     } else {\n      ref.setPackage(getPackageReference(binding.getPackage()));\n     }\n    }\n   }\n   if (binding.actualType() instanceof MissingTypeBinding) {\n    ref \u003d getTypeReference(binding.actualType());\n   }\n\n   if (((ParameterizedTypeBinding) binding).arguments !\u003d null) {\n    for (TypeBinding b : ((ParameterizedTypeBinding) binding).arguments) {\n     if (bindingCache.containsKey(b)) {\n      ref.addActualTypeArgument(getCtCircularTypeReference(b));\n     } else {\n      if (!this.exploringParameterizedBindings.containsKey(b)) {\n       this.exploringParameterizedBindings.put(b, null);\n       CtTypeReference typeRefB \u003d getTypeReference(b);\n       this.exploringParameterizedBindings.put(b, typeRefB);\n       ref.addActualTypeArgument(typeRefB);\n      } else {\n       CtTypeReference typeRefB \u003d this.exploringParameterizedBindings.get(b);\n       if (typeRefB !\u003d null) {\n        ref.addActualTypeArgument(typeRefB.clone());\n       }\n      }\n     }\n    }\n   }\n  }elseif (binding instanceof MissingTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.sourceName()));\n   ref.setPackage(getPackageReference(binding.getPackage()));\n   if (!this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports) {\n    final CtReference declaring \u003d this.getDeclaringReferenceFromImports(binding.sourceName());\n    if (declaring instanceof CtPackageReference) {\n     ref.setPackage((CtPackageReference) declaring);\n    } else if (declaring instanceof CtTypeReference) {\n     ref.setDeclaringType((CtTypeReference) declaring);\n    }\n   }\n  }elseif (binding instanceof BinaryTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.enclosingType() !\u003d null) {\n    ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n   } else {\n    ref.setPackage(getPackageReference(binding.getPackage()));\n   }\n   ref.setSimpleName(new String(binding.sourceName()));\n  }elseif (binding instanceof TypeVariableBinding) {\n   boolean oldBounds \u003d bounds;\n\n   if (binding instanceof CaptureBinding) {\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n    bounds \u003d true;\n   } else {\n    TypeVariableBinding typeParamBinding \u003d (TypeVariableBinding) binding;\n    ReferenceBinding superClass \u003d typeParamBinding.superclass;\n    ReferenceBinding[] superInterfaces \u003d typeParamBinding.superInterfaces();\n\n    CtTypeReference refSuperClass \u003d null;\n\n    // if the type parameter has a super class other than java.lang.Object, we get it\n    // superClass.superclass() is null if it\u0027s java.lang.Object\n    if (superClass !\u003d null \u0026\u0026 !(superClass.superclass() \u003d\u003d null)) {\n\n     // this case could happen with Enum\u003cE extends Enum\u003cE\u003e\u003e for example:\n     // in that case we only want to have E -\u003e Enum -\u003e E\n     // to conserve the same behavior as JavaReflectionTreeBuilder\n     if (!(superClass instanceof ParameterizedTypeBinding) || !this.exploringParameterizedBindings.containsKey(superClass)) {\n      refSuperClass \u003d this.getTypeReference(superClass);\n     }\n\n    // if the type parameter has a super interface, then we\u0027ll get it too, as a superclass\n    // type parameter can only extends an interface or a class, so we don\u0027t make the distinction\n    // in Spoon. Moreover we can only have one extends in a type parameter.\n    } else if (superInterfaces !\u003d null \u0026\u0026 superInterfaces.length \u003d\u003d 1) {\n     refSuperClass \u003d this.getTypeReference(superInterfaces[0]);\n    }\n\n    ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n    ref.setSimpleName(new String(binding.sourceName()));\n\n    if (refSuperClass !\u003d null) {\n     ((CtTypeParameterReference) ref).addBound(refSuperClass);\n    }\n   }\n   TypeVariableBinding b \u003d (TypeVariableBinding) binding;\n   if (bounds) {\n    if (b instanceof CaptureBinding \u0026\u0026 ((CaptureBinding) b).wildcard !\u003d null) {\n     bounds \u003d oldBounds;\n     return getTypeReference(((CaptureBinding) b).wildcard);\n    } else if (b.superclass !\u003d null \u0026\u0026 b.firstBound \u003d\u003d b.superclass) {\n     bounds \u003d false;\n     bindingCache.put(binding, ref);\n     ((CtTypeParameterReference) ref).setBoundingType(getTypeReference(b.superclass));\n     bounds \u003d oldBounds;\n    }\n   }\n   if (bounds \u0026\u0026 b.superInterfaces !\u003d null \u0026\u0026 b.superInterfaces !\u003d Binding.NO_SUPERINTERFACES) {\n    bindingCache.put(binding, ref);\n    List\u003cCtTypeReference\u003c?\u003e\u003e bounds \u003d new ArrayList\u003c\u003e();\n    CtTypeParameterReference typeParameterReference \u003d (CtTypeParameterReference) ref;\n    if (!(typeParameterReference.isDefaultBoundingType())) { // if it\u0027s object we can ignore it\n     bounds.add(typeParameterReference.getBoundingType());\n    }\n    for (ReferenceBinding superInterface : b.superInterfaces) {\n     bounds.add(getTypeReference(superInterface));\n    }\n    ((CtTypeParameterReference) ref).setBoundingType(this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds));\n   if (binding instanceof CaptureBinding) {\n    bounds \u003d false;\n   }elseif (binding instanceof BaseTypeBinding) {\n   String name \u003d new String(binding.sourceName());\n   //always create new TypeReference, because clonning from a cache clones invalid SourcePosition\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(name);\n  } else if (binding instanceof WildcardBinding) {\n   WildcardBinding wildcardBinding \u003d (WildcardBinding) binding;\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\n   if (wildcardBinding.boundKind \u003d\u003d Wildcard.SUPER \u0026\u0026 ref instanceof CtTypeParameterReference) {\n    ((CtTypeParameterReference) ref).setUpper(false);\n   }\n\n   if (wildcardBinding.bound !\u003d null \u0026\u0026 ref instanceof CtTypeParameterReference) {\n    if (bindingCache.containsKey(wildcardBinding.bound)) {\n     ((CtTypeParameterReference) ref).setBoundingType(getCtCircularTypeReference(wildcardBinding.bound));\n    } else {\n\n\n     ((CtTypeParameterReference) ref).setBoundingType(getTypeReference(((WildcardBinding) binding).bound));\n    }\n   }\n  } else if (binding instanceof LocalTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.isAnonymousType()) {\n    ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n    ref.setDeclaringType(getTypeReference((binding.enclosingType())));\n   } else {\n    ref.setSimpleName(new String(binding.sourceName()));\n    if (((LocalTypeBinding) binding).enclosingMethod \u003d\u003d null \u0026\u0026 binding.enclosingType() !\u003d null \u0026\u0026 binding.enclosingType() instanceof LocalTypeBinding) {\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    } else if (binding.enclosingMethod() !\u003d null) {\n     ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    }\n   }\n  } else if (binding instanceof SourceTypeBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   if (binding.isAnonymousType()) {\n    ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n    ref.setDeclaringType(getTypeReference((binding.enclosingType())));\n   } else {\n    ref.setSimpleName(new String(binding.sourceName()));\n    if (binding.enclosingType() !\u003d null) {\n     ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n    } else {\n     ref.setPackage(getPackageReference(binding.getPackage()));\n    }\n    // if(((SourceTypeBinding) binding).typeVariables!\u003dnull \u0026\u0026\n    // ((SourceTypeBinding) binding).typeVariables.length\u003e0){\n    // for (TypeBinding b : ((SourceTypeBinding)\n    // binding).typeVariables) {\n    // ref.getActualTypeArguments().add(getTypeReference(b));\n    // }\n    // }\n   }\n  } else if (binding instanceof ArrayBinding) {\n   CtArrayTypeReference\u003cObject\u003e arrayref;\n   arrayref \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n   ref \u003d arrayref;\n   for (int i \u003d 1; i \u003c binding.dimensions(); i++) {\n    CtArrayTypeReference\u003cObject\u003e tmp \u003d this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n    arrayref.setComponentType(tmp);\n    arrayref \u003d tmp;\n   }\n   arrayref.setComponentType(getTypeReference(binding.leafComponentType()));\n  } else if (binding instanceof PolyTypeBinding) {\n   // JDT can\u0027t resolve the type of this binding and we only have a string.\n   // In this case, we return a type Object because we can\u0027t know more about it.\n   ref \u003d this.jdtTreeBuilder.getFactory().Type().objectType();\n  } else if (binding instanceof ProblemReferenceBinding) {\n   // Spoon is able to analyze also without the classpath\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.readableName()));\n   final CtReference declaring \u003d this.getDeclaringReferenceFromImports(binding.sourceName());\n   setPackageOrDeclaringType(ref, declaring);\n  } else if (binding instanceof JDTTreeBuilder.SpoonReferenceBinding) {\n   ref \u003d this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n   ref.setSimpleName(new String(binding.sourceName()));\n   ref.setDeclaringType(getTypeReference(binding.enclosingType()));\n  } else if (binding instanceof IntersectionTypeBinding18) {\n   List\u003cCtTypeReference\u003c?\u003e\u003e bounds \u003d new ArrayList\u003c\u003e();\n   for (ReferenceBinding superInterface : binding.getIntersectingTypes()) {\n    bounds.add(getTypeReference(superInterface));\n   }\n   ref \u003d this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds);\n  } else {\n   throw new RuntimeException(\"Unknown TypeBinding: \" + binding.getClass() + \" \" + binding);\n  }\n  bindingCache.remove(binding);\n  this.exploringParameterizedBindings.remove(binding);\n  return (CtTypeReference\u003cT\u003e) ref;\n}\n]\n\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c...inter.testclasses;\n\n[import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String string \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n//and what about this comment? ]\u003e but was:\u003c...inter.testclasses;\n\n[\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n/**\n * The content of this file \n * \n\n *   should not be changed\n * Because DJPP should print only modified content again \n */\npublic\n@Deprecated\nabstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged\u003cT, K\u003e /*before extends*/ \n extends ArrayList\u003cT /* let\u0027s confuse \u003e it */ \u003e implements List\u003cT\u003e,\n Cloneable\n{\n \n \n /**/\n final\n //\n private String modified \u003d \"a\"\n   + \"b\" + \"c\"+\"d\";\n \n //and spaces here are wanted too\n \n \n public \u003cT, K\u003e void andSomeOtherMethod(\n   int param1,\n   String param2         , List\u003c?\u003e[][] ... twoDArrayOfLists)\n {/**/\n  System.out.println(\"aaa\"\n    + \"xyz\");\n /*x*/}\n List\u003c?\u003e[][] twoDArrayOfLists \u003d new List\u003c?\u003e[7][];\n}\n\n//and what about this comment? \n]\u003e",
          "isError": false
        }
      ],
      "nbFailures": 3,
      "nbErrors": 0
    },
    {
      "className": "spoon.MavenLauncherTest",
      "failingMethods": [
        "mavenLauncherTestMultiModulesAndVariables",
        "spoonMavenLauncherTest"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Content of classpath: ",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "expected:\u003c23\u003e but was:\u003c0\u003e",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.imports.ImportTest",
      "failingMethods": [
        "testmportInCu"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.position.SourceFragmentTest",
      "failingMethods": [],
      "erroringMethods": [
        "testLocalizationOfSourceFragment",
        "testSourceFragmentWrapChild",
        "testSourceFragmentAddChild",
        "testSourceFragmentWrapChildrenAndSiblings",
        "testDeclarationSourcePositionFragment",
        "testBodyHolderSourcePositionFragment",
        "testSourcePositionFragment"
      ],
      "failures": [
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        },
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        },
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        },
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        },
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        },
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        },
        {
          "failureName": "spoon.SpoonException",
          "failureDetail": "Mandatory parameter compilationUnit is null",
          "isError": true
        }
      ],
      "nbFailures": 0,
      "nbErrors": 7
    },
    {
      "className": "spoon.test.prettyprinter.LinesTest",
      "failingMethods": [],
      "erroringMethods": [
        "testIdenticalPrettyPrinter"
      ],
      "failures": [
        {
          "failureName": "java.lang.IndexOutOfBoundsException",
          "failureDetail": "Index: 2, Size: 2",
          "isError": true
        }
      ],
      "nbFailures": 0,
      "nbErrors": 1
    }
  ],
  "failingModule": "/root/workspace/INRIA/spoon/401928806"
}