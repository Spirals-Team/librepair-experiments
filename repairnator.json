{
  "totalNumberSkippingTests": 4,
  "bugType": "only_fail",
  "totalNumberErroringTests": 2,
  "repo": "INRIA/spoon",
  "failingModule": "/root/workspace/INRIA/spoon/394090644",
  "hostname": "spirals-vortex.lille.inria.fr",
  "totalNumberFailingTests": 20,
  "error-types": [
    "java.lang.AssertionError",
    "java.lang.NullPointerException",
    "org.junit.ComparisonFailure"
  ],
  "totalNumberRunningTests": 1512,
  "failing-test-cases": [
    {
      "className": "spoon.test.parent.ContractOnSettersParametrizedTest",
      "failingMethods": [
        "testContract[public interface CtInterface\u003cT\u003e extends spoon.reflect.declaration.CtType\u003cT\u003e {\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cT\u003e\u003e C setSuperclass(spoon.reflect.reference.CtTypeReference\u003c?\u003e arg0);\n\n    spoon.reflect.declaration.CtInterface\u003cT\u003e clone();\n}]",
        "testContract[public interface CtClass\u003cT\u003e extends spoon.reflect.code.CtStatement , spoon.reflect.declaration.CtType\u003cT\u003e {\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.code.CtStatement\u003e C setLabel(java.lang.String arg0);\n\n    boolean isAnonymous();\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)\n    \u003cC extends spoon.reflect.declaration.CtClass\u003cT\u003e\u003e C setAnonymousExecutables(java.util.List\u003cspoon.reflect.declaration.CtAnonymousExecutable\u003e arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)\n    \u003cC extends spoon.reflect.declaration.CtClass\u003cT\u003e\u003e C addAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)\n    boolean removeAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.CONSTRUCTOR)\n    \u003cC extends spoon.reflect.declaration.CtClass\u003cT\u003e\u003e C setConstructors(java.util.Set\u003cspoon.reflect.declaration.CtConstructor\u003cT\u003e\u003e arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.CONSTRUCTOR)\n    \u003cC extends spoon.reflect.declaration.CtClass\u003cT\u003e\u003e C addConstructor(spoon.reflect.declaration.CtConstructor\u003cT\u003e arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.CONSTRUCTOR)\n    void removeConstructor(spoon.reflect.declaration.CtConstructor\u003cT\u003e arg0);\n\n    @spoon.support.DerivedProperty\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)\n    java.util.List\u003cspoon.reflect.declaration.CtAnonymousExecutable\u003e getAnonymousExecutables();\n\n    spoon.reflect.declaration.CtClass\u003cT\u003e clone();\n\n    T newInstance();\n\n    @spoon.support.DerivedProperty\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.CONSTRUCTOR)\n    java.util.Set\u003cspoon.reflect.declaration.CtConstructor\u003cT\u003e\u003e getConstructors();\n\n    @spoon.support.DerivedProperty\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.CONSTRUCTOR)\n    spoon.reflect.declaration.CtConstructor\u003cT\u003e getConstructor(spoon.reflect.reference.CtTypeReference\u003c?\u003e... arg0);\n}]",
        "testContract[public interface CtTypeParameter extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e {\n    @spoon.support.DerivedProperty\n    spoon.reflect.reference.CtTypeParameterReference getReference();\n\n    @spoon.support.UnsettableProperty\n    \u003cF, C extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C addFieldAtTop(spoon.reflect.declaration.CtField\u003cF\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C setFields(java.util.List\u003cspoon.reflect.declaration.CtField\u003c?\u003e\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cN, C extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C addNestedType(spoon.reflect.declaration.CtType\u003cN\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C setNestedTypes(java.util.Set\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C setMethods(java.util.Set\u003cspoon.reflect.declaration.CtMethod\u003c?\u003e\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cM, C extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C addMethod(spoon.reflect.declaration.CtMethod\u003cM\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C setTypeMembers(java.util.List\u003cspoon.reflect.declaration.CtTypeMember\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C setSuperInterfaces(java.util.Set\u003cspoon.reflect.reference.CtTypeReference\u003c?\u003e\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cS, C extends spoon.reflect.declaration.CtType\u003cjava.lang.Object\u003e\u003e C addSuperInterface(spoon.reflect.reference.CtTypeReference\u003cS\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cT extends spoon.reflect.declaration.CtFormalTypeDeclarer\u003e T setFormalCtTypeParameters(java.util.List\u003cspoon.reflect.declaration.CtTypeParameter\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cT extends spoon.reflect.declaration.CtModifiable\u003e T setModifiers(java.util.Set\u003cspoon.reflect.declaration.ModifierKind\u003e arg0);\n\n    @spoon.support.DerivedProperty\n    spoon.reflect.declaration.CtFormalTypeDeclarer getTypeParameterDeclarer();\n\n    spoon.reflect.declaration.CtTypeParameter clone();\n}]",
        "testContract[public interface CtPackage extends spoon.reflect.declaration.CtNamedElement , spoon.reflect.declaration.CtShadowable {\n    @spoon.support.DerivedProperty\n    spoon.reflect.reference.CtPackageReference getReference();\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.CONTAINED_TYPE)\n    \u003cT extends spoon.reflect.declaration.CtPackage\u003e T addType(spoon.reflect.declaration.CtType\u003c?\u003e arg0);\n\n    java.lang.String getQualifiedName();\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.IMPORT)\n    java.util.Set\u003cspoon.reflect.declaration.CtImport\u003e getImports();\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.IMPORT)\n    \u003cC extends spoon.reflect.declaration.CtPackage\u003e C addImport(spoon.reflect.declaration.CtImport arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.IMPORT)\n    \u003cC extends spoon.reflect.declaration.CtPackage\u003e C addImports(java.util.Collection\u003cspoon.reflect.declaration.CtImport\u003e arg0);\n\n    boolean isUnnamedPackage();\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.SUB_PACKAGE)\n    \u003cT extends spoon.reflect.declaration.CtPackage\u003e T addPackage(spoon.reflect.declaration.CtPackage arg0);\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.CONTAINED_TYPE)\n    java.util.Set\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e getTypes();\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.CONTAINED_TYPE)\n    void removeType(spoon.reflect.declaration.CtType\u003c?\u003e arg0);\n\n    @spoon.support.DerivedProperty\n    spoon.reflect.declaration.CtModule getDeclaringModule();\n\n    @spoon.support.DerivedProperty\n    spoon.reflect.declaration.CtPackage getDeclaringPackage();\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.SUB_PACKAGE)\n    \u003cT extends spoon.reflect.declaration.CtPackage\u003e T setPackages(java.util.Set\u003cspoon.reflect.declaration.CtPackage\u003e arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.SUB_PACKAGE)\n    boolean removePackage(spoon.reflect.declaration.CtPackage arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.CONTAINED_TYPE)\n    \u003cT extends spoon.reflect.declaration.CtPackage\u003e T setTypes(java.util.Set\u003cspoon.reflect.declaration.CtType\u003c?\u003e\u003e arg0);\n\n    spoon.reflect.declaration.CtPackage clone();\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.SUB_PACKAGE)\n    spoon.reflect.declaration.CtPackage getPackage(java.lang.String arg0);\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.SUB_PACKAGE)\n    java.util.Set\u003cspoon.reflect.declaration.CtPackage\u003e getPackages();\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.CONTAINED_TYPE)\n    \u003cT extends spoon.reflect.declaration.CtType\u003c?\u003e\u003e T getType(java.lang.String arg0);\n\n    static final java.lang.String PACKAGE_SEPARATOR;\n\n    static final char PACKAGE_SEPARATOR_CHAR;\n\n    static final java.lang.String TOP_LEVEL_PACKAGE_NAME;\n}]",
        "testContract[public interface CtAnnotationType\u003cT extends java.lang.annotation.Annotation\u003e extends spoon.reflect.declaration.CtType\u003cT\u003e {\n    \u003cC extends spoon.reflect.declaration.CtType\u003cT\u003e\u003e C setMethods(java.util.Set\u003cspoon.reflect.declaration.CtMethod\u003c?\u003e\u003e arg0);\n\n    \u003cM, C extends spoon.reflect.declaration.CtType\u003cT\u003e\u003e C addMethod(spoon.reflect.declaration.CtMethod\u003cM\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cT\u003e\u003e C setSuperclass(spoon.reflect.reference.CtTypeReference\u003c?\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cT\u003e\u003e C setSuperInterfaces(java.util.Set\u003cspoon.reflect.reference.CtTypeReference\u003c?\u003e\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cT extends spoon.reflect.declaration.CtFormalTypeDeclarer\u003e T setFormalCtTypeParameters(java.util.List\u003cspoon.reflect.declaration.CtTypeParameter\u003e arg0);\n\n    @spoon.support.DerivedProperty\n    java.util.Set\u003cspoon.reflect.declaration.CtAnnotationMethod\u003c?\u003e\u003e getAnnotationMethods();\n\n    spoon.reflect.declaration.CtAnnotationType\u003cT\u003e clone();\n}]",
        "testContract[public interface CtEnum\u003cT extends java.lang.Enum\u003c?\u003e\u003e extends spoon.reflect.declaration.CtClass\u003cT\u003e {\n    @spoon.support.UnsettableProperty\n    \u003cC extends spoon.reflect.declaration.CtType\u003cT\u003e\u003e C setSuperclass(spoon.reflect.reference.CtTypeReference\u003c?\u003e arg0);\n\n    @spoon.support.UnsettableProperty\n    \u003cT extends spoon.reflect.declaration.CtFormalTypeDeclarer\u003e T setFormalCtTypeParameters(java.util.List\u003cspoon.reflect.declaration.CtTypeParameter\u003e arg0);\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.VALUE)\n    java.util.List\u003cspoon.reflect.declaration.CtEnumValue\u003c?\u003e\u003e getEnumValues();\n\n    @spoon.reflect.annotations.PropertyGetter(role \u003d spoon.reflect.path.CtRole.VALUE)\n    spoon.reflect.declaration.CtEnumValue\u003c?\u003e getEnumValue(java.lang.String arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.VALUE)\n    \u003cC extends spoon.reflect.declaration.CtEnum\u003cT\u003e\u003e C addEnumValue(spoon.reflect.declaration.CtEnumValue\u003c?\u003e arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.VALUE)\n    boolean removeEnumValue(spoon.reflect.declaration.CtEnumValue\u003c?\u003e arg0);\n\n    @spoon.reflect.annotations.PropertySetter(role \u003d spoon.reflect.path.CtRole.VALUE)\n    \u003cC extends spoon.reflect.declaration.CtEnum\u003cT\u003e\u003e C setEnumValues(java.util.List\u003cspoon.reflect.declaration.CtEnumValue\u003c?\u003e\u003e arg0);\n\n    spoon.reflect.declaration.CtEnum\u003cT\u003e clone();\n}]"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport",
          "isError": false
        }
      ],
      "nbFailures": 6,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.processing.ProcessingTest",
      "failingMethods": [
        "testProcessDontMessWithImports"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.fieldaccesses.FieldAccessTest",
      "failingMethods": [
        "testGetReference"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c[]A.myField\u003e but was:\u003c[spoon.test.fieldaccesses.testclasses.]A.myField\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.api.MetamodelTest",
      "failingMethods": [
        "testRuntimeMetamodel"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "These Metamodel.Field instances are missing on Type CtInterface: [import]\nThese Metamodel.Field instances are missing on Type CtTypeParameter: [import]\nThese Metamodel.Field instances are missing on Type CtEnum: [import]\nThese Metamodel.Field instances are missing on Type CtClass: [import]\nThese Metamodel.Field instances are missing on Type CtPackage: [import]\nThese Metamodel.Field instances are missing on Type CtAnnotationType: [import]",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.jdtimportbuilder.ImportBuilderTest",
      "failingMethods": [
        "testWithImportFromItf",
        "testWithStaticInheritedImport"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "expected:\u003c1\u003e but was:\u003c3\u003e",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "expected:\u003c1\u003e but was:\u003c4\u003e",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    },
    {
      "className": "spoon.MavenLauncherTest",
      "failingMethods": [
        "mavenLauncherTestMultiModulesAndVariables",
        "spoonMavenLauncherTest"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Content of classpath: ",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "expected:\u003c23\u003e but was:\u003c0\u003e",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.imports.ImportTest",
      "failingMethods": [
        "testImportStarredPackageWithNonVisibleClass",
        "testImportStaticAndFieldAccessWithImport"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c[]Constants.CONSTANT.f...\u003e but was:\u003c[spoon.test.imports.testclasses.internal4.]Constants.CONSTANT.f...\u003e",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "expected:\u003c1\u003e but was:\u003c4\u003e",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.prettyprinter.DefaultPrettyPrinterTest",
      "failingMethods": [
        "testPrintAMethodWithGeneric",
        "autoImportUsesFullyQualifiedNameWhenImportedNameAlreadyPresent",
        "testPrintAMethodWithImports"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003cpublic [List\u003c? extends ArrayList\u003e aMethodWithGeneric() {\n    return new ]ArrayList\u003c\u003e();\n}\u003e but was:\u003cpublic [java.util.List\u003c? extends java.util.ArrayList\u003e aMethodWithGeneric() {\n    return new java.util.]ArrayList\u003c\u003e();\n}\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003cpublic [List\u003c?\u003e aMethod() {\n    return new ]ArrayList\u003c\u003e();\n}\u003e but was:\u003cpublic [java.util.List\u003c?\u003e aMethod() {\n    return new java.util.]ArrayList\u003c\u003e();\n}\u003e",
          "isError": false
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003c... {\n    localField \u003d []TypeIdentifierCollis...\u003e but was:\u003c... {\n    localField \u003d [spoon.test.prettyprinter.testclasses.]TypeIdentifierCollis...\u003e",
          "isError": false
        }
      ],
      "nbFailures": 3,
      "nbErrors": 0
    },
    {
      "className": "spoon.reflect.ast.AstCheckerTest",
      "failingMethods": [
        "testPushToStackChanges"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "addImport(spoon.reflect.declaration.CtImport) on spoon.support.reflect.declaration.CtPackageImpl\naddImports(java.util.Collection) on spoon.support.reflect.declaration.CtPackageImpl\naddImport(spoon.reflect.declaration.CtImport) on spoon.support.reflect.declaration.CtTypeImpl\naddImports(java.util.Collection) on spoon.support.reflect.declaration.CtTypeImpl\n",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "spoon.test.pkg.PackageTest",
      "failingMethods": [
        "testAddAnnotationToPackage"
      ],
      "erroringMethods": [
        "testRenamePackageAndPrettyPrintNoclasspath",
        "testRenamePackageAndPrettyPrint"
      ],
      "failures": [
        {
          "failureName": "java.lang.NullPointerException",
          "isError": true
        },
        {
          "failureName": "java.lang.NullPointerException",
          "isError": true
        },
        {
          "failureName": "org.junit.ComparisonFailure",
          "failureDetail": "expected:\u003cimport [spoon.test.annotation.testclasses.GlobalAnnotation];\u003e but was:\u003cimport [java.util.ArrayList];\u003e",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 2
    }
  ]
}