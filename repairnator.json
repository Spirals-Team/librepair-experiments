{
  "totalNumberSkippingTests": 0,
  "bugType": "only_fail",
  "totalNumberErroringTests": 0,
  "repo": "prestodb/presto",
  "failingModule": "/root/workspace/prestodb/presto/230591409/presto-main",
  "hostname": "repairnator",
  "totalNumberFailingTests": 23,
  "error-types": [
    "java.lang.ArrayIndexOutOfBoundsException",
    "java.lang.AssertionError"
  ],
  "totalNumberRunningTests": 3112,
  "failing-test-cases": [
    {
      "className": "com.facebook.presto.operator.TestAggregationOperator",
      "failingMethods": [
        "com.facebook.presto.operator.TestAggregationOperator#testAggregation"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        }
      ],
      "nbFailures": 1,
      "nbErrors": 0
    },
    {
      "className": "com.facebook.presto.operator.TestHashAggregationOperator",
      "failingMethods": [
        "com.facebook.presto.operator.TestHashAggregationOperator#testSpillerFailure",
        "com.facebook.presto.operator.TestHashAggregationOperator#testHashBuilderResize",
        "com.facebook.presto.operator.TestHashAggregationOperator#testHashAggregation",
        "com.facebook.presto.operator.TestHashAggregationOperator#testHashBuilderResizeLimit",
        "com.facebook.presto.operator.TestHashAggregationOperator#testMemoryLimit",
        "com.facebook.presto.operator.TestHashAggregationOperator#testMultiplePartialFlushes",
        "com.facebook.presto.operator.TestHashAggregationOperator#testMergeWithMemorySpill",
        "com.facebook.presto.operator.TestHashAggregationOperator#testMultiSliceAggregationOutput"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        },
        {
          "failureName": "java.lang.ArrayIndexOutOfBoundsException",
          "failureDetail": "0",
          "isError": false
        }
      ],
      "nbFailures": 20,
      "nbErrors": 0
    },
    {
      "className": "com.facebook.presto.sql.planner.optimizations.TestMixedDistinctAggregationOptimizer",
      "failingMethods": [
        "com.facebook.presto.sql.planner.optimizations.TestMixedDistinctAggregationOptimizer#testMixedDistinctAggregationOptimizer",
        "com.facebook.presto.sql.planner.optimizations.TestMixedDistinctAggregationOptimizer#testNestedType"
      ],
      "erroringMethods": [],
      "failures": [
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Plan does not match, expected [\n\n- anyTree\n    - node(AggregationNode)\n        AggregationMatcher{groupingSets\u003d[[CUSTKEY]], masks\u003d{}, groudId\u003dOptional.empty, step\u003dSINGLE}\n        bind Optional[arbitrary] -\u003e arbitrary (*) \n        bind Optional[count] -\u003e count (*) \n        - node(ProjectNode)\n            - node(AggregationNode)\n                AggregationMatcher{groupingSets\u003d[[CUSTKEY, ORDERDATE, GROUP]], masks\u003d{}, groudId\u003dOptional.empty, step\u003dSINGLE}\n                bind Optional[MAX] -\u003e max (TOTALPRICE) \n                - node(GroupIdNode)\n                    GroupIdMatcher{groups\u003d[[CUSTKEY, TOTALPRICE], [CUSTKEY, ORDERDATE]]}\n                    - anyTree\n                        - node(TableScanNode)\n                            TableScanMatcher{expectedTableName\u003dorders}\n                            bind Optional[TOTALPRICE] -\u003e Column orders:totalprice\n                            bind Optional[CUSTKEY] -\u003e Column orders:custkey\n                            bind Optional[ORDERDATE] -\u003e Column orders:orderdate\n\n] but found [\n\n- Output[custkey, s, d] \u003d\u003e [custkey:bigint, max:double, count:bigint]\n        s :\u003d max\n        d :\u003d count\n    - Aggregate[custkey] \u003d\u003e [custkey:bigint, max:double, count:bigint]\n            max :\u003d \"max\"(\"totalprice\")\n            count :\u003d \"count\"(DISTINCT \"orderdate\") (mask \u003d orderdate$distinct)\n        - MarkDistinct[distinct\u003dcustkey:bigint, orderdate:date marker\u003dorderdate$distinct] \u003d\u003e [custkey:bigint, totalprice:double, orderdate:date, orderdate$distinct:boolean]\n            - ScanProject[table \u003d local:tpch:orders:sf0.01, originalConstraint \u003d null] \u003d\u003e [custkey:bigint, totalprice:double, orderdate:date]\n                    custkey :\u003d tpch:custkey\n                    totalprice :\u003d tpch:totalprice\n                    orderdate :\u003d tpch:orderdate\n\n]",
          "isError": false
        },
        {
          "failureName": "java.lang.AssertionError",
          "failureDetail": "Plan does not match, expected [\n\n- anyTree\n    - node(AggregationNode)\n        bind Optional[arbitrary] -\u003e arbitrary (*) \n        bind Optional[count] -\u003e count (*) \n        - node(ProjectNode)\n            - node(AggregationNode)\n                bind Optional[max] -\u003e max (*) \n                - anyTree\n                    - node(ValuesNode)\n\n] but found [\n\n- Output[_col0, _col1] \u003d\u003e [count:bigint, max:integer]\n        _col0 :\u003d count\n        _col1 :\u003d max\n    - Aggregate \u003d\u003e [count:bigint, max:integer]\n            count :\u003d \"count\"(DISTINCT \"field\") (mask \u003d a$distinct)\n            max :\u003d \"max\"(\"field_0\")\n        - MarkDistinct[distinct\u003dfield:row(integer, integer) marker\u003da$distinct] \u003d\u003e [field:row(integer, integer), field_0:integer, a$distinct:boolean]\n            - Values \u003d\u003e [field:row(integer, integer), field_0:integer]\n                    (\"$literal$row(field0 integer,field1 integer)\"(\"from_base64\"(\u0027CwAAAElOVEVSTEVBVkVEAgAAAAkAAABJTlRfQVJSQVkJAAAASU5UX0FSUkFZAQAAAAABAAAAAQAAAAACAAAA\u0027)), 3)\n\n]",
          "isError": false
        }
      ],
      "nbFailures": 2,
      "nbErrors": 0
    }
  ]
}