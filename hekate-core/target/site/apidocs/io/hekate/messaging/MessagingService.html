<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_121) on Fri May 25 13:21:41 CEST 2018 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>MessagingService (Hekate 2.4.0-SNAPSHOT)</title>
<meta name="date" content="2018-05-25">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MessagingService (Hekate 2.4.0-SNAPSHOT)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<link rel="stylesheet" href="../../../highlight/styles/idea.css">                         <link rel="stylesheet" href="../../../jquery/jquery-ui.structure.min.css">                         <link rel="stylesheet" href="../../../jquery/jquery-ui.min.css">                         <link rel="stylesheet" href="../../../jquery/jquery-ui.theme.min.css">                         <link rel="stylesheet" href="../../../style.css">                         <script src="../../../highlight/highlight.pack.js"></script>                         <script src="../../../jquery/jquery.min.js"></script>                         <script src="../../../jquery/jquery-ui.min.js"></script>                         <script>                             hljs.initHighlightingOnLoad();                              $( function() {                                 $(".tabs").tabs();                              });                         </script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MessagingService.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../io/hekate/messaging/MessagingRemoteException.html" title="class in io.hekate.messaging"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../io/hekate/messaging/MessagingServiceFactory.html" title="class in io.hekate.messaging"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/hekate/messaging/MessagingService.html" target="_top">Frames</a></li>
<li><a href="MessagingService.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.hekate.messaging</div>
<h2 title="Interface MessagingService" class="title">Interface MessagingService</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><a href="../../../io/hekate/core/service/Service.html" title="interface in io.hekate.core.service">Service</a></dd>
</dl>
<hr>
<br>
<pre><a href="../../../io/hekate/core/service/DefaultServiceFactory.html" title="annotation in io.hekate.core.service">@DefaultServiceFactory</a>(<a href="../../../io/hekate/core/service/DefaultServiceFactory.html#value--">value</a>=<a href="../../../io/hekate/messaging/MessagingServiceFactory.html" title="class in io.hekate.messaging">MessagingServiceFactory.class</a>)
public interface <span class="typeNameLabel">MessagingService</span>
extends <a href="../../../io/hekate/core/service/Service.html" title="interface in io.hekate.core.service">Service</a></pre>
<div class="block"><span class="startHere">&laquo; start here</span>Main entry point to messaging API.

 <h2>Overview</h2>
 <p>
 Messaging service provides support for building message-oriented communications in the cluster of <a href="../../../io/hekate/core/Hekate.html" title="interface in io.hekate.core"><code>Hekate</code></a> nodes. Message exchange
 is based on the concept of messaging channels. Such channels hide all the complexities of managing resources (like socket and threads)
 and provide a high level API for implementing various messaging patterns.
 </p>

 <h2>Messaging Channels</h2>
 <p>
 Messaging channel is a communication unit that can act as a sender, as a receiver or perform both of those roles simultaneously.
 Channels provide support for unicast messaging (node to node communication) and broadcast messaging (node to many nodes communication).
 Note that "unicast" and "broadcast" in this context are NOT related to UDP (all communications are TCP-based) and merely outline
 the communication patterns.
 </p>

 <h2>Configuring channels</h2>
 <p>
 Configuration of a messaging channel is represented by the <a href="../../../io/hekate/messaging/MessagingChannelConfig.html" title="class in io.hekate.messaging"><code>MessagingChannelConfig</code></a> class. Instances of this class be registered
 via the <a href="../../../io/hekate/messaging/MessagingServiceFactory.html#withChannel-io.hekate.messaging.MessagingChannelConfig-"><code>MessagingServiceFactory.withChannel(MessagingChannelConfig)</code></a> method.
 </p>

 <p>
 Below are the key configuration options of a messaging channel:
 </p>
 <ul>
 <li><a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setName-java.lang.String-"><code>Channel Name</code></a> - only channels with the same name can communicate with each other.
 Note that channel name must be unique within each <a href="../../../io/hekate/messaging/MessagingService.html" title="interface in io.hekate.messaging"><code>MessagingService</code></a> instance and any attempt to register multiple channels with
 the same name will result in an error</li>
 <li><a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setReceiver-io.hekate.messaging.MessageReceiver-"><code>Message Receiver</code></a> if channel should be able to receive messages from
 remote nodes (i.e. act as a server)</li>
 <li><a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setMessageCodec-io.hekate.codec.CodecFactory-"><code>Message Codec</code></a> - for messages serialization/deserialization.
 If not specified then the <a href="../../../io/hekate/core/HekateBootstrap.html#setDefaultCodec-io.hekate.codec.CodecFactory-"><code>default codec</code></a> will be used.</li>
 <li><a href="../../../io/hekate/messaging/MessagingConfigBase.html#setNioThreads-int-"><code>NIO</code></a> and <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setWorkerThreads-int-"><code>worker</code></a> thread pool
 options</li>
 </ul>

 <p>
 Example:
 </p>

 <div class="tabs">
 <ul>
 <li><a href="#configure-java">Java</a></li>
 <li><a href="#configure-xsd">Spring XSD</a></li>
 <li><a href="#configure-bean">Spring bean</a></li>
 </ul>
 <div id="configure-java">
<div class="doc_source">
<pre><code class="java">
// Configure channel that will support messages of String type (for simplicity).
MessagingChannelConfig&lt;String&gt; channelCfg = MessagingChannelConfig.of(String.class)
    .withName("example.channel") // Channel name.
    // Message receiver (optional - if not specified then channel will act as a sender only)
    .withReceiver(msg -&gt; {
        System.out.println("Received request: " + msg.get());

        // Send reply (if required).
        if (msg.mustReply()) {
            msg.reply("some response");
        }
    });

// Prepare messaging service factory and register channel.
MessagingServiceFactory factory = new MessagingServiceFactory()
    .withChannel(channelCfg);

// Start node.
Hekate hekate = new HekateBootstrap()
    .withService(factory)
    .join();
</code></pre>
</div>
 </div>
 <div id="configure-xsd">
 <b>Note:</b> This example requires Spring Framework integration
 (see <a href="../../../io/hekate/spring/bean/HekateSpringBootstrap.html">HekateSpringBootstrap</a>).
<div class="doc_source">
<pre><code class="xml">
&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:h="http://www.hekate.io/spring/hekate-core"
    xmlns="http://www.springframework.org/schema/beans"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.hekate.io/spring/hekate-core
        http://www.hekate.io/spring/hekate-core.xsd"&gt;

    &lt;h:node id="hekate"&gt;
        &lt;!-- Messaging service. --&gt;
        &lt;h:messaging&gt;
            &lt;h:channel name="example.channel"&gt;
                &lt;h:receiver&gt;
                    &lt;bean class="foo.bar.SomeMessageReceiver"/&gt;
                &lt;/h:receiver&gt;

                &lt;!-- ...other options... --&gt;
            &lt;/h:channel&gt;
        &lt;/h:messaging&gt;

        &lt;!-- ...other services... --&gt;
    &lt;/h:node&gt;
&lt;/beans&gt;
</code></pre>
</div>
 </div>
 <div id="configure-bean">
 <b>Note:</b> This example requires Spring Framework integration
 (see <a href="../../../io/hekate/spring/bean/HekateSpringBootstrap.html">HekateSpringBootstrap</a>).
<div class="doc_source">
<pre><code class="xml">
&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.springframework.org/schema/beans"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="hekate" class="io.hekate.spring.bean.HekateSpringBootstrap"&gt;
        &lt;property name="services"&gt;
            &lt;list&gt;
                &lt;!-- Messaging service. --&gt;
                &lt;bean class="io.hekate.messaging.MessagingServiceFactory"&gt;
                    &lt;property name="channels"&gt;
                        &lt;list&gt;
                            &lt;bean id="example.channel" class="io.hekate.messaging.MessagingChannelConfig"&gt;
                                &lt;property name="name" value="example.channel"/&gt;
                                &lt;property name="receiver"&gt;
                                    &lt;bean class="foo.bar.SomeMessageReceiver"/&gt;
                                &lt;/property&gt;

                                &lt;!-- ...other options... --&gt;
                            &lt;/bean&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;

                &lt;!-- ...other services... --&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</div>
 </div>
 </div>

 <p>
 For more details about the available configuration options please see the documentation of <a href="../../../io/hekate/messaging/MessagingChannelConfig.html" title="class in io.hekate.messaging"><code>MessagingChannelConfig</code></a> class.
 </p>

 <h2>Accessing channels</h2>
 <p>
 Channel can be accessed via the <a href="../../../io/hekate/messaging/MessagingService.html#channel-java.lang.String-java.lang.Class-"><code>channel(String, Class)</code></a> method, with the first parameter being the
 <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setName-java.lang.String-"><code>channel name</code></a> and the second parameter being the
 <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#of-java.lang.Class-"><code>base type</code></a> of messages that can be transferred over that channel:
<div class="doc_source">
<pre><code class="java">
MessagingChannel&lt;String&gt; channel = hekate.messaging().channel("example.channel", String.class);
</code></pre>
</div>
 </p>

 <h2>Sending messages</h2>
 <p>
 <a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging"><code>MessagingChannel</code></a> provides API for the following communication patterns:
 </p>
 <ul>
 <li>
 <a href="#request_response">Request/Response</a> - bidirectional node to node communication
 </li>
 <li>
 <a href="#send_and_forget">Send and Forget</a> - unidirectional node to node communication
 </li>
 <li>
 <a href="#aggregate">Aggregation</a> - bidirectional node to many nodes communication
 </li>
 <li>
 <a href="#broadcast">Broadcasting</a> - unidirectional node to many nodes communication
 </li>
 </ul>

 <a name="request_response"></a>
 <h3>Request/Response</h3>
 <p>
 <a href="../../../io/hekate/messaging/MessagingChannel.html#request-T-"><code>MessagingChannel.request(Object)</code></a> can be used for bidirectional communications with remote nodes using the request-response
 pattern:
<div class="doc_source">
<pre><code class="java">
// Execute request to the oldest node in the cluster and synchronously await for reply.
String response = channel.forOldest().request("example request").response();
</code></pre>
</div>
 </p>

 <p>
 ... or using a completely asynchronous callback-based approach (see <a href="../../../io/hekate/messaging/MessagingChannel.html#request-T-io.hekate.messaging.unicast.ResponseCallback-"><code>MessagingChannel.request(Object, ResponseCallback)</code></a>):
<div class="doc_source">
<pre><code class="java">
// Submit request to the oldest node in the cluster
// and process reply in the asynchronous callback.
channel.forOldest().request("example request", (err, reply) -&gt; {
    if (err == null) {
        System.out.println("Got reply: " + reply.get());
    } else {
        System.out.println("Request failed: " + err);
    }
});
</code></pre>
</div>
 </p>

 <a name="send_and_forget"></a>
 <h3>Send and Forget</h3>
 <p>
 <a href="../../../io/hekate/messaging/MessagingChannel.html#send-T-"><code>MessagingChannel.send(Object)</code></a> provides support for unidirectional communications (i.e. when remote node doesn't need to send
 back a response) using the fire and forget approach:
<div class="doc_source">
<pre><code class="java">
// Send message to the oldest node in the cluster
// and synchronously await for operation result (success/failure).
channel.forOldest().send("example message").get();
</code></pre>
</div>
 </p>

 <p>
 ... or using a completely asynchronous callback-based approach (see <a href="../../../io/hekate/messaging/MessagingChannel.html#send-T-io.hekate.messaging.unicast.SendCallback-"><code>MessagingChannel.send(Object, SendCallback)</code></a>):
<div class="doc_source">
<pre><code class="java">
// Send message to the oldest node in the cluster
// and process operation result in the asynchronous callback.
channel.forOldest().send("example message", err -&gt; {
    if (err == null) {
        System.out.println("Message sent.");
    } else {
        System.out.println("Sending failed: " + err);
    }
});
</code></pre>
</div>
 </p>

 <a name="aggregate"></a>
 <h3>Aggregation</h3>
 <p>
 <a href="../../../io/hekate/messaging/MessagingChannel.html#aggregate-T-"><code>MessagingChannel.aggregate(Object)</code></a> can be used for bidirectional communications by submitting a message to multiple nodes and
 gathering (aggregating) replies from those nodes. Results of such aggregation are represented by the <a href="../../../io/hekate/messaging/broadcast/AggregateResult.html" title="interface in io.hekate.messaging.broadcast"><code>AggregateResult</code></a> interface.
 This interface provides methods for analyzing responses from remote nodes and checking for possible failures.
 </p>

 <p>
 Below is the example of synchronous aggregation:
<div class="doc_source">
<pre><code class="java">
// Submit aggregation request to all remote nodes.
channel.forRemotes().aggregate("example message").forEach(rslt -&gt;
    System.out.println("Got result: " + rslt)
);
</code></pre>
</div>
 </p>

 <p>
 ... or using a completely asynchronous callback-based approach (see <a href="../../../io/hekate/messaging/MessagingChannel.html#aggregate-T-io.hekate.messaging.broadcast.AggregateCallback-"><code>MessagingChannel.aggregate(Object, AggregateCallback)</code></a>):
<div class="doc_source">
<pre><code class="java">
// Asynchronously submit aggregation request to all remote nodes.
channel.forRemotes().aggregate("example message", (err, results) -&gt; {
    if (err == null) {
        results.forEach(rslt -&gt;
            System.out.println("Got result: " + rslt)
        );
    } else {
        System.out.println("Aggregation failure: " + err);
    }
});
</code></pre>
</div>
 </p>

 <a name="broadcast"></a>
 <h3>Broadcasting</h3>
 <p>
 <a href="../../../io/hekate/messaging/MessagingChannel.html#broadcast-T-"><code>MessagingChannel.broadcast(Object)</code></a> provides support for unidirectional broadcasting (i.e. when remote nodes do not need to send
 a reply and no aggregation should take place) using the fire and forget approach.
 </p>

 <p>
 Below is the example of synchronous broadcast:
<div class="doc_source">
<pre><code class="java">
// Broadcast message to all remote nodes.
channel.forRemotes().broadcast("example message").get();
</code></pre>
</div>
 </p>
 <p>
 ... or using a completely asynchronous callback-based approach (see <a href="../../../io/hekate/messaging/MessagingChannel.html#broadcast-T-io.hekate.messaging.broadcast.BroadcastCallback-"><code>MessagingChannel.broadcast(Object, BroadcastCallback)</code></a>):
<div class="doc_source">
<pre><code class="java">
// Asynchronously broadcast message to all remote nodes.
channel.forRemotes().broadcast("example message", (err, result) -&gt; {
    if (err == null) {
        System.out.println("Broadcast success.");
    } else {
        System.out.println("Broadcast failure: " + err);
    }
});
</code></pre>
</div>
 </p>

 <h2>Receiving messages</h2>
 <p>
 Messaging channel can receive messages from remote nodes by <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setReceiver-io.hekate.messaging.MessageReceiver-"><code>registering</code></a> an
 instance of <a href="../../../io/hekate/messaging/MessageReceiver.html" title="interface in io.hekate.messaging"><code>MessageReceiver</code></a> interface. Received messages are represented by the <a href="../../../io/hekate/messaging/Message.html" title="interface in io.hekate.messaging"><code>Message</code></a> interface. This interface
 provides methods for <a href="../../../io/hekate/messaging/MessageBase.html#get--"><code>getting</code></a> the payload of a received message as well as methods for <a href="../../../io/hekate/messaging/Message.html#reply-T-"><code>replying</code></a> to that message.
 </p>

 <p>
 <b>Important:</b> Only one receiver can be registered per each messaging channel.
 </p>

 <p>
 Below is the example of <a href="../../../io/hekate/messaging/MessageReceiver.html" title="interface in io.hekate.messaging"><code>MessageReceiver</code></a> implementation:
<div class="doc_source">
<pre><code class="java">
public class ExampleReceiver implements MessageReceiver&lt;String&gt; {
    @Override
    public void receive(Message&lt;String&gt; message) {
        // Get payload.
        String payload = message.get();

        // Check if sender is expecting a response.
        if (message.mustReply()) {
            System.out.println("Received request: " + payload);

            // Send back the response.
            message.reply("...some response...");
        } else {
            // No need to send a response since this is a unidirectional message.
            System.out.println("Received notification: " + payload);
        }
    }
}
</code></pre>
</div>
 </p>

 <h2>Routing and load balancing</h2>
 <p>
 Every messaging channel uses an instance of <a href="../../../io/hekate/messaging/loadbalance/LoadBalancer.html" title="interface in io.hekate.messaging.loadbalance"><code>LoadBalancer</code></a> interface to perform routing of unicast operations
 (like <a href="../../../io/hekate/messaging/MessagingChannel.html#send-T-"><code>send(...)</code></a> and <a href="../../../io/hekate/messaging/MessagingChannel.html#request-T-"><code>request(...)</code></a>). Load balancer can
 be pre-configured via the <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setLoadBalancer-io.hekate.messaging.loadbalance.LoadBalancer-"><code>MessagingChannelConfig.setLoadBalancer(LoadBalancer)</code></a> method or specified dynamically via the <a href="../../../io/hekate/messaging/MessagingChannel.html#withLoadBalancer-io.hekate.messaging.loadbalance.LoadBalancer-"><code>MessagingChannel.withLoadBalancer(LoadBalancer)</code></a> method. If load balancer is not specified then messaging channel will fall back to the
 <a href="../../../io/hekate/messaging/loadbalance/DefaultLoadBalancer.html" title="class in io.hekate.messaging.loadbalance"><code>DefaultLoadBalancer</code></a>.
 </p>
 <p>
 Note that load balancing does not get applied to broadcast operations (like <a href="../../../io/hekate/messaging/MessagingChannel.html#broadcast-T-"><code>MessagingChannel.broadcast(Object)</code></a> and <a href="../../../io/hekate/messaging/MessagingChannel.html#aggregate-T-"><code>MessagingChannel.aggregate(Object)</code></a>). Such operations are submitted to all nodes within the channel's cluster topology.
 Please see the "<a href="#topology_filterring">Cluster topology filtering</a>" section for details of how to control the channel's
 cluster topology.
 </p>

 <h3>Consistent routing</h3>
 <p>
 Applications can provide an affinity key to the <a href="../../../io/hekate/messaging/loadbalance/LoadBalancer.html" title="interface in io.hekate.messaging.loadbalance"><code>LoadBalancer</code></a> so that it could perform consistent routing based on some
 application-specific criteria. For example, if the <a href="../../../io/hekate/messaging/loadbalance/DefaultLoadBalancer.html" title="class in io.hekate.messaging.loadbalance"><code>DefaultLoadBalancer</code></a> is being used by the messaging channel then it will make
 sure that all messages with the same affinity key will always be routed to the same cluster node (unless the cluster topology doesn't
 change) by using the channel's <a href="../../../io/hekate/messaging/MessagingChannel.html#partitions--"><code>partition mapper</code></a>. Custom implementations of the <a href="../../../io/hekate/messaging/loadbalance/LoadBalancer.html" title="interface in io.hekate.messaging.loadbalance"><code>LoadBalancer</code></a> interface can use their own algorithms for consistent routing.
 </p>

 <p>
 Affinity key can be specified via the <a href="../../../io/hekate/messaging/MessagingChannel.html#withAffinity-java.lang.Object-"><code>MessagingChannel.withAffinity(Object)</code></a> method. This method returns a lightweight wrapper
 over the messaging channel instance. Such wrapper will apply the specified affinity key to all messaging operations of that wrapper.
 </p>

 <p>
 If affinity key is specified for a broadcast operation then messaging channel will use its <a href="../../../io/hekate/messaging/MessagingChannel.html#partitions--"><code>partition mapper</code></a> to select the target <a href="../../../io/hekate/partition/Partition.html" title="interface in io.hekate.partition"><code>Partition</code></a> for that key. Once the partition is selected then all of its
 <a href="../../../io/hekate/partition/Partition.html#nodes--"><code>nodes</code></a> will be used for broadcast (i.e. <a href="../../../io/hekate/partition/Partition.html#primaryNode--"><code>primary node</code></a> + <a href="../../../io/hekate/partition/Partition.html#backupNodes--"><code>backup nodes</code></a>).
 </p>

 <h3>Thread affinity</h3>
 <p>
 Besides providing a hint to the <a href="../../../io/hekate/messaging/loadbalance/LoadBalancer.html" title="interface in io.hekate.messaging.loadbalance"><code>LoadBalancer</code></a>, specifying an affinity key also instructs the messaging channel to process all
 messages of the same affinity key on the same thread. This applies both to sending a message (see <a href="../../../io/hekate/messaging/unicast/SendCallback.html" title="interface in io.hekate.messaging.unicast"><code>SendCallback</code></a> or <a href="../../../io/hekate/messaging/unicast/ResponseCallback.html" title="interface in io.hekate.messaging.unicast"><code>ResponseCallback</code></a>) and to receiving a message (see <a href="../../../io/hekate/messaging/MessageReceiver.html#receive-io.hekate.messaging.Message-"><code>MessageReceiver.receive(Message)</code></a>).
 </p>

 <a name="topology_filterring"></a>
 <h3>Cluster topology filtering</h3>
 <p>
 It is possible to narrow down the list of nodes that are visible to the <a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging"><code>MessagingChannel</code></a> by setting a <a href="../../../io/hekate/cluster/ClusterNodeFilter.html" title="interface in io.hekate.cluster"><code>ClusterNodeFilter</code></a>.
 Such filter can be pre-configured via the <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setClusterFilter-io.hekate.cluster.ClusterNodeFilter-"><code>MessagingChannelConfig.setClusterFilter(ClusterNodeFilter)</code></a> method or set dynamically
 via the <a href="../../../io/hekate/cluster/ClusterFilterSupport.html#filter-io.hekate.cluster.ClusterNodeFilter-"><code>ClusterFilterSupport.filter(ClusterNodeFilter)</code></a> method.
 </p>

 <p>
 Note that the <a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging"><code>MessagingChannel</code></a> interface extends the <a href="../../../io/hekate/cluster/ClusterFilterSupport.html" title="interface in io.hekate.cluster"><code>ClusterFilterSupport</code></a> interface, which gives it a number of shortcut
 methods for dynamic filtering of the cluster topology:
 </p>
 <ul>
 <li><a href="../../../io/hekate/cluster/ClusterFilterSupport.html#forRemotes--"><code>ClusterFilterSupport.forRemotes()</code></a></li>
 <li><a href="../../../io/hekate/cluster/ClusterFilterSupport.html#forRole-java.lang.String-"><code>ClusterFilterSupport.forRole(String)</code></a></li>
 <li><a href="../../../io/hekate/cluster/ClusterFilterSupport.html#forProperty-java.lang.String-"><code>ClusterFilterSupport.forProperty(String)</code></a></li>
 <li><a href="../../../io/hekate/cluster/ClusterFilterSupport.html#forNode-io.hekate.cluster.ClusterNode-"><code>ClusterFilterSupport.forNode(ClusterNode)</code></a></li>
 <li><a href="../../../io/hekate/cluster/ClusterFilterSupport.html#forOldest--"><code>ClusterFilterSupport.forOldest()</code></a></li>
 <li><a href="../../../io/hekate/cluster/ClusterFilterSupport.html#forYoungest--"><code>ClusterFilterSupport.forYoungest()</code></a></li>
 <li>...<a href="../../../io/hekate/cluster/ClusterFilterSupport.html" title="interface in io.hekate.cluster"><code>etc</code></a></li>
 </ul>

 <p>
 If filter is specified then all messaging operations will be distributed among only those nodes that match the filter's criteria.
 </p>

 <h2>Thread pooling</h2>
 <p>
 Messaging service manages a pool of threads for each of its registered channels. The following  thread pools are managed:
 </p>

 <ul>
 <li>
 <b>NIO thread pool</b> - thread pool for managing NIO socket channels. The size of this thread pool is controlled by the <a href="../../../io/hekate/messaging/MessagingConfigBase.html#setNioThreads-int-"><code>MessagingConfigBase.setNioThreads(int)</code></a> configuration option.
 </li>
 <li>
 <b>Worker thread pool</b> - Optional thread pool to offload messages processing work from NIO threads. The size of this pool is
 controlled by the <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setWorkerThreads-int-"><code>MessagingChannelConfig.setWorkerThreads(int)</code></a> configuration option. It is recommended to set this parameter in
 case if message processing is a heavy operation that can block NIO thread for a long time.
 </li>
 </ul>

 <h2>Messaging failover</h2>
 <p>
 Failover of messaging errors is controlled by the <a href="../../../io/hekate/failover/FailoverPolicy.html" title="interface in io.hekate.failover"><code>FailoverPolicy</code></a> interface. Implementations of this interface can be
 configured for each <a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging"><code>MessagingChannel</code></a> individually via <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setFailoverPolicy-io.hekate.failover.FailoverPolicy-"><code>MessagingChannelConfig.setFailoverPolicy(FailoverPolicy)</code></a> method or
 defined at runtime via <a href="../../../io/hekate/messaging/MessagingChannel.html#withFailover-io.hekate.failover.FailoverPolicy-"><code>MessagingChannel.withFailover(FailoverPolicy)</code></a>. In case of a messaging error this interface will be called
 by the channel in order to decided on whether the message should be retransmitted or the messaging operation should fail.
 </p>
 <p>
 On the <a href="../../../io/hekate/messaging/MessageReceiver.html#receive-io.hekate.messaging.Message-"><code>receiving</code></a> side it is possible to detect messages that were retransmitted by checking the
 <a href="../../../io/hekate/messaging/Message.html#isRetransmit--"><code>Message.isRetransmit()</code></a> flag.
 </p>

 <p>
 For more details and usage examples please see the documentation of <a href="../../../io/hekate/failover/FailoverPolicy.html" title="interface in io.hekate.failover"><code>FailoverPolicy</code></a> interface.
 </p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging">MessagingChannel</a>&lt;?&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/hekate/messaging/MessagingService.html#allChannels--">allChannels</a></span>()</code>
<div class="block">Returns all channels that are <a href="../../../io/hekate/messaging/MessagingServiceFactory.html#setChannels-java.util.List-"><code>registered</code></a> within this service.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging">MessagingChannel</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/hekate/messaging/MessagingService.html#channel-java.lang.String-">channel</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name)</code>
<div class="block">Returns an unchecked messaging channel for the specified name.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging">MessagingChannel</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/hekate/messaging/MessagingService.html#channel-java.lang.String-java.lang.Class-">channel</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name,
       <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;baseType)</code>
<div class="block">Returns a type-safe messaging channel for the specified name.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/hekate/messaging/MessagingService.html#hasChannel-java.lang.String-">hasChannel</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;channelName)</code>
<div class="block">Returns <code>true</code> if this service has a messaging channel with the specified name.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="allChannels--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allChannels</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging">MessagingChannel</a>&lt;?&gt;&gt;&nbsp;allChannels()</pre>
<div class="block">Returns all channels that are <a href="../../../io/hekate/messaging/MessagingServiceFactory.html#setChannels-java.util.List-"><code>registered</code></a> within this service.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Channels or an empty list if there are no registered channels.</dd>
</dl>
</li>
</ul>
<a name="channel-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>channel</h4>
<pre><a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging">MessagingChannel</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;&nbsp;channel(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name)
                          throws <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></pre>
<div class="block">Returns an unchecked messaging channel for the specified name.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - Channel name (see <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setName-java.lang.String-"><code>MessagingChannelConfig.setName(String)</code></a>).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Messaging channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if there is no such channel configuration with the specified name.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/hekate/messaging/MessagingServiceFactory.html#setChannels-java.util.List-"><code>MessagingServiceFactory.setChannels(List)</code></a></dd>
</dl>
</li>
</ul>
<a name="channel-java.lang.String-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>channel</h4>
<pre>&lt;T&gt;&nbsp;<a href="../../../io/hekate/messaging/MessagingChannel.html" title="interface in io.hekate.messaging">MessagingChannel</a>&lt;T&gt;&nbsp;channel(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name,
                                <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;baseType)
                         throws <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></pre>
<div class="block">Returns a type-safe messaging channel for the specified name.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Base type of messages that can be supported by the messaging channel.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - Channel name (see <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setName-java.lang.String-"><code>MessagingChannelConfig.setName(String)</code></a>).</dd>
<dd><code>baseType</code> - Base type of messages that can be supported by the messaging channel (see <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#MessagingChannelConfig-java.lang.Class-"><code>MessagingChannelConfig.MessagingChannelConfig(Class)</code></a>).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Messaging channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if there is no such channel configuration with the specified name.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/hekate/messaging/MessagingServiceFactory.html#setChannels-java.util.List-"><code>MessagingServiceFactory.setChannels(List)</code></a></dd>
</dl>
</li>
</ul>
<a name="hasChannel-java.lang.String-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>hasChannel</h4>
<pre>boolean&nbsp;hasChannel(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;channelName)</pre>
<div class="block">Returns <code>true</code> if this service has a messaging channel with the specified name.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelName</code> - Channel name (see <a href="../../../io/hekate/messaging/MessagingChannelConfig.html#setName-java.lang.String-"><code>MessagingChannelConfig.setName(String)</code></a>).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if messaging channel exists.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MessagingService.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../io/hekate/messaging/MessagingRemoteException.html" title="class in io.hekate.messaging"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../io/hekate/messaging/MessagingServiceFactory.html" title="class in io.hekate.messaging"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/hekate/messaging/MessagingService.html" target="_top">Frames</a></li>
<li><a href="MessagingService.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2018 <a href="http://hekate.io/">The Hekate Project</a>. All rights reserved.</small></p>
</body>
</html>
