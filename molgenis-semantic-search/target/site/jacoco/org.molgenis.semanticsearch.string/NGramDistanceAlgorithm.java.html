<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NGramDistanceAlgorithm.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">semantic-search</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.semanticsearch.string</a> &gt; <span class="el_source">NGramDistanceAlgorithm.java</span></div><h1>NGramDistanceAlgorithm.java</h1><pre class="source lang-java linenums">package org.molgenis.semanticsearch.string;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import org.apache.commons.lang3.StringUtils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * This class has implemented n-gram distance algorithm so a similarity score could be calculated between two sequences.
 * The two input strings would be tokenized depending on what nGrams we have specified. The default ngram is 2 which can
 * be changed in the constructor. The two groups of tokens will be further used to work out the similarity score. In
 * addition, by default a list of stop words has been defined, in the method stringMatching(), one of the parameters
 * &quot;removeStopWords&quot; indicates whether the stop words will be used to remove the useless or meaningless words from the
 * String. This the stop words could be customized by setStopWords(List&lt;String&gt; stopWords) or setStopWords(String[]
 * stopWords).
 * &lt;p&gt;
 * How to use? LevenShteinDistanceModel model = new LevenShteinDistanceModel(2); double similarityScore =
 * model.stringMatching(&quot;Smoking&quot;, &quot;Smoker&quot;, false); System.out.println(similarityScore);
 * &lt;p&gt;
 * The other way List&lt;String&gt; tokens_1 = model.createNGrams(&quot;Smoking&quot;, false); List&lt;String&gt; tokens_2 =
 * model.createNGrams(&quot;Have you smoked last year?&quot;, true); //remove stop words! double similarityScore =
 * model.calculateScore(tokens_1, tokens_2);
 *
 * @author Chao Pang
 */

<span class="nc" id="L32">public class NGramDistanceAlgorithm</span>
{
<span class="fc" id="L34">	private static int N_GRAMS = 2;</span>
	public static final Set&lt;String&gt; STOPWORDSLIST;

	static
	{
<span class="fc" id="L39">		STOPWORDSLIST = ImmutableSet.of(&quot;a&quot;, &quot;you&quot;, &quot;about&quot;, &quot;above&quot;, &quot;after&quot;, &quot;again&quot;, &quot;against&quot;, &quot;all&quot;, &quot;am&quot;, &quot;an&quot;,</span>
				&quot;and&quot;, &quot;any&quot;, &quot;are&quot;, &quot;aren't&quot;, &quot;as&quot;, &quot;at&quot;, &quot;be&quot;, &quot;because&quot;, &quot;been&quot;, &quot;before&quot;, &quot;being&quot;, &quot;below&quot;,
				&quot;between&quot;, &quot;both&quot;, &quot;but&quot;, &quot;by&quot;, &quot;can't&quot;, &quot;cannot&quot;, &quot;could&quot;, &quot;couldn't&quot;, &quot;did&quot;, &quot;didn't&quot;, &quot;do&quot;, &quot;does&quot;,
				&quot;doesn't&quot;, &quot;doing&quot;, &quot;don't&quot;, &quot;down&quot;, &quot;during&quot;, &quot;each&quot;, &quot;few&quot;, &quot;for&quot;, &quot;from&quot;, &quot;further&quot;, &quot;had&quot;, &quot;hadn't&quot;,
				&quot;has&quot;, &quot;hasn't&quot;, &quot;have&quot;, &quot;haven't&quot;, &quot;having&quot;, &quot;he&quot;, &quot;he'd&quot;, &quot;he'll&quot;, &quot;he's&quot;, &quot;her&quot;, &quot;here&quot;, &quot;here's&quot;,
				&quot;hers&quot;, &quot;herself&quot;, &quot;him&quot;, &quot;himself&quot;, &quot;his&quot;, &quot;how&quot;, &quot;how's&quot;, &quot;i&quot;, &quot;i'd&quot;, &quot;i'll&quot;, &quot;i'm&quot;, &quot;i've&quot;, &quot;if&quot;,
				&quot;in&quot;, &quot;into&quot;, &quot;is&quot;, &quot;isn't&quot;, &quot;it&quot;, &quot;it's&quot;, &quot;its&quot;, &quot;itself&quot;, &quot;let's&quot;, &quot;me&quot;, &quot;more&quot;, &quot;most&quot;, &quot;mustn't&quot;,
				&quot;my&quot;, &quot;myself&quot;, &quot;no&quot;, &quot;nor&quot;, &quot;not&quot;, &quot;of&quot;, &quot;off&quot;, &quot;on&quot;, &quot;once&quot;, &quot;only&quot;, &quot;or&quot;, &quot;other&quot;, &quot;ought&quot;, &quot;our&quot;,
				&quot;ours&quot;, &quot;ourselves&quot;, &quot;out&quot;, &quot;over&quot;, &quot;own&quot;, &quot;same&quot;, &quot;shan't&quot;, &quot;she&quot;, &quot;she'd&quot;, &quot;she'll&quot;, &quot;she's&quot;,
				&quot;should&quot;, &quot;shouldn't&quot;, &quot;so&quot;, &quot;some&quot;, &quot;such&quot;, &quot;than&quot;, &quot;that&quot;, &quot;that's&quot;, &quot;the&quot;, &quot;their&quot;, &quot;theirs&quot;, &quot;them&quot;,
				&quot;themselves&quot;, &quot;then&quot;, &quot;there&quot;, &quot;there's&quot;, &quot;these&quot;, &quot;they&quot;, &quot;they'd&quot;, &quot;they'll&quot;, &quot;they're&quot;, &quot;they've&quot;,
				&quot;this&quot;, &quot;those&quot;, &quot;through&quot;, &quot;to&quot;, &quot;too&quot;, &quot;under&quot;, &quot;until&quot;, &quot;up&quot;, &quot;very&quot;, &quot;was&quot;, &quot;wasn't&quot;, &quot;we&quot;, &quot;we'd&quot;,
				&quot;we'll&quot;, &quot;we're&quot;, &quot;we've&quot;, &quot;were&quot;, &quot;weren't&quot;, &quot;what&quot;, &quot;what's&quot;, &quot;when&quot;, &quot;when's&quot;, &quot;where&quot;, &quot;where's&quot;,
				&quot;which&quot;, &quot;while&quot;, &quot;who&quot;, &quot;who's&quot;, &quot;whom&quot;, &quot;why&quot;, &quot;why's&quot;, &quot;with&quot;, &quot;won't&quot;, &quot;would&quot;, &quot;wouldn't&quot;, &quot;you&quot;,
				&quot;you'd&quot;, &quot;you'll&quot;, &quot;you're&quot;, &quot;you've&quot;, &quot;your&quot;, &quot;yours&quot;, &quot;yourself&quot;, &quot;yourselves&quot;, &quot;many&quot;, &quot;)&quot;, &quot;(&quot;);
<span class="fc" id="L54">	}</span>

	public static double stringMatching(String queryOne, String queryTwo)
	{
<span class="fc" id="L58">		double similarityScore = calculateScore(createNGrams(queryOne.toLowerCase().trim(), true),</span>
<span class="fc" id="L59">				createNGrams(queryTwo.toLowerCase().trim(), true));</span>
<span class="fc" id="L60">		return similarityScore;</span>
	}

	public static double stringMatching(String queryOne, String queryTwo, boolean removeStopWords)
	{
<span class="nc" id="L65">		double similarityScore = calculateScore(createNGrams(queryOne.toLowerCase().trim(), removeStopWords),</span>
<span class="nc" id="L66">				createNGrams(queryTwo.toLowerCase().trim(), removeStopWords));</span>
<span class="nc" id="L67">		return similarityScore;</span>
	}

	/**
	 * create n-grams tokens of the string.
	 *
	 * @return a map of ngram tokens with the corresponding frequency
	 */

	public static Map&lt;String, Integer&gt; createNGrams(String inputQuery, boolean removeStopWords)
	{
<span class="fc" id="L78">		List&lt;String&gt; wordsInString = Lists.newArrayList(Stemmer.replaceIllegalCharacter(inputQuery).split(&quot; &quot;));</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">		if (removeStopWords) wordsInString.removeAll(STOPWORDSLIST);</span>
<span class="fc" id="L80">		List&lt;String&gt; stemmedWordsInString = wordsInString.stream().map(Stemmer::stem).collect(Collectors.toList());</span>
<span class="fc" id="L81">		Map&lt;String, Integer&gt; tokens = new HashMap&lt;&gt;();</span>
		// Padding the string
<span class="fc bfc" id="L83" title="All 2 branches covered.">		for (String singleWord : stemmedWordsInString)</span>
		{
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">			if (!StringUtils.isEmpty(singleWord))</span>
			{
				// The s$ will be the produced from two words.
<span class="fc" id="L88">				StringBuilder singleString = new StringBuilder(singleWord.length() + 2);</span>
<span class="fc" id="L89">				singleString.append('^').append(singleWord.toLowerCase()).append('$');</span>
<span class="fc" id="L90">				int length = singleString.length();</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">				for (int i = 0; i &lt; length - 1; i++)</span>
				{
<span class="fc" id="L93">					String token = null;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">					if (i + N_GRAMS &lt; length)</span>
					{
<span class="fc" id="L96">						token = singleString.substring(i, i + N_GRAMS);</span>

					}
					else
					{
<span class="fc" id="L101">						token = singleString.substring(length - 2);</span>
					}

<span class="fc bfc" id="L104" title="All 2 branches covered.">					if (!tokens.containsKey(token))</span>
					{
<span class="fc" id="L106">						tokens.put(token, 1);</span>
					}
					else
					{
<span class="fc" id="L110">						tokens.put(token, (tokens.get(token) + 1));</span>
					}
				}
			}
<span class="fc" id="L114">		}</span>

<span class="fc" id="L116">		return tokens;</span>
	}

	/**
	 * Calculate the ngram distance
	 */
	private static double calculateScore(Map&lt;String, Integer&gt; inputStringTokens,
			Map&lt;String, Integer&gt; ontologyTermTokens)
	{
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">		if (inputStringTokens.size() == 0 || ontologyTermTokens.size() == 0) return (double) 0;</span>
<span class="fc" id="L126">		int totalToken = getTotalNumTokens(inputStringTokens) + getTotalNumTokens(ontologyTermTokens);</span>
<span class="fc" id="L127">		int numMatchedToken = 0;</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">		for (String token : inputStringTokens.keySet())</span>
		{
<span class="fc bfc" id="L131" title="All 2 branches covered.">			if (ontologyTermTokens.containsKey(token))</span>
			{
<span class="fc" id="L133">				numMatchedToken += Math.min(inputStringTokens.get(token), ontologyTermTokens.get(token));</span>
			}
<span class="fc" id="L135">		}</span>

<span class="fc" id="L137">		return 2.0 * numMatchedToken / totalToken * 100;</span>
	}

	private static int getTotalNumTokens(Map&lt;String, Integer&gt; inputStringTokens)
	{
<span class="fc" id="L142">		int totalNum = 0;</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">		for (Integer frequency : inputStringTokens.values())</span>
		{
<span class="fc" id="L146">			totalNum += frequency;</span>
<span class="fc" id="L147">		}</span>
<span class="fc" id="L148">		return totalNum;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>