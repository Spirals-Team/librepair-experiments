<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PoliciesModelFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Model :: Policies</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.model.policies</a> &gt; <span class="el_source">PoliciesModelFactory.java</span></div><h1>PoliciesModelFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.model.policies;

import static org.eclipse.ditto.model.base.common.ConditionChecker.argumentNotEmpty;
import static org.eclipse.ditto.model.base.common.ConditionChecker.checkNotNull;
import static org.eclipse.ditto.model.base.exceptions.DittoJsonException.wrapJsonRuntimeException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.stream.Collectors;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

import org.eclipse.ditto.json.JsonFactory;
import org.eclipse.ditto.json.JsonObject;
import org.eclipse.ditto.json.JsonParseException;
import org.eclipse.ditto.json.JsonPointer;
import org.eclipse.ditto.json.JsonValue;
import org.eclipse.ditto.model.base.exceptions.DittoJsonException;

/**
 * Factory that new {@link Policy} objects and other objects related to policies.
 */
@Immutable
public final class PoliciesModelFactory {

    /*
     * Inhibit instantiation of this utility class.
     */
<span class="nc" id="L43">    private PoliciesModelFactory() {</span>
<span class="nc" id="L44">        throw new AssertionError();</span>
    }

    /**
     * Returns a {@link Label} for the given character sequence. If the given key value is already a Label, this is
     * immediately properly cast and returned.
     *
     * @param labelValue the character sequence value of the Label to be created.
     * @return a new Label with {@code labelValue} as its value.
     * @throws NullPointerException if {@code labelValue} is {@code null}.
     * @throws IllegalArgumentException if {@code labelValue} is empty.
     */
    public static Label newLabel(final CharSequence labelValue) {
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (labelValue instanceof Label) {</span>
<span class="fc" id="L58">            return (Label) labelValue;</span>
        }
<span class="fc" id="L60">        return ImmutableLabel.of(labelValue);</span>
    }

    /**
     * Returns a new {@link SubjectIssuer} with the specified {@code subjectIssuer}.
     *
     * @param subjectIssuer the SubjectIssuer char sequence.
     * @return the new {@link SubjectIssuer}.
     * @throws NullPointerException if {@code subjectIssuer} is {@code null}.
     * @throws IllegalArgumentException if {@code subjectIssuer} is empty.
     */
    public static SubjectIssuer newSubjectIssuer(final CharSequence subjectIssuer) {
<span class="fc" id="L72">        return ImmutableSubjectIssuer.of(subjectIssuer);</span>
    }

    /**
     * Returns a {@link SubjectId} for the given {@code issuer} and {@code subject} sequences.
     *
     * @param issuer the character sequence for the SubjectId's {@code issuer}.
     * @param subject the character sequence for the SubjectId's {@code subject}.
     * @return a new SubjectId.
     * @throws NullPointerException if {@code issuer} or {@code subject} is {@code null}.
     * @throws IllegalArgumentException if {@code issuer} or {@code subject} is empty.
     */
    public static SubjectId newSubjectId(final SubjectIssuer issuer, final CharSequence subject) {
<span class="fc" id="L85">        return ImmutableSubjectId.of(issuer, subject);</span>
    }

    /**
     * Returns a {@link SubjectId} for the given character sequence. If the given key value is already a SubjectId, this
     * is immediately properly cast and returned.
     *
     * @param subjectIssuerWithId the Subject issuer + Subject ID (separated with a &quot;{@value
     * SubjectId#ISSUER_DELIMITER}&quot;) of the SubjectId to be created.
     * @return a new SubjectId with {@code subjectIssuerWithId} as its value.
     * @throws NullPointerException if {@code subjectIssuerWithId} is {@code null}.
     * @throws IllegalArgumentException if {@code subjectIssuerWithId} is empty.
     */
    public static SubjectId newSubjectId(final CharSequence subjectIssuerWithId) {
<span class="fc" id="L99">        checkNotNull(subjectIssuerWithId, &quot;subjectIssuerWithId&quot;);</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (SubjectId.class.isAssignableFrom(subjectIssuerWithId.getClass())) {</span>
<span class="fc" id="L102">            return (SubjectId) subjectIssuerWithId;</span>
        }
<span class="fc" id="L104">        return ImmutableSubjectId.of(subjectIssuerWithId);</span>
    }

    /**
     * Returns a new {@link SubjectType} with the specified {@code subjectType}.
     *
     * @param subjectType the SubjectType char sequence.
     * @return the new {@link SubjectType}.
     * @throws NullPointerException if {@code subjectType} is {@code null}.
     */
    public static SubjectType newSubjectType(final CharSequence subjectType) {
<span class="fc" id="L115">        return ImmutableSubjectType.of(subjectType);</span>
    }


    /**
     * Returns a new {@code Subject} object with the given {@code subjectId} and
     * subject type {@link SubjectType#UNKNOWN}.
     *
     * @param subjectId the ID of the new Subject.
     * @return a new {@code Subject} object.
     * @throws NullPointerException if {@code subjectId} is {@code null}.
     */
    public static Subject newSubject(final SubjectId subjectId) {
<span class="fc" id="L128">        return ImmutableSubject.of(subjectId);</span>
    }

    /**
     * Returns a new {@link Subject} with the specified {@code subjectId} and {@code subjectType}.
     *
     * @param subjectId the ID of the new Subject to create.
     * @param subjectType the SubjectType of the new Subject to create.
     * @return the new {@link Subject}.
     * @throws NullPointerException if any argument is {@code null}.
     */
    public static Subject newSubject(final SubjectId subjectId, final SubjectType subjectType) {
<span class="fc" id="L140">        return ImmutableSubject.of(subjectId, subjectType);</span>
    }

    /**
     * Returns a new immutable {@link Subject} based on the given JSON object.
     *
     * @param subjectIssuerWithId the Subject issuer + Subject ID (separated with a &quot;{@value
     * SubjectId#ISSUER_DELIMITER}&quot;) of the Subject to be created.
     * @param jsonObject provides the initial values for the result.
     * @return the new Subject.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed.
     */
    public static Subject newSubject(final CharSequence subjectIssuerWithId, final JsonObject jsonObject) {
<span class="fc" id="L154">        return ImmutableSubject.fromJson(subjectIssuerWithId, jsonObject);</span>
    }

    /**
     * Returns a new empty {@link Subjects}.
     *
     * @return the new {@code Subjects}.
     */
    public static Subjects emptySubjects() {
<span class="nc" id="L163">        return ImmutableSubjects.of(Collections.emptyList());</span>
    }

    /**
     * Returns a new {@link Subjects} containing the given subjects.
     *
     * @param subjects the {@link Subject}s to be contained in the new Subjects.
     * @return the new {@code Subjects}.
     * @throws NullPointerException if {@code subjects} is {@code null}.
     */
    public static Subjects newSubjects(final Iterable&lt;Subject&gt; subjects) {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (subjects instanceof Subjects) {</span>
<span class="fc" id="L175">            return (Subjects) subjects;</span>
        }
<span class="fc" id="L177">        return ImmutableSubjects.of(subjects);</span>
    }

    /**
     * Returns a new {@link Subjects} containing the given subjects.
     *
     * @param subject the {@link Subject} to be contained in the new Subjects.
     * @param furtherSubjects further {@link Subject}s to be contained in the new Subjects.
     * @return the new {@code Subjects}.
     */
    public static Subjects newSubjects(final Subject subject, final Subject... furtherSubjects) {
<span class="fc" id="L188">        checkNotNull(subject, &quot;mandatory subject&quot;);</span>
<span class="fc" id="L189">        checkNotNull(furtherSubjects, &quot;additional subjects&quot;);</span>

<span class="fc" id="L191">        final Collection&lt;Subject&gt; allSubjects = new ArrayList&lt;&gt;(1 + furtherSubjects.length);</span>
<span class="fc" id="L192">        allSubjects.add(subject);</span>
<span class="fc" id="L193">        Collections.addAll(allSubjects, furtherSubjects);</span>

<span class="fc" id="L195">        return newSubjects(allSubjects);</span>
    }

    /**
     * Returns a new immutable {@link Subjects} based on the given JSON object.
     *
     * @param jsonObject provides the initial values for the result.
     * @return the new Subjects.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed.
     */
    public static Subjects newSubjects(final JsonObject jsonObject) {
<span class="fc" id="L207">        return ImmutableSubjects.fromJson(jsonObject);</span>
    }

    /**
     * Returns a {@link ResourceKey} for the given character sequence. The {@code typeWithPath} must contain a
     * &quot;{@value ResourceKey#KEY_DELIMITER}&quot; to separate Resource type and Resource path.
     * If the given key value is already a ResourceKey, this is immediately properly cast and returned.
     *
     * @param typeWithPath the character sequence value of the ResourceKey to be created.
     * @return a new ResourceKey.
     * @throws NullPointerException if {@code typeWithPath} is {@code null}.
     * @throws IllegalArgumentException if {@code typeWithPath} is empty.
     */
    public static ResourceKey newResourceKey(final CharSequence typeWithPath) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (typeWithPath instanceof ResourceKey) {</span>
<span class="nc" id="L222">            return (ResourceKey) typeWithPath;</span>
        }

<span class="fc" id="L225">        argumentNotEmpty(typeWithPath, &quot;typeWithPath&quot;);</span>

<span class="fc" id="L227">        final String[] typeWithPathSplit = splitTypeWithPath(typeWithPath.toString());</span>
<span class="fc" id="L228">        return ImmutableResourceKey.newInstance(typeWithPathSplit[0], JsonPointer.of(typeWithPathSplit[1]));</span>
    }

    private static String[] splitTypeWithPath(final String typeWithPath) {
<span class="fc" id="L232">        final String[] split = typeWithPath.split(ResourceKey.KEY_DELIMITER, 2);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (split.length &lt; 2) {</span>
<span class="nc" id="L234">            throw new DittoJsonException(JsonParseException.newBuilder()</span>
<span class="nc" id="L235">                    .message(&quot;The provided string was not in the expected format 'type:path'&quot;)</span>
<span class="nc" id="L236">                    .build());</span>
        }
<span class="fc" id="L238">        return split;</span>
    }

    /**
     * Returns a {@link ResourceKey} for the given {@code resourceType} and {@code resourcePath}.
     *
     * @param resourceType the type value of the ResourceKey to be created.
     * @param resourcePath the path value of the ResourceKey to be created.
     * @return a new ResourceKey.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws IllegalArgumentException if {@code resourceType} is empty.
     */
    public static ResourceKey newResourceKey(final CharSequence resourceType, final CharSequence resourcePath) {
<span class="fc" id="L251">        checkNotNull(resourcePath, &quot;resource path&quot;);</span>
<span class="fc" id="L252">        return ImmutableResourceKey.newInstance(resourceType, JsonPointer.of(resourcePath));</span>
    }

    /**
     * Returns a new {@link Resource} with the specified {@code resourceType}, {@code resourcePath} and
     * {@code effectedPermissions}.
     *
     * @param resourceType the type of the new Resource to create.
     * @param resourcePath the path of the new Resource to create.
     * @param effectedPermissions the EffectedPermissions of the new Resource to create.
     * @return the new {@link Resource}.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws IllegalArgumentException if {@code resourceType} is empty.
     */
    public static Resource newResource(final CharSequence resourceType, final CharSequence resourcePath,
            final EffectedPermissions effectedPermissions) {

<span class="fc" id="L269">        return newResource(newResourceKey(resourceType, resourcePath), effectedPermissions);</span>
    }

    /**
     * Returns a new {@link Resource} with the specified {@code resourceKey} and {@code effectedPermissions}.
     *
     * @param resourceKey the JSON key which is assumed to be the path of the new Resource to create prefixed with a
     * type.
     * @param effectedPermissions the EffectedPermissions of the new Resource to create.
     * @return the new {@link Resource}.
     */
    public static Resource newResource(final ResourceKey resourceKey, final JsonValue effectedPermissions) {
<span class="nc" id="L281">        return ImmutableResource.of(resourceKey, effectedPermissions);</span>
    }

    /**
     * Returns a new {@link Resource} with the specified {@code resourceKey} and {@code effectedPermissions}.
     *
     * @param resourceKey the JSON key which is assumed to be the path of the new Resource to create prefixed with a
     * type.
     * @param effectedPermissions the EffectedPermissions of the new Resource to create.
     * @return the new {@link Resource}.
     * @throws NullPointerException if any argument is {@code null}.
     */
    public static Resource newResource(final ResourceKey resourceKey, final EffectedPermissions effectedPermissions) {
<span class="fc" id="L294">        return ImmutableResource.of(resourceKey, effectedPermissions);</span>
    }

    /**
     * Returns a new empty {@link Resources}.
     *
     * @return the new {@code Resources}.
     */
    public static Resources emptyResources() {
<span class="fc" id="L303">        return ImmutableResources.of(Collections.emptyList());</span>
    }

    /**
     * Returns a new {@link Resources} containing the given resources.
     *
     * @param resources the resource iterator to use
     * @return the new {@code Resources}.
     * @throws NullPointerException if {@code resources} is {@code null}.
     */
    public static Resources newResources(final Iterable&lt;Resource&gt; resources) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (resources instanceof Resources) {</span>
<span class="fc" id="L315">            return (Resources) resources;</span>
        }
<span class="fc" id="L317">        return ImmutableResources.of(resources);</span>
    }

    /**
     * Returns a new {@link Resources} containing the given resource.
     *
     * @param resource the {@link Resource} to be contained in the new Resources.
     * @param furtherResources further {@link Resource}s to be contained in the new Resources.
     * @return the new {@code Resources}.
     * @throws NullPointerException if any argument is {@code null}.
     */
    public static Resources newResources(final Resource resource, final Resource... furtherResources) {
<span class="fc" id="L329">        checkNotNull(resource, &quot;mandatory resource&quot;);</span>
<span class="fc" id="L330">        checkNotNull(furtherResources, &quot;additional resources&quot;);</span>

<span class="fc" id="L332">        final Collection&lt;Resource&gt; allResources = new ArrayList&lt;&gt;(1 + furtherResources.length);</span>
<span class="fc" id="L333">        allResources.add(resource);</span>
<span class="fc" id="L334">        Collections.addAll(allResources, furtherResources);</span>

<span class="fc" id="L336">        return newResources(allResources);</span>
    }

    /**
     * Returns a new immutable {@link Resources} based on the given JSON object.
     *
     * @param jsonObject provides the initial values for the result.
     * @return the new Resources.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed.
     */
    public static Resources newResources(final JsonObject jsonObject) {
<span class="fc" id="L348">        return ImmutableResources.fromJson(jsonObject);</span>
    }

    /**
     * Returns a new {@link EffectedPermissions} containing the given {@code grantedPermissions} and
     * {@code revokedPermissions}.
     *
     * @param grantedPermissions the Permissions which should be granted - may be {@code null}.
     * @param revokedPermissions the Permissions which should be revoked - may be {@code null}.
     * @return the new {@code EffectedPermissions}.
     */
    public static EffectedPermissions newEffectedPermissions(@Nullable final Iterable&lt;String&gt; grantedPermissions,
            @Nullable final Iterable&lt;String&gt; revokedPermissions) {

<span class="fc" id="L362">        return ImmutableEffectedPermissions.of(getOrEmptyCollection(grantedPermissions),</span>
<span class="fc" id="L363">                getOrEmptyCollection(revokedPermissions));</span>
    }

    private static Iterable&lt;String&gt; getOrEmptyCollection(@Nullable final Iterable&lt;String&gt; iterable) {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        return (null != iterable) ? iterable : Collections.emptySet();</span>
    }

    /**
     * Returns a new immutable {@link PolicyRevision} which is initialised with the given revision number.
     *
     * @param revisionNumber the {@code long} value of the revision.
     * @return the new immutable {@code PolicyRevision}.
     */
    public static PolicyRevision newPolicyRevision(final long revisionNumber) {
<span class="fc" id="L377">        return ImmutablePolicyRevision.of(revisionNumber);</span>
    }

    /**
     * Returns a new empty immutable instance of {@link Permissions}.
     *
     * @return the new {@code Permissions}.
     */
    public static Permissions noPermissions() {
<span class="fc" id="L386">        return ImmutablePermissions.none();</span>
    }

    /**
     * Returns a new immutable instance of {@link Permissions} containing the given permissions.
     *
     * @param permissions the permissions to initialise the result with.
     * @return the new {@code Permissions}.
     * @throws NullPointerException if {@code permissions} is {@code null};
     */
    public static Permissions newPermissions(final Collection&lt;String&gt; permissions) {
<span class="fc" id="L397">        return ImmutablePermissions.of(permissions);</span>
    }

    /**
     * Returns a new immutable instance of {@link Permissions} containing the given permissions.
     *
     * @param permission the mandatory permission to be contained in the result.
     * @param furtherPermissions additional permissions to be contained in the result.
     * @return the new {@code Permissions}.
     * @throws NullPointerException if any argument is {@code null}.
     */
    public static Permissions newPermissions(final String permission, final String... furtherPermissions) {
<span class="fc" id="L409">        return ImmutablePermissions.of(permission, furtherPermissions);</span>
    }

    /**
     * Returns a new immutable {@link PolicyEntry} with the given authorization subject and permissions.
     *
     * @param label the Label of the PolicyEntry to create.
     * @param subjects the Subjects contained in the PolicyEntry to create.
     * @param resources the Resources of the PolicyEntry to create.
     * @return the new Policy entry.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws IllegalArgumentException if {@code label} is empty.
     */
    public static PolicyEntry newPolicyEntry(final CharSequence label, final Iterable&lt;Subject&gt; subjects, final Iterable&lt;Resource&gt; resources) {
<span class="fc" id="L423">        return ImmutablePolicyEntry.of(Label.of(label), newSubjects(subjects), newResources(resources));</span>
    }

    /**
     * Returns a new immutable {@link PolicyEntry} based on the given JSON object.
     *
     * @param label the Label for the PolicyEntry to create.
     * @param jsonObject the JSON object representation of a PolicyEntry.
     * @return the new Policy entry.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed.
     */
    public static PolicyEntry newPolicyEntry(final CharSequence label, final JsonObject jsonObject) {
<span class="nc" id="L436">        return ImmutablePolicyEntry.fromJson(label, jsonObject);</span>
    }

    /**
     * Returns a new immutable {@link PolicyEntry} based on the given JSON value.
     *
     * @param label the Label for the PolicyEntry to create.
     * @param jsonValue the JSON value representation of a PolicyEntry.
     * @return the new Policy entry.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws IllegalArgumentException if {@code label} is empty.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed.
     * @throws PolicyIdInvalidException if the parsed policy ID did not comply to {@link Policy#ID_REGEX}.
     */
    public static PolicyEntry newPolicyEntry(final CharSequence label, final JsonValue jsonValue) {
<span class="nc" id="L451">        final JsonObject jsonObject = wrapJsonRuntimeException(jsonValue::asObject);</span>
<span class="nc" id="L452">        return ImmutablePolicyEntry.fromJson(label, jsonObject);</span>
    }

    /**
     * Returns a new immutable {@link PolicyEntry} based on the given JSON string.
     *
     * @param label the Label for the PolicyEntry to create.
     * @param jsonString the JSON object representation as String of a PolicyEntry.
     * @return the new Policy entry.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed.
     */
    public static PolicyEntry newPolicyEntry(final CharSequence label, final String jsonString) {
<span class="nc" id="L465">        final JsonObject jsonObject = wrapJsonRuntimeException(() -&gt; JsonFactory.newObject(jsonString));</span>
<span class="nc" id="L466">        return ImmutablePolicyEntry.fromJson(label, jsonObject);</span>
    }

    /**
     * Returns a new immutable Iterable of Policy entries based on the given JSON object.
     *
     * @param jsonObject the JSON object representation of Policy entries.
     * @return the new initialised {@code Iterable} of {@code PolicyEntry}s.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed to
     * {@link Iterable} of {@link PolicyEntry}s.
     */
    public static Iterable&lt;PolicyEntry&gt; newPolicyEntries(final JsonObject jsonObject) {
<span class="nc" id="L479">        checkNotNull(jsonObject, &quot;JSON object&quot;);</span>
<span class="nc" id="L480">        return jsonObject.stream()</span>
<span class="nc" id="L481">                .map(jsonField -&gt; newPolicyEntry(jsonField.getKey(), jsonField.getValue()))</span>
<span class="nc" id="L482">                .collect(Collectors.toSet());</span>
    }

    /**
     * Returns a new immutable Iterable of Policy entries based on the given JSON string.
     *
     * @param jsonString the JSON object representation as String of Policy entries.
     * @return the new initialised {@code Policy}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed to
     * {@link Iterable} of {@link PolicyEntry}s.
     */
    public static Iterable&lt;PolicyEntry&gt; newPolicyEntries(final String jsonString) {
<span class="nc" id="L494">        final JsonObject jsonObject = wrapJsonRuntimeException(() -&gt; JsonFactory.newObject(jsonString));</span>
<span class="nc" id="L495">        return newPolicyEntries(jsonObject);</span>
    }

    /**
     * Returns a mutable builder with a fluent API for an immutable {@link Policy}.
     *
     * @param id the ID of the new Policy.
     * @return the new builder.
     * @throws PolicyIdInvalidException if {@code id} is invalid.
     */
    public static PolicyBuilder newPolicyBuilder(final CharSequence id) {
<span class="fc" id="L506">        return ImmutablePolicyBuilder.of(id);</span>
    }

    /**
     * Returns a mutable builder for a {@code Policy} based on the given {@code existingPolicy}.
     *
     * @param existingPolicy the existing Policy to instantiate the builder with.
     * @return the new builder.
     */
    public static PolicyBuilder newPolicyBuilder(final Policy existingPolicy) {
<span class="nc" id="L516">        return ImmutablePolicyBuilder.of(existingPolicy);</span>
    }

    /**
     * Returns a mutable builder with a fluent API for an immutable {@link Policy}. The builder is initialised
     * with the given Policy entries.
     *
     * @param id the ID of the new Policy.
     * @param policyEntries the initial entries of the new builder.
     * @return the new builder.
     * @throws NullPointerException if {@code policyEntries} is {@code null}.
     * @throws org.eclipse.ditto.model.policies.PolicyIdInvalidException if {@code id} is invalid.
     */
    public static PolicyBuilder newPolicyBuilder(final CharSequence id, final Iterable&lt;PolicyEntry&gt; policyEntries) {
<span class="nc" id="L530">        return ImmutablePolicyBuilder.of(id, policyEntries);</span>
    }

    /**
     * Returns a new immutable Policy which is initialised with the specified entries.
     *
     * @param id the ID of the new Policy.
     * @param entry the mandatory entry of the Policy.
     * @param furtherEntries additional entries of the Policy.
     * @return the new initialised Policy.
     * @throws NullPointerException if any argument is {@code null}.
     */
    public static Policy newPolicy(final CharSequence id, final PolicyEntry entry,
            final PolicyEntry... furtherEntries) {

<span class="nc" id="L545">        checkNotNull(entry, &quot;mandatory entry&quot;);</span>
<span class="nc" id="L546">        checkNotNull(furtherEntries, &quot;additional policy entries&quot;);</span>

<span class="nc" id="L548">        final Collection&lt;PolicyEntry&gt; allEntries = new HashSet&lt;&gt;(1 + furtherEntries.length);</span>
<span class="nc" id="L549">        allEntries.add(entry);</span>
<span class="nc" id="L550">        Collections.addAll(allEntries, furtherEntries);</span>

<span class="nc" id="L552">        return ImmutablePolicy.of(id, PolicyLifecycle.ACTIVE, PolicyRevision.newInstance(1), null, allEntries);</span>
    }

    /**
     * Returns a new immutable Policy which is initialised with the specified entries.
     *
     * @param id the ID of the new Policy.
     * @param entries the entries of the Policy.
     * @return the new initialised Policy.
     * @throws NullPointerException if any argument is {@code null}.
     */
    public static Policy newPolicy(final CharSequence id, final Iterable&lt;PolicyEntry&gt; entries) {
<span class="nc" id="L564">        return ImmutablePolicy.of(id, PolicyLifecycle.ACTIVE, PolicyRevision.newInstance(1), null, entries);</span>
    }

    /**
     * Returns a new immutable Policy based on the given JSON object.
     *
     * @param jsonObject the JSON object representation of a Policy.
     * @return the new initialised {@code Policy}.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonObject} cannot be parsed to
     * {@link Policy}.
     */
    public static Policy newPolicy(final JsonObject jsonObject) {
<span class="nc" id="L577">        return ImmutablePolicy.fromJson(jsonObject);</span>
    }

    /**
     * Returns a new immutable Policy based on the given JSON string.
     *
     * @param jsonString the JSON object representation as String of a Policy.
     * @return the new initialised {@code Policy}.
     * @throws org.eclipse.ditto.model.base.exceptions.DittoJsonException if {@code jsonString} cannot be parsed to
     * {@link Policy}.
     */
    public static Policy newPolicy(final String jsonString) {
<span class="nc" id="L589">        final JsonObject jsonObject = wrapJsonRuntimeException(() -&gt; JsonFactory.newObject(jsonString));</span>
<span class="nc" id="L590">        return newPolicy(jsonObject);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>