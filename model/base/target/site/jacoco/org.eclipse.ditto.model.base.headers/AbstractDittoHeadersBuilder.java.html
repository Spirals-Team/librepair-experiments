<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDittoHeadersBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Model :: Base</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.model.base.headers</a> &gt; <span class="el_source">AbstractDittoHeadersBuilder.java</span></div><h1>AbstractDittoHeadersBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.model.base.headers;

import static org.eclipse.ditto.model.base.common.ConditionChecker.argumentNotEmpty;
import static org.eclipse.ditto.model.base.common.ConditionChecker.checkNotEmpty;
import static org.eclipse.ditto.model.base.common.ConditionChecker.checkNotNull;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;

import javax.annotation.Nullable;
import javax.annotation.concurrent.NotThreadSafe;

import org.eclipse.ditto.json.JsonCollectors;
import org.eclipse.ditto.json.JsonFactory;
import org.eclipse.ditto.json.JsonField;
import org.eclipse.ditto.json.JsonValue;
import org.eclipse.ditto.json.JsonValueContainer;
import org.eclipse.ditto.model.base.auth.AuthorizationContext;
import org.eclipse.ditto.model.base.json.JsonSchemaVersion;

/**
 * An abstract base implementation for subclasses of {@link DittoHeadersBuilder}. This implementation does already
 * most of the work including header value validation.
 */
@NotThreadSafe
public abstract class AbstractDittoHeadersBuilder&lt;S extends AbstractDittoHeadersBuilder, R extends DittoHeaders&gt;
        implements DittoHeadersBuilder&lt;S, R&gt; {

    protected final S myself;
    private final Map&lt;String, String&gt; headers;
    private final Collection&lt;HeaderDefinition&gt; definitions;

    /**
     * Constructs a new {@code AbstractDittoHeadersBuilder} object.
     *
     * @param initialHeaders initial key-value-pairs or an empty map.
     * @param definitions a collection of all well known {@link HeaderDefinition}s of this builder. The definitions
     * are used for header value validation.
     * @param selfType this type is used to simulate the &quot;self type&quot; of the returned object for Method Chaining of
     * the builder methods.
     * @throws NullPointerException if any argument is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    protected AbstractDittoHeadersBuilder(final Map&lt;String, String&gt; initialHeaders,
<span class="fc" id="L61">            final Collection&lt;HeaderDefinition&gt; definitions, final Class&lt;?&gt; selfType) {</span>

<span class="fc" id="L63">        checkNotNull(initialHeaders, &quot;initial headers&quot;);</span>
<span class="fc" id="L64">        checkNotNull(definitions, &quot;header definitions&quot;);</span>
<span class="fc" id="L65">        validateValueTypes(initialHeaders, definitions);</span>
<span class="fc" id="L66">        myself = (S) selfType.cast(this);</span>
<span class="fc" id="L67">        headers = new HashMap&lt;&gt;(initialHeaders);</span>
<span class="fc" id="L68">        this.definitions = new HashSet&lt;&gt;(definitions);</span>
<span class="fc" id="L69">        Collections.addAll(this.definitions, DittoHeaderDefinition.values());</span>
<span class="fc" id="L70">    }</span>

    /**
     * Validates the values of the specified headers with the help of the specified definitions.
     *
     * @param headers the key-value-pairs to be validated.
     * @param definitions perform the actual validation.
     */
    protected void validateValueTypes(final Map&lt;String, String&gt; headers,
            final Collection&lt;HeaderDefinition&gt; definitions) {

<span class="fc bfc" id="L81" title="All 2 branches covered.">        for (final HeaderDefinition definition : definitions) {</span>
<span class="fc" id="L82">            final String value = headers.get(definition.getKey());</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">            if (null != value) {</span>
<span class="fc" id="L84">                definition.validateValue(value);</span>
            }
<span class="fc" id="L86">        }</span>
<span class="fc" id="L87">    }</span>

    protected static Map&lt;String, String&gt; toMap(final JsonValueContainer&lt;JsonField&gt; jsonObject) {
<span class="fc" id="L90">        checkNotNull(jsonObject, &quot;JSON object&quot;);</span>
<span class="fc" id="L91">        final Map&lt;String, String&gt; result = new HashMap&lt;&gt;(jsonObject.getSize());</span>
<span class="fc" id="L92">        jsonObject.forEach(jsonField -&gt; {</span>
<span class="fc" id="L93">            final JsonValue jsonValue = jsonField.getValue();</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            final String stringValue = jsonValue.isString() ? jsonValue.asString() : jsonValue.toString();</span>
<span class="fc" id="L95">            result.put(jsonField.getKeyName(), stringValue);</span>
<span class="fc" id="L96">        });</span>

<span class="fc" id="L98">        return result;</span>
    }

    @Override
    public S correlationId(@Nullable final CharSequence correlationId) {
<span class="fc" id="L103">        putCharSequence(DittoHeaderDefinition.CORRELATION_ID, correlationId);</span>
<span class="fc" id="L104">        return myself;</span>
    }

    /**
     * Puts the specified CharSequence value to this builder using the key of the specified definition. If the value
     * is {@code null} a possibly existing value for the same key is removed; thus putting a {@code null} value is same
     * as removing the key-value-pair.
     *
     * @param definition provides the key to be associated with {@code value}.
     * @param value the value to be associated with the key of {@code definition}.
     */
    protected void putCharSequence(final HeaderDefinition definition, @Nullable final CharSequence value) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (null != value) {</span>
<span class="fc" id="L117">            checkNotEmpty(value, definition.getKey());</span>
<span class="fc" id="L118">            headers.put(definition.getKey(), value.toString());</span>
        } else {
<span class="fc" id="L120">            removeHeader(definition.getKey());</span>
        }
<span class="fc" id="L122">    }</span>

    @Override
    public S source(@Nullable final CharSequence source) {
<span class="fc" id="L126">        putCharSequence(DittoHeaderDefinition.SOURCE, source);</span>
<span class="fc" id="L127">        return myself;</span>
    }

    @Override
    public S schemaVersion(@Nullable final JsonSchemaVersion schemaVersion) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (null != schemaVersion) {</span>
<span class="fc" id="L133">            putCharSequence(DittoHeaderDefinition.SCHEMA_VERSION, schemaVersion.toString());</span>
        } else {
<span class="fc" id="L135">            removeHeader(DittoHeaderDefinition.SCHEMA_VERSION.getKey());</span>
        }
<span class="fc" id="L137">        return myself;</span>
    }

    @Override
    public S authorizationContext(@Nullable final AuthorizationContext authorizationContext) {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (null != authorizationContext) {</span>
<span class="fc" id="L143">            return authorizationSubjects(authorizationContext.getAuthorizationSubjectIds());</span>
        }
<span class="nc" id="L145">        return myself;</span>
    }

    protected void putStringCollection(final HeaderDefinition definition, final Collection&lt;String&gt; collection) {
<span class="fc" id="L149">        checkNotNull(collection, definition.getKey());</span>
<span class="fc" id="L150">        putJsonValue(definition, toJsonValueArray(collection));</span>
<span class="fc" id="L151">    }</span>

    private static JsonValue toJsonValueArray(final Collection&lt;String&gt; stringCollection) {
<span class="fc" id="L154">        return stringCollection.stream()</span>
<span class="fc" id="L155">                .map(JsonFactory::newValue)</span>
<span class="fc" id="L156">                .collect(JsonCollectors.valuesToArray());</span>
    }

    private void putJsonValue(final HeaderDefinition definition, final JsonValue jsonValue) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        putCharSequence(definition, jsonValue.isString() ? jsonValue.asString() : jsonValue.toString());</span>
<span class="fc" id="L161">    }</span>

    @Override
    public S authorizationSubjects(final Collection&lt;String&gt; authorizationSubjectIds) {
<span class="fc" id="L165">        putStringCollection(DittoHeaderDefinition.AUTHORIZATION_SUBJECTS, authorizationSubjectIds);</span>
<span class="fc" id="L166">        return myself;</span>
    }

    @Override
    public S authorizationSubjects(final CharSequence authorizationSubject,
            final CharSequence... furtherAuthorizationSubjects) {

<span class="fc" id="L173">        checkNotNull(authorizationSubject, &quot;Authorization Subject ID&quot;);</span>
<span class="nc" id="L174">        checkNotNull(furtherAuthorizationSubjects, &quot;further Authorization Subject IDs&quot;);</span>

<span class="nc" id="L176">        final Collection&lt;String&gt; allAuthorizationSubjects = new ArrayList&lt;&gt;(1 + furtherAuthorizationSubjects.length);</span>
<span class="nc" id="L177">        allAuthorizationSubjects.add(authorizationSubject.toString());</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        for (final CharSequence furtherAuthorizationSubject : furtherAuthorizationSubjects) {</span>
<span class="nc" id="L179">            checkNotNull(furtherAuthorizationSubject, &quot;further Authorization Subject ID&quot;);</span>
<span class="nc" id="L180">            allAuthorizationSubjects.add(furtherAuthorizationSubject.toString());</span>
        }

<span class="nc" id="L183">        return authorizationSubjects(allAuthorizationSubjects);</span>
    }

    @Override
    public S readSubjects(final Collection&lt;String&gt; readSubjects) {
<span class="fc" id="L188">        putStringCollection(DittoHeaderDefinition.READ_SUBJECTS, readSubjects);</span>
<span class="fc" id="L189">        return myself;</span>
    }

    @Override
    public S channel(@Nullable final CharSequence channel) {
<span class="fc" id="L194">        putCharSequence(DittoHeaderDefinition.CHANNEL, channel);</span>
<span class="fc" id="L195">        return myself;</span>
    }

    @Override
    public S responseRequired(final boolean responseRequired) {
<span class="fc" id="L200">        putBoolean(DittoHeaderDefinition.RESPONSE_REQUIRED, responseRequired);</span>
<span class="fc" id="L201">        return myself;</span>
    }

    protected void putBoolean(final HeaderDefinition definition, final boolean value) {
<span class="fc" id="L205">        putJsonValue(definition, JsonFactory.newValue(value));</span>
<span class="fc" id="L206">    }</span>

    @Override
    public S dryRun(final boolean dryRun) {
<span class="fc" id="L210">        putBoolean(DittoHeaderDefinition.DRY_RUN, dryRun);</span>
<span class="fc" id="L211">        return myself;</span>
    }

    @Override
    public S origin(final CharSequence origin) {
<span class="nc" id="L216">        putCharSequence(DittoHeaderDefinition.ORIGIN, origin);</span>
<span class="nc" id="L217">        return myself;</span>
    }

    @Override
    public S contentType(final CharSequence contentType) {
<span class="nc" id="L222">        putCharSequence(DittoHeaderDefinition.CONTENT_TYPE, contentType);</span>
<span class="nc" id="L223">        return myself;</span>
    }

    @Override
    public S putHeader(final CharSequence key, final CharSequence value) {
<span class="fc" id="L228">        validateKey(key);</span>
<span class="fc" id="L229">        checkNotNull(value, &quot;value&quot;);</span>
<span class="fc" id="L230">        validateValueType(key, value);</span>
<span class="fc" id="L231">        headers.put(key.toString(), value.toString());</span>
<span class="fc" id="L232">        return myself;</span>
    }

    private static void validateKey(final CharSequence key) {
<span class="fc" id="L236">        argumentNotEmpty(key, &quot;key&quot;);</span>
<span class="fc" id="L237">    }</span>

    protected void validateValueType(final CharSequence key, final CharSequence value) {
<span class="fc" id="L240">        definitions.stream()</span>
<span class="fc" id="L241">                .filter(definition -&gt; Objects.equals(definition.getKey(), key))</span>
<span class="fc" id="L242">                .findAny()</span>
<span class="pc" id="L243">                .ifPresent(definition -&gt; definition.validateValue(value));</span>
<span class="fc" id="L244">    }</span>

    @Override
    public S putHeaders(final Map&lt;String, String&gt; headers) {
<span class="nc" id="L248">        checkNotNull(headers, &quot;headers&quot;);</span>
<span class="nc" id="L249">        validateValueTypes(headers, definitions);</span>
<span class="nc" id="L250">        this.headers.putAll(headers);</span>
<span class="nc" id="L251">        return myself;</span>
    }

    @Override
    public S removeHeader(final CharSequence key) {
<span class="fc" id="L256">        validateKey(key);</span>
<span class="fc" id="L257">        headers.remove(key.toString());</span>
<span class="fc" id="L258">        return myself;</span>
    }

    @Override
    public R build() {
<span class="fc" id="L263">        final ImmutableDittoHeaders dittoHeaders = ImmutableDittoHeaders.of(headers);</span>
<span class="fc" id="L264">        return doBuild(dittoHeaders);</span>
    }

    protected abstract R doBuild(DittoHeaders dittoHeaders);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>