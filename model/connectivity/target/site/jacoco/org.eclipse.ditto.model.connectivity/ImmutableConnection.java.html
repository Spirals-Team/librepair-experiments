<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImmutableConnection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Model :: Connectivity</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.model.connectivity</a> &gt; <span class="el_source">ImmutableConnection.java</span></div><h1>ImmutableConnection.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.model.connectivity;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

import org.eclipse.ditto.json.JsonArray;
import org.eclipse.ditto.json.JsonCollectors;
import org.eclipse.ditto.json.JsonFactory;
import org.eclipse.ditto.json.JsonField;
import org.eclipse.ditto.json.JsonMissingFieldException;
import org.eclipse.ditto.json.JsonObject;
import org.eclipse.ditto.json.JsonObjectBuilder;
import org.eclipse.ditto.json.JsonParseException;
import org.eclipse.ditto.json.JsonValue;
import org.eclipse.ditto.model.base.auth.AuthorizationContext;
import org.eclipse.ditto.model.base.auth.AuthorizationModelFactory;
import org.eclipse.ditto.model.base.auth.AuthorizationSubject;
import org.eclipse.ditto.model.base.json.JsonSchemaVersion;

/**
 * Immutable implementation of {@link Connection}.
 */
@Immutable
final class ImmutableConnection implements Connection {

<span class="fc" id="L50">    private static final Pattern URI_REGEX_PATTERN = Pattern.compile(Connection.UriRegex.REGEX);</span>

    private final String id;
    private final ConnectionType connectionType;
    private final ConnectionStatus connectionStatus;
    private final AuthorizationContext authorizationContext;
    private final String uri;
    private final String protocol;
    @Nullable private final String username;
    @Nullable private final String password;
    private final String hostname;
    private final int port;
    private final String path;

    private final Set&lt;Source&gt; sources;
    private final Set&lt;Target&gt; targets;
    private final int clientCount;
    private final boolean failoverEnabled;
    private final boolean validateCertificate;
    private final int processorPoolSize;
    private final Map&lt;String, String&gt; specificConfig;
    @Nullable private final MappingContext mappingContext;

<span class="fc" id="L73">    ImmutableConnection(final ImmutableConnectionBuilder builder) {</span>
<span class="fc" id="L74">        this.id = builder.id;</span>
<span class="fc" id="L75">        this.connectionType = builder.connectionType;</span>
<span class="fc" id="L76">        this.connectionStatus = builder.connectionStatus;</span>
<span class="fc" id="L77">        this.uri = builder.uri;</span>
<span class="fc" id="L78">        this.authorizationContext = builder.authorizationContext;</span>
<span class="fc" id="L79">        checkSourceAndTargetAreValid(builder);</span>
<span class="fc" id="L80">        this.sources = Collections.unmodifiableSet(new HashSet&lt;&gt;(builder.sources));</span>
<span class="fc" id="L81">        this.targets = Collections.unmodifiableSet(new HashSet&lt;&gt;(builder.targets));</span>
<span class="fc" id="L82">        this.clientCount = builder.clientCount;</span>
<span class="fc" id="L83">        this.failoverEnabled = builder.failoverEnabled;</span>
<span class="fc" id="L84">        this.validateCertificate = builder.validateCertificate;</span>
<span class="fc" id="L85">        this.processorPoolSize = builder.processorPoolSize;</span>
<span class="fc" id="L86">        this.specificConfig = Collections.unmodifiableMap(new HashMap&lt;&gt;(</span>
                builder.specificConfig));
<span class="fc" id="L88">        this.mappingContext = builder.mappingContext;</span>

<span class="fc" id="L90">        final Matcher matcher = URI_REGEX_PATTERN.matcher(uri);</span>

<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (matcher.matches()) {</span>
<span class="fc" id="L93">            protocol = matcher.group(Connection.UriRegex.PROTOCOL_REGEX_GROUP);</span>
<span class="fc" id="L94">            username = matcher.group(Connection.UriRegex.USERNAME_REGEX_GROUP);</span>
<span class="fc" id="L95">            password = matcher.group(Connection.UriRegex.PASSWORD_REGEX_GROUP);</span>
<span class="fc" id="L96">            hostname = matcher.group(Connection.UriRegex.HOSTNAME_REGEX_GROUP);</span>
<span class="fc" id="L97">            port = Integer.parseInt(matcher.group(Connection.UriRegex.PORT_REGEX_GROUP));</span>
<span class="fc" id="L98">            path = matcher.group(Connection.UriRegex.PATH_REGEX_GROUP);</span>
        } else {
<span class="nc" id="L100">            throw ConnectionUriInvalidException.newBuilder(uri).build();</span>
        }
<span class="fc" id="L102">    }</span>

    private void checkSourceAndTargetAreValid(final ImmutableConnectionBuilder builder) {
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">        if (builder.sources.isEmpty() &amp;&amp; builder.targets.isEmpty()) {</span>
<span class="fc" id="L106">            throw ConnectionConfigurationInvalidException</span>
<span class="fc" id="L107">                    .newBuilder(&quot;Either a source or a target must be specified &quot; +</span>
                            &quot;in the configuration of a connection.&quot;)
<span class="fc" id="L109">                    .build();</span>
        }
<span class="fc" id="L111">    }</span>

    /**
     * Creates a new {@code Connection} object from the specified JSON object.
     *
     * @param jsonObject a JSON object which provides the data for the Connection to be created.
     * @return a new Connection which is initialised with the extracted data from {@code jsonObject}.
     * @throws NullPointerException if {@code jsonObject} is {@code null}.
     * @throws org.eclipse.ditto.json.JsonParseException if {@code jsonObject} is not an appropriate JSON object.
     */
    public static Connection fromJson(final JsonObject jsonObject) {
<span class="fc" id="L122">        final String readId = jsonObject.getValueOrThrow(JsonFields.ID);</span>
<span class="fc" id="L123">        final String readConnectionTypeStr = jsonObject.getValueOrThrow(JsonFields.CONNECTION_TYPE);</span>
<span class="fc" id="L124">        final ConnectionType readConnectionType = ConnectionType.forName(readConnectionTypeStr)</span>
<span class="pc" id="L125">                .orElseThrow(() -&gt; JsonParseException.newBuilder()</span>
<span class="nc" id="L126">                        .message(&quot;Invalid connection type: &quot; + readConnectionTypeStr)</span>
<span class="nc" id="L127">                        .build());</span>
<span class="fc" id="L128">        final String readConnectionStatusStr = jsonObject.getValueOrThrow(JsonFields.CONNECTION_STATUS);</span>
<span class="fc" id="L129">        final ConnectionStatus readConnectionStatus = ConnectionStatus.forName(readConnectionStatusStr)</span>
<span class="pc" id="L130">                .orElseThrow(() -&gt; JsonParseException.newBuilder()</span>
<span class="nc" id="L131">                        .message(&quot;Invalid ConnectionStatus: &quot; + readConnectionStatusStr)</span>
<span class="nc" id="L132">                        .build());</span>
<span class="fc" id="L133">        final String readUri = jsonObject.getValueOrThrow(JsonFields.URI);</span>
<span class="fc" id="L134">        final JsonArray authContext = jsonObject.getValue(JsonFields.AUTHORIZATION_CONTEXT)</span>
<span class="fc" id="L135">                .orElseGet(() -&gt;</span>
<span class="nc" id="L136">                        jsonObject.getValue(</span>
                                &quot;authorizationSubject&quot;) // as a fallback use the already persisted &quot;authorizationSubject&quot; field
<span class="nc" id="L138">                                .filter(JsonValue::isString)</span>
<span class="nc" id="L139">                                .map(JsonValue::asString)</span>
<span class="nc" id="L140">                                .map(str -&gt; JsonArray.newBuilder().add(str).build())</span>
<span class="nc" id="L141">                                .orElseThrow(() -&gt; new JsonMissingFieldException(JsonFields.AUTHORIZATION_CONTEXT))</span>
                );
<span class="fc" id="L143">        final List&lt;AuthorizationSubject&gt; authorizationSubjects = authContext.stream()</span>
<span class="fc" id="L144">                .filter(JsonValue::isString)</span>
<span class="fc" id="L145">                .map(JsonValue::asString)</span>
<span class="fc" id="L146">                .map(AuthorizationSubject::newInstance)</span>
<span class="fc" id="L147">                .collect(Collectors.toList());</span>
<span class="fc" id="L148">        final AuthorizationContext readAuthorizationContext =</span>
<span class="fc" id="L149">                AuthorizationModelFactory.newAuthContext(authorizationSubjects);</span>
<span class="fc" id="L150">        final Set&lt;Source&gt; readSources = jsonObject.getValue(JsonFields.SOURCES)</span>
<span class="fc" id="L151">                .map(array -&gt; array.stream()</span>
<span class="fc" id="L152">                        .filter(JsonValue::isObject)</span>
<span class="fc" id="L153">                        .map(JsonValue::asObject)</span>
<span class="fc" id="L154">                        .map(ImmutableSource::fromJson)</span>
<span class="fc" id="L155">                        .collect(Collectors.toSet()))</span>
<span class="fc" id="L156">                .orElse(Collections.emptySet());</span>
<span class="fc" id="L157">        final Set&lt;Target&gt; readTargets = jsonObject.getValue(JsonFields.TARGETS)</span>
<span class="fc" id="L158">                .map(array -&gt; array.stream()</span>
<span class="fc" id="L159">                        .filter(JsonValue::isObject)</span>
<span class="fc" id="L160">                        .map(JsonValue::asObject)</span>
<span class="fc" id="L161">                        .map(ImmutableTarget::fromJson)</span>
<span class="fc" id="L162">                        .collect(Collectors.toSet()))</span>
<span class="fc" id="L163">                .orElse(Collections.emptySet());</span>

<span class="fc" id="L165">        final Optional&lt;Integer&gt; readClientCount = jsonObject.getValue(JsonFields.CLIENT_COUNT);</span>
<span class="fc" id="L166">        final Optional&lt;Boolean&gt; readFailoverEnabled = jsonObject.getValue(JsonFields.FAILOVER_ENABLED);</span>
<span class="fc" id="L167">        final Optional&lt;Boolean&gt; readValidateCertificates = jsonObject.getValue(JsonFields.VALIDATE_CERTIFICATES);</span>
<span class="fc" id="L168">        final Optional&lt;Integer&gt; readProcessorPoolSize = jsonObject.getValue(JsonFields.PROCESSOR_POOL_SIZE);</span>
<span class="fc" id="L169">        final Map&lt;String, String&gt; readConnectionTypeSpecificConfiguration = jsonObject</span>
<span class="fc" id="L170">                .getValue(JsonFields.SPECIFIC_CONFIG)</span>
<span class="fc" id="L171">                .filter(JsonValue::isObject)</span>
<span class="fc" id="L172">                .map(JsonValue::asObject)</span>
<span class="fc" id="L173">                .map(JsonObject::stream)</span>
<span class="fc" id="L174">                .map(jsonFields -&gt; jsonFields</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                        .collect(Collectors.toMap(JsonField::getKeyName, f -&gt; f.getValue().isString() ?</span>
<span class="nc" id="L176">                                f.getValue().asString() : f.getValue().toString())))</span>
<span class="fc" id="L177">                .orElse(Collections.emptyMap());</span>

<span class="fc" id="L179">        final MappingContext readMappingContext = jsonObject</span>
<span class="fc" id="L180">                .getValue(JsonFields.MAPPING_CONTEXT)</span>
<span class="fc" id="L181">                .map(ConnectivityModelFactory::mappingContextFromJson)</span>
<span class="fc" id="L182">                .orElse(null);</span>

<span class="fc" id="L184">        final ConnectionBuilder builder =</span>
<span class="fc" id="L185">                ImmutableConnectionBuilder.of(readId, readConnectionType, readConnectionStatus, readUri,</span>
                        readAuthorizationContext);

<span class="fc" id="L188">        builder.sources(readSources);</span>
<span class="fc" id="L189">        builder.targets(readTargets);</span>
<span class="fc" id="L190">        readClientCount.ifPresent(builder::clientCount);</span>
<span class="fc" id="L191">        readFailoverEnabled.ifPresent(builder::failoverEnabled);</span>
<span class="fc" id="L192">        readValidateCertificates.ifPresent(builder::validateCertificate);</span>
<span class="fc" id="L193">        readProcessorPoolSize.ifPresent(builder::processorPoolSize);</span>
<span class="fc" id="L194">        builder.specificConfig(readConnectionTypeSpecificConfiguration);</span>
<span class="fc" id="L195">        builder.mappingContext(readMappingContext);</span>
<span class="fc" id="L196">        return builder.build();</span>
    }

    @Override
    public String getId() {
<span class="fc" id="L201">        return id;</span>
    }

    @Override
    public ConnectionType getConnectionType() {
<span class="fc" id="L206">        return connectionType;</span>
    }

    @Override
    public ConnectionStatus getConnectionStatus() {
<span class="nc" id="L211">        return connectionStatus;</span>
    }

    @Override
    public AuthorizationContext getAuthorizationContext() {
<span class="fc" id="L216">        return authorizationContext;</span>
    }

    @Override
    public Set&lt;Source&gt; getSources() {
<span class="fc" id="L221">        return sources;</span>
    }

    @Override
    public Set&lt;Target&gt; getTargets() {
<span class="nc" id="L226">        return targets;</span>
    }

    @Override
    public int getClientCount() {
<span class="nc" id="L231">        return clientCount;</span>
    }

    @Override
    public boolean isFailoverEnabled() {
<span class="nc" id="L236">        return failoverEnabled;</span>
    }

    @Override
    public String getUri() {
<span class="fc" id="L241">        return uri;</span>
    }

    @Override
    public String getProtocol() {
<span class="nc" id="L246">        return protocol;</span>
    }

    @Override
    public Optional&lt;String&gt; getUsername() {
<span class="nc" id="L251">        return Optional.ofNullable(username);</span>
    }

    @Override
    public Optional&lt;String&gt; getPassword() {
<span class="nc" id="L256">        return Optional.ofNullable(password);</span>
    }

    @Override
    public String getHostname() {
<span class="nc" id="L261">        return hostname;</span>
    }

    @Override
    public int getPort() {
<span class="nc" id="L266">        return port;</span>
    }

    @Override
    public String getPath() {
<span class="nc" id="L271">        return path;</span>
    }

    @Override
    public boolean isValidateCertificates() {
<span class="nc" id="L276">        return validateCertificate;</span>
    }

    @Override
    public int getProcessorPoolSize() {
<span class="nc" id="L281">        return processorPoolSize;</span>
    }

    @Override
    public Map&lt;String, String&gt; getSpecificConfig() {
<span class="nc" id="L286">        return specificConfig;</span>
    }

    @Override
    public Optional&lt;MappingContext&gt; getMappingContext() {
<span class="nc" id="L291">        return Optional.ofNullable(mappingContext);</span>
    }

    @Override
    public JsonObject toJson(final JsonSchemaVersion schemaVersion, final Predicate&lt;JsonField&gt; thePredicate) {
<span class="fc" id="L296">        final Predicate&lt;JsonField&gt; predicate = schemaVersion.and(thePredicate);</span>
<span class="fc" id="L297">        final JsonObjectBuilder jsonObjectBuilder = JsonFactory.newObjectBuilder();</span>

<span class="fc" id="L299">        jsonObjectBuilder.set(JsonFields.SCHEMA_VERSION, schemaVersion.toInt(), predicate);</span>
<span class="fc" id="L300">        jsonObjectBuilder.set(JsonFields.ID, id, predicate);</span>
<span class="fc" id="L301">        jsonObjectBuilder.set(JsonFields.CONNECTION_TYPE, connectionType.getName(), predicate);</span>
<span class="fc" id="L302">        jsonObjectBuilder.set(JsonFields.CONNECTION_STATUS, connectionStatus.getName(), predicate);</span>
<span class="fc" id="L303">        jsonObjectBuilder.set(JsonFields.URI, uri, predicate);</span>
<span class="fc" id="L304">        jsonObjectBuilder.set(JsonFields.AUTHORIZATION_CONTEXT, authorizationContext.stream()</span>
<span class="fc" id="L305">                .map(AuthorizationSubject::getId)</span>
<span class="fc" id="L306">                .map(JsonFactory::newValue)</span>
<span class="fc" id="L307">                .collect(JsonCollectors.valuesToArray()), predicate);</span>
<span class="fc" id="L308">        jsonObjectBuilder.set(JsonFields.SOURCES, sources.stream()</span>
<span class="fc" id="L309">                .map(source -&gt; source.toJson(schemaVersion, thePredicate))</span>
<span class="fc" id="L310">                .collect(JsonCollectors.valuesToArray()), predicate.and(Objects::nonNull));</span>
<span class="fc" id="L311">        jsonObjectBuilder.set(JsonFields.TARGETS, targets.stream()</span>
<span class="fc" id="L312">                .map(source -&gt; source.toJson(schemaVersion, thePredicate))</span>
<span class="fc" id="L313">                .collect(JsonCollectors.valuesToArray()), predicate.and(Objects::nonNull));</span>
<span class="fc" id="L314">        jsonObjectBuilder.set(JsonFields.CLIENT_COUNT, clientCount, predicate);</span>
<span class="fc" id="L315">        jsonObjectBuilder.set(JsonFields.FAILOVER_ENABLED, failoverEnabled, predicate);</span>
<span class="fc" id="L316">        jsonObjectBuilder.set(JsonFields.VALIDATE_CERTIFICATES, validateCertificate, predicate);</span>
<span class="fc" id="L317">        jsonObjectBuilder.set(JsonFields.PROCESSOR_POOL_SIZE, processorPoolSize, predicate);</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (!specificConfig.isEmpty()) {</span>
<span class="nc" id="L319">            jsonObjectBuilder.set(JsonFields.SPECIFIC_CONFIG, specificConfig.entrySet().stream()</span>
<span class="nc" id="L320">                    .map(entry -&gt; JsonField.newInstance(entry.getKey(), JsonValue.of(entry.getValue())))</span>
<span class="nc" id="L321">                    .collect(JsonCollectors.fieldsToObject()), predicate);</span>
        }
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (mappingContext != null) {</span>
<span class="fc" id="L324">            jsonObjectBuilder.set(JsonFields.MAPPING_CONTEXT, mappingContext.toJson(schemaVersion, thePredicate),</span>
                    predicate);
        }
<span class="fc" id="L327">        return jsonObjectBuilder.build();</span>
    }

    @SuppressWarnings(&quot;OverlyComplexMethod&quot;)
    @Override
    public boolean equals(@Nullable final Object o) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (this == o) {return true;}</span>
<span class="fc bfc" id="L334" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) {return false;}</span>
<span class="fc" id="L335">        final ImmutableConnection that = (ImmutableConnection) o;</span>
<span class="fc bfc" id="L336" title="All 4 branches covered.">        return failoverEnabled == that.failoverEnabled &amp;&amp;</span>
                port == that.port &amp;&amp;
<span class="fc bfc" id="L338" title="All 2 branches covered.">                Objects.equals(id, that.id) &amp;&amp;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                Objects.equals(connectionType, that.connectionType) &amp;&amp;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                Objects.equals(connectionStatus, that.connectionStatus) &amp;&amp;</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                Objects.equals(authorizationContext, that.authorizationContext) &amp;&amp;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                Objects.equals(sources, that.sources) &amp;&amp;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                Objects.equals(targets, that.targets) &amp;&amp;</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                Objects.equals(clientCount, that.clientCount) &amp;&amp;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                Objects.equals(uri, that.uri) &amp;&amp;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                Objects.equals(protocol, that.protocol) &amp;&amp;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                Objects.equals(username, that.username) &amp;&amp;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                Objects.equals(password, that.password) &amp;&amp;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">                Objects.equals(hostname, that.hostname) &amp;&amp;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                Objects.equals(path, that.path) &amp;&amp;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                Objects.equals(processorPoolSize, that.processorPoolSize) &amp;&amp;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">                Objects.equals(validateCertificate, that.validateCertificate) &amp;&amp;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">                Objects.equals(specificConfig, that.specificConfig) &amp;&amp;</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                Objects.equals(mappingContext, that.mappingContext);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L359">        return Objects.hash(id, connectionType, connectionStatus, authorizationContext, sources, targets, clientCount,</span>
<span class="fc" id="L360">                failoverEnabled, uri, protocol, username, password, hostname, path, port, validateCertificate,</span>
<span class="fc" id="L361">                processorPoolSize, specificConfig, mappingContext);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L366">        return getClass().getSimpleName() + &quot; [&quot; +</span>
                &quot;id=&quot; + id +
                &quot;, connectionType=&quot; + connectionType +
                &quot;, connectionStatus=&quot; + connectionStatus +
                &quot;, authorizationContext=&quot; + authorizationContext +
                &quot;, failoverEnabled=&quot; + failoverEnabled +
                &quot;, uri=&quot; + uri +
                &quot;, protocol=&quot; + protocol +
                &quot;, username=&quot; + username +
                &quot;, password=&quot; + password +
                &quot;, hostname=&quot; + hostname +
                &quot;, port=&quot; + port +
                &quot;, path=&quot; + path +
                &quot;, sources=&quot; + sources +
                &quot;, targets=&quot; + targets +
                &quot;, clientCount=&quot; + clientCount +
                &quot;, validateCertificate=&quot; + validateCertificate +
                &quot;, processorPoolSize=&quot; + processorPoolSize +
                &quot;, specificConfig=&quot; + specificConfig +
                &quot;, mappingContext=&quot; + mappingContext +
                &quot;]&quot;;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>