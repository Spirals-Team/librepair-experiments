<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImmutableExternalMessage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Model :: Connectivity</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.model.connectivity</a> &gt; <span class="el_source">ImmutableExternalMessage.java</span></div><h1>ImmutableExternalMessage.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 *
 */
package org.eclipse.ditto.model.connectivity;

import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

/**
 * Immutable implementation of {@link ExternalMessage}.
 */
@Immutable
final class ImmutableExternalMessage implements ExternalMessage {

    private final Map&lt;String, String&gt; headers;
    @Nullable private final String topicPath;
    private final boolean response;
    private final PayloadType payloadType;

    @Nullable private final String textPayload;
    @Nullable private final ByteBuffer bytePayload;

    ImmutableExternalMessage(final Map&lt;String, String&gt; headers,
            @Nullable final String topicPath,
            final boolean response,
            final PayloadType payloadType,
            @Nullable final String textPayload,
<span class="nc" id="L43">            @Nullable final ByteBuffer bytePayload) {</span>

<span class="nc" id="L45">        this.headers = Collections.unmodifiableMap(new HashMap&lt;&gt;(headers));</span>
<span class="nc" id="L46">        this.topicPath = topicPath;</span>
<span class="nc" id="L47">        this.response = response;</span>
<span class="nc" id="L48">        this.payloadType = payloadType;</span>
<span class="nc" id="L49">        this.textPayload = textPayload;</span>
<span class="nc" id="L50">        this.bytePayload = bytePayload;</span>
<span class="nc" id="L51">    }</span>

    @Override
    public Map&lt;String, String&gt; getHeaders() {
<span class="nc" id="L55">        return headers;</span>
    }

    @Override
    public ExternalMessage withHeader(final String key, final String value) {
<span class="nc" id="L60">        return ConnectivityModelFactory.newExternalMessageBuilder(this).withAdditionalHeaders(key, value).build();</span>
    }

    @Override
    public ExternalMessage withHeaders(final Map&lt;String, String&gt; additionalHeaders) {
<span class="nc" id="L65">        return ConnectivityModelFactory.newExternalMessageBuilder(this).withAdditionalHeaders(additionalHeaders).build();</span>
    }

    @Override
    public Optional&lt;String&gt; findHeader(final String key) {
<span class="nc bnc" id="L70" title="All 2 branches missed.">        return Optional.ofNullable(headers.get(key)).filter(s -&gt; !s.isEmpty());</span>
    }

    @Override
    public Optional&lt;String&gt; findHeaderIgnoreCase(final String key) {
<span class="nc" id="L75">        return headers.entrySet().stream().filter(e -&gt; key.equalsIgnoreCase(e.getKey())).findFirst()</span>
<span class="nc" id="L76">                .map(Map.Entry::getValue);</span>
    }

    @Override
    public boolean isTextMessage() {
<span class="nc" id="L81">        return PayloadType.TEXT.equals(payloadType);</span>
    }

    @Override
    public boolean isBytesMessage() {
<span class="nc" id="L86">        return PayloadType.BYTES.equals(payloadType);</span>
    }

    @Override
    public Optional&lt;String&gt; getTextPayload() {
<span class="nc" id="L91">        return Optional.ofNullable(textPayload);</span>
    }

    @Override
    public Optional&lt;ByteBuffer&gt; getBytePayload() {
<span class="nc" id="L96">        return Optional.ofNullable(bytePayload);</span>
    }

    @Override
    public Optional&lt;String&gt; getTopicPath() {
<span class="nc" id="L101">        return Optional.ofNullable(topicPath);</span>
    }

    @Override
    public PayloadType getPayloadType() {
<span class="nc" id="L106">        return payloadType;</span>
    }

    @Override
    public boolean isResponse() {
<span class="nc" id="L111">        return response;</span>
    }

    @Override
    public boolean equals(final Object o) {
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (this == o) {</span>
<span class="fc" id="L117">            return true;</span>
        }
<span class="fc bfc" id="L119" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="fc" id="L120">            return false;</span>
        }
<span class="fc" id="L122">        final ImmutableExternalMessage that = (ImmutableExternalMessage) o;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        return Objects.equals(headers, that.headers) &amp;&amp;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                Objects.equals(textPayload, that.textPayload) &amp;&amp;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                Objects.equals(bytePayload, that.bytePayload) &amp;&amp;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                Objects.equals(topicPath, that.topicPath) &amp;&amp;</span>
<span class="fc bfc" id="L127" title="All 4 branches covered.">                Objects.equals(response, that.response) &amp;&amp;</span>
                payloadType == that.payloadType;
    }

    @Override
    public int hashCode() {
<span class="fc" id="L133">        return Objects.hash(headers, textPayload, bytePayload, payloadType, response, topicPath);</span>
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        return getClass().getSimpleName() + &quot; [&quot; +</span>
                &quot;headers=&quot; + headers +
                &quot;, topicPath=&quot; + topicPath +
                &quot;, response=&quot; + response +
                &quot;, payloadType=&quot; + payloadType +
                &quot;, textPayload=&quot; + textPayload +
                &quot;, bytePayload=&quot; +
<span class="nc" id="L145">                (bytePayload == null ? &quot;null&quot; : (&quot;&lt;binary&gt; (size :&quot; + bytePayload.array().length + &quot;)&quot;)) + &quot;'&quot; +</span>
                &quot;]&quot;;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>