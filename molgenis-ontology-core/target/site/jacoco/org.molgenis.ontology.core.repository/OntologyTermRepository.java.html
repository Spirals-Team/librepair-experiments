<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OntologyTermRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ontology-core</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.ontology.core.repository</a> &gt; <span class="el_source">OntologyTermRepository.java</span></div><h1>OntologyTermRepository.java</h1><pre class="source lang-java linenums">package org.molgenis.ontology.core.repository;

import com.google.common.collect.FluentIterable;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import org.apache.commons.lang3.StringUtils;
import org.molgenis.data.*;
import org.molgenis.data.QueryRule.Operator;
import org.molgenis.data.support.QueryImpl;
import org.molgenis.ontology.core.meta.OntologyMetaData;
import org.molgenis.ontology.core.meta.OntologyTermMetaData;
import org.molgenis.ontology.core.meta.OntologyTermNodePathMetaData;
import org.molgenis.ontology.core.meta.OntologyTermSynonymMetaData;
import org.molgenis.ontology.core.model.Ontology;
import org.molgenis.ontology.core.model.OntologyTerm;

import java.util.*;
import java.util.stream.Collectors;

import static java.util.Objects.requireNonNull;
import static org.molgenis.ontology.core.meta.OntologyTermMetaData.*;

/**
 * Maps {@link OntologyTermMetaData} {@link Entity} &lt;-&gt; {@link OntologyTerm}
 */
public class OntologyTermRepository
{
	private final DataService dataService;

	public OntologyTermRepository(DataService dataService)
<span class="fc" id="L31">	{</span>
<span class="fc" id="L32">		this.dataService = requireNonNull(dataService);</span>
<span class="fc" id="L33">	}</span>

	public List&lt;OntologyTerm&gt; findOntologyTerms(String term, int pageSize)
	{
		Iterable&lt;Entity&gt; ontologyTermEntities;

		// #1 find exact match
<span class="nc" id="L40">		Query&lt;Entity&gt; termNameQuery = new QueryImpl&lt;&gt;().eq(OntologyTermMetaData.ONTOLOGY_TERM_NAME, term)</span>
<span class="nc" id="L41">													   .pageSize(pageSize);</span>
<span class="nc" id="L42">		ontologyTermEntities = () -&gt; dataService.findAll(ONTOLOGY_TERM, termNameQuery).iterator();</span>

<span class="nc bnc" id="L44" title="All 2 branches missed.">		if (!ontologyTermEntities.iterator().hasNext())</span>
		{
<span class="nc" id="L46">			Query&lt;Entity&gt; termsQuery = new QueryImpl&lt;&gt;().search(term).pageSize(pageSize);</span>
<span class="nc" id="L47">			ontologyTermEntities = () -&gt; dataService.findAll(ONTOLOGY_TERM, termsQuery).iterator();</span>
		}
<span class="nc" id="L49">		return Lists.newArrayList(Iterables.transform(ontologyTermEntities, OntologyTermRepository::toOntologyTerm));</span>
	}

	/**
	 * Finds exact {@link OntologyTerm}s within {@link Ontology}s.
	 *
	 * @param ontologyIds IDs of the {@link Ontology}s to search in
	 * @param terms       {@link List} of search terms. the {@link OntologyTerm} must match at least one of these terms
	 * @param pageSize    max number of results
	 * @return {@link List} of {@link OntologyTerm}s
	 */
	public List&lt;OntologyTerm&gt; findExcatOntologyTerms(List&lt;String&gt; ontologyIds, Set&lt;String&gt; terms, int pageSize)
	{
<span class="fc" id="L62">		List&lt;OntologyTerm&gt; findOntologyTerms = findOntologyTerms(ontologyIds, terms, pageSize);</span>
<span class="fc" id="L63">		return findOntologyTerms.stream()</span>
<span class="fc" id="L64">								.filter(ontologyTerm -&gt; isOntologyTermExactMatch(terms, ontologyTerm))</span>
<span class="fc" id="L65">								.collect(Collectors.toList());</span>
	}

	private boolean isOntologyTermExactMatch(Set&lt;String&gt; terms, OntologyTerm ontologyTerm)
	{
<span class="fc" id="L70">		Set&lt;String&gt; lowerCaseSearchTerms = terms.stream().map(StringUtils::lowerCase).collect(Collectors.toSet());</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">		for (String synonym : ontologyTerm.getSynonyms())</span>
		{
<span class="fc bfc" id="L73" title="All 2 branches covered.">			if (lowerCaseSearchTerms.contains(synonym.toLowerCase()))</span>
			{
<span class="fc" id="L75">				return true;</span>
			}
<span class="fc" id="L77">		}</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">		if (lowerCaseSearchTerms.contains(ontologyTerm.getLabel().toLowerCase()))</span>
		{
<span class="nc" id="L80">			return true;</span>
		}
<span class="fc" id="L82">		return false;</span>
	}

	/**
	 * Finds {@link OntologyTerm}s within {@link Ontology}s.
	 *
	 * @param ontologyIds IDs of the {@link Ontology}s to search in
	 * @param terms       {@link List} of search terms. the {@link OntologyTerm} must match at least one of these terms
	 * @param pageSize    max number of results
	 * @return {@link List} of {@link OntologyTerm}s
	 */
	public List&lt;OntologyTerm&gt; findOntologyTerms(List&lt;String&gt; ontologyIds, Set&lt;String&gt; terms, int pageSize)
	{
<span class="fc" id="L95">		List&lt;QueryRule&gt; rules = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">		for (String term : terms)</span>
		{
<span class="fc bfc" id="L98" title="All 2 branches covered.">			if (!rules.isEmpty())</span>
			{
<span class="fc" id="L100">				rules.add(new QueryRule(Operator.OR));</span>
			}
<span class="fc" id="L102">			rules.add(new QueryRule(OntologyTermMetaData.ONTOLOGY_TERM_SYNONYM, Operator.FUZZY_MATCH, term));</span>
<span class="fc" id="L103">		}</span>
<span class="fc" id="L104">		rules = Arrays.asList(new QueryRule(ONTOLOGY, Operator.IN, ontologyIds), new QueryRule(Operator.AND),</span>
				new QueryRule(rules));

<span class="fc" id="L107">		final List&lt;QueryRule&gt; finalRules = rules;</span>
<span class="fc" id="L108">		Iterable&lt;Entity&gt; termEntities = () -&gt; dataService.findAll(ONTOLOGY_TERM,</span>
<span class="fc" id="L109">				new QueryImpl&lt;&gt;(finalRules).pageSize(pageSize)).iterator();</span>

<span class="fc" id="L111">		return Lists.newArrayList(Iterables.transform(termEntities, OntologyTermRepository::toOntologyTerm));</span>
	}

	public List&lt;OntologyTerm&gt; getAllOntologyTerms(String ontologyId)
	{
<span class="nc" id="L116">		Entity ontologyEntity = dataService.findOne(OntologyMetaData.ONTOLOGY,</span>
<span class="nc" id="L117">				new QueryImpl&lt;&gt;().eq(OntologyMetaData.ONTOLOGY_IRI, ontologyId));</span>

<span class="nc bnc" id="L119" title="All 2 branches missed.">		if (ontologyEntity != null)</span>
		{
<span class="nc" id="L121">			Iterable&lt;Entity&gt; ontologyTermEntities = () -&gt; dataService.findAll(OntologyTermMetaData.ONTOLOGY_TERM,</span>
<span class="nc" id="L122">					new QueryImpl&lt;&gt;().eq(OntologyTermMetaData.ONTOLOGY, ontologyEntity).pageSize(Integer.MAX_VALUE))</span>
<span class="nc" id="L123">																	 .iterator();</span>

<span class="nc" id="L125">			return Lists.newArrayList(</span>
<span class="nc" id="L126">					Iterables.transform(ontologyTermEntities, OntologyTermRepository::toOntologyTerm));</span>
		}

<span class="nc" id="L129">		return Collections.emptyList();</span>
	}

	/**
	 * Retrieves an {@link OntologyTerm} for one or more IRIs
	 *
	 * @param iris Array of {@link OntologyTerm} IRIs
	 * @return combined {@link OntologyTerm} for the iris.
	 */
	public OntologyTerm getOntologyTerm(String[] iris)
	{
<span class="fc" id="L140">		List&lt;OntologyTerm&gt; ontologyTerms = Lists.newArrayList();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">		for (String iri : iris)</span>
		{
<span class="fc" id="L143">			OntologyTerm ontologyTerm = toOntologyTerm(</span>
<span class="fc" id="L144">					dataService.findOne(ONTOLOGY_TERM, QueryImpl.EQ(ONTOLOGY_TERM_IRI, iri)));</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">			if (ontologyTerm == null)</span>
			{
<span class="nc" id="L147">				return null;</span>
			}
<span class="fc" id="L149">			ontologyTerms.add(ontologyTerm);</span>
		}
<span class="fc" id="L151">		return OntologyTerm.and(ontologyTerms.toArray(new OntologyTerm[0]));</span>
	}

	/**
	 * Calculate the distance between any two ontology terms in the ontology tree structure by calculating the
	 * difference in nodePaths.
	 *
	 * @return the distance between two ontology terms
	 */
	public int getOntologyTermDistance(OntologyTerm ontologyTerm1, OntologyTerm ontologyTerm2)
	{
<span class="nc" id="L162">		String nodePath1 = getOntologyTermNodePath(ontologyTerm1);</span>
<span class="nc" id="L163">		String nodePath2 = getOntologyTermNodePath(ontologyTerm2);</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">		if (StringUtils.isEmpty(nodePath1))</span>
		{
<span class="nc" id="L167">			throw new MolgenisDataAccessException(&quot;The nodePath cannot be null : &quot; + ontologyTerm1.toString());</span>
		}

<span class="nc bnc" id="L170" title="All 2 branches missed.">		if (StringUtils.isEmpty(nodePath2))</span>
		{
<span class="nc" id="L172">			throw new MolgenisDataAccessException(&quot;The nodePath cannot be null : &quot; + ontologyTerm2.toString());</span>
		}

<span class="nc" id="L175">		return calculateNodePathDistance(nodePath1, nodePath2);</span>
	}

	private String getOntologyTermNodePath(OntologyTerm ontologyTerm)
	{
<span class="nc" id="L180">		Entity ontologyTermEntity = dataService.findOne(ONTOLOGY_TERM,</span>
<span class="nc" id="L181">				new QueryImpl&lt;&gt;().eq(ONTOLOGY_TERM_IRI, ontologyTerm.getIRI()));</span>

<span class="nc" id="L183">		Iterable&lt;Entity&gt; ontologyTermNodePathEntities = ontologyTermEntity.getEntities(</span>
				OntologyTermMetaData.ONTOLOGY_TERM_NODE_PATH);

<span class="nc" id="L186">		return ontologyTermNodePathEntities.iterator().next().getString(OntologyTermNodePathMetaData.NODE_PATH);</span>
	}

	/**
	 * Calculate the distance between nodePaths, e.g. 0[0].1[1].2[2], 0[0].2[1].2[2]. The distance is the non-overlap
	 * part of the strings
	 *
	 * @return distance
	 */
	public int calculateNodePathDistance(String nodePath1, String nodePath2)
	{
<span class="fc" id="L197">		String[] nodePathFragment1 = nodePath1.split(&quot;\\.&quot;);</span>
<span class="fc" id="L198">		String[] nodePathFragment2 = nodePath2.split(&quot;\\.&quot;);</span>

<span class="fc" id="L200">		int overlapBlock = 0;</span>
<span class="fc bfc" id="L201" title="All 4 branches covered.">		while (overlapBlock &lt; nodePathFragment1.length &amp;&amp; overlapBlock &lt; nodePathFragment2.length</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">				&amp;&amp; nodePathFragment1[overlapBlock].equals(nodePathFragment2[overlapBlock]))</span>
		{
<span class="fc" id="L204">			overlapBlock++;</span>
		}

<span class="fc" id="L207">		return nodePathFragment1.length + nodePathFragment2.length - overlapBlock * 2;</span>
	}

	/**
	 * Retrieve all descendant ontology terms
	 *
	 * @return a list of {@link OntologyTerm}
	 */
	public List&lt;OntologyTerm&gt; getChildren(OntologyTerm ontologyTerm)
	{
<span class="nc" id="L217">		Iterable&lt;Entity&gt; ontologyTermEntities = () -&gt; dataService.findAll(ONTOLOGY_TERM,</span>
<span class="nc" id="L218">				QueryImpl.EQ(ONTOLOGY_TERM_IRI, ontologyTerm.getIRI())).iterator();</span>

<span class="nc" id="L220">		List&lt;OntologyTerm&gt; children = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		for (Entity ontologyTermEntity : ontologyTermEntities)</span>
		{
<span class="nc" id="L223">			Entity ontologyEntity = ontologyTermEntity.getEntity(OntologyTermMetaData.ONTOLOGY);</span>
<span class="nc" id="L224">			ontologyTermEntity.getEntities(OntologyTermMetaData.ONTOLOGY_TERM_NODE_PATH)</span>
<span class="nc" id="L225">							  .forEach(ontologyTermNodePathEntity -&gt; children.addAll(</span>
<span class="nc" id="L226">									  getChildOntologyTermsByNodePath(ontologyEntity, ontologyTermNodePathEntity)));</span>
<span class="nc" id="L227">		}</span>
<span class="nc" id="L228">		return children;</span>
	}

	public List&lt;OntologyTerm&gt; getChildOntologyTermsByNodePath(Entity ontologyEntity, Entity nodePathEntity)
	{
<span class="fc" id="L233">		String nodePath = nodePathEntity.getString(OntologyTermNodePathMetaData.NODE_PATH);</span>

<span class="fc" id="L235">		Iterable&lt;Entity&gt; relatedOntologyTermEntities = () -&gt; dataService.findAll(OntologyTermMetaData.ONTOLOGY_TERM,</span>
				new QueryImpl&lt;&gt;(new QueryRule(OntologyTermMetaData.ONTOLOGY_TERM_NODE_PATH, Operator.FUZZY_MATCH,
<span class="fc" id="L237">						&quot;\&quot;&quot; + nodePath + &quot;\&quot;&quot;)).and().eq(OntologyTermMetaData.ONTOLOGY, ontologyEntity)).iterator();</span>
<span class="fc" id="L238">		Iterable&lt;Entity&gt; childOntologyTermEntities = FluentIterable.from(relatedOntologyTermEntities)</span>
<span class="fc" id="L239">																   .filter(entity -&gt; qualifiedNodePath(nodePath,</span>
																		   entity))
<span class="fc" id="L241">																   .toList();</span>

<span class="fc" id="L243">		return Lists.newArrayList(</span>
<span class="fc" id="L244">				Iterables.transform(childOntologyTermEntities, OntologyTermRepository::toOntologyTerm));</span>
	}

	private boolean qualifiedNodePath(String nodePath, Entity entity)
	{
<span class="fc" id="L249">		Iterable&lt;Entity&gt; nodePathEntities = entity.getEntities(OntologyTermMetaData.ONTOLOGY_TERM_NODE_PATH);</span>
<span class="fc" id="L250">		return Lists.newArrayList(nodePathEntities).stream().anyMatch(nodePathEntity -&gt;</span>
		{
<span class="fc" id="L252">			String childNodePath = nodePathEntity.getString(OntologyTermNodePathMetaData.NODE_PATH);</span>
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">			return !StringUtils.equals(nodePath, childNodePath) &amp;&amp; childNodePath.startsWith(nodePath);</span>
		});
	}

	private static OntologyTerm toOntologyTerm(Entity entity)
	{
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">		if (entity == null)</span>
		{
<span class="nc" id="L261">			return null;</span>
		}

		// Collect synonyms if there are any
<span class="fc" id="L265">		List&lt;String&gt; synonyms = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L266">		Iterable&lt;Entity&gt; ontologyTermSynonymEntities = entity.getEntities(OntologyTermMetaData.ONTOLOGY_TERM_SYNONYM);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">		if (ontologyTermSynonymEntities != null)</span>
		{
<span class="pc" id="L269">			ontologyTermSynonymEntities.forEach(synonymEntity -&gt; synonyms.add(</span>
<span class="nc" id="L270">					synonymEntity.getString(OntologyTermSynonymMetaData.ONTOLOGY_TERM_SYNONYM_ATTR)));</span>
		}
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">		if (!synonyms.contains(entity.getString(ONTOLOGY_TERM_NAME)))</span>
		{
<span class="fc" id="L274">			synonyms.add(entity.getString(ONTOLOGY_TERM_NAME));</span>
		}

<span class="fc" id="L277">		return OntologyTerm.create(entity.getString(ONTOLOGY_TERM_IRI), entity.getString(ONTOLOGY_TERM_NAME), null,</span>
				synonyms);
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>