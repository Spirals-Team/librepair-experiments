<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolicyPersistenceActorMailbox.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Policies :: Persistence</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.policies.persistence.actors.policy</a> &gt; <span class="el_source">PolicyPersistenceActorMailbox.java</span></div><h1>PolicyPersistenceActorMailbox.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.policies.persistence.actors.policy;

import java.util.Deque;
import java.util.concurrent.LinkedBlockingDeque;

import org.eclipse.ditto.signals.commands.policies.PolicyErrorResponse;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyTooManyModifyingRequestsException;
import org.eclipse.ditto.signals.commands.policies.modify.PolicyModifyCommand;

import com.typesafe.config.Config;

import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.dispatch.DequeBasedMessageQueue;
import akka.dispatch.Envelope;
import akka.dispatch.MailboxType;
import akka.dispatch.MessageQueue;
import akka.dispatch.ProducesMessageQueue;
import akka.dispatch.UnboundedDequeBasedMessageQueueSemantics;
import akka.event.Logging;
import akka.event.LoggingAdapter;

/**
 * Mailbox which handles {@link PolicyModifyCommand}s which should be passed to the {@link PolicyPersistenceActor} in a
 * special way: those are not enqueued into the mailbox if the mailbox size gets bigger than the configured
 * {@link #capacity}.
 * &lt;p&gt;
 * In that case the {@link PolicyPersistenceActor} cannot write the modifications fast enough to the persistence
 * and it makes no sense to enqueue further modifications.
 * &lt;/p&gt;
 * &lt;p&gt;
 * {@link org.eclipse.ditto.signals.commands.policies.query.PolicyQueryCommand}s and other messages (e.g. Recovery-Messages) are
 * always enqueued and not treated in a special way.
 * &lt;/p&gt;
 */
public class PolicyPersistenceActorMailbox implements MailboxType,
        ProducesMessageQueue&lt;PolicyPersistenceActorMailbox.PolicyPersistenceActorMessageQueue&gt; {

    private final int capacity;

    /**
     * Creates a new {@code PolicyBoundedMailbox}.
     * This constructor signature must exist, it will be called by Akka.
     *
     * @param settings the ActorSystem settings.
     * @param config the config.
     */
<span class="nc" id="L59">    public PolicyPersistenceActorMailbox(final ActorSystem.Settings settings, final Config config) {</span>
        // put your initialization code here
<span class="nc" id="L61">        capacity = config.getInt(&quot;mailbox-capacity&quot;);</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (capacity &lt; 1) {</span>
<span class="nc" id="L63">            throw new IllegalArgumentException(&quot;Mailbox capacity must not be less than 1&quot;);</span>
        }
<span class="nc" id="L65">    }</span>

    @Override
    public MessageQueue create(final scala.Option&lt;ActorRef&gt; owner, final scala.Option&lt;ActorSystem&gt; system) {
        // The create method is called to create the MessageQueue
<span class="nc" id="L70">        return new PolicyPersistenceActorMessageQueue(capacity, system.get());</span>
    }

    /**
     * The MessageQueue implementation.
     */
    static class PolicyPersistenceActorMessageQueue extends LinkedBlockingDeque&lt;Envelope&gt; implements
            DequeBasedMessageQueue, UnboundedDequeBasedMessageQueueSemantics {

        private static final long serialVersionUID = -3799029649510677683L;

        private final transient LoggingAdapter log;

        private final int capacity;

<span class="nc" id="L85">        PolicyPersistenceActorMessageQueue(final int capacity, final ActorSystem actorSystem) {</span>
<span class="nc" id="L86">            log = Logging.getLogger(actorSystem, PolicyPersistenceActorMessageQueue.class);</span>
<span class="nc" id="L87">            this.capacity = capacity;</span>
<span class="nc" id="L88">        }</span>

        @Override
        public Deque&lt;Envelope&gt; queue() {
<span class="nc" id="L92">            return this;</span>
        }

        @Override
        public void enqueue(final ActorRef receiver, final Envelope handle) {
<span class="nc" id="L97">            final Object message = handle.message();</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if (message instanceof PolicyModifyCommand) {</span>
<span class="nc" id="L99">                queueSizeBasedAction(handle.sender(), (PolicyModifyCommand) message, () -&gt; queue().add(handle));</span>
            } else {
                // all other messages are enqueued right away and with no &quot;limit&quot;:
<span class="nc" id="L102">                queue().add(handle);</span>
            }
<span class="nc" id="L104">        }</span>

        @Override
        public void enqueueFirst(final ActorRef receiver, final Envelope handle) {
<span class="nc" id="L108">            final Object message = handle.message();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (message instanceof PolicyModifyCommand) {</span>
<span class="nc" id="L110">                queueSizeBasedAction(handle.sender(), (PolicyModifyCommand) message, () -&gt; queue().addFirst(handle));</span>
            } else {
                // all other messages are enqueued right away and with no &quot;limit&quot;:
<span class="nc" id="L113">                queue().addFirst(handle);</span>
            }
<span class="nc" id="L115">        }</span>

        private void queueSizeBasedAction(final ActorRef sender, final PolicyModifyCommand command, final Runnable r) {
            // instead of blocking return &quot;too many requests&quot; response if numberOfMessages &gt; capacity
<span class="nc bnc" id="L119" title="All 2 branches missed.">            if (numberOfMessages() &gt; capacity) {</span>
<span class="nc" id="L120">                log.warning(&quot;Number of messages ({}) in the Mailbox of thing with ID '{}' exceeded the max capacity of &quot;</span>
<span class="nc" id="L121">                                + &quot;{} -&gt; rejecting PolicyModifyCommand '{}'&quot;, numberOfMessages(), command.getId(), capacity,</span>
<span class="nc" id="L122">                        command.getType());</span>

<span class="nc" id="L124">                final PolicyErrorResponse errorResponse =</span>
<span class="nc" id="L125">                        PolicyErrorResponse.of(command.getId(), PolicyTooManyModifyingRequestsException //</span>
<span class="nc" id="L126">                                .newBuilder(command.getId()) //</span>
<span class="nc" id="L127">                                .dittoHeaders(command.getDittoHeaders()) //</span>
<span class="nc" id="L128">                                .build());</span>
<span class="nc" id="L129">                sender.tell(errorResponse, null);</span>
<span class="nc" id="L130">            } else {</span>
<span class="nc" id="L131">                r.run();</span>
            }
<span class="nc" id="L133">        }</span>

        @Override
        public Envelope dequeue() {
<span class="nc" id="L137">            return queue().poll();</span>
        }

        @Override
        public int numberOfMessages() {
<span class="nc" id="L142">            return queue().size();</span>
        }

        @Override
        public boolean hasMessages() {
<span class="nc bnc" id="L147" title="All 2 branches missed.">            return !queue().isEmpty();</span>
        }

        @Override
        public void cleanUp(final ActorRef owner, final MessageQueue deadLetters) {
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (hasMessages()) {</span>
<span class="nc" id="L153">                Envelope envelope = dequeue();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                while (envelope != null) {</span>
<span class="nc" id="L155">                    deadLetters.enqueue(owner, envelope);</span>
<span class="nc" id="L156">                    envelope = dequeue();</span>
                }
            }
<span class="nc" id="L159">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>