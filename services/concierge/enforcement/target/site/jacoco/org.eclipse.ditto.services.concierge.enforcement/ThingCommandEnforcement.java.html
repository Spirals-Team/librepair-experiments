<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ThingCommandEnforcement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Concierge :: Enforcement</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.concierge.enforcement</a> &gt; <span class="el_source">ThingCommandEnforcement.java</span></div><h1>ThingCommandEnforcement.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.concierge.enforcement;

import static java.util.Objects.requireNonNull;
import static org.eclipse.ditto.model.things.Permission.ADMINISTRATE;
import static org.eclipse.ditto.services.models.policies.Permission.MIN_REQUIRED_POLICY_PERMISSIONS;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletionStage;
import java.util.function.BiFunction;

import org.eclipse.ditto.json.JsonFactory;
import org.eclipse.ditto.json.JsonFieldSelector;
import org.eclipse.ditto.json.JsonFieldSelectorBuilder;
import org.eclipse.ditto.json.JsonObject;
import org.eclipse.ditto.json.JsonObjectBuilder;
import org.eclipse.ditto.json.JsonValue;
import org.eclipse.ditto.model.base.auth.AuthorizationContext;
import org.eclipse.ditto.model.base.auth.AuthorizationSubject;
import org.eclipse.ditto.model.base.exceptions.DittoRuntimeException;
import org.eclipse.ditto.model.base.headers.DittoHeaders;
import org.eclipse.ditto.model.base.headers.WithDittoHeaders;
import org.eclipse.ditto.model.base.json.FieldType;
import org.eclipse.ditto.model.base.json.JsonSchemaVersion;
import org.eclipse.ditto.model.enforcers.AclEnforcer;
import org.eclipse.ditto.model.enforcers.Enforcer;
import org.eclipse.ditto.model.enforcers.PolicyEnforcers;
import org.eclipse.ditto.model.policies.Permissions;
import org.eclipse.ditto.model.policies.PoliciesModelFactory;
import org.eclipse.ditto.model.policies.PoliciesResourceType;
import org.eclipse.ditto.model.policies.Policy;
import org.eclipse.ditto.model.policies.ResourceKey;
import org.eclipse.ditto.model.policies.Subject;
import org.eclipse.ditto.model.policies.SubjectId;
import org.eclipse.ditto.model.policies.SubjectIssuer;
import org.eclipse.ditto.model.things.AccessControlList;
import org.eclipse.ditto.model.things.AclInvalidException;
import org.eclipse.ditto.model.things.AclNotAllowedException;
import org.eclipse.ditto.model.things.AclValidator;
import org.eclipse.ditto.model.things.Thing;
import org.eclipse.ditto.services.concierge.cache.IdentityCache;
import org.eclipse.ditto.services.models.concierge.EntityId;
import org.eclipse.ditto.services.models.concierge.cache.Entry;
import org.eclipse.ditto.services.models.policies.Permission;
import org.eclipse.ditto.services.models.policies.PoliciesAclMigrations;
import org.eclipse.ditto.services.models.policies.PoliciesValidator;
import org.eclipse.ditto.services.utils.cache.Cache;
import org.eclipse.ditto.signals.commands.base.CommandToExceptionRegistry;
import org.eclipse.ditto.signals.commands.policies.PolicyCommand;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyConflictException;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyNotAccessibleException;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyUnavailableException;
import org.eclipse.ditto.signals.commands.policies.modify.CreatePolicy;
import org.eclipse.ditto.signals.commands.policies.modify.CreatePolicyResponse;
import org.eclipse.ditto.signals.commands.policies.query.RetrievePolicy;
import org.eclipse.ditto.signals.commands.policies.query.RetrievePolicyResponse;
import org.eclipse.ditto.signals.commands.things.ThingCommand;
import org.eclipse.ditto.signals.commands.things.ThingCommandResponse;
import org.eclipse.ditto.signals.commands.things.ThingErrorResponse;
import org.eclipse.ditto.signals.commands.things.exceptions.PolicyIdNotAllowedException;
import org.eclipse.ditto.signals.commands.things.exceptions.PolicyInvalidException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingCommandToAccessExceptionRegistry;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingCommandToModifyExceptionRegistry;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingNotAccessibleException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingNotCreatableException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingNotModifiableException;
import org.eclipse.ditto.signals.commands.things.exceptions.ThingUnavailableException;
import org.eclipse.ditto.signals.commands.things.modify.CreateThing;
import org.eclipse.ditto.signals.commands.things.modify.DeleteThing;
import org.eclipse.ditto.signals.commands.things.modify.ModifyThing;
import org.eclipse.ditto.signals.commands.things.modify.ThingModifyCommand;
import org.eclipse.ditto.signals.commands.things.query.RetrieveThing;
import org.eclipse.ditto.signals.commands.things.query.RetrieveThingResponse;
import org.eclipse.ditto.signals.commands.things.query.ThingQueryCommand;
import org.eclipse.ditto.signals.commands.things.query.ThingQueryCommandResponse;

import akka.actor.ActorRef;
import akka.event.DiagnosticLoggingAdapter;
import akka.pattern.AskTimeoutException;
import akka.pattern.PatternsCS;

/**
 * Authorize {@code ThingCommand}.
 */
public final class ThingCommandEnforcement extends AbstractEnforcement&lt;ThingCommand&gt; {

    /**
     * Label of default policy entry in default policy.
     */
    private static final String DEFAULT_POLICY_ENTRY_LABEL = &quot;DEFAULT&quot;;

    /**
     * Json fields that are always shown regardless of authorization.
     */
<span class="fc" id="L109">    private static final JsonFieldSelector THING_QUERY_COMMAND_RESPONSE_WHITELIST =</span>
<span class="fc" id="L110">            JsonFactory.newFieldSelector(Thing.JsonFields.ID);</span>

    private final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration;
    private final ActorRef thingsShardRegion;
    private final ActorRef policiesShardRegion;
    private final EnforcerRetriever thingEnforcerRetriever;
    private final EnforcerRetriever policyEnforcerRetriever;
    private final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache;
    private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache;
    private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache;

    private ThingCommandEnforcement(final Context data, final ActorRef thingsShardRegion,
            final ActorRef policiesShardRegion, final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache,
            final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache,
            final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache,
            final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration) {

<span class="fc" id="L127">        super(data);</span>
<span class="fc" id="L128">        this.thingsShardRegion = requireNonNull(thingsShardRegion);</span>
<span class="fc" id="L129">        this.policiesShardRegion = requireNonNull(policiesShardRegion);</span>
<span class="fc" id="L130">        this.subjectIssuersForPolicyMigration = requireNonNull(subjectIssuersForPolicyMigration);</span>

<span class="fc" id="L132">        this.thingIdCache = requireNonNull(thingIdCache);</span>
<span class="fc" id="L133">        this.policyEnforcerCache = requireNonNull(policyEnforcerCache);</span>
<span class="fc" id="L134">        this.aclEnforcerCache = requireNonNull(aclEnforcerCache);</span>
<span class="fc" id="L135">        thingEnforcerRetriever =</span>
<span class="fc" id="L136">                PolicyOrAclEnforcerRetrieverFactory.create(thingIdCache, policyEnforcerCache, aclEnforcerCache);</span>
<span class="fc" id="L137">        policyEnforcerRetriever = new EnforcerRetriever(IdentityCache.INSTANCE, policyEnforcerCache);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Authorize a thing command. Either the command is forwarded to things-shard-region for execution or
     * the sender is told of an error.
     *
     * @param signal the command to authorize.
     * @param sender of the command.
     * @param log the logger to use for logging.
     */
    @Override
    public void enforce(final ThingCommand signal, final ActorRef sender, final DiagnosticLoggingAdapter log) {
<span class="fc" id="L150">        thingEnforcerRetriever.retrieve(entityId(), (enforcerKeyEntry, enforcerEntry) -&gt; {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (!enforcerEntry.exists()) {</span>
<span class="fc" id="L152">                enforceThingCommandByNonexistentEnforcer(enforcerKeyEntry, signal, sender);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            } else if (isAclEnforcer(enforcerKeyEntry)) {</span>
<span class="fc" id="L154">                enforceThingCommandByAclEnforcer(signal, enforcerEntry.getValue(), sender);</span>
            } else {
<span class="fc" id="L156">                final String policyId = enforcerKeyEntry.getValue().getId();</span>
<span class="fc" id="L157">                enforceThingCommandByPolicyEnforcer(signal, policyId, enforcerEntry.getValue(), sender);</span>
            }
<span class="fc" id="L159">        });</span>
<span class="fc" id="L160">    }</span>

    /**
     * Provides {@link AbstractEnforcement} for commands of type {@link ThingCommand}.
     */
    public static final class Provider implements EnforcementProvider&lt;ThingCommand&gt; {

<span class="fc" id="L167">        private static final List&lt;SubjectIssuer&gt; DEFAULT_SUBJECT_ISSUERS_FOR_POLICY_MIGRATION =</span>
<span class="fc" id="L168">                Collections.singletonList(SubjectIssuer.GOOGLE);</span>
        private final ActorRef thingsShardRegion;
        private final ActorRef policiesShardRegion;
        private final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache;
        private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache;
        private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache;
        private final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration;

        /**
         * Constructor.
         *
         * @param thingsShardRegion the ActorRef to the Things shard region.
         * @param policiesShardRegion the ActorRef to the Policies shard region.
         * @param thingIdCache the thing-id-cache.
         * @param policyEnforcerCache the policy-enforcer cache.
         * @param aclEnforcerCache the acl-enforcer cache.
         */
        public Provider(final ActorRef thingsShardRegion,
                final ActorRef policiesShardRegion, final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache) {
<span class="fc" id="L189">            this(thingsShardRegion, policiesShardRegion, thingIdCache, policyEnforcerCache, aclEnforcerCache,</span>
                    DEFAULT_SUBJECT_ISSUERS_FOR_POLICY_MIGRATION);
<span class="fc" id="L191">        }</span>

        /**
         * Constructor.
         *
         * @param thingsShardRegion the ActorRef to the Things shard region.
         * @param policiesShardRegion the ActorRef to the Policies shard region.
         * @param thingIdCache the thing-id-cache.
         * @param policyEnforcerCache the policy-enforcer cache.
         * @param aclEnforcerCache the acl-enforcer cache.
         * @param subjectIssuersForPolicyMigration a list of {@link SubjectIssuer}s for which a {@link Subject} will
         * be created per ACL SID. E.g. when {@link SubjectIssuer#GOOGLE} is specified, for the ACL SID &quot;123&quot;, a
         * {@link Subject} &quot;google:123&quot; will be created.
         */
        public Provider(final ActorRef thingsShardRegion,
                final ActorRef policiesShardRegion, final Cache&lt;EntityId, Entry&lt;EntityId&gt;&gt; thingIdCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; policyEnforcerCache,
                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; aclEnforcerCache,
<span class="fc" id="L209">                final List&lt;SubjectIssuer&gt; subjectIssuersForPolicyMigration) {</span>
<span class="fc" id="L210">            this.thingsShardRegion = requireNonNull(thingsShardRegion);</span>
<span class="fc" id="L211">            this.policiesShardRegion = requireNonNull(policiesShardRegion);</span>
<span class="fc" id="L212">            this.thingIdCache = requireNonNull(thingIdCache);</span>
<span class="fc" id="L213">            this.policyEnforcerCache = requireNonNull(policyEnforcerCache);</span>
<span class="fc" id="L214">            this.aclEnforcerCache = requireNonNull(aclEnforcerCache);</span>
<span class="fc" id="L215">            this.subjectIssuersForPolicyMigration = requireNonNull(subjectIssuersForPolicyMigration);</span>
<span class="fc" id="L216">        }</span>

        @Override
        public Class&lt;ThingCommand&gt; getCommandClass() {
<span class="fc" id="L220">            return ThingCommand.class;</span>
        }

        @Override
        public boolean isApplicable(final ThingCommand command) {
            // live commands are not applicable for thing command enforcement
            // because they should never be forwarded to things shard region
<span class="fc bfc" id="L227" title="All 2 branches covered.">            return !LiveSignalEnforcement.isLiveSignal(command);</span>
        }

        @Override
        public AbstractEnforcement&lt;ThingCommand&gt; createEnforcement(final AbstractEnforcement.Context context) {
<span class="fc" id="L232">            return new ThingCommandEnforcement(context, thingsShardRegion, policiesShardRegion, thingIdCache,</span>
                    policyEnforcerCache, aclEnforcerCache, subjectIssuersForPolicyMigration
            );
        }
    }

    /**
     * Authorize a thing command in the absence of an enforcer. This happens when the thing did
     * not exist or when the policy of the thing does not exist.
     *
     * @param enforcerKeyEntry cache entry in the entity ID cache for the enforcer cache key.
     * @param thingCommand the command to authorize.
     * @param sender sender of the command.
     */
    private void enforceThingCommandByNonexistentEnforcer(final Entry&lt;EntityId&gt; enforcerKeyEntry,
            final ThingCommand thingCommand, final ActorRef sender) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (enforcerKeyEntry.exists()) {</span>
            // Thing exists but its policy is deleted.
<span class="fc" id="L250">            final String thingId = thingCommand.getThingId();</span>
<span class="fc" id="L251">            final String policyId = enforcerKeyEntry.getValue().getId();</span>
<span class="fc" id="L252">            final DittoRuntimeException error = errorForExistingThingWithDeletedPolicy(thingCommand, thingId, policyId);</span>
<span class="fc" id="L253">            log(thingCommand).info(&quot;Enforcer was not existing for Thing &lt;{}&gt;, responding with: {}&quot;, thingId, error);</span>
<span class="fc" id="L254">            replyToSender(error, sender);</span>
<span class="fc" id="L255">        } else {</span>
            // Without prior enforcer in cache, enforce CreateThing by self.
<span class="fc" id="L257">            enforceCreateThingBySelf(thingCommand, sender).ifPresent(pair -&gt;</span>
<span class="fc" id="L258">                    handleInitialCreateThing(pair.createThing, pair.enforcer, sender));</span>
        }
<span class="fc" id="L260">    }</span>

    /**
     * Authorize a thing command by ACL enforcer with special handling for the field &quot;/acl&quot;.
     *
     * @param thingCommand the thing command.
     * @param enforcer the ACL enforcer.
     * @param sender sender of the command.
     */
    private void enforceThingCommandByAclEnforcer(final ThingCommand&lt;?&gt; thingCommand, final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc" id="L271">        final Optional&lt;? extends ThingCommand&gt; authorizedCommand = authorizeByAcl(enforcer, thingCommand);</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (authorizedCommand.isPresent()) {</span>
<span class="fc" id="L274">            final ThingCommand commandWithReadSubjects = authorizedCommand.get();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">            if (commandWithReadSubjects instanceof RetrieveThing &amp;&amp;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                    shouldRetrievePolicyWithThing(commandWithReadSubjects)) {</span>
<span class="nc" id="L277">                final RetrieveThing retrieveThing = (RetrieveThing) commandWithReadSubjects;</span>
<span class="nc" id="L278">                retrieveThingAclAndMigrateToPolicy(retrieveThing, enforcer, sender);</span>
<span class="nc" id="L279">            } else {</span>
<span class="fc" id="L280">                forwardToThingsShardRegion(commandWithReadSubjects, sender);</span>
            }
<span class="fc" id="L282">        } else {</span>
<span class="fc" id="L283">            respondWithError(thingCommand, sender, self());</span>
        }
<span class="fc" id="L285">    }</span>

    private void retrieveThingAclAndMigrateToPolicy(final RetrieveThing retrieveThing,
            final Enforcer enforcer,
            final ActorRef sender) {
        final JsonFieldSelectorBuilder jsonFieldSelectorBuilder =
<span class="nc" id="L291">                JsonFactory.newFieldSelectorBuilder().addFieldDefinition(Thing.JsonFields.ACL);</span>
<span class="nc" id="L292">        retrieveThing.getSelectedFields().ifPresent(jsonFieldSelectorBuilder::addPointers);</span>
<span class="nc" id="L293">        final DittoHeaders dittoHeaders = retrieveThing</span>
<span class="nc" id="L294">                .getDittoHeaders()</span>
<span class="nc" id="L295">                .toBuilder()</span>
<span class="nc" id="L296">                .schemaVersion(JsonSchemaVersion.V_1)</span>
<span class="nc" id="L297">                .build();</span>
<span class="nc" id="L298">        final RetrieveThing retrieveThingV1 = RetrieveThing.getBuilder(retrieveThing.getThingId(), dittoHeaders)</span>
<span class="nc" id="L299">                .withSelectedFields(jsonFieldSelectorBuilder.build())</span>
<span class="nc" id="L300">                .build();</span>
<span class="nc" id="L301">        PatternsCS.ask(thingsShardRegion, retrieveThingV1, getAskTimeout().toMillis())</span>
<span class="nc" id="L302">                .handleAsync((response, error) -&gt; {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                    if (response instanceof RetrieveThingResponse) {</span>
<span class="nc" id="L304">                        final RetrieveThingResponse retrieveThingResponse = (RetrieveThingResponse) response;</span>
<span class="nc" id="L305">                        final Optional&lt;AccessControlList&gt; aclOptional =</span>
<span class="nc" id="L306">                                retrieveThingResponse.getThing().getAccessControlList();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                        if (aclOptional.isPresent()) {</span>
<span class="nc" id="L308">                            final Policy policy =</span>
<span class="nc" id="L309">                                    PoliciesAclMigrations.accessControlListToPolicyEntries(aclOptional.get(),</span>
<span class="nc" id="L310">                                            retrieveThing.getThingId(), subjectIssuersForPolicyMigration);</span>
<span class="nc" id="L311">                            reportAggregatedThingAndPolicy(retrieveThing,</span>
<span class="nc" id="L312">                                    retrieveThingResponse.setDittoHeaders(retrieveThing.getDittoHeaders()),</span>
                                    policy, enforcer, sender);
<span class="nc" id="L314">                        } else {</span>
<span class="nc" id="L315">                            replyToSender(retrieveThingResponse.setDittoHeaders(retrieveThing.getDittoHeaders()),</span>
                                    sender);
                        }
<span class="nc bnc" id="L318" title="All 2 branches missed.">                    } else if (response instanceof WithDittoHeaders) {</span>
<span class="nc" id="L319">                        final WithDittoHeaders withDittoHeaders = (WithDittoHeaders) response;</span>
<span class="nc" id="L320">                        replyToSender(withDittoHeaders.setDittoHeaders(retrieveThing.getDittoHeaders()), sender);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="nc" id="L322">                        reportThingUnavailable(retrieveThing.getThingId(), retrieveThing.getDittoHeaders(), sender);</span>
                    } else {
<span class="nc" id="L324">                        reportUnexpectedErrorOrResponse(&quot;retrieving thing for ACL migration&quot;,</span>
<span class="nc" id="L325">                                sender, response, error, retrieveThing.getDittoHeaders());</span>
                    }
<span class="nc" id="L327">                    return null;</span>
                });
<span class="nc" id="L329">    }</span>

    /**
     * Authorize a thing command by policy enforcer with view restriction for query commands.
     *
     * @param thingCommand the thing command.
     * @param policyId Id of the thing's policy.
     * @param enforcer the policy enforcer.
     * @param sender sender of the command.
     */
    private void enforceThingCommandByPolicyEnforcer(final ThingCommand&lt;?&gt; thingCommand,
            final String policyId,
            final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc" id="L343">        final boolean authorized = authorizeByPolicy(enforcer, thingCommand)</span>
<span class="fc" id="L344">                .map(commandWithReadSubjects -&gt; {</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">                    if (commandWithReadSubjects instanceof ThingQueryCommand) {</span>
<span class="fc" id="L346">                        final ThingQueryCommand thingQueryCommand = (ThingQueryCommand) commandWithReadSubjects;</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                        if (thingQueryCommand instanceof RetrieveThing &amp;&amp;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                                shouldRetrievePolicyWithThing(thingQueryCommand)) {</span>

<span class="fc" id="L350">                            final RetrieveThing retrieveThing = (RetrieveThing) thingQueryCommand;</span>
<span class="fc" id="L351">                            return retrieveThingAndPolicy(retrieveThing, policyId, enforcer, sender);</span>
                        } else {
<span class="fc" id="L353">                            return askThingsShardRegionAndBuildJsonView(thingQueryCommand, enforcer, sender);</span>
                        }
                    } else {
<span class="fc" id="L356">                        return forwardToThingsShardRegion(commandWithReadSubjects, sender);</span>
                    }
                })
<span class="fc" id="L359">                .isPresent();</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (!authorized) {</span>
<span class="fc" id="L362">            respondWithError(thingCommand, sender, self());</span>
        }
<span class="fc" id="L364">    }</span>

    /**
     * Responds to the passed {@code sender} with an error based on the type of the passed in {@code thingCommand}.
     *
     * @param thingCommand the ThingCommand to use for determining which error to send back
     * @param sender the sender to send back the error to
     * @param self the self reference
     */
    static void respondWithError(final ThingCommand thingCommand, final ActorRef sender, final ActorRef self) {
<span class="fc" id="L374">        sender.tell(errorForThingCommand(thingCommand), self);</span>
<span class="fc" id="L375">    }</span>

    /**
     * Retrieve for response of a query command and limit the response
     * according to a policy
     * enforcer.
     *
     * @param commandWithReadSubjects the command to ask.
     * @param enforcer enforcer to build JsonView with.
     * @param sender sender of the command.
     * @return always {@code true}.
     */
    private boolean askThingsShardRegionAndBuildJsonView(
            final ThingQueryCommand commandWithReadSubjects,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L392">        PatternsCS.ask(thingsShardRegion, commandWithReadSubjects, getAskTimeout().toMillis())</span>
<span class="fc" id="L393">                .handleAsync((response, error) -&gt; {</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                    if (response instanceof ThingQueryCommandResponse) {</span>
<span class="fc" id="L395">                        reportJsonViewForThingQuery(sender, (ThingQueryCommandResponse) response, enforcer);</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                    } else if (response instanceof DittoRuntimeException) {</span>
<span class="fc" id="L397">                        replyToSender(response, sender);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                        final AskTimeoutException askTimeoutException = error instanceof AskTimeoutException</span>
                                ? (AskTimeoutException) error
                                : (AskTimeoutException) response;
<span class="nc" id="L402">                        reportTimeoutForThingQuery(commandWithReadSubjects, sender, askTimeoutException);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    } else if (error != null) {</span>
<span class="nc" id="L404">                        reportUnexpectedError(&quot;before building JsonView&quot;, sender, error,</span>
<span class="nc" id="L405">                                commandWithReadSubjects.getDittoHeaders());</span>
                    } else {
<span class="nc" id="L407">                        reportUnknownResponse(&quot;before building JsonView&quot;, sender, response,</span>
<span class="nc" id="L408">                                commandWithReadSubjects.getDittoHeaders());</span>
                    }
<span class="fc" id="L410">                    return null;</span>
                });
<span class="fc" id="L412">        return true;</span>
    }

    /**
     * Retrieve a thing and its policy and combine them into a response.
     *
     * @param retrieveThing the retrieve-thing command.
     * @param policyId ID of the thing's policy.
     * @param enforcer the enforcer for the command.
     * @param sender sender of the command.
     * @return always {@code true}.
     */
    private boolean retrieveThingAndPolicy(
            final RetrieveThing retrieveThing,
            final String policyId,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L430">        final Optional&lt;RetrievePolicy&gt; retrievePolicyOptional = PolicyCommandEnforcement.authorizePolicyCommand(</span>
<span class="fc" id="L431">                RetrievePolicy.of(policyId, retrieveThing.getDittoHeaders()), enforcer);</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (retrievePolicyOptional.isPresent()) {</span>
<span class="fc" id="L434">            retrieveThingBeforePolicy(retrieveThing, sender).thenAccept(thingResponse -&gt;</span>
<span class="fc" id="L435">                    thingResponse.ifPresent(retrieveThingResponse -&gt; {</span>
<span class="fc" id="L436">                        final RetrievePolicy retrievePolicy = retrievePolicyOptional.get();</span>
<span class="fc" id="L437">                        retrieveInlinedPolicyForThing(retrieveThing, retrievePolicy).thenAccept(policyResponse -&gt; {</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                            if (policyResponse.isPresent()) {</span>
<span class="fc" id="L439">                                final RetrievePolicyResponse filteredPolicyResponse =</span>
<span class="fc" id="L440">                                        PolicyCommandEnforcement.buildJsonViewForPolicyQueryCommandResponse(</span>
<span class="fc" id="L441">                                                policyResponse.get(), enforcer);</span>
<span class="fc" id="L442">                                reportAggregatedThingAndPolicyResponse(retrieveThing, retrieveThingResponse,</span>
                                        filteredPolicyResponse, enforcer, sender);
<span class="fc" id="L444">                            } else {</span>
<span class="fc" id="L445">                                replyToSender(retrieveThingResponse, sender);</span>
                            }
<span class="fc" id="L447">                        });</span>
<span class="fc" id="L448">                    }));</span>
<span class="fc" id="L449">            return true;</span>
        } else {
            // sender is not authorized to view the policy, ignore the request to embed policy.
<span class="fc" id="L452">            return askThingsShardRegionAndBuildJsonView(retrieveThing, enforcer, sender);</span>
        }
    }

    /**
     * Retrieve a thing before retrieving its inlined policy. Report errors to sender.
     *
     * @param retrieveThing the command.
     * @param sender whom to report errors to.
     * @return future response from things-shard-region.
     */
    private CompletionStage&lt;Optional&lt;RetrieveThingResponse&gt;&gt; retrieveThingBeforePolicy(
            final RetrieveThing retrieveThing,
            final ActorRef sender) {

<span class="fc" id="L467">        return PatternsCS.ask(thingsShardRegion, retrieveThing, getAskTimeout().toMillis())</span>
<span class="fc" id="L468">                .handleAsync((response, error) -&gt; {</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                    if (response instanceof RetrieveThingResponse) {</span>
<span class="fc" id="L470">                        return Optional.of((RetrieveThingResponse) response);</span>
<span class="pc bpc" id="L471" title="2 of 4 branches missed.">                    } else if (response instanceof ThingErrorResponse || response instanceof DittoRuntimeException) {</span>
<span class="nc" id="L472">                        replyToSender(response, sender);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="fc" id="L474">                        reportThingUnavailable(retrieveThing.getThingId(), retrieveThing.getDittoHeaders(), sender);</span>
                    } else {
<span class="nc" id="L476">                        reportUnexpectedErrorOrResponse(&quot;retrieving thing before inlined policy&quot;,</span>
<span class="nc" id="L477">                                sender, response, error, retrieveThing.getDittoHeaders());</span>
                    }
<span class="fc" id="L479">                    return Optional.empty();</span>
                });
    }

    private void reportThingUnavailable(final String thingId, final DittoHeaders dittoHeaders, final ActorRef sender) {
<span class="fc" id="L484">        final ThingUnavailableException thingUnavailableException =</span>
<span class="fc" id="L485">                ThingUnavailableException.newBuilder(thingId).dittoHeaders(dittoHeaders).build();</span>
<span class="fc" id="L486">        replyToSender(thingUnavailableException, sender);</span>
<span class="fc" id="L487">    }</span>

    /**
     * Retrieve inlined policy after retrieving a thing. Do not report errors.
     *
     * @param retrieveThing the original command.
     * @param retrievePolicy the command to retrieve the thing's policy.
     * @return future response from policies-shard-region.
     */
    private CompletionStage&lt;Optional&lt;RetrievePolicyResponse&gt;&gt; retrieveInlinedPolicyForThing(
            final RetrieveThing retrieveThing,
            final RetrievePolicy retrievePolicy) {

<span class="fc" id="L500">        return PatternsCS.ask(policiesShardRegion, retrievePolicy, getAskTimeout().toMillis())</span>
<span class="fc" id="L501">                .handleAsync((response, error) -&gt; {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">                    if (response instanceof RetrievePolicyResponse) {</span>
<span class="fc" id="L503">                        return Optional.of((RetrievePolicyResponse) response);</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">                    } else if (error != null) {</span>
<span class="nc" id="L505">                        log(error).error(error, &quot;retrieving inlined policy after RetrieveThing&quot;);</span>
                    } else {
<span class="fc" id="L507">                        log(response).info(&quot;No authorized response when retrieving inlined policy &lt;{}&gt; for thing &lt;{}&gt;: {}&quot;,</span>
<span class="fc" id="L508">                                retrievePolicy.getId(), retrieveThing.getThingId(), response);</span>
                    }
<span class="fc" id="L510">                    return Optional.empty();</span>
                });
    }

    /**
     * Put thing and policy together as response to the sender.
     *
     * @param retrieveThing the original command.
     * @param retrieveThingResponse response from things-shard-region.
     * @param retrievePolicyResponse response from policies-shard-region.
     * @param enforcer enforcer to bulid the Json view.
     * @param sender sender of the original command.
     */
    private void reportAggregatedThingAndPolicyResponse(
            final RetrieveThing retrieveThing,
            final RetrieveThingResponse retrieveThingResponse,
            final RetrievePolicyResponse retrievePolicyResponse,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L530">        reportAggregatedThingAndPolicy(retrieveThing, retrieveThingResponse, retrievePolicyResponse.getPolicy(),</span>
                enforcer, sender);
<span class="fc" id="L532">    }</span>

    private void reportAggregatedThingAndPolicy(
            final RetrieveThing retrieveThing,
            final RetrieveThingResponse retrieveThingResponse,
            final Policy policy,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L541">        final RetrieveThingResponse limitedView =</span>
<span class="fc" id="L542">                buildJsonViewForThingQueryCommandResponse(retrieveThingResponse, enforcer);</span>

<span class="fc" id="L544">        final JsonObject inlinedPolicy =</span>
<span class="fc" id="L545">                policy.toInlinedJson(retrieveThing.getImplementedSchemaVersion(), FieldType.notHidden());</span>

<span class="fc" id="L547">        final JsonObject thingWithInlinedPolicy = limitedView.getEntity().asObject().toBuilder()</span>
<span class="fc" id="L548">                .setAll(inlinedPolicy)</span>
<span class="fc" id="L549">                .build();</span>

<span class="fc" id="L551">        replyToSender(limitedView.setEntity(thingWithInlinedPolicy), sender);</span>
<span class="fc" id="L552">    }</span>

    /**
     * Report timeout of {@code ThingQueryComand}.
     *
     * @param command the original command.
     * @param sender sender of the command.
     * @param askTimeoutException the timeout exception.
     */
    private void reportTimeoutForThingQuery(
            final ThingQueryCommand command,
            final ActorRef sender,
            final AskTimeoutException askTimeoutException) {
<span class="nc" id="L565">        log(command).error(askTimeoutException, &quot;Timeout before building JsonView&quot;);</span>
<span class="nc" id="L566">        replyToSender(ThingUnavailableException.newBuilder(command.getThingId())</span>
<span class="nc" id="L567">                .dittoHeaders(command.getDittoHeaders())</span>
<span class="nc" id="L568">                .build(), sender);</span>
<span class="nc" id="L569">    }</span>

    /**
     * Mixin-private: report thing query response with view on entity restricted by enforcer.
     *
     * @param sender sender of the command.
     * @param thingQueryCommandResponse response of query.
     * @param enforcer the enforcer.
     */
    private void reportJsonViewForThingQuery(final ActorRef sender,
            final ThingQueryCommandResponse&lt;?&gt; thingQueryCommandResponse,
            final Enforcer enforcer) {

        try {
<span class="fc" id="L583">            final ThingQueryCommandResponse responseWithLimitedJsonView =</span>
<span class="fc" id="L584">                    buildJsonViewForThingQueryCommandResponse(thingQueryCommandResponse, enforcer);</span>
<span class="fc" id="L585">            replyToSender(responseWithLimitedJsonView, sender);</span>
<span class="nc" id="L586">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L587">            reportError(&quot;Error after building JsonView&quot;, sender, e, thingQueryCommandResponse.getDittoHeaders());</span>
<span class="fc" id="L588">        }</span>
<span class="fc" id="L589">    }</span>

    /**
     * Query caches again to authorize a {@code CreateThing} command with explicit policy ID and no inline policy.
     *
     * @param createThing the command.
     * @param policyId the policy ID.
     * @param sender sender of the command.
     */
    private void enforceCreateThingForNonexistentThingWithPolicyId(final CreateThing createThing,
            final String policyId,
            final ActorRef sender) {
<span class="fc" id="L601">        final EntityId policyEntityId = EntityId.of(PolicyCommand.RESOURCE_TYPE, policyId);</span>
<span class="fc" id="L602">        policyEnforcerRetriever.retrieve(policyEntityId, (policyIdEntry, policyEnforcerEntry) -&gt; {</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">            if (policyEnforcerEntry.exists()) {</span>
<span class="fc" id="L604">                enforceThingCommandByPolicyEnforcer(createThing, policyId, policyEnforcerEntry.getValue(), sender);</span>
            } else {
<span class="nc" id="L606">                final DittoRuntimeException error =</span>
<span class="nc" id="L607">                        errorForExistingThingWithDeletedPolicy(createThing, createThing.getThingId(), policyId);</span>
<span class="nc" id="L608">                replyToSender(error, sender);</span>
            }
<span class="fc" id="L610">        });</span>
<span class="fc" id="L611">    }</span>

    /**
     * Limit view on entity of {@code ThingQueryCommandResponse} by enforcer.
     *
     * @param response the response.
     * @param enforcer the enforcer.
     * @return response with view on entity restricted by enforcer..
     */
    private static &lt;T extends ThingQueryCommandResponse&gt; T buildJsonViewForThingQueryCommandResponse(
            final ThingQueryCommandResponse&lt;T&gt; response,
            final Enforcer enforcer) {

<span class="fc" id="L624">        final JsonValue entity = response.getEntity();</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (entity.isObject()) {</span>
<span class="fc" id="L626">            final JsonObject filteredView =</span>
<span class="fc" id="L627">                    getJsonViewForThingQueryCommandResponse(entity.asObject(), response, enforcer);</span>
<span class="fc" id="L628">            return response.setEntity(filteredView);</span>
        } else {
<span class="nc" id="L630">            return response.setEntity(entity);</span>
        }
    }

    /**
     * Forward a command to things-shard-region.
     * Do not call {@code Actor.forward(Object, ActorContext)} because it is not thread-safe.
     *
     * @param command command to forward.
     * @param sender sender of the command.
     * @return true.
     */
    private boolean forwardToThingsShardRegion(final ThingCommand command, final ActorRef sender) {
<span class="fc" id="L643">        thingsShardRegion.tell(command, sender);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (command instanceof ThingModifyCommand &amp;&amp;</span>
<span class="pc bpc" id="L645" title="1 of 4 branches missed.">                (affectsAcl((ThingModifyCommand) command) || affectsPolicyId((ThingModifyCommand) command))) {</span>
<span class="fc" id="L646">            invalidateCaches(command.getThingId());</span>
        }
<span class="fc" id="L648">        return true;</span>
    }

    /**
     * Whenever a Command changed the authorization, the caches must be invalidated - otherwise a directly following
     * Command targeted for the same entity will probably fail as the enforcer was not yet updated.
     *
     * @param thingId the ID of the Thing to invalidate caches for.
     */
    private void invalidateCaches(final String thingId) {
<span class="fc" id="L658">        final EntityId entityId = EntityId.of(ThingCommand.RESOURCE_TYPE, thingId);</span>
<span class="fc" id="L659">        thingIdCache.invalidate(entityId);</span>
<span class="fc" id="L660">        aclEnforcerCache.invalidate(entityId);</span>
<span class="fc" id="L661">        policyEnforcerCache.invalidate(entityId);</span>
<span class="fc" id="L662">    }</span>

    /**
     * Restrict view on a JSON object by enforcer.
     *
     * @param responseEntity the JSON object to restrict view on.
     * @param response the response containing the object.
     * @param enforcer the enforcer.
     * @return JSON object with view restricted by enforcer.
     */
    private static JsonObject getJsonViewForThingQueryCommandResponse(final JsonObject responseEntity,
            final ThingQueryCommandResponse response,
            final Enforcer enforcer) {


<span class="fc" id="L677">        final ResourceKey resourceKey = ResourceKey.newInstance(ThingCommand.RESOURCE_TYPE, response.getResourcePath());</span>
<span class="fc" id="L678">        final AuthorizationContext authorizationContext = response.getDittoHeaders().getAuthorizationContext();</span>

<span class="fc" id="L680">        return enforcer.buildJsonView(resourceKey, responseEntity, authorizationContext,</span>
<span class="fc" id="L681">                THING_QUERY_COMMAND_RESPONSE_WHITELIST, Permissions.newInstance(Permission.READ));</span>
    }


    /**
     * Create error for commands to an existing thing whose policy is deleted.
     *
     * @param thingCommand the triggering command.
     * @param thingId ID of the thing.
     * @param policyId ID of the deleted policy.
     * @return an appropriate error.
     */
    private static DittoRuntimeException errorForExistingThingWithDeletedPolicy(
            final ThingCommand thingCommand,
            final String thingId,
            final String policyId) {

<span class="fc" id="L698">        final String message = String.format(</span>
                &quot;The Thing with ID ''%s'' could not be accessed as its Policy with ID ''%s'' is not or no longer existing.&quot;,
                thingId, policyId);
<span class="fc" id="L701">        final String description = String.format(</span>
                &quot;Recreate/create the Policy with ID ''%s'' in order to get access to the Thing again.&quot;,
                policyId);

<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (thingCommand instanceof ThingModifyCommand) {</span>
<span class="fc" id="L706">            return ThingNotModifiableException.newBuilder(thingId)</span>
<span class="fc" id="L707">                    .message(message)</span>
<span class="fc" id="L708">                    .description(description)</span>
<span class="fc" id="L709">                    .dittoHeaders(thingCommand.getDittoHeaders())</span>
<span class="fc" id="L710">                    .build();</span>
        } else {
<span class="fc" id="L712">            return ThingNotAccessibleException.newBuilder(thingId)</span>
<span class="fc" id="L713">                    .message(message)</span>
<span class="fc" id="L714">                    .description(description)</span>
<span class="fc" id="L715">                    .dittoHeaders(thingCommand.getDittoHeaders())</span>
<span class="fc" id="L716">                    .build();</span>
        }
    }

    /**
     * Create error due to failing to execute a thing-command in the expected way.
     *
     * @param thingCommand the command.
     * @return the error.
     */
    private static DittoRuntimeException errorForThingCommand(final ThingCommand thingCommand) {
<span class="fc bfc" id="L727" title="All 2 branches covered.">        final CommandToExceptionRegistry&lt;ThingCommand, DittoRuntimeException&gt; registry =</span>
                thingCommand instanceof ThingModifyCommand
<span class="fc" id="L729">                        ? ThingCommandToModifyExceptionRegistry.getInstance()</span>
<span class="fc" id="L730">                        : ThingCommandToAccessExceptionRegistry.getInstance();</span>
<span class="fc" id="L731">        return registry.exceptionFrom(thingCommand);</span>
    }

    /**
     * Check if an enforcer key points to an access-control-list enforcer.
     *
     * @param enforcerKeyEntry cache key entry of an enforcer.
     * @return whether it is based on an access control list and requires special handling.
     */
    private static boolean isAclEnforcer(final Entry&lt;EntityId&gt; enforcerKeyEntry) {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        return enforcerKeyEntry.exists() &amp;&amp;</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">                Objects.equals(ThingCommand.RESOURCE_TYPE, enforcerKeyEntry.getValue().getResourceType());</span>
    }

    /**
     * Authorize a thing-command by authorization information contained in itself. Only {@code
     * CreateThing} commands are authorized in this manner in the absence of an existing enforcer. {@code
     * ModifyThing} commands are transformed to {@code CreateThing} commands before being processed.
     *
     * @param receivedThingCommand the command to authorize.
     * @return optionally the authorized command extended by  read subjects.
     */
    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingBySelf(
            final ThingCommand receivedThingCommand, final ActorRef sender) {

<span class="fc" id="L756">        final ThingCommand thingCommand = transformModifyThingToCreateThing(receivedThingCommand);</span>
        final Optional&lt;CreateThingWithEnforcer&gt; result;
<span class="fc bfc" id="L758" title="All 2 branches covered.">        if (thingCommand instanceof CreateThing) {</span>
<span class="fc" id="L759">            final CreateThing createThing = (CreateThing) thingCommand;</span>
<span class="fc" id="L760">            final Optional&lt;JsonObject&gt; initialPolicyOptional = createThing.getInitialPolicy();</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">            if (initialPolicyOptional.isPresent()) {</span>
<span class="fc" id="L762">                result = enforceCreateThingByOwnInlinedPolicy(createThing, initialPolicyOptional.get(), sender);</span>
            } else {
<span class="fc" id="L764">                final Optional&lt;AccessControlList&gt; aclOptional =</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">                        createThing.getThing().getAccessControlList().filter(acl -&gt; !acl.isEmpty());</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">                if (aclOptional.isPresent()) {</span>
<span class="fc" id="L767">                    result = enforceCreateThingByOwnAcl(createThing, aclOptional.get(), sender);</span>
                } else {
<span class="fc" id="L769">                    result = enforceCreateThingByAuthorizationContext(createThing);</span>
                }
            }
<span class="fc" id="L772">        } else {</span>
            // Other commands cannot be authorized by ACL or policy contained in self.
<span class="fc" id="L774">            final DittoRuntimeException error =</span>
<span class="fc" id="L775">                    ThingNotAccessibleException.newBuilder(thingCommand.getThingId())</span>
<span class="fc" id="L776">                            .dittoHeaders(thingCommand.getDittoHeaders())</span>
<span class="fc" id="L777">                            .build();</span>
<span class="fc" id="L778">            log(thingCommand).info(&quot;Enforcer was not existing for Thing &lt;{}&gt; and no auth info was inlined, &quot; +</span>
<span class="fc" id="L779">                            &quot;responding with: {}&quot;, thingCommand.getThingId(), error);</span>
<span class="fc" id="L780">            replyToSender(error, sender);</span>
<span class="fc" id="L781">            result = Optional.empty();</span>
        }
<span class="fc" id="L783">        return result;</span>
    }

    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingByAuthorizationContext(final CreateThing createThing) {
        // Command without authorization information is authorized by default.
<span class="fc" id="L788">        final Set&lt;String&gt; authorizedSubjects = createThing.getDittoHeaders()</span>
<span class="fc" id="L789">                .getAuthorizationContext()</span>
<span class="fc" id="L790">                .getFirstAuthorizationSubject()</span>
<span class="fc" id="L791">                .map(subject -&gt; Collections.singleton(subject.getId()))</span>
<span class="fc" id="L792">                .orElse(Collections.emptySet());</span>
<span class="fc" id="L793">        final CreateThing command =</span>
<span class="fc" id="L794">                AbstractEnforcement.addReadSubjectsToSignal(createThing, authorizedSubjects);</span>
<span class="fc" id="L795">        final Enforcer enforcer = new AuthorizedSubjectsEnforcer(authorizedSubjects);</span>
<span class="fc" id="L796">        return Optional.of(new CreateThingWithEnforcer(command, enforcer));</span>
    }

    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingByOwnInlinedPolicy(final CreateThing createThing,
            final JsonObject inlinedPolicy, final ActorRef sender) {
<span class="fc" id="L801">        final Policy initialPolicy = PoliciesModelFactory.newPolicy(inlinedPolicy);</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">        if (PoliciesValidator.newInstance(initialPolicy).isValid()) {</span>
<span class="fc" id="L803">            final Enforcer initialEnforcer = PolicyEnforcers.defaultEvaluator(initialPolicy);</span>
<span class="fc" id="L804">            return attachEnforcerOrReplyWithError(createThing, initialEnforcer,</span>
                    ThingCommandEnforcement::authorizeByPolicy, sender);
        } else {
<span class="nc" id="L807">            final DittoRuntimeException error =</span>
<span class="nc" id="L808">                    PolicyInvalidException.newBuilder(MIN_REQUIRED_POLICY_PERMISSIONS, createThing.getThingId())</span>
<span class="nc" id="L809">                            .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L810">                            .build();</span>
<span class="nc" id="L811">            replyToSender(error, sender);</span>
<span class="nc" id="L812">            return Optional.empty();</span>
        }
    }

    private Optional&lt;CreateThingWithEnforcer&gt; enforceCreateThingByOwnAcl(final CreateThing createThing,
            final AccessControlList acl, final ActorRef sender) {
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">        if (AclValidator.newInstance(acl, Thing.MIN_REQUIRED_PERMISSIONS).isValid()) {</span>
<span class="fc" id="L819">            final Enforcer initialEnforcer = AclEnforcer.of(acl);</span>
<span class="fc" id="L820">            return attachEnforcerOrReplyWithError(createThing, initialEnforcer,</span>
                    ThingCommandEnforcement::authorizeByAcl, sender);
        } else {
<span class="nc" id="L823">            final DittoRuntimeException error = AclInvalidException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L824">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L825">                    .build();</span>
<span class="nc" id="L826">            replyToSender(error, sender);</span>
<span class="nc" id="L827">            return Optional.empty();</span>
        }

    }

    private Optional&lt;CreateThingWithEnforcer&gt; attachEnforcerOrReplyWithError(final CreateThing command,
            final Enforcer enforcer,
            final BiFunction&lt;Enforcer, ThingCommand&lt;CreateThing&gt;, Optional&lt;CreateThing&gt;&gt; authorization,
            final ActorRef sender) {

<span class="fc" id="L837">        final Optional&lt;CreateThing&gt; authorizedCommand = authorization.apply(enforcer, command);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (authorizedCommand.isPresent()) {</span>
<span class="fc" id="L839">            return authorizedCommand.map(cmd -&gt; new CreateThingWithEnforcer(cmd, enforcer));</span>
        } else {
<span class="fc" id="L841">            respondWithError(command, sender, self());</span>
<span class="fc" id="L842">            return Optional.empty();</span>
        }
    }

    /**
     * Transform a {@code ModifyThing} command sent to nonexistent thing to {@code CreateThing}
     * command if it is sent to a nonexistent thing.
     *
     * @param receivedCommand the command to transform.
     * @return {@code CreateThing} command containing the same information if the argument is a {@code ModifyThing}
     * command. Otherwise return the command itself.
     */
    private static ThingCommand transformModifyThingToCreateThing(final ThingCommand receivedCommand) {
<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (receivedCommand instanceof ModifyThing) {</span>
<span class="fc" id="L856">            final ModifyThing modifyThing = (ModifyThing) receivedCommand;</span>
<span class="fc" id="L857">            final JsonObject initialPolicy = modifyThing.getInitialPolicy().orElse(null);</span>
<span class="fc" id="L858">            return CreateThing.of(modifyThing.getThing(), initialPolicy, modifyThing.getDittoHeaders());</span>
        } else {
<span class="fc" id="L860">            return receivedCommand;</span>
        }
    }

    /**
     * Authorize a thing-command by a policy enforcer.
     *
     * @param &lt;T&gt; type of the thing-command.
     * @param policyEnforcer the policy enforcer.
     * @param command the command to authorize.
     * @return optionally the authorized command extended by read subjects.
     */
    static &lt;T extends ThingCommand&gt; Optional&lt;T&gt; authorizeByPolicy(final Enforcer policyEnforcer,
            final ThingCommand&lt;T&gt; command) {

<span class="fc" id="L875">        final ResourceKey thingResourceKey = PoliciesResourceType.thingResource(command.getResourcePath());</span>
<span class="fc" id="L876">        final AuthorizationContext authorizationContext = command.getDittoHeaders().getAuthorizationContext();</span>
        final boolean authorized;
<span class="fc bfc" id="L878" title="All 2 branches covered.">        if (command instanceof ThingModifyCommand) {</span>
<span class="fc" id="L879">            final String permission = Permission.WRITE;</span>
<span class="fc" id="L880">            authorized = policyEnforcer.hasUnrestrictedPermissions(thingResourceKey, authorizationContext, permission);</span>
<span class="fc" id="L881">        } else {</span>
<span class="fc" id="L882">            final String permission = Permission.READ;</span>
<span class="fc" id="L883">            authorized = policyEnforcer.hasPartialPermissions(thingResourceKey, authorizationContext, permission);</span>
        }
<span class="fc bfc" id="L885" title="All 2 branches covered.">        return authorized</span>
<span class="fc" id="L886">                ? Optional.of(AbstractEnforcement.addReadSubjectsToThingSignal(command, policyEnforcer))</span>
<span class="fc" id="L887">                : Optional.empty();</span>
    }

    /**
     * Authorize a thing-command by an ACL enforcer.
     *
     * @param &lt;T&gt; type of the thing-command.
     * @param aclEnforcer the ACL enforcer.
     * @param command the command to authorize.
     * @return optionally the authorized command extended by read subjects.
     */
    static &lt;T extends ThingCommand&gt; Optional&lt;T&gt; authorizeByAcl(final Enforcer aclEnforcer,
            final ThingCommand&lt;T&gt; command) {
<span class="fc" id="L900">        final ResourceKey thingResourceKey = PoliciesResourceType.thingResource(command.getResourcePath());</span>
<span class="fc" id="L901">        final AuthorizationContext authorizationContext = command.getDittoHeaders().getAuthorizationContext();</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">        final Permissions permissions = command instanceof ThingModifyCommand</span>
<span class="fc" id="L903">                ? computeAclPermissions((ThingModifyCommand) command)</span>
<span class="fc" id="L904">                : Permissions.newInstance(Permission.READ);</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        return aclEnforcer.hasUnrestrictedPermissions(thingResourceKey, authorizationContext, permissions)</span>
<span class="fc" id="L906">                ? Optional.of(AbstractEnforcement.addReadSubjectsToThingSignal(command, aclEnforcer))</span>
<span class="fc" id="L907">                : Optional.empty();</span>
    }

    /**
     * Compute ACL permissions relevant for a {@code ThingModifyCommand}. The field &quot;/acl&quot; is handled
     * specially with the &quot;ADMINISTRATE&quot; permission.
     *
     * @param command the command.
     * @return permissions needed to execute the command.
     */
    private static Permissions computeAclPermissions(final ThingModifyCommand command) {
<span class="fc bfc" id="L918" title="All 2 branches covered.">        return affectsAcl(command)</span>
<span class="fc" id="L919">                ? Permissions.newInstance(Permission.WRITE, ADMINISTRATE.name())</span>
<span class="fc" id="L920">                : Permissions.newInstance(Permission.WRITE);</span>
    }

    /**
     * Decide whether a command affects the ACL.
     *
     * @param command the command.
     * @return whether it affects the ACL.
     */
    private static boolean affectsAcl(final ThingModifyCommand command) {
<span class="pc bpc" id="L930" title="2 of 6 branches missed.">        return command instanceof DeleteThing || resourcePathIntersectsAcl(command) || entityIntersectsAcl(command);</span>
    }

    /**
     * Decide whether a command affects the Policy ID (e.g. changes it).
     *
     * @param command the command.
     * @return whether it affects the Policy ID.
     */
    private static boolean affectsPolicyId(final ThingModifyCommand command) {
<span class="pc bpc" id="L940" title="3 of 6 branches missed.">        return command instanceof DeleteThing || resourcePathIntersectsPolicyId(command) || entityIntersectsPolicyId(command);</span>
    }

    /**
     * Decide whether a command's resource path intersects with the ACL.
     *
     * @param command the command.
     * @return whether its resource path intersects with the ACL.
     */
    private static boolean resourcePathIntersectsAcl(final ThingModifyCommand command) {
<span class="fc" id="L950">        return command.getResourcePath().getRoot()</span>
<span class="fc" id="L951">                .flatMap(root -&gt; Thing.JsonFields.ACL.getPointer()</span>
<span class="fc" id="L952">                        .getRoot()</span>
<span class="fc" id="L953">                        .map(aclRoot -&gt; Objects.equals(root, aclRoot)))</span>
<span class="fc" id="L954">                .orElse(true);</span>
    }

    /**
     * Decide whether a command's resource path intersects with the Policy ID.
     *
     * @param command the command.
     * @return whether its resource path intersects with the Policy ID.
     */
    private static boolean resourcePathIntersectsPolicyId(final ThingModifyCommand command) {
<span class="fc" id="L964">        return command.getResourcePath().getRoot()</span>
<span class="fc" id="L965">                .flatMap(root -&gt; Thing.JsonFields.POLICY_ID.getPointer()</span>
<span class="fc" id="L966">                        .getRoot()</span>
<span class="fc" id="L967">                        .map(aclRoot -&gt; Objects.equals(root, aclRoot)))</span>
<span class="fc" id="L968">                .orElse(true);</span>
    }

    /**
     * Decide whether a command's entity intersects with the ACL.
     *
     * @param command the command.
     * @return whether its entity intersects with the ACL.
     */
    private static boolean entityIntersectsAcl(final ThingModifyCommand command) {
<span class="pc bpc" id="L978" title="2 of 4 branches missed.">        return (command instanceof ModifyThing || command instanceof CreateThing) &amp;&amp;</span>
<span class="nc" id="L979">                command.getEntity()</span>
<span class="nc" id="L980">                        .filter(JsonValue::isObject)</span>
<span class="nc" id="L981">                        .map(jsonValue -&gt; jsonValue.asObject().contains(Thing.JsonFields.ACL.getPointer()))</span>
<span class="pc bnc" id="L982" title="All 2 branches missed.">                        .isPresent();</span>
    }

    /**
     * Decide whether a command's entity intersects with the Policy ID (e.g. changes it).
     *
     * @param command the command.
     * @return whether its entity intersects with the Policy ID.
     */
    private static boolean entityIntersectsPolicyId(final ThingModifyCommand command) {
<span class="pc bpc" id="L992" title="2 of 4 branches missed.">        return (command instanceof ModifyThing || command instanceof CreateThing) &amp;&amp;</span>
<span class="nc" id="L993">                command.getEntity()</span>
<span class="nc" id="L994">                        .filter(JsonValue::isObject)</span>
<span class="nc" id="L995">                        .map(jsonValue -&gt; jsonValue.asObject().contains(Thing.JsonFields.POLICY_ID.getPointer()))</span>
<span class="pc bnc" id="L996" title="All 2 branches missed.">                        .isPresent();</span>
    }

    /**
     * Check if inlined policy should be retrieved together with the thing.
     *
     * @param command the thing query command.
     * @return whether it is necessary to retrieve the thing's policy.
     */
    private static boolean shouldRetrievePolicyWithThing(final ThingCommand command) {
<span class="fc" id="L1006">        final RetrieveThing retrieveThing = (RetrieveThing) command;</span>
<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">        final boolean isNotV1 = JsonSchemaVersion.V_1 != command.getImplementedSchemaVersion();</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        return isNotV1 &amp;&amp; retrieveThing.getSelectedFields().filter(selector -&gt;</span>
<span class="fc" id="L1009">                selector.getPointers().stream().anyMatch(jsonPointer -&gt;</span>
<span class="fc" id="L1010">                        jsonPointer.getRoot()</span>
<span class="fc" id="L1011">                                .filter(jsonKey -&gt; Policy.INLINED_FIELD_NAME.equals(jsonKey.toString()))</span>
<span class="fc" id="L1012">                                .isPresent()))</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                .isPresent();</span>
    }

    /**
     * A pair of {@code CreateThing} command with {@code Enforcer}.
     */
    private static final class CreateThingWithEnforcer {

        private final CreateThing createThing;
        private final Enforcer enforcer;

        private CreateThingWithEnforcer(final CreateThing createThing,
<span class="fc" id="L1025">                final Enforcer enforcer) {</span>
<span class="fc" id="L1026">            this.createThing = createThing;</span>
<span class="fc" id="L1027">            this.enforcer = enforcer;</span>
<span class="fc" id="L1028">        }</span>
    }

    private void handleInitialCreateThing(final CreateThing createThing, final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        if (shouldCreatePolicyForCreateThing(createThing)) {</span>
<span class="fc" id="L1034">            final Optional&lt;DittoRuntimeException&gt; errorOpt = checkForErrorsInCreateThingWithPolicy(createThing);</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">            if (errorOpt.isPresent()) {</span>
<span class="nc" id="L1036">                replyToSender(errorOpt.get(), sender);</span>
            } else {
<span class="fc" id="L1038">                createThingWithInitialPolicy(createThing, enforcer, sender);</span>
            }
<span class="fc bfc" id="L1040" title="All 2 branches covered.">        } else if (createThing.getThing().getPolicyId().isPresent()) {</span>
<span class="fc" id="L1041">            final String policyId = createThing.getThing().getPolicyId().orElseThrow(IllegalStateException::new);</span>
<span class="fc" id="L1042">            final Optional&lt;DittoRuntimeException&gt; errorOpt = checkForErrorsInCreateThingWithPolicy(createThing);</span>
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">            if (errorOpt.isPresent()) {</span>
<span class="nc" id="L1044">                replyToSender(errorOpt.get(), sender);</span>
            } else {
<span class="fc" id="L1046">                enforceCreateThingForNonexistentThingWithPolicyId(createThing, policyId, sender);</span>
            }
<span class="fc" id="L1048">        } else {</span>
            // nothing to do with policy, simply forward the command
<span class="fc" id="L1050">            forwardToThingsShardRegion(createThing, sender);</span>
        }
<span class="fc" id="L1052">    }</span>

    private void createThingWithInitialPolicy(final CreateThing createThing,
            final Enforcer enforcer,
            final ActorRef sender) {

        try {
<span class="fc" id="L1059">            final Optional&lt;Policy&gt; policy =</span>
<span class="fc" id="L1060">                    getInlinedOrDefaultPolicyForCreateThing(createThing);</span>

<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">            if (policy.isPresent()) {</span>

<span class="fc" id="L1064">                final CreatePolicy createPolicy = CreatePolicy.of(policy.get(), createThing.getDittoHeaders());</span>
<span class="fc" id="L1065">                final Optional&lt;CreatePolicy&gt; authorizedCreatePolicy =</span>
<span class="fc" id="L1066">                        PolicyCommandEnforcement.authorizePolicyCommand(createPolicy, enforcer);</span>

                // CreatePolicy is rejected; abort CreateThing.
<span class="fc" id="L1069">                final boolean created = authorizedCreatePolicy</span>
<span class="fc" id="L1070">                        .filter(cmd -&gt; createPolicyAndThing(cmd, createThing, sender))</span>
<span class="fc" id="L1071">                        .isPresent();</span>

<span class="fc bfc" id="L1073" title="All 2 branches covered.">                if (!created) {</span>
<span class="fc" id="L1074">                    final DittoRuntimeException error = errorForThingCommand(createThing);</span>
<span class="fc" id="L1075">                    replyToSender(error, sender);</span>
                }
<span class="fc" id="L1077">            } else {</span>
                // cannot create policy.
<span class="nc" id="L1079">                final String thingId = createThing.getThingId();</span>
<span class="nc" id="L1080">                final String message = String.format(&quot;The Thing with ID ''%s'' could not be created with implicit &quot; +</span>
                        &quot;Policy because no authorization subject is present.&quot;, thingId);
<span class="nc" id="L1082">                final ThingNotCreatableException error =</span>
<span class="nc" id="L1083">                        ThingNotCreatableException.newBuilderForPolicyMissing(thingId, thingId)</span>
<span class="nc" id="L1084">                                .message(message)</span>
<span class="nc" id="L1085">                                .description(() -&gt; null)</span>
<span class="nc" id="L1086">                                .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1087">                                .build();</span>
<span class="nc" id="L1088">                replyToSender(error, sender);</span>
            }
<span class="nc" id="L1090">        } catch (final RuntimeException error) {</span>
<span class="nc" id="L1091">            reportError(&quot;error before creating thing with initial policy&quot;, sender, error,</span>
<span class="nc" id="L1092">                    createThing.getDittoHeaders());</span>
<span class="fc" id="L1093">        }</span>
<span class="fc" id="L1094">    }</span>

    private static Optional&lt;Policy&gt; getInlinedOrDefaultPolicyForCreateThing(final CreateThing createThing) {
<span class="fc" id="L1097">        final Optional&lt;JsonObject&gt; initialPolicy = createThing.getInitialPolicy();</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        if (initialPolicy.isPresent()) {</span>
<span class="fc" id="L1099">            final JsonObject policyJson = initialPolicy.get();</span>
<span class="fc" id="L1100">            final JsonObjectBuilder policyJsonBuilder = policyJson.toBuilder();</span>
<span class="fc" id="L1101">            final Thing thing = createThing.getThing();</span>
<span class="pc bpc" id="L1102" title="1 of 4 branches missed.">            if (thing.getPolicyId().isPresent() || !policyJson.contains(Policy.JsonFields.ID.getPointer())) {</span>
<span class="fc" id="L1103">                final String policyId = thing.getPolicyId().orElse(createThing.getThingId());</span>
<span class="fc" id="L1104">                policyJsonBuilder.set(Policy.JsonFields.ID, policyId);</span>
            }
<span class="fc" id="L1106">            return Optional.of(PoliciesModelFactory.newPolicy(policyJsonBuilder.build()));</span>
        } else {
<span class="fc" id="L1108">            return getDefaultPolicy(createThing.getDittoHeaders().getAuthorizationContext(), createThing.getThingId());</span>
        }
    }

    private static Optional&lt;DittoRuntimeException&gt; checkForErrorsInCreateThingWithPolicy(
            final CreateThing createThing) {
<span class="fc" id="L1114">        return checkAclAbsenceInCreateThing(createThing)</span>
<span class="fc" id="L1115">                .map(Optional::of)</span>
<span class="fc" id="L1116">                .orElseGet(() -&gt; checkPolicyIdValidityForCreateThing(createThing));</span>
    }

    private static Optional&lt;DittoRuntimeException&gt; checkAclAbsenceInCreateThing(final CreateThing createThing) {
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">        if (createThing.getThing().getAccessControlList().isPresent()) {</span>
<span class="nc" id="L1121">            final DittoRuntimeException error = AclNotAllowedException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1122">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1123">                    .build();</span>
<span class="nc" id="L1124">            return Optional.of(error);</span>
        } else {
<span class="fc" id="L1126">            return Optional.empty();</span>
        }
    }

    private static Optional&lt;DittoRuntimeException&gt; checkPolicyIdValidityForCreateThing(final CreateThing createThing) {
<span class="fc" id="L1131">        final Thing thing = createThing.getThing();</span>
<span class="fc" id="L1132">        final Optional&lt;String&gt; thingIdOpt = thing.getId();</span>
<span class="fc" id="L1133">        final Optional&lt;String&gt; policyIdOpt = thing.getPolicyId();</span>
<span class="fc" id="L1134">        final Optional&lt;String&gt; policyIdInPolicyOpt = createThing.getInitialPolicy()</span>
<span class="fc" id="L1135">                .flatMap(jsonObject -&gt; jsonObject.getValue(Thing.JsonFields.POLICY_ID));</span>

        final boolean isValid;
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        if (policyIdOpt.isPresent()) {</span>
<span class="pc bpc" id="L1139" title="1 of 4 branches missed.">            isValid = !policyIdInPolicyOpt.isPresent() || policyIdInPolicyOpt.equals(policyIdOpt);</span>
        } else {
<span class="pc bpc" id="L1141" title="1 of 4 branches missed.">            isValid = !policyIdInPolicyOpt.isPresent() || policyIdInPolicyOpt.equals(thingIdOpt);</span>
        }

<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">        if (!isValid) {</span>
<span class="nc" id="L1145">            final DittoRuntimeException error = PolicyIdNotAllowedException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1146">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1147">                    .build();</span>
<span class="nc" id="L1148">            return Optional.of(error);</span>
        } else {
<span class="fc" id="L1150">            return Optional.empty();</span>
        }
    }

    private static boolean shouldCreatePolicyForCreateThing(final CreateThing createThing) {
<span class="fc" id="L1155">        final JsonSchemaVersion commandVersion =</span>
<span class="fc" id="L1156">                createThing.getDittoHeaders().getSchemaVersion().orElse(JsonSchemaVersion.LATEST);</span>
<span class="fc bfc" id="L1157" title="All 4 branches covered.">        return createThing.getInitialPolicy().isPresent() ||</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">                (JsonSchemaVersion.V_1 != commandVersion &amp;&amp; !createThing.getThing().getPolicyId().isPresent());</span>
    }

    private boolean createPolicyAndThing(final CreatePolicy createPolicy,
            final CreateThing createThingWithoutPolicyId,
            final ActorRef sender) {

<span class="fc" id="L1165">        final long timeout = getAskTimeout().toMillis();</span>

<span class="fc" id="L1167">        final CreateThing createThing = CreateThing.of(</span>
<span class="fc" id="L1168">                createThingWithoutPolicyId.getThing().setPolicyId(createPolicy.getId()),</span>
                null,
<span class="fc" id="L1170">                createThingWithoutPolicyId.getDittoHeaders());</span>

<span class="fc" id="L1172">        PatternsCS.ask(policiesShardRegion, createPolicy, timeout).handleAsync((policyResponse, policyError) -&gt; {</span>

<span class="fc" id="L1174">            final Optional&lt;CreateThing&gt; nextStep =</span>
<span class="fc" id="L1175">                    handlePolicyResponseForCreateThing(createPolicy, createThing, policyResponse, policyError, sender);</span>

<span class="fc" id="L1177">            nextStep.ifPresent(cmd -&gt; PatternsCS.ask(thingsShardRegion, cmd, timeout)</span>
<span class="fc" id="L1178">                    .handleAsync((thingResponse, thingError) -&gt;</span>
<span class="fc" id="L1179">                            handleThingResponseForCreateThing(createThing, thingResponse, thingError, sender)));</span>

<span class="fc" id="L1181">            return null;</span>
        });

<span class="fc" id="L1184">        return true;</span>
    }

    private Optional&lt;CreateThing&gt; handlePolicyResponseForCreateThing(
            final CreatePolicy createPolicy,
            final CreateThing createThing,
            final Object policyResponse,
            final Throwable policyError,
            final ActorRef sender) {

<span class="fc bfc" id="L1194" title="All 2 branches covered.">        if (policyResponse instanceof CreatePolicyResponse) {</span>

<span class="fc" id="L1196">            return Optional.of(createThing);</span>

<span class="pc bpc" id="L1198" title="3 of 4 branches missed.">        } else if (policyResponse instanceof PolicyConflictException ||</span>
                policyResponse instanceof PolicyNotAccessibleException) {

<span class="fc" id="L1201">            reportInitialPolicyCreationFailure(createPolicy.getId(), createThing, sender);</span>

<span class="nc bnc" id="L1203" title="All 2 branches missed.">        } else if (isAskTimeoutException(policyResponse, policyError)) {</span>

<span class="nc" id="L1205">            replyToSender(PolicyUnavailableException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1206">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1207">                    .build(), sender);</span>

        } else {

<span class="nc" id="L1211">            final String hint =</span>
<span class="nc" id="L1212">                    String.format(&quot;creating initial policy during creation of Thing &lt;%s&gt;&quot;,</span>
<span class="nc" id="L1213">                            createThing.getThingId());</span>
<span class="nc" id="L1214">            reportUnexpectedErrorOrResponse(hint, sender, policyResponse, policyError, createThing.getDittoHeaders());</span>
        }

<span class="fc" id="L1217">        return Optional.empty();</span>
    }

    private Void handleThingResponseForCreateThing(
            final CreateThing createThing,
            final Object thingResponse,
            final Throwable thingError,
            final ActorRef sender) {

<span class="pc bpc" id="L1226" title="3 of 4 branches missed.">        if (thingResponse instanceof ThingCommandResponse || thingResponse instanceof DittoRuntimeException) {</span>

<span class="fc" id="L1228">            replyToSender(thingResponse, sender);</span>

<span class="nc bnc" id="L1230" title="All 2 branches missed.">        } else if (isAskTimeoutException(thingResponse, thingError)) {</span>

<span class="nc" id="L1232">            replyToSender(ThingUnavailableException.newBuilder(createThing.getThingId())</span>
<span class="nc" id="L1233">                    .dittoHeaders(createThing.getDittoHeaders())</span>
<span class="nc" id="L1234">                    .build(), sender);</span>

        } else {

<span class="nc" id="L1238">            final String hint =</span>
<span class="nc" id="L1239">                    String.format(&quot;after creating initial policy during creation of Thing &lt;%s&gt;&quot;,</span>
<span class="nc" id="L1240">                            createThing.getThingId());</span>
<span class="nc" id="L1241">            reportUnexpectedErrorOrResponse(hint, sender, thingResponse, thingError, createThing.getDittoHeaders());</span>
        }

<span class="fc" id="L1244">        return null;</span>
    }

    private void reportInitialPolicyCreationFailure(final String policyId,
            final CreateThing command,
            final ActorRef sender) {

<span class="fc" id="L1251">        log(command).info(&quot;The Policy with ID '{}' is already existing, the CreateThing &quot; +</span>
                &quot;command which would have created an implicit Policy for the Thing with ID '{}' &quot; +
<span class="fc" id="L1253">                &quot;is therefore not handled&quot;, policyId, command.getThingId());</span>
<span class="fc" id="L1254">        final ThingNotCreatableException error =</span>
<span class="fc" id="L1255">                ThingNotCreatableException.newBuilderForPolicyExisting(command.getThingId(), policyId)</span>
<span class="fc" id="L1256">                        .dittoHeaders(command.getDittoHeaders())</span>
<span class="fc" id="L1257">                        .build();</span>
<span class="fc" id="L1258">        replyToSender(error, sender);</span>
<span class="fc" id="L1259">    }</span>

    private static Optional&lt;Policy&gt; getDefaultPolicy(final AuthorizationContext authorizationContext,
            final CharSequence thingId) {

<span class="fc" id="L1264">        final Optional&lt;Subject&gt; subjectOptional = authorizationContext.getFirstAuthorizationSubject()</span>
<span class="fc" id="L1265">                .map(AuthorizationSubject::getId)</span>
<span class="fc" id="L1266">                .map(SubjectId::newInstance)</span>
<span class="fc" id="L1267">                .map(Subject::newInstance);</span>

<span class="fc" id="L1269">        return subjectOptional.map(subject -&gt;</span>
<span class="fc" id="L1270">                Policy.newBuilder(thingId)</span>
<span class="fc" id="L1271">                        .forLabel(DEFAULT_POLICY_ENTRY_LABEL)</span>
<span class="fc" id="L1272">                        .setSubject(subject)</span>
<span class="fc" id="L1273">                        .setGrantedPermissions(PoliciesResourceType.thingResource(&quot;/&quot;),</span>
                                org.eclipse.ditto.services.models.things.Permission.DEFAULT_THING_PERMISSIONS)
<span class="fc" id="L1275">                        .setGrantedPermissions(PoliciesResourceType.policyResource(&quot;/&quot;),</span>
                                org.eclipse.ditto.services.models.policies.Permission.DEFAULT_POLICY_PERMISSIONS)
<span class="fc" id="L1277">                        .setGrantedPermissions(PoliciesResourceType.messageResource(&quot;/&quot;),</span>
                                org.eclipse.ditto.services.models.policies.Permission.DEFAULT_POLICY_PERMISSIONS)
<span class="fc" id="L1279">                        .build());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>