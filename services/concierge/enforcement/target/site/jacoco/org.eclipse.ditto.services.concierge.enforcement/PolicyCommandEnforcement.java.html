<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolicyCommandEnforcement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Concierge :: Enforcement</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.concierge.enforcement</a> &gt; <span class="el_source">PolicyCommandEnforcement.java</span></div><h1>PolicyCommandEnforcement.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.concierge.enforcement;

import static java.util.Objects.requireNonNull;

import java.util.Optional;

import org.eclipse.ditto.json.JsonFactory;
import org.eclipse.ditto.json.JsonFieldSelector;
import org.eclipse.ditto.json.JsonObject;
import org.eclipse.ditto.json.JsonValue;
import org.eclipse.ditto.model.base.auth.AuthorizationContext;
import org.eclipse.ditto.model.base.exceptions.DittoRuntimeException;
import org.eclipse.ditto.model.enforcers.Enforcer;
import org.eclipse.ditto.model.enforcers.PolicyEnforcers;
import org.eclipse.ditto.model.policies.Permissions;
import org.eclipse.ditto.model.policies.PoliciesResourceType;
import org.eclipse.ditto.model.policies.Policy;
import org.eclipse.ditto.model.policies.ResourceKey;
import org.eclipse.ditto.services.concierge.cache.IdentityCache;
import org.eclipse.ditto.services.models.concierge.EntityId;
import org.eclipse.ditto.services.models.concierge.cache.Entry;
import org.eclipse.ditto.services.models.policies.Permission;
import org.eclipse.ditto.services.utils.cache.Cache;
import org.eclipse.ditto.signals.commands.base.CommandToExceptionRegistry;
import org.eclipse.ditto.signals.commands.policies.PolicyCommand;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyCommandToAccessExceptionRegistry;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyCommandToModifyExceptionRegistry;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyNotAccessibleException;
import org.eclipse.ditto.signals.commands.policies.exceptions.PolicyUnavailableException;
import org.eclipse.ditto.signals.commands.policies.modify.CreatePolicy;
import org.eclipse.ditto.signals.commands.policies.modify.ModifyPolicy;
import org.eclipse.ditto.signals.commands.policies.modify.PolicyModifyCommand;
import org.eclipse.ditto.signals.commands.policies.query.PolicyQueryCommand;
import org.eclipse.ditto.signals.commands.policies.query.PolicyQueryCommandResponse;
import org.eclipse.ditto.signals.commands.things.ThingCommand;

import akka.actor.ActorRef;
import akka.event.DiagnosticLoggingAdapter;
import akka.pattern.AskTimeoutException;
import akka.pattern.PatternsCS;

/**
 * Authorize {@link PolicyCommand}.
 */
public final class PolicyCommandEnforcement extends AbstractEnforcement&lt;PolicyCommand&gt; {

    /**
     * Json fields that are always shown regardless of authorization.
     */
<span class="fc" id="L61">    private static final JsonFieldSelector POLICY_QUERY_COMMAND_RESPONSE_WHITELIST =</span>
<span class="fc" id="L62">            JsonFactory.newFieldSelector(Policy.JsonFields.ID);</span>
    private final ActorRef policiesShardRegion;
    private final EnforcerRetriever enforcerRetriever;
    private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; enforcerCache;

    private PolicyCommandEnforcement(final Context data, final ActorRef policiesShardRegion,
            final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; enforcerCache) {

<span class="fc" id="L70">        super(data);</span>
<span class="fc" id="L71">        this.policiesShardRegion = requireNonNull(policiesShardRegion);</span>
<span class="fc" id="L72">        this.enforcerCache = requireNonNull(enforcerCache);</span>
<span class="fc" id="L73">        enforcerRetriever = new EnforcerRetriever(IdentityCache.INSTANCE, enforcerCache);</span>
<span class="fc" id="L74">    }</span>

    /**
     * Authorize a policy-command by a policy enforcer.
     *
     * @param &lt;T&gt; type of the policy-command.
     * @param enforcer the policy enforcer.
     * @param command the command to authorize.
     * @return optionally the authorized command.
     */
    public static &lt;T extends PolicyCommand&gt; Optional&lt;T&gt; authorizePolicyCommand(final T command,
            final Enforcer enforcer) {

<span class="fc" id="L87">        final ResourceKey policyResourceKey = PoliciesResourceType.policyResource(command.getResourcePath());</span>
<span class="fc" id="L88">        final AuthorizationContext authorizationContext = command.getDittoHeaders().getAuthorizationContext();</span>
        final boolean authorized;
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (command instanceof PolicyModifyCommand) {</span>
<span class="fc" id="L91">            final String permission = Permission.WRITE;</span>
<span class="fc" id="L92">            authorized = enforcer.hasUnrestrictedPermissions(policyResourceKey, authorizationContext, permission);</span>
<span class="fc" id="L93">        } else {</span>
<span class="fc" id="L94">            final String permission = Permission.READ;</span>
<span class="fc" id="L95">            authorized = enforcer.hasPartialPermissions(policyResourceKey, authorizationContext, permission);</span>
        }

<span class="fc bfc" id="L98" title="All 2 branches covered.">        return authorized</span>
<span class="fc" id="L99">                ? Optional.of(command)</span>
<span class="fc" id="L100">                : Optional.empty();</span>
    }

    /**
     * Limit view on entity of {@code PolicyQueryCommandResponse} by enforcer.
     *
     * @param response the response.
     * @param enforcer the enforcer.
     * @return response with view on entity restricted by enforcer..
     */
    public static &lt;T extends PolicyQueryCommandResponse&gt; T buildJsonViewForPolicyQueryCommandResponse(
            final PolicyQueryCommandResponse&lt;T&gt; response,
            final Enforcer enforcer) {

<span class="fc" id="L114">        final JsonValue entity = response.getEntity();</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (entity.isObject()) {</span>
<span class="fc" id="L116">            final JsonObject filteredView =</span>
<span class="fc" id="L117">                    getJsonViewForPolicyQueryCommandResponse(entity.asObject(), response, enforcer);</span>
<span class="fc" id="L118">            return response.setEntity(filteredView);</span>
        } else {
<span class="nc" id="L120">            return response.setEntity(entity);</span>
        }
    }

    private static JsonObject getJsonViewForPolicyQueryCommandResponse(final JsonObject responseEntity,
            final PolicyQueryCommandResponse response,
            final Enforcer enforcer) {


<span class="fc" id="L129">        final ResourceKey resourceKey =</span>
<span class="fc" id="L130">                ResourceKey.newInstance(PolicyCommand.RESOURCE_TYPE, response.getResourcePath());</span>
<span class="fc" id="L131">        final AuthorizationContext authorizationContext = response.getDittoHeaders().getAuthorizationContext();</span>

<span class="fc" id="L133">        return enforcer.buildJsonView(resourceKey, responseEntity, authorizationContext,</span>
<span class="fc" id="L134">                POLICY_QUERY_COMMAND_RESPONSE_WHITELIST, Permissions.newInstance(Permission.READ));</span>
    }

    private static PolicyCommand transformModifyPolicyToCreatePolicy(final PolicyCommand receivedCommand) {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (receivedCommand instanceof ModifyPolicy) {</span>
<span class="fc" id="L139">            final ModifyPolicy modifyPolicy = (ModifyPolicy) receivedCommand;</span>
<span class="fc" id="L140">            return CreatePolicy.of(modifyPolicy.getPolicy(), modifyPolicy.getDittoHeaders());</span>
        } else {
<span class="fc" id="L142">            return receivedCommand;</span>
        }
    }

    /**
     * Create error due to failing to execute a policy-command in the expected way.
     *
     * @param policyCommand the command.
     * @return the error.
     */
    private static DittoRuntimeException errorForPolicyCommand(final PolicyCommand policyCommand) {
<span class="fc bfc" id="L153" title="All 2 branches covered.">        final CommandToExceptionRegistry&lt;PolicyCommand, DittoRuntimeException&gt; registry =</span>
                policyCommand instanceof PolicyModifyCommand
<span class="fc" id="L155">                        ? PolicyCommandToModifyExceptionRegistry.getInstance()</span>
<span class="fc" id="L156">                        : PolicyCommandToAccessExceptionRegistry.getInstance();</span>
<span class="fc" id="L157">        return registry.exceptionFrom(policyCommand);</span>
    }

    /**
     * Authorize a policy command. Either the command is forwarded to policies-shard-region for execution or
     * the sender is told of an error.
     *
     * @param signal the command to authorize.
     * @param sender sender of the command.
     * @param log the logger to use for logging.
     */
    @Override
    public void enforce(final PolicyCommand signal, final ActorRef sender, final DiagnosticLoggingAdapter log) {
<span class="fc" id="L170">        enforcerRetriever.retrieve(entityId(), (idEntry, enforcerEntry) -&gt; {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            if (enforcerEntry.exists()) {</span>
<span class="fc" id="L172">                enforcePolicyCommandByEnforcer(signal, enforcerEntry.getValue(), sender);</span>
            } else {
<span class="fc" id="L174">                enforcePolicyCommandByNonexistentEnforcer(signal, sender);</span>
            }
<span class="fc" id="L176">        });</span>
<span class="fc" id="L177">    }</span>

    private void enforcePolicyCommandByEnforcer(final PolicyCommand&lt;?&gt; policyCommand, final Enforcer enforcer,
            final ActorRef sender) {
<span class="fc" id="L181">        final Optional&lt;? extends PolicyCommand&gt; authorizedCommandOpt = authorizePolicyCommand(policyCommand, enforcer);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (authorizedCommandOpt.isPresent()) {</span>
<span class="fc" id="L183">            final PolicyCommand authorizedCommand = authorizedCommandOpt.get();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (authorizedCommand instanceof PolicyQueryCommand) {</span>
<span class="fc" id="L185">                final PolicyQueryCommand policyQueryCommand = (PolicyQueryCommand) authorizedCommand;</span>
<span class="fc" id="L186">                askPoliciesShardRegionAndBuildJsonView(policyQueryCommand, enforcer, sender);</span>
<span class="fc" id="L187">            } else {</span>
<span class="fc" id="L188">                forwardToPoliciesShardRegion(authorizedCommand, sender);</span>
            }
<span class="fc" id="L190">        } else {</span>
<span class="fc" id="L191">            respondWithError(policyCommand, sender);</span>
        }
<span class="fc" id="L193">    }</span>

    private void enforcePolicyCommandByNonexistentEnforcer(final PolicyCommand receivedCommand, final ActorRef sender) {
<span class="fc" id="L196">        final PolicyCommand policyCommand = transformModifyPolicyToCreatePolicy(receivedCommand);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (policyCommand instanceof CreatePolicy) {</span>
<span class="fc" id="L198">            final CreatePolicy createPolicy = (CreatePolicy) policyCommand;</span>
<span class="fc" id="L199">            final Enforcer enforcer = PolicyEnforcers.defaultEvaluator(createPolicy.getPolicy());</span>
<span class="fc" id="L200">            final Optional&lt;CreatePolicy&gt; authorizedCommand = authorizePolicyCommand(createPolicy, enforcer);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if (authorizedCommand.isPresent()) {</span>
<span class="fc" id="L202">                forwardToPoliciesShardRegion(createPolicy, sender);</span>
            } else {
<span class="nc" id="L204">                respondWithError(receivedCommand, sender);</span>
            }
<span class="fc" id="L206">        } else {</span>
<span class="fc" id="L207">            final PolicyNotAccessibleException policyNotAccessibleException =</span>
<span class="fc" id="L208">                    PolicyNotAccessibleException.newBuilder(receivedCommand.getId())</span>
<span class="fc" id="L209">                            .dittoHeaders(receivedCommand.getDittoHeaders())</span>
<span class="fc" id="L210">                            .build();</span>
<span class="fc" id="L211">            replyToSender(policyNotAccessibleException, sender);</span>
        }
<span class="fc" id="L213">    }</span>

    private void forwardToPoliciesShardRegion(final PolicyCommand command, final ActorRef sender) {
<span class="fc" id="L216">        policiesShardRegion.tell(command, sender);</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (command instanceof PolicyModifyCommand) {</span>
<span class="fc" id="L218">            invalidateCaches(command.getId());</span>
        }
<span class="fc" id="L220">    }</span>

    /**
     * Whenever a Command changed the authorization, the caches must be invalidated - otherwise a directly following
     * Command targeted for the same entity will probably fail as the enforcer was not yet updated.
     *
     * @param policyId the ID of the Policy to invalidate caches for.
     */
    private void invalidateCaches(final String policyId) {
<span class="fc" id="L229">        final EntityId entityId = EntityId.of(ThingCommand.RESOURCE_TYPE, policyId);</span>
<span class="fc" id="L230">        enforcerCache.invalidate(entityId);</span>
<span class="fc" id="L231">    }</span>

    private void respondWithError(final PolicyCommand policyCommand, final ActorRef sender) {
<span class="fc" id="L234">        sender.tell(errorForPolicyCommand(policyCommand), self());</span>
<span class="fc" id="L235">    }</span>

    private void askPoliciesShardRegionAndBuildJsonView(
            final PolicyQueryCommand commandWithReadSubjects,
            final Enforcer enforcer,
            final ActorRef sender) {

<span class="fc" id="L242">        PatternsCS.ask(policiesShardRegion, commandWithReadSubjects, getAskTimeout().toMillis())</span>
<span class="fc" id="L243">                .handleAsync((response, error) -&gt; {</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">                    if (response instanceof PolicyQueryCommandResponse) {</span>
<span class="fc" id="L245">                        reportJsonViewForPolicyQuery(sender, (PolicyQueryCommandResponse) response, enforcer);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                    } else if (response instanceof DittoRuntimeException) {</span>
<span class="nc" id="L247">                        replyToSender(response, sender);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                    } else if (isAskTimeoutException(response, error)) {</span>
<span class="nc" id="L249">                        reportTimeoutForPolicyQuery(commandWithReadSubjects, sender, (AskTimeoutException) response);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                    } else if (error != null) {</span>
<span class="nc" id="L251">                        reportUnexpectedError(&quot;before building JsonView&quot;, sender, error,</span>
<span class="nc" id="L252">                                commandWithReadSubjects.getDittoHeaders());</span>
                    } else {
<span class="nc" id="L254">                        reportUnknownResponse(&quot;before building JsonView&quot;, sender, response,</span>
<span class="nc" id="L255">                                commandWithReadSubjects.getDittoHeaders());</span>
                    }
<span class="fc" id="L257">                    return null;</span>
                });
<span class="fc" id="L259">    }</span>

    private void reportTimeoutForPolicyQuery(
            final PolicyQueryCommand command,
            final ActorRef sender,
            final AskTimeoutException askTimeoutException) {
<span class="nc" id="L265">        log(command).error(askTimeoutException, &quot;Timeout before building JsonView&quot;);</span>
<span class="nc" id="L266">        replyToSender(PolicyUnavailableException.newBuilder(command.getId())</span>
<span class="nc" id="L267">                .dittoHeaders(command.getDittoHeaders())</span>
<span class="nc" id="L268">                .build(), sender);</span>
<span class="nc" id="L269">    }</span>

    private void reportJsonViewForPolicyQuery(final ActorRef sender,
            final PolicyQueryCommandResponse&lt;?&gt; thingQueryCommandResponse,
            final Enforcer enforcer) {

        try {
<span class="fc" id="L276">            final PolicyQueryCommandResponse responseWithLimitedJsonView =</span>
<span class="fc" id="L277">                    buildJsonViewForPolicyQueryCommandResponse(thingQueryCommandResponse, enforcer);</span>
<span class="fc" id="L278">            replyToSender(responseWithLimitedJsonView, sender);</span>
<span class="nc" id="L279">        } catch (final RuntimeException e) {</span>
<span class="nc" id="L280">            reportError(&quot;Error after building JsonView&quot;, sender, e, thingQueryCommandResponse.getDittoHeaders());</span>
<span class="fc" id="L281">        }</span>
<span class="fc" id="L282">    }</span>

    /**
     * Provides {@link AbstractEnforcement} for commands of type {@link PolicyCommand}.
     */
    public static final class Provider implements EnforcementProvider&lt;PolicyCommand&gt; {

        private final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; enforcerCache;
        private ActorRef policiesShardRegion;

        /**
         * Constructor.
         *
         * @param policiesShardRegion the ActorRef to the Policies shard region.
         * @param enforcerCache the enforcer cache.
         */
        public Provider(final ActorRef policiesShardRegion,
<span class="fc" id="L299">                final Cache&lt;EntityId, Entry&lt;Enforcer&gt;&gt; enforcerCache) {</span>
<span class="fc" id="L300">            this.policiesShardRegion = requireNonNull(policiesShardRegion);</span>
<span class="fc" id="L301">            this.enforcerCache = requireNonNull(enforcerCache);</span>
<span class="fc" id="L302">        }</span>

        @Override
        public Class&lt;PolicyCommand&gt; getCommandClass() {
<span class="fc" id="L306">            return PolicyCommand.class;</span>
        }

        @Override
        public AbstractEnforcement&lt;PolicyCommand&gt; createEnforcement(final AbstractEnforcement.Context context) {
<span class="fc" id="L311">            return new PolicyCommandEnforcement(context, policiesShardRegion, enforcerCache);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>