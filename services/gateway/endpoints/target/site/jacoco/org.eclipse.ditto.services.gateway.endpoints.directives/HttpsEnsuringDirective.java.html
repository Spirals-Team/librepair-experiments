<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpsEnsuringDirective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Gateway :: Endpoints</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.gateway.endpoints.directives</a> &gt; <span class="el_source">HttpsEnsuringDirective.java</span></div><h1>HttpsEnsuringDirective.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.gateway.endpoints.directives;

import static akka.http.javadsl.server.Directives.complete;
import static akka.http.javadsl.server.Directives.extractActorSystem;
import static akka.http.javadsl.server.Directives.extractRequestContext;
import static akka.http.javadsl.server.Directives.redirect;
import static org.eclipse.ditto.services.gateway.endpoints.utils.DirectivesLoggingUtils.enhanceLogWithCorrelationId;

import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import java.util.regex.Pattern;

import org.eclipse.ditto.services.gateway.starter.service.util.ConfigKeys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.typesafe.config.Config;

import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.model.Uri;
import akka.http.javadsl.server.RequestContext;
import akka.http.javadsl.server.Route;

/**
 * Custom Akka Http directive ensuring that proxied requests only come via HTTPs.
 */
public final class HttpsEnsuringDirective {

<span class="fc" id="L41">    private static final Logger LOGGER = LoggerFactory.getLogger(HttpsEnsuringDirective.class);</span>

    private static final String X_FORWARDED_PROTO_STANDARD = &quot;X-Forwarded-Proto&quot;;
    public static final String X_FORWARDED_PROTO_LBAAS = &quot;x_forwarded_proto&quot;; // LBaaS sets this value

    private static final String HTTPS_PROTO = &quot;https&quot;;
    private static final String HTTPS_TEXT =
            &quot;Connection via plain HTTP not supported, please connect via HTTPS instead&quot;;

<span class="fc" id="L50">    private static final AtomicBoolean FORCE_HTTPS_DISABLED_ALREADY_LOGGED = new AtomicBoolean(false);</span>

    private HttpsEnsuringDirective() {
        // no op
    }

    /**
     * Ensures that proxied requests only come via HTTPs rejects all others - with one exception: Depending on the
     * configuration of {@link ConfigKeys#REDIRECT_TO_HTTPS} and
     * {@link ConfigKeys#REDIRECT_TO_HTTPS_BLACKLIST_PATTERN}, the requests are redirected to https instead of rejected.
     * &lt;p&gt;NOTE: The HTTPs check can completely disabled by configuration of {@link ConfigKeys#FORCE_HTTPS}.&lt;/p&gt;
     *
     * @param correlationId the correlationId (used for logging)
     * @param inner the inner route to be wrapped with the HTTPs check
     * @return the new route wrapping {@code inner} with the HTTPs check
     */
    public static Route ensureHttps(final String correlationId, final Supplier&lt;Route&gt; inner) {
<span class="fc" id="L67">        return extractActorSystem(actorSystem -&gt; extractRequestContext(</span>
<span class="fc" id="L68">                requestContext -&gt; enhanceLogWithCorrelationId(correlationId, () -&gt; {</span>
<span class="fc" id="L69">                    final Config config = actorSystem.settings().config();</span>

<span class="fc" id="L71">                    final boolean forceHttps = config.getBoolean(ConfigKeys.FORCE_HTTPS);</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">                    if (!forceHttps) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">                        if (FORCE_HTTPS_DISABLED_ALREADY_LOGGED.compareAndSet(false, true)) {</span>
<span class="nc" id="L74">                            LOGGER.warn(&quot;No HTTPS is enforced&quot;);</span>
                        }
<span class="nc" id="L76">                        return inner.get();</span>
                    }

<span class="fc" id="L79">                    final boolean redirectToHttps = config.getBoolean(ConfigKeys.REDIRECT_TO_HTTPS);</span>
<span class="fc" id="L80">                    final String redirectToHttpsBlacklistPatternString =</span>
<span class="fc" id="L81">                            config.getString(ConfigKeys.REDIRECT_TO_HTTPS_BLACKLIST_PATTERN);</span>
<span class="fc" id="L82">                    final Pattern redirectToHttpsBlacklistPattern =</span>
<span class="fc" id="L83">                            Pattern.compile(redirectToHttpsBlacklistPatternString);</span>

                    // check whether the request came from HTTPS (before Proxy which terminated SSL and called us via HTTP)
<span class="fc" id="L86">                    final Uri requestUri = requestContext.getRequest().getUri();</span>
<span class="fc" id="L87">                    final Optional&lt;String&gt; forwardedProtoHeader =</span>
<span class="fc" id="L88">                            extractXForwardedProtoHeader(requestUri, requestContext);</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">                    if (!HTTPS_PROTO.equalsIgnoreCase(forwardedProtoHeader.orElse(null))) {</span>
<span class="fc" id="L91">                        return handleNonHttpsRequest(requestUri, redirectToHttps, redirectToHttpsBlacklistPattern);</span>
                    } else {
<span class="fc" id="L93">                        return inner.get();</span>
                    }
                })));
    }

    private static Optional&lt;String&gt; extractXForwardedProtoHeader(final Uri requestUri,
            final RequestContext requestContext) {
        String forwardedProtoHeaderValue;

<span class="fc" id="L102">        final Optional&lt;akka.http.javadsl.model.HttpHeader&gt; standardForwardedProtoHeader = requestContext.getRequest()</span>
<span class="fc" id="L103">                .getHeader(X_FORWARDED_PROTO_STANDARD) //</span>
<span class="pc bnc" id="L104" title="All 2 branches missed.">                .filter(header -&gt; header.value().length() &gt; 0);</span>
<span class="fc" id="L105">        forwardedProtoHeaderValue = standardForwardedProtoHeader.map(akka.http.javadsl.model.HttpHeader::value)</span>
<span class="fc" id="L106">                .orElse(null);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (forwardedProtoHeaderValue != null) {</span>
<span class="nc" id="L108">            LOGGER.debug(&quot;Header {} was: '{}' for uri: {}&quot;, X_FORWARDED_PROTO_STANDARD, forwardedProtoHeaderValue,</span>
                    requestUri);
        } else {
<span class="fc" id="L111">            final Optional&lt;akka.http.javadsl.model.HttpHeader&gt; forwardedProtoHeaderLbaas = requestContext.getRequest()</span>
<span class="fc" id="L112">                    .getHeader(X_FORWARDED_PROTO_LBAAS) //</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                    .filter(header -&gt; header.value().length() &gt; 0);</span>
<span class="fc" id="L114">            forwardedProtoHeaderValue = forwardedProtoHeaderLbaas.map(akka.http.javadsl.model.HttpHeader::value)</span>
<span class="fc" id="L115">                    .orElse(null);</span>

<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (forwardedProtoHeaderValue != null) {</span>
<span class="fc" id="L118">                LOGGER.debug(&quot;Header {} was: '{}' for uri: {}&quot;, X_FORWARDED_PROTO_LBAAS, forwardedProtoHeaderValue,</span>
                        requestUri);
            } else {
<span class="fc" id="L121">                LOGGER.debug(&quot;Missing header {} for uri: {}&quot;, X_FORWARDED_PROTO_STANDARD + &quot; or &quot; +</span>
                        X_FORWARDED_PROTO_LBAAS, requestUri);
            }
        }

<span class="fc" id="L126">        return Optional.ofNullable(forwardedProtoHeaderValue);</span>
    }

    private static Route handleNonHttpsRequest(final Uri requestUri, final boolean redirectToHttps,
            final Pattern redirectToHttpsBlacklistPattern) {
<span class="pc bpc" id="L131" title="1 of 4 branches missed.">        if (redirectToHttps &amp;&amp; !redirectToHttpsBlacklistPattern.matcher(requestUri.getPathString()).matches()) {</span>
<span class="fc" id="L132">            return redirectToHttps(requestUri);</span>
        } else {
<span class="fc" id="L134">            return disallowRequest(requestUri);</span>
        }
    }

    private static Route redirectToHttps(final Uri originalUri) {
<span class="fc" id="L139">        final Uri httpsUri = originalUri.scheme(HTTPS_PROTO);</span>

<span class="fc" id="L141">        LOGGER.debug(&quot;Redirecting uri '{}' to '{}'.&quot;, originalUri, httpsUri);</span>
<span class="fc" id="L142">        return redirect(httpsUri, StatusCodes.MOVED_PERMANENTLY);</span>
    }

    private static Route disallowRequest(final Uri requestUri) {
<span class="fc" id="L146">        LOGGER.info(&quot;REST request on uri '{}' did not originate via HTTPS, sending back '{}'&quot;, requestUri,</span>
                StatusCodes.NOT_FOUND);
<span class="fc" id="L148">        return complete(StatusCodes.NOT_FOUND, HTTPS_TEXT);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>