<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMessageMapperFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Connectivity :: Mapping</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.connectivity.mapping</a> &gt; <span class="el_source">DefaultMessageMapperFactory.java</span></div><h1>DefaultMessageMapperFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.connectivity.mapping;

import static org.eclipse.ditto.model.base.common.ConditionChecker.checkNotNull;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

import org.eclipse.ditto.model.connectivity.MappingContext;
import org.eclipse.ditto.model.connectivity.MessageMapperConfigurationInvalidException;

import com.typesafe.config.Config;

import akka.actor.ActorSystem;
import akka.actor.DynamicAccess;
import akka.actor.ExtendedActorSystem;
import akka.event.DiagnosticLoggingAdapter;
import scala.Tuple2;
import scala.collection.JavaConversions;
import scala.reflect.ClassTag;
import scala.util.Try;

/**
 * Encapsulates responsibility for instantiating {@link MessageMapper} objects.
 * &lt;p&gt;
 * As the message mapper instantiation is usually triggered by an actor, there are only limited possibilities of
 * logging fine grained errors and at the same time keep all responsibility for mapper instantiation behavior away
 * of the actor.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Due to this, the factory can be instantiated with a reference to the actors log adapter and will log problems to
 * the debug and warning level (no info and error). Setting a log adapter does not change factory behaviour!
 * &lt;p&gt;
 */
@Immutable
public final class DefaultMessageMapperFactory implements MessageMapperFactory {

    private final Config mappingConfig;

    /**
     * The actor system used for dynamic class instantiation.
     */
    private final DynamicAccess dynamicAccess;

    /**
     * The class scanned for static {@link MessageMapper} factory functions.
     */
    private final Class&lt;?&gt; factoryClass;

    private final DiagnosticLoggingAdapter log;

    /**
     * Constructor
     *
     * @param mappingConfig the static service configuration for mapping related stuff
     * @param dynamicAccess the actor systems dynamic access used for dynamic class instantiation
     * @param factoryClass the factory class scanned for factory functions
     * @param log the log adapter used for debug and warning logs
     */
    private DefaultMessageMapperFactory(final Config mappingConfig, final DynamicAccess dynamicAccess,
<span class="fc" id="L79">            final Class&lt;?&gt; factoryClass, final DiagnosticLoggingAdapter log) {</span>
<span class="fc" id="L80">        this.mappingConfig = checkNotNull(mappingConfig);;</span>
<span class="fc" id="L81">        this.dynamicAccess = checkNotNull(dynamicAccess);</span>
<span class="fc" id="L82">        this.factoryClass = checkNotNull(factoryClass);</span>
<span class="fc" id="L83">        this.log = checkNotNull(log);</span>
<span class="fc" id="L84">    }</span>

    /**
     * Creates a new factory and returns the instance
     *
     * @param actorSystem the actor system to use for mapping config + dynamicAccess
     * @param factoryClass the factory class scanned for factory functions
     * @param log the log adapter used for debug and warning logs
     * @return the new instance
     */
    public static DefaultMessageMapperFactory of(final ActorSystem actorSystem,
            final Class&lt;?&gt; factoryClass, final DiagnosticLoggingAdapter log) {
<span class="fc" id="L96">        final Config mappingConfig = actorSystem.settings().config().getConfig(&quot;ditto.connectivity.mapping&quot;);</span>
<span class="fc" id="L97">        final DynamicAccess dynamicAccess = ((ExtendedActorSystem) actorSystem).dynamicAccess();</span>
<span class="fc" id="L98">        return new DefaultMessageMapperFactory(mappingConfig, dynamicAccess, factoryClass, log);</span>
    }

    @Override
    public Optional&lt;MessageMapper&gt; mapperOf(final MappingContext mappingContext) {

<span class="fc" id="L104">        Optional&lt;MessageMapper&gt; mapper = Optional.empty();</span>
        try {
<span class="fc" id="L106">            mapper = findFactoryMethodAndCreateInstance(mappingContext);</span>
<span class="nc" id="L107">        } catch (final IllegalAccessException e) {</span>
<span class="nc" id="L108">            log.warning(&quot;Failed to load mapper of ctx &lt;{}&gt;! Can't access factory function: {}&quot;, mappingContext,</span>
<span class="nc" id="L109">                    e.getMessage());</span>
<span class="nc" id="L110">        } catch (final InvocationTargetException e) {</span>
<span class="nc" id="L111">            log.warning(&quot;Failed to load mapper of ctx &lt;{}&gt;! Can't invoke factory function: {}&quot;, mappingContext,</span>
<span class="nc" id="L112">                    e.getMessage());</span>
<span class="pc" id="L113">        }</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (!mapper.isPresent()) {</span>
            try {
<span class="fc" id="L117">                mapper = findClassAndCreateInstance(mappingContext);</span>
<span class="nc" id="L118">            } catch (final InstantiationException e) {</span>
<span class="nc" id="L119">                log.warning(&quot;Failed to load mapper of ctx &lt;{}&gt;! Can't instantiate mapper class: {}&quot;,</span>
<span class="nc" id="L120">                        mappingContext, e.getMessage());</span>
<span class="fc" id="L121">            } catch (final ClassCastException e) {</span>
<span class="fc" id="L122">                log.warning(&quot;Failed to load mapper of ctx &lt;{}&gt;! Class is no MessageMapper: {}&quot;,</span>
<span class="fc" id="L123">                        mappingContext, e.getMessage());</span>
<span class="pc" id="L124">            }</span>
        }

<span class="fc" id="L127">        final DefaultMessageMapperConfiguration options =</span>
<span class="fc" id="L128">                DefaultMessageMapperConfiguration.of(mappingContext.getOptions());</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        return mapper.map(m -&gt; configureInstance(m, options) ? m : null);</span>
    }

    @Override
    public MessageMapperRegistry registryOf(final MappingContext defaultContext, @Nullable final MappingContext context) {
<span class="fc" id="L134">        final MessageMapper defaultMapper = mapperOf(defaultContext)</span>
<span class="fc" id="L135">                .map(WrappingMessageMapper::wrap)</span>
<span class="fc" id="L136">                .orElseThrow(() -&gt;</span>
<span class="nc" id="L137">                        new IllegalArgumentException(&quot;No mapper found for default context: &quot; + defaultContext));</span>

        final MessageMapper messageMapper;
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (context != null) {</span>
<span class="fc" id="L141">            messageMapper = mapperOf(context)</span>
<span class="fc" id="L142">                    .map(WrappingMessageMapper::wrap).orElse(null);</span>
        } else {
<span class="nc" id="L144">            messageMapper = null;</span>
        }
<span class="fc" id="L146">        return DefaultMessageMapperRegistry.of(defaultMapper, messageMapper);</span>
    }

    /**
     * Tries to match a factory function for the specified context and uses this to instantiate a mapper.
     *
     * @param mappingContext the mapping context
     * @return the instantiated mapper, if a factory function matched.
     * @throws InvocationTargetException if a factory function matched, but could not be invoked.
     * @throws IllegalAccessException if a factory function matched, but is not accessible.
     */
    Optional&lt;MessageMapper&gt; findFactoryMethodAndCreateInstance(final MappingContext mappingContext)
            throws IllegalAccessException, InvocationTargetException {
<span class="fc" id="L159">        final Optional&lt;Method&gt; factoryMethod = findMessageMapperFactoryMethod(factoryClass, mappingContext);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (!factoryMethod.isPresent()) {</span>
<span class="fc" id="L161">            log.debug(&quot;No factory method found for ctx: &lt;{}&gt;&quot;, mappingContext);</span>
<span class="fc" id="L162">            return Optional.empty();</span>
        }

<span class="fc" id="L165">        final MessageMapper mapper = (MessageMapper) factoryMethod.get().invoke(null);</span>
<span class="fc" id="L166">        return Optional.of(mapper);</span>
    }


    /**
     * Interprets the mapping engine name as a canonical class name which is used to dynamically instantiate a mapper.
     *
     * @param mappingContext the mapping context
     * @return the instantiated mapper, if a class matched.
     * @throws InstantiationException if a class matched, but mapper instantiation failed.
     * @throws ClassCastException if a class matched but does not conform to the {@link MessageMapper} interface.
     */
    Optional&lt;MessageMapper&gt; findClassAndCreateInstance(final MappingContext mappingContext)
            throws InstantiationException {
<span class="fc" id="L180">        checkNotNull(mappingContext);</span>

        try {
<span class="fc" id="L183">            return Optional.of(createInstanceFor(mappingContext.getMappingEngine()));</span>
<span class="fc" id="L184">        } catch (final ClassNotFoundException e) {</span>
<span class="fc" id="L185">            log.debug(&quot;No mapper class found for ctx: &lt;{}&gt;&quot;, mappingContext);</span>
<span class="fc" id="L186">            return Optional.empty();</span>
        }
    }

    private boolean configureInstance(final MessageMapper mapper, final DefaultMessageMapperConfiguration options) {
        try {
<span class="fc" id="L192">            mapper.configure(mappingConfig, options);</span>
<span class="fc" id="L193">            return true;</span>
<span class="fc" id="L194">        } catch (final MessageMapperConfigurationInvalidException e) {</span>
<span class="fc" id="L195">            log.warning(&quot;Failed to apply configuration &lt;{}&gt; to mapper instance &lt;{}&gt;: {}&quot;, options, mapper,</span>
<span class="fc" id="L196">                    e.getMessage());</span>
<span class="fc" id="L197">            return false;</span>
        }
    }

    private MessageMapper createInstanceFor(final String className) throws ClassNotFoundException,
            InstantiationException {
<span class="fc" id="L203">        final ClassTag&lt;MessageMapper&gt; tag = scala.reflect.ClassTag$.MODULE$.apply(MessageMapper.class);</span>
<span class="fc" id="L204">        final List&lt;Tuple2&lt;Class&lt;?&gt;, Object&gt;&gt; constructorArgs = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L206">        final Try&lt;MessageMapper&gt; mapperTry = this.dynamicAccess</span>
<span class="fc" id="L207">                .createInstanceFor(className, JavaConversions.asScalaBuffer(constructorArgs).toList(), tag);</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (mapperTry.isFailure()) {</span>
<span class="fc" id="L210">            final Throwable error = mapperTry.failed().get();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (error.getClass().isAssignableFrom(ClassNotFoundException.class)) {</span>
<span class="fc" id="L212">                throw (ClassNotFoundException) error;</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            } else if (error.getClass().isAssignableFrom(InstantiationException.class)) {</span>
<span class="nc" id="L214">                throw (InstantiationException) error;</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            } else if (error.getClass().isAssignableFrom(ClassCastException.class)) {</span>
<span class="fc" id="L216">                throw (ClassCastException) error;</span>
            } else {
<span class="nc" id="L218">                throw new IllegalStateException(&quot;There was an unknown error when trying to creating instance for '&quot;</span>
                        + className + &quot;'&quot;, error);
            }
        }

<span class="fc" id="L223">        return mapperTry.get();</span>
    }


    private static Optional&lt;Method&gt; findMessageMapperFactoryMethod(final Class&lt;?&gt; factory, final MappingContext ctx) {
<span class="fc" id="L228">        return Arrays.stream(factory.getDeclaredMethods())</span>
<span class="fc" id="L229">                .filter(DefaultMessageMapperFactory::isFactoryMethod)</span>
<span class="fc" id="L230">                .filter(m -&gt; m.getName().toLowerCase().contains(ctx.getMappingEngine().toLowerCase()))</span>
<span class="fc" id="L231">                .findFirst();</span>
    }

    private static boolean isFactoryMethod(final Method m) {
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">        return m.getReturnType().equals(MessageMapper.class) &amp;&amp; m.getParameterTypes().length == 0;</span>
    }

    @Override
    public boolean equals(final Object o) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (this == o) return true;</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="nc" id="L242">        final DefaultMessageMapperFactory that = (DefaultMessageMapperFactory) o;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        return Objects.equals(dynamicAccess, that.dynamicAccess) &amp;&amp;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                Objects.equals(factoryClass, that.factoryClass) &amp;&amp;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                Objects.equals(log, that.log);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L250">        return Objects.hash(dynamicAccess, factoryClass, log);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>