<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractStreamForwarder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: Services :: Utils :: Akka Utils</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.services.utils.akka.streaming</a> &gt; <span class="el_source">AbstractStreamForwarder.java</span></div><h1>AbstractStreamForwarder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.services.utils.akka.streaming;

import static org.eclipse.ditto.services.utils.akka.streaming.StreamConstants.DOES_NOT_HAVE_NEXT_MSG;
import static org.eclipse.ditto.services.utils.akka.streaming.StreamConstants.FORWARDER_EXCEEDED_MAX_IDLE_TIME_MSG;
import static org.eclipse.ditto.services.utils.akka.streaming.StreamConstants.STREAM_ACK_MSG;
import static org.eclipse.ditto.services.utils.akka.streaming.StreamConstants.STREAM_COMPLETED;
import static org.eclipse.ditto.services.utils.akka.streaming.StreamConstants.STREAM_FAILED;
import static org.eclipse.ditto.services.utils.akka.streaming.StreamConstants.STREAM_STARTED;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import org.eclipse.ditto.services.models.streaming.BatchedEntityIdWithRevisions;
import org.eclipse.ditto.services.utils.akka.LogUtil;

import akka.NotUsed;
import akka.actor.AbstractActor;
import akka.actor.ActorRef;
import akka.actor.Cancellable;
import akka.event.DiagnosticLoggingAdapter;
import akka.japi.pf.ReceiveBuilder;
import akka.pattern.PatternsCS;
import akka.stream.ActorMaterializer;
import akka.stream.javadsl.Sink;
import akka.stream.javadsl.Source;
import scala.concurrent.duration.FiniteDuration;

/**
 * Actor that receives a stream of elements, forwards them to another actor, and expects as many acknowledgements as
 * there are messages forwarded. Terminates self if no message was received for a period of time. Below is this
 * actor's state transition diagram.
 * &lt;pre&gt;
 * {@code
 *
 *    +-----+
 *    |START|
 *    +--+--+
 *       |
 *       |
 *       | STREAM_STARTED: ACK
 *       |
 *       v
 *  +----+----+               NO: ACK              +---------+
 *  |         +&lt;-----------------------------------+         |
 *  |ITERATING|                                    |HAS_NEXT?|
 *  |         +-----------------------------------&gt;+         |
 *  +----+----+         ELEMENTS: MAP_ENTITY       +--+---+--+
 *       |                                            |   ^
 *       |                                            |   |
 *       |STREAM_FINISHED: ACK            YES: FORWARD|   |ACK
 *       |                                            |   |
 *       v                                            v   |
 *  +----+----+                            +----------+---+----------+
 *  |KILL_SELF|                            |WAIT_FOR_ACK_FROM_UPDATER|
 *  +---------+                            +-------------------------+
 *
 * }
 * &lt;/pre&gt;
 *
 * @param &lt;E&gt; Type of received stream elements.
 */

public abstract class AbstractStreamForwarder&lt;E&gt; extends AbstractActor {

    /**
     * Logger associated with this actor.
     */
<span class="fc" id="L84">    protected final DiagnosticLoggingAdapter log = LogUtil.obtain(this);</span>
<span class="fc" id="L85">    protected final ActorMaterializer materializer = ActorMaterializer.create(getContext());</span>

<span class="fc" id="L87">    private Instant lastMessageReceived = Instant.now();</span>

    private Cancellable activityCheck;

<span class="fc" id="L91">    protected AbstractStreamForwarder() {</span>
<span class="fc" id="L92">        log.info(&quot;Creating new StreamForwarder&quot;);</span>
<span class="fc" id="L93">    }</span>

    /**
     * Returns the maximum time this actor waits for a message before it terminates itself.
     *
     * @return The maximum idle time.
     */
    protected abstract Duration getMaxIdleTime();

    /**
     * Returns the class of stream elements.
     *
     * @return The class.
     */
    protected abstract Class&lt;E&gt; getElementClass();

    /**
     * Returns the recipient of forwarded messages.
     *
     * @return The recipient.
     */
    protected abstract ActorRef getRecipient();

    /**
     * Returns the recipient of stream status messages.
     *
     * @return Whom to send stream completion and failure messages.
     */
    protected abstract ActorRef getCompletionRecipient();

    /**
     * Transforms a stream element into a source of messages to forward to the recipient.
     *
     * @param element The stream element.
     * @return A source of messages.
     */
    protected abstract Source&lt;Object, NotUsed&gt; mapEntity(final E element);

    private Receive initialBehavior() {
<span class="fc" id="L132">        return ReceiveBuilder.create()</span>
<span class="fc" id="L133">                .matchEquals(STREAM_STARTED, unit -&gt; {</span>
<span class="fc" id="L134">                    getSender().tell(STREAM_ACK_MSG, getSelf());</span>
<span class="fc" id="L135">                    updateLastMessageReceived();</span>
<span class="fc" id="L136">                    getContext().become(iteratingBehavior());</span>
<span class="fc" id="L137">                })</span>
<span class="fc" id="L138">                .matchEquals(STREAM_FAILED, this::streamFailed)</span>
<span class="fc" id="L139">                .matchEquals(CheckForActivity.INSTANCE, this::checkForActivity)</span>
<span class="fc" id="L140">                .build();</span>
    }

    private Receive iteratingBehavior() {
<span class="fc" id="L144">        return ReceiveBuilder.create()</span>
<span class="fc" id="L145">                .matchEquals(STREAM_COMPLETED, this::streamCompleted)</span>
<span class="fc" id="L146">                .matchEquals(STREAM_FAILED, this::streamFailed)</span>
<span class="fc" id="L147">                .matchEquals(CheckForActivity.INSTANCE, this::checkForActivity)</span>
<span class="fc" id="L148">                .match(BatchedEntityIdWithRevisions.class, this::transitionToForwardingLoop)</span>
<span class="fc" id="L149">                .build();</span>
    }

    private Receive hasNextBehavior(final ActorRef elementSender) {
<span class="fc" id="L153">        return ReceiveBuilder.create()</span>
<span class="fc" id="L154">                .matchEquals(STREAM_ACK_MSG, unit -&gt; updateLastMessageReceived())</span>
<span class="fc" id="L155">                .matchEquals(DOES_NOT_HAVE_NEXT_MSG, unit -&gt; {</span>
<span class="fc" id="L156">                    updateLastMessageReceived();</span>
<span class="fc" id="L157">                    getContext().become(iteratingBehavior());</span>
<span class="fc" id="L158">                    log.debug(&quot;sending ack {} to streaming actor {}&quot;, STREAM_ACK_MSG, elementSender);</span>
<span class="fc" id="L159">                    elementSender.tell(STREAM_ACK_MSG, getSelf());</span>
<span class="fc" id="L160">                })</span>
<span class="fc" id="L161">                .matchEquals(STREAM_FAILED, this::streamFailed)</span>
<span class="fc" id="L162">                .match(CheckForActivity.class, this::checkForActivity)</span>
<span class="fc" id="L163">                .build();</span>
    }

    /**
     * Create a source of messages to forward from the batched elements received from the stream, expect
     * acknowledgement from the recipient for each message, and send self {@code DOES_NOT_HAVE_NEXT_MSG} at the end.
     *
     * @param batchedElements the batched stream elements.
     */
    private void transitionToForwardingLoop(final BatchedEntityIdWithRevisions&lt;?&gt; batchedElements) {
<span class="fc" id="L173">        log.debug(&quot;got element: {}&quot;, batchedElements);</span>
<span class="fc" id="L174">        final ActorRef self = getSelf();</span>
<span class="fc" id="L175">        final ActorRef recipient = getRecipient();</span>
<span class="fc" id="L176">        final long timeoutMillis = getMaxIdleTime().toMillis();</span>
<span class="fc" id="L177">        final List&lt;E&gt; typedElements = typecheck(batchedElements.getElements());</span>
<span class="fc" id="L178">        getContext().become(hasNextBehavior(getSender()));</span>
<span class="fc" id="L179">        Source.fromIterator(typedElements::iterator)</span>
<span class="fc" id="L180">                .flatMapConcat(this::mapEntity)</span>
<span class="fc" id="L181">                .concat(Source.single(DOES_NOT_HAVE_NEXT_MSG))</span>
<span class="fc" id="L182">                .mapAsync(1, msgToForward -&gt; {</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                    if (DOES_NOT_HAVE_NEXT_MSG.equals(msgToForward)) {</span>
<span class="fc" id="L184">                        self.tell(msgToForward, self);</span>
<span class="fc" id="L185">                        return CompletableFuture.completedFuture(msgToForward);</span>
                    } else {
<span class="fc" id="L187">                        return PatternsCS.&lt;Object&gt;ask(recipient, msgToForward, timeoutMillis)</span>
<span class="fc" id="L188">                                .thenApply(ack -&gt; {</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                                    if (isSuccessAck(ack)) {</span>
<span class="fc" id="L190">                                        log.debug(&quot;got ack: {}&quot;, ack);</span>
                                    } else {
<span class="fc" id="L192">                                        log.error(&quot;got failure ack: {}&quot;, ack);</span>
                                    }
<span class="fc" id="L194">                                    self.tell(STREAM_ACK_MSG, ActorRef.noSender());</span>
<span class="fc" id="L195">                                    return ack;</span>
                                });
                    }
                })
<span class="fc" id="L199">                .runWith(Sink.ignore(), materializer);</span>
<span class="fc" id="L200">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private List&lt;E&gt; typecheck(final List&lt;?&gt; elements) {
<span class="fc" id="L204">        final List&lt;E&gt; result = new ArrayList&lt;&gt;(elements.size());</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (Object element : elements) {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (getElementClass().isInstance(element)) {</span>
<span class="fc" id="L207">                result.add((E) element);</span>
            } else {
<span class="nc" id="L209">                final String failureMessage = String.format(&quot;Element type mismatch. Expected &lt;%s&gt;, actual &lt;%s %s&gt;&quot;,</span>
<span class="nc" id="L210">                        getElementClass().toString(), element.getClass().toString(), element.toString());</span>
<span class="nc" id="L211">                streamFailed(failureMessage);</span>
                // return empty list to ensure no message is sent downstream before shutdown.
<span class="nc" id="L213">                return Collections.emptyList();</span>
            }
<span class="fc" id="L215">        }</span>
<span class="fc" id="L216">        return result;</span>
    }

    private static boolean isSuccessAck(final Object ack) {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        return (ack instanceof StreamAck) &amp;&amp;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                StreamAck.Status.SUCCESS == ((StreamAck) ack).getStatus();</span>
    }

    @Override
    public void preStart() throws Exception {
<span class="fc" id="L226">        super.preStart();</span>

<span class="fc" id="L228">        final FiniteDuration delayAndInterval = FiniteDuration.create(getMaxIdleTime().getSeconds(), TimeUnit.SECONDS);</span>
<span class="fc" id="L229">        activityCheck = getContext().system().scheduler()</span>
<span class="fc" id="L230">                .schedule(delayAndInterval, delayAndInterval, getSelf(), CheckForActivity.INSTANCE,</span>
<span class="fc" id="L231">                        getContext().dispatcher(), ActorRef.noSender());</span>
<span class="fc" id="L232">    }</span>

    @Override
    public void postStop() throws Exception {
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">        if (null != activityCheck) {</span>
<span class="fc" id="L237">            activityCheck.cancel();</span>
        }
<span class="fc" id="L239">        super.postStop();</span>
<span class="fc" id="L240">    }</span>

    @Override
    public Receive createReceive() {
<span class="fc" id="L244">        return initialBehavior();</span>
    }

    private void checkForActivity(final CheckForActivity checkForActivity) {
<span class="fc" id="L248">        final Duration sinceLastMessage = Duration.between(lastMessageReceived, Instant.now());</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (sinceLastMessage.compareTo(getMaxIdleTime()) &gt; 0) {</span>
<span class="fc" id="L250">            log.error(&quot;Stream timed out&quot;);</span>
<span class="fc" id="L251">            getCompletionRecipient().tell(FORWARDER_EXCEEDED_MAX_IDLE_TIME_MSG, getSelf());</span>
<span class="fc" id="L252">            shutdown();</span>
        } else {
<span class="fc" id="L254">            log.debug(&quot;Stream is still considered as active&quot;);</span>
        }
<span class="fc" id="L256">    }</span>

    private void streamCompleted(final Object completionMessage) {
<span class="fc" id="L259">        log.info(&quot;Stream successfully finished.&quot;);</span>
<span class="fc" id="L260">        getCompletionRecipient().tell(completionMessage, getSelf());</span>
<span class="fc" id="L261">        getContext().stop(getSelf());</span>
<span class="fc" id="L262">    }</span>

    private void streamFailed(final Object failureMessage) {
<span class="nc" id="L265">        getCompletionRecipient().forward(failureMessage, getContext());</span>
<span class="nc" id="L266">        shutdown();</span>
<span class="nc" id="L267">    }</span>

    private void updateLastMessageReceived() {
<span class="fc" id="L270">        lastMessageReceived = Instant.now();</span>
<span class="fc" id="L271">        log.debug(&quot;Updated last message&quot;);</span>
<span class="fc" id="L272">    }</span>

    private void shutdown() {
<span class="fc" id="L275">        getContext().stop(getSelf());</span>
<span class="fc" id="L276">    }</span>

<span class="fc" id="L278">    private enum CheckForActivity {</span>
<span class="fc" id="L279">        INSTANCE</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>