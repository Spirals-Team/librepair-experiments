[INFO] Scanning for projects...
[WARNING] 
[WARNING] Some problems were encountered while building the effective model for fr.inria.gforge.spoon:spoon-core:jar:6.3.0-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.pitest:pitest-maven is missing. @ line 520, column 15
[WARNING] 
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING] 
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING] 
[INFO] Inspecting build with total of 1 modules...
[INFO] Installing Nexus Staging features:
[INFO]   ... total of 1 executions of maven-deploy-plugin replaced with nexus-staging-maven-plugin
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Spoon Core 6.3.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-enforcer-plugin:1.0:enforce (enforce-maven) @ spoon-core ---
[INFO] Skipping Rule Enforcement.
[INFO] 
[INFO] --- jacoco-maven-plugin:0.8.1:prepare-agent (default) @ spoon-core ---
[INFO] argLine set to -javaagent:/root/./workspace/INRIA/spoon/399429949/.m2/org/jacoco/org.jacoco.agent/0.8.1/org.jacoco.agent-0.8.1-runtime.jar=destfile=/root/workspace/INRIA/spoon/399429949/target/jacoco.exec
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ spoon-core ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 3 resources
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.7.0:compile (default-compile) @ spoon-core ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ spoon-core ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 178 resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.7.0:testCompile (default-testCompile) @ spoon-core ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-surefire-plugin:2.21.0:test (default-test) @ spoon-core ---
[INFO] Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.pom
[INFO] Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.pom (4 KB at 4.9 KB/sec)
[INFO] Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-providers/2.21.0/surefire-providers-2.21.0.pom
[INFO] Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-providers/2.21.0/surefire-providers-2.21.0.pom (3 KB at 106.7 KB/sec)
[INFO] Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.jar
[INFO] Downloaded: https://repo.maven.apache.org/maven2/org/apache/maven/surefire/surefire-junit4/2.21.0/surefire-junit4-2.21.0.jar (83 KB at 562.3 KB/sec)
[INFO] 
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running spoon.test.api.NoClasspathTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.905 s - in spoon.test.api.NoClasspathTest
[INFO] Running spoon.test.api.FileSystemFolderTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.api.FileSystemFolderTest
[INFO] Running spoon.test.api.APITest
./target/nooutput_d64a51bf-12d8-4ac0-8cfb-ca1d12d2d3fd
2018-07-03 07:37:17,233 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.ElementPrinterHelper.writeComment(ElementPrinterHelper.java:392)
	at spoon.reflect.visitor.ElementPrinterHelper.writeComment(ElementPrinterHelper.java:401)
	at spoon.reflect.visitor.ElementPrinterHelper.writeComment(ElementPrinterHelper.java:413)
	at spoon.reflect.visitor.ElementPrinterHelper.writeHeader(ElementPrinterHelper.java:356)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.writeHeader(DefaultJavaPrettyPrinter.java:1926)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1952)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.Launcher.prettyprint(Launcher.java:786)
	at spoon.Launcher.run(Launcher.java:724)
	at spoon.test.api.APITest.testBasicAPIUsage(APITest.java:73)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[INFO] Tests run: 22, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 40.35 s - in spoon.test.api.APITest
[INFO] Running spoon.test.api.MetamodelTest
[INFO] Tests run: 14, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 8.288 s - in spoon.test.api.MetamodelTest
[INFO] Running spoon.test.exceptions.ExceptionTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.588 s - in spoon.test.exceptions.ExceptionTest
[INFO] Running spoon.test.module.TestModule
[WARNING] Tests run: 8, Failures: 0, Errors: 0, Skipped: 2, Time elapsed: 0.282 s - in spoon.test.module.TestModule
[INFO] Running spoon.test.imports.ImportTest
2018-07-03 07:37:30,634 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.Launcher.prettyprint(Launcher.java:786)
	at spoon.Launcher.run(Launcher.java:724)
	at spoon.test.imports.ImportTest.testmportInCu(ImportTest.java:1004)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[ERROR] Tests run: 44, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 9.297 s <<< FAILURE! - in spoon.test.imports.ImportTest
[ERROR] testmportInCu(spoon.test.imports.ImportTest)  Time elapsed: 0.226 s  <<< FAILURE!
java.lang.AssertionError
	at spoon.test.imports.ImportTest.testmportInCu(ImportTest.java:1010)

[INFO] Running spoon.test.imports.ImportAndExtendWithPackageNameTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.053 s - in spoon.test.imports.ImportAndExtendWithPackageNameTest
[INFO] Running spoon.test.imports.ImportScannerTest
2018-07-03 07:38:07,936 WARN spoon.Launcher - ImportScannerTest: Import scanner imports 581 unused imports and misses 0 imports
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 32.513 s - in spoon.test.imports.ImportScannerTest
[INFO] Running spoon.test.prettyprinter.PrintChangesTest
[ERROR] Tests run: 3, Failures: 3, Errors: 0, Skipped: 0, Time elapsed: 1.986 s <<< FAILURE! - in spoon.test.prettyprinter.PrintChangesTest
[ERROR] testPrintUnchaged(spoon.test.prettyprinter.PrintChangesTest)  Time elapsed: 0.203 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...inter.testclasses;

[import java.util.ArrayList;
import java.util.List;

/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

//and what about this comment? ]> but was:<...inter.testclasses;

[
/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

]>
	at spoon.test.prettyprinter.PrintChangesTest.testPrintUnchaged(PrintChangesTest.java:38)

[ERROR] testPrintChangedReferenceBuilder(spoon.test.prettyprinter.PrintChangesTest)  Time elapsed: 1.655 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...port.compiler.jdt;

[import org.eclipse.jdt.core.compiler.CharOperation;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
import org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;
import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.Scope;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
import spoon.reflect.code.CtLambda;
import spoon.reflect.declaration.CtModule;
import spoon.reflect.declaration.CtPackage;
import spoon.reflect.declaration.CtParameter;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.PackageFactory;
import spoon.reflect.reference.CtArrayTypeReference;
import spoon.reflect.reference.CtCatchVariableReference;
import spoon.reflect.reference.CtExecutableReference;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtLocalVariableReference;
import spoon.reflect.reference.CtModuleReference;
import spoon.reflect.reference.CtPackageReference;
import spoon.reflect.reference.CtParameterReference;
import spoon.reflect.reference.CtReference;
import spoon.reflect.reference.CtTypeParameterReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.reference.CtVariableReference;
import spoon.support.reflect.CtExtendedModifier;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;

public class ReferenceBuilder {

	// Allow to detect circular references and to avoid endless recursivity
	// when resolving parameterizedTypes (e.g. Enum<E extends Enum<E>>)
	private Map<TypeBinding, CtTypeReference> exploringParameterizedBindings = new HashMap<>();

	private boolean bounds = false;

	private final JDTTreeBuilder jdtTreeBuilder;

	ReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {
		this.jdtTreeBuilder = jdtTreeBuilder;
	}

	private CtTypeReference<?> getBoundedTypeReference(TypeBinding binding) {
		bounds = true;
		CtTypeReference<?> ref = getTypeReference(binding);
		bounds = false;
		return ref;
	}

	/**
	 * Builds a type reference from a {@link TypeReference}.
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @param <T>   Type of the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope) {
		return buildTypeReference(type, scope, false);
	}
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<T> typeReference = this.<T>getTypeReference(type.resolvedType, type);
		return buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);
	}

	/**
	 * Builds a qualified type reference from a {@link TypeReference}.
	 *
	 * @param type Qualified type from JDT.
	 * @param scope Scope of the parent element.
	 * @return
	 */
	<T> CtTypeReference<T> buildTypeReference(QualifiedTypeReference type, Scope scope) {
		CtTypeReference<T> accessedType = buildTypeReference((TypeReference) type, scope);
		final TypeBinding receiverType = type != null ? type.resolvedType : null;
		if (receiverType != null) {
			final CtTypeReference<T> ref = getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {
				@Override
				public boolean onAccess(char[][] tokens, int index) {
					return true;
				}
			});
			if (ref != null) {
				accessedType = ref;
			}
		}
		return accessedType;
	}

	/**
	 * Builds a type parameter reference from a {@link TypeReference}
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @return a type parameter reference.
	 */
	private CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {
		if (type == null) {
			return null;
		}
		return (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);
	}


	private <T> CtTypeReference<T> buildTypeReferenceInternal(CtTypeReference<T> typeReference, TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<?> currentReference = typeReference;

		for (int position = type.getTypeName().length - 1; position >= 0; position--) {
			if (currentReference == null) {
				break;
			}
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = isTypeCast;
			this.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = false;
			if (type.annotations != null && type.annotations.length - 1 <= position && type.annotations[position] != null && type.annotations[position].length > 0) {
				for (Annotation annotation : type.annotations[position]) {
					if (scope instanceof ClassScope) {
						annotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);
					} else if (scope instanceof BlockScope) {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);
					} else {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) null);
					}
				}
			}
			if (type.getTypeArguments() != null && type.getTypeArguments().length - 1 <= position && type.getTypeArguments()[position] != null && type.getTypeArguments()[position].length > 0) {
				CtTypeReference<?> componentReference = getTypeReferenceOfArrayComponent(currentReference);
				componentReference.getActualTypeArguments().clear();
				for (TypeReference typeArgument : type.getTypeArguments()[position]) {
					if (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {
						componentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));
					} else {
						componentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));
					}
				}
			} else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)
					&& !isTypeArgumentExplicit(type.getTypeArguments())) {
				for (CtTypeReference<?> actualTypeArgument : currentReference.getActualTypeArguments()) {
					actualTypeArgument.setImplicit(true);
					if (actualTypeArgument instanceof CtArrayTypeReference) {
						((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);
					}
				}
			}
			if (type instanceof Wildcard && typeReference instanceof CtTypeParameterReference) {
				((CtTypeParameterReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));
			}
			this.jdtTreeBuilder.getContextBuilder().exit(type);
			currentReference = currentReference.getDeclaringType();
		}
		return typeReference;
	}

	private CtTypeReference<?> getTypeReferenceOfArrayComponent(CtTypeReference<?> currentReference) {
		while (currentReference instanceof CtArrayTypeReference) {
			currentReference = ((CtArrayTypeReference<?>) currentReference).getComponentType();
		}
		return currentReference;
	}

	private boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {
		if (typeArguments == null) {
			return true;
		}
		boolean isGenericTypeExplicit = true;
		// This loop is necessary because it is the only way to know if the generic type
		// is implicit or not.
		for (TypeReference[] typeArgument : typeArguments) {
			isGenericTypeExplicit = typeArgument != null && typeArgument.length > 0;
			if (isGenericTypeExplicit) {
				break;
			}
		}
		return isGenericTypeExplicit;
	}

	/**
	 * Builds a type reference from a qualified name when a type specified in the name isn't available.
	 *
	 * @param tokens        Qualified name.
	 * @param receiverType  Last type in the qualified name.
	 * @param enclosingType Enclosing type of the type name.
	 * @param listener      Listener to know if we must build the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {
		final List<CtExtendedModifier> listPublicProtected = Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));
		if (enclosingType != null && Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {
			String access = "";
			int i = 0;
			final CompilationUnitDeclaration[] units = ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;
			for (; i < tokens.length; i++) {
				final char[][] qualified = Arrays.copyOfRange(tokens, 0, i + 1);
				if (searchPackage(qualified, units) == null) {
					access = CharOperation.toString(qualified);
					break;
				}
			}
			if (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {
				access = searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);
			}
			final TypeBinding accessBinding = searchTypeBinding(access, units);
			if (accessBinding != null && listener.onAccess(tokens, i)) {
				final TypeBinding superClassBinding = searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));
				if (superClassBinding != null) {
					return this.getTypeReference(superClassBinding.clone(accessBinding));
				} else {
					return this.getTypeReference(receiverType);
				}
			} else {
				return this.getTypeReference(receiverType);
			}
		}
		return null;
	}

	/**
	 * Try to get the declaring reference (package or type) from imports of the current
	 * compilation unit declaration (current class). This method returns a CtReference
	 * which can be a CtTypeReference if it retrieves the information in an static import,
	 * a CtPackageReference if it retrieves the information in an standard import, otherwise
	 * it returns null.
	 *
	 * @param expectedName Name expected in imports.
	 * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.
	 */
	CtReference getDeclaringReferenceFromImports(char[] expectedName) {
		CompilationUnitDeclaration cuDeclaration = this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;
		LookupEnvironment environment = cuDeclaration.scope.environment;

		if (cuDeclaration != null && cuDeclaration.imports != null) {
			for (ImportReference anImport : cuDeclaration.imports) {
				if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {
					if (anImport.isStatic()) {
						int indexDeclaring = 2;
						if ((anImport.bits & ASTNode.OnDemand) != 0) {
							// With .*
							indexDeclaring = 1;
						}
						char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);
						char[][] className = CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));
						PackageBinding aPackage;
						try {
							if (packageName.length != 0) {
								aPackage = environment.createPackage(packageName);
							} else {
								aPackage = null;
							}
							final MissingTypeBinding declaringType = environment.createMissingType(aPackage, className);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = true;
							final CtTypeReference<Object> typeReference = getTypeReference(declaringType);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = false;
							return typeReference;
						} catch (NullPointerException e) {
							return null;
						}

					} else {
						PackageBinding packageBinding = null;
						char[][] chars = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);
						// `findImport(chars, false, false);` and `createPackage(chars)` require
						// an array with a minimum length of 1 and throw an
						// ArrayIndexOutOfBoundsException if `chars.length == 0`. Fixes #759.
						if (chars.length > 0) {
							Binding someBinding = cuDeclaration.scope.findImport(chars, false, false);
							if (someBinding != null && someBinding.isValidBinding() && someBinding instanceof PackageBinding) {
								packageBinding = (PackageBinding) someBinding;
							} else {
								try {
									packageBinding = environment.createPackage(chars);
								} catch (NullPointerException e) {
									packageBinding = null;
								}
							}
						}
						if (packageBinding == null || packageBinding instanceof ProblemPackageBinding) {
							// Big crisis here. We are already in noclasspath mode but JDT doesn't support always
							// creation of a package in this mode. So, if we are in this brace, we make the job of JDT...
							packageBinding = new PackageBinding(chars, null, environment, environment.module);
						}
						return getPackageReference(packageBinding);
					}
				}
			}
		}
		return null;
	}

	@SuppressWarnings("unchecked")
	<T> CtExecutableReference<T> getExecutableReference(MethodBinding exec) {
		if (exec == null) {
			return null;
		}
		final CtExecutableReference ref = this.jdtTreeBuilder.getFactory().Core().createExecutableReference();
		if (exec.isConstructor()) {
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);

			// in case of constructor of an array, it's the return type that we want
			if (exec.returnType instanceof VoidTypeBinding) {
				ref.setType(getTypeReference(exec.declaringClass));
			} else {
				ref.setType(getTypeReference(exec.returnType));
			}
		} else {
			ref.setSimpleName(new String(exec.selector));
			ref.setType(getTypeReference(exec.returnType));
		}
		if (exec instanceof ProblemMethodBinding) {
			if (exec.declaringClass != null && Arrays.asList(exec.declaringClass.methods()).contains(exec)) {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			} else {
				final CtReference declaringType = getDeclaringReferenceFromImports(exec.constantPoolName());
				if (declaringType instanceof CtTypeReference) {
					ref.setDeclaringType((CtTypeReference<?>) declaringType);
				}
			}
			if (exec.isConstructor()) {
				// super() invocation have a good declaring class.
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(true);
		} else {
			if (exec.isConstructor() && !(exec.returnType instanceof VoidTypeBinding)) {
				ref.setDeclaringType(getTypeReference(exec.returnType));
			} else {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(exec.isStatic());
		}

		if (exec.declaringClass instanceof ParameterizedTypeBinding) {
			ref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));
		}

		// original() method returns a result not null when the current method is generic.
		if (exec.original() != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>(exec.original().parameters.length);
			for (TypeBinding b : exec.original().parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		} else if (exec.parameters != null) {
			// This is a method without a generic argument.
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (TypeBinding b : exec.parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}

		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(AllocationExpression allocationExpression) {
		CtExecutableReference<T> ref;
		if (allocationExpression.binding != null) {
			ref = getExecutableReference(allocationExpression.binding);
		} else {
			ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);
			ref.setDeclaringType(getTypeReference(null, allocationExpression.type));

			final List<CtTypeReference<?>> parameters = new ArrayList<>(allocationExpression.argumentTypes.length);
			for (TypeBinding b : allocationExpression.argumentTypes) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}
		if (allocationExpression.type == null) {
			ref.setType(this.<T>getTypeReference(allocationExpression.expectedType()));
		}
		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(MessageSend messageSend) {
		if (messageSend.binding != null) {
			return getExecutableReference(messageSend.binding);
		}
		CtExecutableReference<T> ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
		ref.setSimpleName(CharOperation.charToString(messageSend.selector));
		ref.setType(this.<T>getTypeReference(messageSend.expectedType()));
		if (messageSend.receiver.resolvedType == null) {
			// It is crisis dude! static context, we don't have much more information.
			if (messageSend.receiver instanceof SingleNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());
			} else if (messageSend.receiver instanceof QualifiedNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());
			}
		} else {
			ref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));
		}
		if (messageSend.arguments != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (Expression expression : messageSend.arguments) {
				parameters.add(getTypeReference(expression.resolvedType));
			}
			ref.setParameters(parameters);
		}
		return ref;
	}

	private CtPackageReference getPackageReference(PackageBinding reference) {
		return getPackageReference(new String(reference.shortReadableName()));
	}

	public CtPackageReference getPackageReference(String name) {
		if (name.length() == 0) {
			return this.jdtTreeBuilder.getFactory().Package().topLevel();
		}
		CtPackageReference ref = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
		ref.setSimpleName(name);
		return ref;
	}

	final Map<TypeBinding, CtTypeReference> bindingCache = new HashMap<>();

	<T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<T> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		CtTypeReference<T> result = getTypeReference(ref);
		return result;
	}

	CtTypeReference<Object> getTypeParameterReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<Object> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			if (!(ctRef instanceof CtTypeParameterReference)) {
				CtTypeParameterReference typeParameterRef = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
				typeParameterRef.setSimpleName(ctRef.getSimpleName());
				typeParameterRef.setDeclaringType(ctRef.getDeclaringType());
				typeParameterRef.setPackage(ctRef.getPackage());
				ctRef = typeParameterRef;
			}
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		return getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));
	}

	/**
	 * In no classpath, the model of the super interface isn't always correct.
	 */
	private boolean isCorrectTypeReference(TypeReference ref) {
		if (ref.resolvedType == null) {
			return false;
		}
		if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {
			return true;
		}
		final String[] compoundName = CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);
		final String[] typeName = CharOperation.charArrayToStringArray(ref.getTypeName());
		if (compoundName.length == 0 || typeName.length == 0) {
			return false;
		}
		return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);
	}

	private <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {
		if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
			for (TypeReference[] typeReferences : original.getTypeArguments()) {
				if (typeReferences != null) {
					for (TypeReference typeReference : typeReferences) {
						type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));
					}
				}
			}
		}
	}

	/**
	 * JDT doesn't return a correct AST with the resolved type of the reference.
	 * This method try to build a correct Spoon AST from the name of the JDT
	 * reference, thanks to the parsing of the string, the name parameterized from
	 * the JDT reference and java convention.
	 * Returns a complete Spoon AST when the name is correct, otherwise a spoon type
	 * reference with a name that correspond to the name of the JDT type reference.
	 */
	<T> CtTypeReference<T> getTypeReference(TypeReference ref) {
		if (ref == null) {
			return null;
		}
		CtTypeReference<T> res = null;
		CtTypeReference inner = null;
		final String[] namesParameterized = CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());
		String nameParameterized = CharOperation.toString(ref.getParameterizedTypeName());
		String typeName = CharOperation.toString(ref.getTypeName());

		int index = namesParameterized.length - 1;
		for (; index >= 0; index--) {
			// Start at the end to get the class name first.
			CtTypeReference main = getTypeReference(namesParameterized[index]);
			if (main == null) {
				break;
			}
			if (res == null) {
				res = (CtTypeReference<T>) main;
			} else {
				inner.setDeclaringType((CtTypeReference<?>) main);
			}
			inner = main;
		}
		if (res == null) {
			return this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);
		}

		if (inner.getPackage() == null) {
			PackageFactory packageFactory = this.jdtTreeBuilder.getFactory().Package();
			CtPackageReference packageReference = index >= 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();
			inner.setPackage(packageReference);
		}
		if (!res.toString().replace(", ?", ",?").endsWith(nameParameterized)) {
			// verify that we did not match a class that have the same name in a different package
			return this.jdtTreeBuilder.getFactory().Type().createReference(typeName);
		}
		return res;
	}

	private String concatSubArray(String[] a, int endIndex) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < endIndex; i++) {
			sb.append(a[i]).append('.');
		}
		sb.append(a[endIndex]);
		return sb.toString();
	}

	/**
	 * Try to build a CtTypeReference from a simple name with specified generic types but
	 * returns null if the name doesn't correspond to a type (not start by an upper case).
	 */
	private <T> CtTypeReference<T> getTypeReference(String name) {
		CtTypeReference<T> main = null;
		if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (name.startsWith("?")) {
				main = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			if (m.find()) {
				main.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (Character.isUpperCase(name.charAt(0))) {
			if (name.endsWith("[]")) {
				main = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
				name = name.substring(0, name.length() - 2);
				((CtArrayTypeReference<T>) main).setComponentType(this.getTypeReference(name));
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			main.setSimpleName(name);
			final CtReference declaring = this.getDeclaringReferenceFromImports(name.toCharArray());
			setPackageOrDeclaringType(main, declaring);
		} else if (name.startsWith("?")) {
			return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		}
		return main;
	}

	/**
	 * Try to build a CtTypeParameterReference from a single name with specified generic types but
	 * keep in mind that if you give wrong data in the strong, reference will be wrong.
	 */
	private CtTypeReference<Object> getTypeParameterReference(String name) {
		CtTypeReference<Object> param = null;
		if (name.contains("extends") || name.contains("super")) {
			String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
			param = getTypeParameterReference(split[0].trim());
			((CtTypeParameterReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));
		} else if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (m.find()) {
				param = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
				param.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (name.contains("?")) {
			param = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		} else {
			param = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
			param.setSimpleName(name);
		}
		return param;
	}

	@SuppressWarnings("unchecked")
	<T> CtTypeReference<T> getTypeReference(TypeBinding binding) {
		if (binding == null) {
			return null;
		}

		CtTypeReference<?> ref = null;

		if (binding instanceof RawTypeBinding) {
			ref = getTypeReference(((ParameterizedTypeBinding) binding).genericType());
		} else if (binding instanceof ParameterizedTypeBinding) {
			if (binding.actualType() != null && binding.actualType() instanceof LocalTypeBinding) {
				// When we define a nested class in a method and when the enclosing class of this method
				// is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class
				// and hide the real class in actualType().
				ref = getTypeReference(binding.actualType());
			} else {
				ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
				this.exploringParameterizedBindings.put(binding, ref);
				if (binding.isAnonymousType()) {
					ref.setSimpleName("");
				} else {
					ref.setSimpleName(String.valueOf(binding.sourceName()));
					if (binding.enclosingType() != null) {
						ref.setDeclaringType(getTypeReference(binding.enclosingType()));
					} else {
						ref.setPackage(getPackageReference(binding.getPackage()));
					}
				}
			}
			if (binding.actualType() instanceof MissingTypeBinding) {
				ref = getTypeReference(binding.actualType());
			}

			if (((ParameterizedTypeBinding) binding).arguments != null) {
				for (TypeBinding b : ((ParameterizedTypeBinding) binding).arguments) {
					if (bindingCache.containsKey(b)) {
						ref.addActualTypeArgument(getCtCircularTypeReference(b));
					} else {
						if (!this.exploringParameterizedBindings.containsKey(b)) {
							this.exploringParameterizedBindings.put(b, null);
							CtTypeReference typeRefB = getTypeReference(b);
							this.exploringParameterizedBindings.put(b, typeRefB);
							ref.addActualTypeArgument(typeRefB);
						} else {
							CtTypeReference typeRefB = this.exploringParameterizedBindings.get(b);
							if (typeRefB != null) {
								ref.addActualTypeArgument(typeRefB.clone());
							}
						}
					}
				}
			}
		} else if (binding instanceof MissingTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(new String(binding.sourceName()));
			ref.setPackage(getPackageReference(binding.getPackage()));
			if (!this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports) {
				final CtReference declaring = this.getDeclaringReferenceFromImports(binding.sourceName());
				if (declaring instanceof CtPackageReference) {
					ref.setPackage((CtPackageReference) declaring);
				} else if (declaring instanceof CtTypeReference) {
					ref.setDeclaringType((CtTypeReference) declaring);
				}
			}
		} else if (binding instanceof BinaryTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			if (binding.enclosingType() != null) {
				ref.setDeclaringType(getTypeReference(binding.enclosingType()));
			} else {
				ref.setPackage(getPackageReference(binding.getPackage()));
			}
			ref.setSimpleName(new String(binding.sourceName()));
		} else if (binding instanceof TypeVariableBinding) {
			boolean oldBounds = bounds;

			if (binding instanceof CaptureBinding) {
				ref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
				bounds = true;
			} else {
				TypeVariableBinding typeParamBinding = (TypeVariableBinding) binding;
				ReferenceBinding superClass = typeParamBinding.superclass;
				ReferenceBinding[] superInterfaces = typeParamBinding.superInterfaces();

				CtTypeReference refSuperClass = null;

				// if the type parameter has a super class other than java.lang.Object, we get it
				// superClass.superclass() is null if it's java.lang.Object
				if (superClass != null && !(superClass.superclass() == null)) {

					// this case could happen with Enum<E extends Enum<E>> for example:
					// in that case we only want to have E -> Enum -> E
					// to conserve the same behavior as JavaReflectionTreeBuilder
					if (!(superClass instanceof ParameterizedTypeBinding) || !this.exploringParameterizedBindings.containsKey(superClass)) {
						refSuperClass = this.getTypeReference(superClass);
					}

				// if the type parameter has a super interface, then we'll get it too, as a superclass
				// type parameter can only extends an interface or a class, so we don't make the distinction
				// in Spoon. Moreover we can only have one extends in a type parameter.
				} else if (superInterfaces != null && superInterfaces.length == 1) {
					refSuperClass = this.getTypeReference(superInterfaces[0]);
				}

				ref = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
				ref.setSimpleName(new String(binding.sourceName()));

				if (refSuperClass != null) {
					((CtTypeParameterReference) ref).addBound(refSuperClass);
				}
			}
			TypeVariableBinding b = (TypeVariableBinding) binding;
			if (bounds) {
				if (b instanceof CaptureBinding && ((CaptureBinding) b).wildcard != null) {
					bounds = oldBounds;
					return getTypeReference(((CaptureBinding) b).wildcard);
				} else if (b.superclass != null && b.firstBound == b.superclass) {
					bounds = false;
					bindingCache.put(binding, ref);
					((CtTypeParameterReference) ref).setBoundingType(getTypeReference(b.superclass));
					bounds = oldBounds;
				}
			}
			if (bounds && b.superInterfaces != null && b.superInterfaces != Binding.NO_SUPERINTERFACES) {
				bounds = false;
				bindingCache.put(binding, ref);
				List<CtTypeReference<?>> bounds = new ArrayList<>();
				CtTypeParameterReference typeParameterReference = (CtTypeParameterReference) ref;
				if (!(typeParameterReference.isDefaultBoundingType())) { // if it's object we can ignore it
					bounds.add(typeParameterReference.getBoundingType());
				}
				for (ReferenceBinding superInterface : b.superInterfaces) {
					bounds.add(getTypeReference(superInterface));
				}
				((CtTypeParameterReference) ref).setBoundingType(this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds));
			}
			if (binding instanceof CaptureBinding) {
				bounds = false;
			}
		} else if (binding instanceof BaseTypeBinding) {
			String name = new String(binding.sourceName());
			//always create new TypeReference, because clonning from a cache clones invalid SourcePosition
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(name);
		} else if (binding instanceof WildcardBinding) {
			WildcardBinding wildcardBinding = (WildcardBinding) binding;
			ref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();

			if (wildcardBinding.boundKind == Wildcard.SUPER && ref instanceof CtTypeParameterReference) {
				((CtTypeParameterReference) ref).setUpper(false);
			}

			if (wildcardBinding.bound != null && ref instanceof CtTypeParameterReference) {
				if (bindingCache.containsKey(wildcardBinding.bound)) {
					((CtTypeParameterReference) ref).setBoundingType(getCtCircularTypeReference(wildcardBinding.bound));
				} else {


					((CtTypeParameterReference) ref).setBoundingType(getTypeReference(((WildcardBinding) binding).bound));
				}
			}
		} else if (binding instanceof LocalTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			if (binding.isAnonymousType()) {
				ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));
				ref.setDeclaringType(getTypeReference((binding.enclosingType())));
			} else {
				ref.setSimpleName(new String(binding.sourceName()));
				if (((LocalTypeBinding) binding).enclosingMethod == null && binding.enclosingType() != null && binding.enclosingType() instanceof LocalTypeBinding) {
					ref.setDeclaringType(getTypeReference(binding.enclosingType()));
				} else if (binding.enclosingMethod() != null) {
					ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));
					ref.setDeclaringType(getTypeReference(binding.enclosingType()));
				}
			}
		} else if (binding instanceof SourceTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			if (binding.isAnonymousType()) {
				ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));
				ref.setDeclaringType(getTypeReference((binding.enclosingType())));
			} else {
				ref.setSimpleName(new String(binding.sourceName()));
				if (binding.enclosingType() != null) {
					ref.setDeclaringType(getTypeReference(binding.enclosingType()));
				} else {
					ref.setPackage(getPackageReference(binding.getPackage()));
				}
				// if(((SourceTypeBinding) binding).typeVariables!=null &&
				// ((SourceTypeBinding) binding).typeVariables.length>0){
				// for (TypeBinding b : ((SourceTypeBinding)
				// binding).typeVariables) {
				// ref.getActualTypeArguments().add(getTypeReference(b));
				// }
				// }
			}
		} else if (binding instanceof ArrayBinding) {
			CtArrayTypeReference<Object> arrayref;
			arrayref = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
			ref = arrayref;
			for (int i = 1; i < binding.dimensions(); i++) {
				CtArrayTypeReference<Object> tmp = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
				arrayref.setComponentType(tmp);
				arrayref = tmp;
			}
			arrayref.setComponentType(getTypeReference(binding.leafComponentType()));
		} else if (binding instanceof PolyTypeBinding) {
			// JDT can't resolve the type of this binding and we only have a string.
			// In this case, we return a type Object because we can't know more about it.
			ref = this.jdtTreeBuilder.getFactory().Type().objectType();
		} else if (binding instanceof ProblemReferenceBinding) {
			// Spoon is able to analyze also without the classpath
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(new String(binding.readableName()));
			final CtReference declaring = this.getDeclaringReferenceFromImports(binding.sourceName());
			setPackageOrDeclaringType(ref, declaring);
		} else if (binding instanceof JDTTreeBuilder.SpoonReferenceBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(new String(binding.sourceName()));
			ref.setDeclaringType(getTypeReference(binding.enclosingType()));
		} else if (binding instanceof IntersectionTypeBinding18) {
			List<CtTypeReference<?>> bounds = new ArrayList<>();
			for (ReferenceBinding superInterface : binding.getIntersectingTypes()) {
				bounds.add(getTypeReference(superInterface));
			}
			ref = this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds);
		} else {
			throw new RuntimeException("Unknown TypeBinding: " + binding.getClass() + " " + binding);
		}
		bindingCache.remove(binding);
		this.exploringParameterizedBindings.remove(binding);
		return (CtTypeReference<T>) ref;
	}

	private CtTypeReference<?> getCtCircularTypeReference(TypeBinding b) {
		return bindingCache.get(b).clone();
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(MethodBinding methbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		ref.setSimpleName(new String(methbin.selector));
		ref.setType((CtTypeReference<T>) getTypeReference(methbin.returnType));

		if (methbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(methbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType());
		}
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding varbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (varbin == null) {
			return ref;
		}
		ref.setSimpleName(new String(varbin.name));
		ref.setType(this.<T>getTypeReference(varbin.type));

		if (varbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(varbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType() == null ? null : ref.getType().clone());
		}
		ref.setFinal(varbin.isFinal());
		ref.setStatic((varbin.modifiers & ClassFileConstants.AccStatic) != 0);
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding fieldBinding, char[] tokens) {
		final CtFieldReference<T> ref = getVariableReference(fieldBinding);
		if (fieldBinding != null) {
			return ref;
		}
		ref.setSimpleName(CharOperation.charToString(tokens));
		return ref;
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(VariableBinding varbin) {

		if (varbin instanceof FieldBinding) {
			return getVariableReference((FieldBinding) varbin);
		} else if (varbin instanceof LocalVariableBinding) {
			final LocalVariableBinding localVariableBinding = (LocalVariableBinding) varbin;
			if (localVariableBinding.declaration instanceof Argument && localVariableBinding.declaringScope instanceof MethodScope) {
				CtParameterReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createParameterReference();
				ref.setSimpleName(new String(varbin.name));
				ref.setType((CtTypeReference<T>) getTypeReference(varbin.type));
				final ReferenceContext referenceContext = localVariableBinding.declaringScope.referenceContext();
				return ref;
			} else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {
				CtCatchVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			} else {
				CtLocalVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			}
		} else {
			// unknown VariableBinding, the caller must do something
			return null;
		}
	}

	<T> CtVariableReference<T> getVariableReference(ProblemBinding binding) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (binding == null) {
			return ref;
		}
		ref.setSimpleName(new String(binding.name));
		ref.setType((CtTypeReference<T>) getTypeReference(binding.searchType));
		return ref;
	}

	List<CtTypeReference<?>> getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {
		List<CtTypeReference<?>> res = new ArrayList<>(genericTypeArguments.length);
		for (TypeBinding tb : genericTypeArguments) {
			res.add(getBoundedTypeReference(tb));
		}
		return res;
	}

	/**
	 * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type
	 */
	void setPackageOrDeclaringType(CtTypeReference<?> ref, CtReference declaring) {
		if (declaring instanceof CtPackageReference) {
			ref.setPackage((CtPackageReference) declaring);
		} else if (declaring instanceof CtTypeReference) {
			ref.setDeclaringType((CtTypeReference) declaring);
		} else if (declaring == null) {
			try {
				// sometimes JDT does not provide the information that ref comes from java.lang
				// it seems to occurs in particular with anonymous inner classes: see #1307
				// In that case, we try to load the class to check if it belongs to java.lang
				Class.forName("java.lang." + ref.getSimpleName());
				CtPackageReference javaLangPackageReference = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
				javaLangPackageReference.setSimpleName("java.lang");
				ref.setPackage(javaLangPackageReference);
			} catch (NoClassDefFoundError | ClassNotFoundException e) {
				// in that case we consider the package should be the same as the current one. Fix #1293
				ref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());
			}
		} else {
			throw new AssertionError("unexpected declaring type: " + declaring.getClass() + " of " + declaring);
		}
	}

	/**
	 * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression.
	 * Here, we make the job of JDT and bind their variables accesses to their parameters.
	 *
	 * @param singleNameReference Name of the variable access.
	 * @return executable reference which corresponds to the lambda.
	 */
	public CtExecutableReference<?> getLambdaExecutableReference(SingleNameReference singleNameReference) {
		ASTPair potentialLambda = null;
		for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {
			if (astPair.node instanceof LambdaExpression) {
				potentialLambda = astPair;
				// stop at innermost lambda, fixes #1100
				break;
			}
		}
		if (potentialLambda == null) {
			return null;
		}
		LambdaExpression lambdaJDT = (LambdaExpression) potentialLambda.node;
		for (Argument argument : lambdaJDT.arguments()) {
			if (CharOperation.equals(argument.name, singleNameReference.token)) {
				CtTypeReference<?> declaringType = null;
				if (lambdaJDT.enclosingScope instanceof MethodScope) {
					declaringType = jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());
				}
				CtLambda<?> ctLambda = (CtLambda<?>) potentialLambda.element;
				List<CtTypeReference<?>> parametersType = new ArrayList<>();
				List<CtParameter<?>> parameters = ctLambda.getParameters();
				for (CtParameter<?> parameter : parameters) {
					parametersType.add(parameter.getType() != null
							? parameter.getType().clone()
							// it's the best match :(
							: jdtTreeBuilder.getFactory().Type().OBJECT.clone()
					);
				}
				return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);
			}
		}
		return null;
	}

	public CtModuleReference getModuleReference(ModuleReference moduleReference) {
		String moduleName = new String(moduleReference.moduleName);
		CtModule module = this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);
		if (module == null) {
			CtModuleReference ctModuleReference = this.jdtTreeBuilder.getFactory().Core().createModuleReference();
			ctModuleReference.setSimpleName(moduleName);
			return ctModuleReference;
		} else {
			return module.getReference();
		}
	}
}]
> but was:<...port.compiler.jdt;

[
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.eclipse.jdt.core.compiler.CharOperation;
import org.eclipse.jdt.internal.compiler.Compiler;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
import org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;
import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
import org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.Scope;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
import spoon.reflect.code.CtLambda;
import spoon.reflect.declaration.CtModule;
import spoon.reflect.declaration.CtPackage;
import spoon.reflect.declaration.CtParameter;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.PackageFactory;
import spoon.reflect.factory.TypeFactory;
import spoon.reflect.reference.CtArrayTypeReference;
import spoon.reflect.reference.CtCatchVariableReference;
import spoon.reflect.reference.CtExecutableReference;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtLocalVariableReference;
import spoon.reflect.reference.CtModuleReference;
import spoon.reflect.reference.CtPackageReference;
import spoon.reflect.reference.CtParameterReference;
import spoon.reflect.reference.CtReference;
import spoon.reflect.reference.CtTypeParameterReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.reference.CtVariableReference;
import spoon.support.reflect.CtExtendedModifier;

import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;


public class ReferenceBuilder {

	// Allow to detect circular references and to avoid endless recursivity
	// when resolving parameterizedTypes (e.g. Enum<E extends Enum<E>>)
	private Map<TypeBinding, CtTypeReference> exploringParameterizedBindings = new HashMap<>();

	private boolean bounds = false;

	private final JDTTreeBuilder jdtTreeBuilder;

	ReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {
		this.jdtTreeBuilder = jdtTreeBuilder;
	}

	private CtTypeReference<?> getBoundedTypeReference(TypeBinding binding) {
		bounds = true;
		CtTypeReference<?> ref = getTypeReference(binding);
		bounds = false;
		return ref;
	}

	/**
	 * Builds a type reference from a {@link TypeReference}.
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @param <T>   Type of the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope) {
		return buildTypeReference(type, scope, false);
	}
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<T> typeReference = this.<T>getTypeReference(type.resolvedType, type);
		return buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);
	}

	/**
	 * Builds a qualified type reference from a {@link TypeReference}.
	 *
	 * @param type Qualified type from JDT.
	 * @param scope Scope of the parent element.
	 * @return
	 */
	<T> CtTypeReference<T> buildTypeReference(QualifiedTypeReference type, Scope scope) {
		CtTypeReference<T> accessedType = buildTypeReference((TypeReference) type, scope);
		final TypeBinding receiverType = type != null ? type.resolvedType : null;
		if (receiverType != null) {
			final CtTypeReference<T> ref = getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {
				@Override
				public boolean onAccess(char[][] tokens, int index) {
					return true;
				}
			});
			if (ref != null) {
				accessedType = ref;
			}
		}
		return accessedType;
	}

	/**
	 * Builds a type parameter reference from a {@link TypeReference}
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @return a type parameter reference.
	 */
	private CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {
		if (type == null) {
			return null;
		}
		return (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);
	}


	private <T> CtTypeReference<T> buildTypeReferenceInternal(CtTypeReference<T> typeReference, TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<?> currentReference = typeReference;

		for (int position = type.getTypeName().length - 1; position >= 0; position--) {
			if (currentReference == null) {
				break;
			}
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = isTypeCast;
			this.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = false;
			if (type.annotations != null && type.annotations.length - 1 <= position && type.annotations[position] != null && type.annotations[position].length > 0) {
				for (Annotation annotation : type.annotations[position]) {
					if (scope instanceof ClassScope) {
						annotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);
					} else if (scope instanceof BlockScope) {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);
					} else {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) null);
					}
				}
			}
			if (type.getTypeArguments() != null && type.getTypeArguments().length - 1 <= position && type.getTypeArguments()[position] != null && type.getTypeArguments()[position].length > 0) {
				CtTypeReference<?> componentReference = getTypeReferenceOfArrayComponent(currentReference);
				componentReference.getActualTypeArguments().clear();
				for (TypeReference typeArgument : type.getTypeArguments()[position]) {
					if (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {
						componentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));
					} else {
						componentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));
					}
				}
			} else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)
					&& !isTypeArgumentExplicit(type.getTypeArguments())) {
				for (CtTypeReference<?> actualTypeArgument : currentReference.getActualTypeArguments()) {
					actualTypeArgument.setImplicit(true);
					if (actualTypeArgument instanceof CtArrayTypeReference) {
						((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);
					}
				}
			}
			if (type instanceof Wildcard && typeReference instanceof CtTypeParameterReference) {
				((CtTypeParameterReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));
			}
			this.jdtTreeBuilder.getContextBuilder().exit(type);
			currentReference = currentReference.getDeclaringType();
		}
		return typeReference;
	}

	private CtTypeReference<?> getTypeReferenceOfArrayComponent(CtTypeReference<?> currentReference) {
		while (currentReference instanceof CtArrayTypeReference) {
			currentReference = ((CtArrayTypeReference<?>) currentReference).getComponentType();
		}
		return currentReference;
	}

	private boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {
		if (typeArguments == null) {
			return true;
		}
		boolean isGenericTypeExplicit = true;
		// This loop is necessary because it is the only way to know if the generic type
		// is implicit or not.
		for (TypeReference[] typeArgument : typeArguments) {
			isGenericTypeExplicit = typeArgument != null && typeArgument.length > 0;
			if (isGenericTypeExplicit) {
				break;
			}
		}
		return isGenericTypeExplicit;
	}

	/**
	 * Builds a type reference from a qualified name when a type specified in the name isn't available.
	 *
	 * @param tokens        Qualified name.
	 * @param receiverType  Last type in the qualified name.
	 * @param enclosingType Enclosing type of the type name.
	 * @param listener      Listener to know if we must build the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {
		final List<CtExtendedModifier> listPublicProtected = Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));
		if (enclosingType != null && Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {
			String access = "";
			int i = 0;
			final CompilationUnitDeclaration[] units = ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;
			for (; i < tokens.length; i++) {
				final char[][] qualified = Arrays.copyOfRange(tokens, 0, i + 1);
				if (searchPackage(qualified, units) == null) {
					access = CharOperation.toString(qualified);
					break;
				}
			}
			if (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {
				access = searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);
			}
			final TypeBinding accessBinding = searchTypeBinding(access, units);
			if (accessBinding != null && listener.onAccess(tokens, i)) {
				final TypeBinding superClassBinding = searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));
				if (superClassBinding != null) {
					return this.getTypeReference(superClassBinding.clone(accessBinding));
				} else {
					return this.getTypeReference(receiverType);
				}
			} else {
				return this.getTypeReference(receiverType);
			}
		}
		return null;
	}

	/**
	 * Try to get the declaring reference (package or type) from imports of the current
	 * compilation unit declaration (current class). This method returns a CtReference
	 * which can be a CtTypeReference if it retrieves the information in an static import,
	 * a CtPackageReference if it retrieves the information in an standard import, otherwise
	 * it returns null.
	 *
	 * @param expectedName Name expected in imports.
	 * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.
	 */
	CtReference getDeclaringReferenceFromImports(char[] expectedName) {
		CompilationUnitDeclaration cuDeclaration = this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;
		LookupEnvironment environment = cuDeclaration.scope.environment;

		if (cuDeclaration != null && cuDeclaration.imports != null) {
			for (ImportReference anImport : cuDeclaration.imports) {
				if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {
					if (anImport.isStatic()) {
						int indexDeclaring = 2;
						if ((anImport.bits & ASTNode.OnDemand) != 0) {
							// With .*
							indexDeclaring = 1;
						}
						char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);
						char[][] className = CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));
						PackageBinding aPackage;
						try {
							if (packageName.length != 0) {
								aPackage = environment.createPackage(packageName);
							} else {
								aPackage = null;
							}
							final MissingTypeBinding declaringType = environment.createMissingType(aPackage, className);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = true;
							final CtTypeReference<Object> typeReference = getTypeReference(declaringType);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = false;
							return typeReference;
						} catch (NullPointerException e) {
							return null;
						}

					} else {
						PackageBinding packageBinding = null;
						char[][] chars = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);
						// `findImport(chars, false, false);` and `createPackage(chars)` require
						// an array with a minimum length of 1 and throw an
						// ArrayIndexOutOfBoundsException if `chars.length == 0`. Fixes #759.
						if (chars.length > 0) {
							Binding someBinding = cuDeclaration.scope.findImport(chars, false, false);
							if (someBinding != null && someBinding.isValidBinding() && someBinding instanceof PackageBinding) {
								packageBinding = (PackageBinding) someBinding;
							} else {
								try {
									packageBinding = environment.createPackage(chars);
								} catch (NullPointerException e) {
									packageBinding = null;
								}
							}
						}
						if (packageBinding == null || packageBinding instanceof ProblemPackageBinding) {
							// Big crisis here. We are already in noclasspath mode but JDT doesn't support always
							// creation of a package in this mode. So, if we are in this brace, we make the job of JDT...
							packageBinding = new PackageBinding(chars, null, environment, environment.module);
						}
						return getPackageReference(packageBinding);
					}
				}
			}
		}
		return null;
	}

	@SuppressWarnings("unchecked")
	<T> CtExecutableReference<T> getExecutableReference(MethodBinding exec) {
		if (exec == null) {
			return null;
		}
		final CtExecutableReference ref = this.jdtTreeBuilder.getFactory().Core().createExecutableReference();
		if (exec.isConstructor()) {
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);

			// in case of constructor of an array, it's the return type that we want
			if (exec.returnType instanceof VoidTypeBinding) {
				ref.setType(getTypeReference(exec.declaringClass));
			} else {
				ref.setType(getTypeReference(exec.returnType));
			}
		} else {
			ref.setSimpleName(new String(exec.selector));
			ref.setType(getTypeReference(exec.returnType));
		}
		if (exec instanceof ProblemMethodBinding) {
			if (exec.declaringClass != null && Arrays.asList(exec.declaringClass.methods()).contains(exec)) {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			} else {
				final CtReference declaringType = getDeclaringReferenceFromImports(exec.constantPoolName());
				if (declaringType instanceof CtTypeReference) {
					ref.setDeclaringType((CtTypeReference<?>) declaringType);
				}
			}
			if (exec.isConstructor()) {
				// super() invocation have a good declaring class.
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(true);
		} else {
			if (exec.isConstructor() && !(exec.returnType instanceof VoidTypeBinding)) {
				ref.setDeclaringType(getTypeReference(exec.returnType));
			} else {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(exec.isStatic());
		}

		if (exec.declaringClass instanceof ParameterizedTypeBinding) {
			ref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));
		}

		// original() method returns a result not null when the current method is generic.
		if (exec.original() != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>(exec.original().parameters.length);
			for (TypeBinding b : exec.original().parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		} else if (exec.parameters != null) {
			// This is a method without a generic argument.
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (TypeBinding b : exec.parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}

		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(AllocationExpression allocationExpression) {
		CtExecutableReference<T> ref;
		if (allocationExpression.binding != null) {
			ref = getExecutableReference(allocationExpression.binding);
		} else {
			ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);
			ref.setDeclaringType(getTypeReference(null, allocationExpression.type));

			final List<CtTypeReference<?>> parameters = new ArrayList<>(allocationExpression.argumentTypes.length);
			for (TypeBinding b : allocationExpression.argumentTypes) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}
		if (allocationExpression.type == null) {
			ref.setType(this.<T>getTypeReference(allocationExpression.expectedType()));
		}
		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(MessageSend messageSend) {
		if (messageSend.binding != null) {
			return getExecutableReference(messageSend.binding);
		}
		CtExecutableReference<T> ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
		ref.setSimpleName(CharOperation.charToString(messageSend.selector));
		ref.setType(this.<T>getTypeReference(messageSend.expectedType()));
		if (messageSend.receiver.resolvedType == null) {
			// It is crisis dude! static context, we don't have much more information.
			if (messageSend.receiver instanceof SingleNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());
			} else if (messageSend.receiver instanceof QualifiedNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());
			}
		} else {
			ref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));
		}
		if (messageSend.arguments != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (Expression expression : messageSend.arguments) {
				parameters.add(getTypeReference(expression.resolvedType));
			}
			ref.setParameters(parameters);
		}
		return ref;
	}

	private CtPackageReference getPackageReference(PackageBinding reference) {
		return getPackageReference(new String(reference.shortReadableName()));
	}

	public CtPackageReference getPackageReference(String name) {
		if (name.length() == 0) {
			return this.jdtTreeBuilder.getFactory().Package().topLevel();
		}
		CtPackageReference ref = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
		ref.setSimpleName(name);
		return ref;
	}

	final Map<TypeBinding, CtTypeReference> bindingCache = new HashMap<>();

	<T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<T> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		CtTypeReference<T> result = getTypeReference(ref);
		return result;
	}

	CtTypeReference<Object> getTypeParameterReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<Object> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			if (!(ctRef instanceof CtTypeParameterReference)) {
				CtTypeParameterReference typeParameterRef = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
				typeParameterRef.setSimpleName(ctRef.getSimpleName());
				typeParameterRef.setDeclaringType(ctRef.getDeclaringType());
				typeParameterRef.setPackage(ctRef.getPackage());
				ctRef = typeParameterRef;
			}
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		return getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));
	}

	/**
	 * In no classpath, the model of the super interface isn't always correct.
	 */
	private boolean isCorrectTypeReference(TypeReference ref) {
		if (ref.resolvedType == null) {
			return false;
		}
		if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {
			return true;
		}
		final String[] compoundName = CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);
		final String[] typeName = CharOperation.charArrayToStringArray(ref.getTypeName());
		if (compoundName.length == 0 || typeName.length == 0) {
			return false;
		}
		return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);
	}

	private <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {
		if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
			for (TypeReference[] typeReferences : original.getTypeArguments()) {
				if (typeReferences != null) {
					for (TypeReference typeReference : typeReferences) {
						type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));
					}
				}
			}
		}
	}

	/**
	 * JDT doesn't return a correct AST with the resolved type of the reference.
	 * This method try to build a correct Spoon AST from the name of the JDT
	 * reference, thanks to the parsing of the string, the name parameterized from
	 * the JDT reference and java convention.
	 * Returns a complete Spoon AST when the name is correct, otherwise a spoon type
	 * reference with a name that correspond to the name of the JDT type reference.
	 */
	<T> CtTypeReference<T> getTypeReference(TypeReference ref) {
		if (ref == null) {
			return null;
		}
		CtTypeReference<T> res = null;
		CtTypeReference inner = null;
		final String[] namesParameterized = CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());
		String nameParameterized = CharOperation.toString(ref.getParameterizedTypeName());
		String typeName = CharOperation.toString(ref.getTypeName());

		int index = namesParameterized.length - 1;
		for (; index >= 0; index--) {
			// Start at the end to get the class name first.
			CtTypeReference main = getTypeReference(namesParameterized[index]);
			if (main == null) {
				break;
			}
			if (res == null) {
				res = (CtTypeReference<T>) main;
			} else {
				inner.setDeclaringType((CtTypeReference<?>) main);
			}
			inner = main;
		}
		if (res == null) {
			return this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);
		}

		if (inner.getPackage() == null) {
			PackageFactory packageFactory = this.jdtTreeBuilder.getFactory().Package();
			CtPackageReference packageReference = index >= 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();
			inner.setPackage(packageReference);
		}
		if (!res.toString().replace(", ?", ",?").endsWith(nameParameterized)) {
			// verify that we did not match a class that have the same name in a different package
			return this.jdtTreeBuilder.getFactory().Type().createReference(typeName);
		}
		return res;
	}

	private String concatSubArray(String[] a, int endIndex) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < endIndex; i++) {
			sb.append(a[i]).append('.');
		}
		sb.append(a[endIndex]);
		return sb.toString();
	}

	/**
	 * Try to build a CtTypeReference from a simple name with specified generic types but
	 * returns null if the name doesn't correspond to a type (not start by an upper case).
	 */
	private <T> CtTypeReference<T> getTypeReference(String name) {
		CtTypeReference<T> main = null;
		if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (name.startsWith("?")) {
				main = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			if (m.find()) {
				main.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (Character.isUpperCase(name.charAt(0))) {
			if (name.endsWith("[]")) {
				main = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
				name = name.substring(0, name.length() - 2);
				((CtArrayTypeReference<T>) main).setComponentType(this.getTypeReference(name));
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			main.setSimpleName(name);
			final CtReference declaring = this.getDeclaringReferenceFromImports(name.toCharArray());
			setPackageOrDeclaringType(main, declaring);
		} else if (name.startsWith("?")) {
			return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		}
		return main;
	}

	/**
	 * Try to build a CtTypeParameterReference from a single name with specified generic types but
	 * keep in mind that if you give wrong data in the strong, reference will be wrong.
	 */
	private CtTypeReference<Object> getTypeParameterReference(String name) {
		CtTypeReference<Object> param = null;
		if (name.contains("extends") || name.contains("super")) {
			String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
			param = getTypeParameterReference(split[0].trim());
			((CtTypeParameterReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));
		} else if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (m.find()) {
				param = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
				param.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (name.contains("?")) {
			param = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		} else {
			param = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
			param.setSimpleName(name);
		}
		return param;
	}

	@SuppressWarnings("unchecked")
	<T> CtTypeReference<T> getTypeReference(TypeBinding binding) 

	private CtTypeReference<?> getCtCircularTypeReference(TypeBinding b) {
		return bindingCache.get(b).clone();
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(MethodBinding methbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		ref.setSimpleName(new String(methbin.selector));
		ref.setType((CtTypeReference<T>) getTypeReference(methbin.returnType));

		if (methbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(methbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType());
		}
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding varbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (varbin == null) {
			return ref;
		}
		ref.setSimpleName(new String(varbin.name));
		ref.setType(this.<T>getTypeReference(varbin.type));

		if (varbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(varbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType() == null ? null : ref.getType().clone());
		}
		ref.setFinal(varbin.isFinal());
		ref.setStatic((varbin.modifiers & ClassFileConstants.AccStatic) != 0);
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding fieldBinding, char[] tokens) {
		final CtFieldReference<T> ref = getVariableReference(fieldBinding);
		if (fieldBinding != null) {
			return ref;
		}
		ref.setSimpleName(CharOperation.charToString(tokens));
		return ref;
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(VariableBinding varbin) {

		if (varbin instanceof FieldBinding) {
			return getVariableReference((FieldBinding) varbin);
		} else if (varbin instanceof LocalVariableBinding) {
			final LocalVariableBinding localVariableBinding = (LocalVariableBinding) varbin;
			if (localVariableBinding.declaration instanceof Argument && localVariableBinding.declaringScope instanceof MethodScope) {
				CtParameterReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createParameterReference();
				ref.setSimpleName(new String(varbin.name));
				ref.setType((CtTypeReference<T>) getTypeReference(varbin.type));
				final ReferenceContext referenceContext = localVariableBinding.declaringScope.referenceContext();
				return ref;
			} else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {
				CtCatchVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			} else {
				CtLocalVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			}
		} else {
			// unknown VariableBinding, the caller must do something
			return null;
		}
	}

	<T> CtVariableReference<T> getVariableReference(ProblemBinding binding) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (binding == null) {
			return ref;
		}
		ref.setSimpleName(new String(binding.name));
		ref.setType((CtTypeReference<T>) getTypeReference(binding.searchType));
		return ref;
	}

	List<CtTypeReference<?>> getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {
		List<CtTypeReference<?>> res = new ArrayList<>(genericTypeArguments.length);
		for (TypeBinding tb : genericTypeArguments) {
			res.add(getBoundedTypeReference(tb));
		}
		return res;
	}

	/**
	 * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type
	 */
	void setPackageOrDeclaringType(CtTypeReference<?> ref, CtReference declaring) {
		if (declaring instanceof CtPackageReference) {
			ref.setPackage((CtPackageReference) declaring);
		} else if (declaring instanceof CtTypeReference) {
			ref.setDeclaringType((CtTypeReference) declaring);
		} else if (declaring == null) {
			try {
				// sometimes JDT does not provide the information that ref comes from java.lang
				// it seems to occurs in particular with anonymous inner classes: see #1307
				// In that case, we try to load the class to check if it belongs to java.lang
				Class.forName("java.lang." + ref.getSimpleName());
				CtPackageReference javaLangPackageReference = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
				javaLangPackageReference.setSimpleName("java.lang");
				ref.setPackage(javaLangPackageReference);
			} catch (NoClassDefFoundError | ClassNotFoundException e) {
				// in that case we consider the package should be the same as the current one. Fix #1293
				ref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());
			}
		} else {
			throw new AssertionError("unexpected declaring type: " + declaring.getClass() + " of " + declaring);
		}
	}

	/**
	 * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression.
	 * Here, we make the job of JDT and bind their variables accesses to their parameters.
	 *
	 * @param singleNameReference Name of the variable access.
	 * @return executable reference which corresponds to the lambda.
	 */
	public CtExecutableReference<?> getLambdaExecutableReference(SingleNameReference singleNameReference) {
		ASTPair potentialLambda = null;
		for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {
			if (astPair.node instanceof LambdaExpression) {
				potentialLambda = astPair;
				// stop at innermost lambda, fixes #1100
				break;
			}
		}
		if (potentialLambda == null) {
			return null;
		}
		LambdaExpression lambdaJDT = (LambdaExpression) potentialLambda.node;
		for (Argument argument : lambdaJDT.arguments()) {
			if (CharOperation.equals(argument.name, singleNameReference.token)) {
				CtTypeReference<?> declaringType = null;
				if (lambdaJDT.enclosingScope instanceof MethodScope) {
					declaringType = jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());
				}
				CtLambda<?> ctLambda = (CtLambda<?>) potentialLambda.element;
				List<CtTypeReference<?>> parametersType = new ArrayList<>();
				List<CtParameter<?>> parameters = ctLambda.getParameters();
				for (CtParameter<?> parameter : parameters) {
					parametersType.add(parameter.getType() != null
							? parameter.getType().clone()
							// it's the best match :(
							: jdtTreeBuilder.getFactory().Type().OBJECT.clone()
					);
				}
				return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);
			}
		}
		return null;
	}

	public CtModuleReference getModuleReference(ModuleReference moduleReference) {
		String moduleName = new String(moduleReference.moduleName);
		CtModule module = this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);
		if (module == null) {
			CtModuleReference ctModuleReference = this.jdtTreeBuilder.getFactory().Core().createModuleReference();
			ctModuleReference.setSimpleName(moduleName);
			return ctModuleReference;
		} else {
			return module.getReference();
		}
	}
}
]
>
	at spoon.test.prettyprinter.PrintChangesTest.testPrintChangedReferenceBuilder(PrintChangesTest.java:89)

[ERROR] testPrintChanged(spoon.test.prettyprinter.PrintChangesTest)  Time elapsed: 0.128 s  <<< FAILURE!
org.junit.ComparisonFailure: 
expected:<...inter.testclasses;

[import java.util.ArrayList;
import java.util.List;

/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

//and what about this comment? ]> but was:<...inter.testclasses;

[
import java.util.ArrayList;
import java.util.List;


/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String modified = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

//and what about this comment? 
]>
	at spoon.test.prettyprinter.PrintChangesTest.testPrintChanged(PrintChangesTest.java:63)

[INFO] Running spoon.test.prettyprinter.QualifiedThisRefTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.328 s - in spoon.test.prettyprinter.QualifiedThisRefTest
[INFO] Running spoon.test.prettyprinter.LinesTest
2018-07-03 07:38:11,073 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.Launcher.prettyprint(Launcher.java:786)
	at spoon.Launcher.run(Launcher.java:724)
	at spoon.test.prettyprinter.LinesTest.testIdenticalPrettyPrinter(LinesTest.java:88)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:38:11,076 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.Launcher.prettyprint(Launcher.java:786)
	at spoon.Launcher.run(Launcher.java:724)
	at spoon.test.prettyprinter.LinesTest.testIdenticalPrettyPrinter(LinesTest.java:88)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[ERROR] Tests run: 3, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.684 s <<< FAILURE! - in spoon.test.prettyprinter.LinesTest
[ERROR] testIdenticalPrettyPrinter(spoon.test.prettyprinter.LinesTest)  Time elapsed: 0.283 s  <<< ERROR!
java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
	at spoon.test.prettyprinter.LinesTest.testIdenticalPrettyPrinter(LinesTest.java:102)

[INFO] Running spoon.test.prettyprinter.PrinterTest
[INFO] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.194 s - in spoon.test.prettyprinter.PrinterTest
[INFO] Running spoon.test.prettyprinter.DefaultPrettyPrinterTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.156 s - in spoon.test.prettyprinter.DefaultPrettyPrinterTest
[INFO] Running spoon.test.visitor.AssignmentsEqualsTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.065 s - in spoon.test.visitor.AssignmentsEqualsTest
[INFO] Running spoon.test.visitor.VisitorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.074 s - in spoon.test.visitor.VisitorTest
[INFO] Running spoon.test.loop.LoopTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.163 s - in spoon.test.loop.LoopTest
[INFO] Running spoon.test.intercession.insertBefore.InsertMethodsTest
[INFO] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.504 s - in spoon.test.intercession.insertBefore.InsertMethodsTest
[INFO] Running spoon.test.intercession.OneCanCallSetterWithNullParameterizedTest
[INFO] Tests run: 117, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.936 s - in spoon.test.intercession.OneCanCallSetterWithNullParameterizedTest
[INFO] Running spoon.test.intercession.IntercessionTest
[WARNING] Tests run: 8, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 7.827 s - in spoon.test.intercession.IntercessionTest
[INFO] Running spoon.test.intercession.RemoveTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.078 s - in spoon.test.intercession.RemoveTest
[INFO] Running spoon.test.variable.AccessFullyQualifiedFieldTest
[INFO] Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.317 s - in spoon.test.variable.AccessFullyQualifiedFieldTest
[INFO] Running spoon.test.variable.InferredVariableTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.261 s - in spoon.test.variable.InferredVariableTest
[INFO] Running spoon.test.variable.AccessTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.627 s - in spoon.test.variable.AccessTest
[INFO] Running spoon.test.annotation.AnnotationTest
[INFO] Tests run: 52, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.92 s - in spoon.test.annotation.AnnotationTest
[INFO] Running spoon.test.annotation.AnnotationValuesTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.331 s - in spoon.test.annotation.AnnotationValuesTest
[INFO] Running spoon.test.annotation.AnnotationLoopTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.116 s - in spoon.test.annotation.AnnotationLoopTest
[INFO] Running spoon.test.pkg.PackageTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.522 s - in spoon.test.pkg.PackageTest
[INFO] Running spoon.test.comment.CommentTest
[INFO] Tests run: 19, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 40.958 s - in spoon.test.comment.CommentTest
[INFO] Running spoon.test.sourcePosition.SourcePositionTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.266 s - in spoon.test.sourcePosition.SourcePositionTest
[INFO] Running spoon.test.method.MethodTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.441 s - in spoon.test.method.MethodTest
[INFO] Running spoon.test.position.PositionTest
2018-07-03 07:39:20,796 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:20,799 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:20,800 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:20,801 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClass(PositionTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,396 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:161)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,398 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:161)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,399 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:161)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,400 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionInterface(PositionTest.java:161)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,790 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:76)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,795 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:76)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,798 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:76)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:21,803 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionClassWithComments(PositionTest.java:76)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:22,513 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:195)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:22,515 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:195)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:22,517 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:195)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:22,518 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.testing.utils.ModelUtils.build(ModelUtils.java:101)
	at spoon.test.position.PositionTest.testPositionAnnotation(PositionTest.java:195)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[INFO] Tests run: 24, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.406 s - in spoon.test.position.PositionTest
[INFO] Running spoon.test.position.SourceFragmentTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.124 s - in spoon.test.position.SourceFragmentTest
[INFO] Running spoon.test.initializers.InitializerTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.247 s - in spoon.test.initializers.InitializerTest
[INFO] Running spoon.test.template.PatternTest
[INFO] Tests run: 31, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.625 s - in spoon.test.template.PatternTest
[INFO] Running spoon.test.template.TemplateTest
0
[INFO] Tests run: 24, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.544 s - in spoon.test.template.TemplateTest
[INFO] Running spoon.test.template.TemplateClassAccessTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.122 s - in spoon.test.template.TemplateClassAccessTest
[INFO] Running spoon.test.template.core.ParameterInfoTest
[INFO] Tests run: 21, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.014 s - in spoon.test.template.core.ParameterInfoTest
[INFO] Running spoon.test.template.TemplateEnumAccessTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.187 s - in spoon.test.template.TemplateEnumAccessTest
[INFO] Running spoon.test.template.TemplateArrayAccessTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.208 s - in spoon.test.template.TemplateArrayAccessTest
[INFO] Running spoon.test.template.TemplateInvocationSubstitutionTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.314 s - in spoon.test.template.TemplateInvocationSubstitutionTest
[INFO] Running spoon.test.template.TemplateReplaceReturnTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.468 s - in spoon.test.template.TemplateReplaceReturnTest
[INFO] Running spoon.test.modifiers.TestModifiers
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.805 s - in spoon.test.modifiers.TestModifiers
[INFO] Running spoon.test.ctClass.CtClassTest
2018-07-03 07:39:37,741 ERROR spoon.Launcher - cannot load class: daikon.Runtime
spoon.support.SpoonClassNotFoundException: cannot load class: daikon.Runtime
	at spoon.support.reflect.reference.CtTypeReferenceImpl.findClass(CtTypeReferenceImpl.java:159)
	at spoon.support.reflect.reference.CtTypeReferenceImpl.getActualClass(CtTypeReferenceImpl.java:141)
	at spoon.support.reflect.reference.CtFieldReferenceImpl.getActualField(CtFieldReferenceImpl.java:64)
	at spoon.support.reflect.reference.CtFieldReferenceImpl.getModifiers(CtFieldReferenceImpl.java:228)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.isInitializeStaticFinalField(DefaultJavaPrettyPrinter.java:889)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.printCtFieldAccess(DefaultJavaPrettyPrinter.java:836)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtFieldWrite(DefaultJavaPrettyPrinter.java:795)
	at spoon.support.reflect.code.CtFieldWriteImpl.accept(CtFieldWriteImpl.java:27)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:349)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtAssignment(DefaultJavaPrettyPrinter.java:497)
	at spoon.support.reflect.code.CtAssignmentImpl.accept(CtAssignmentImpl.java:54)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:349)
	at spoon.reflect.visitor.ElementPrinterHelper.writeStatement(ElementPrinterHelper.java:181)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtBlock(DefaultJavaPrettyPrinter.java:529)
	at spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:67)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:349)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtAnonymousExecutable(DefaultJavaPrettyPrinter.java:448)
	at spoon.support.reflect.declaration.CtAnonymousExecutableImpl.accept(CtAnonymousExecutableImpl.java:46)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:349)
	at spoon.reflect.visitor.ElementPrinterHelper.writeElementList(ElementPrinterHelper.java:195)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.visitCtClass(DefaultJavaPrettyPrinter.java:621)
	at spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:67)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.scan(DefaultJavaPrettyPrinter.java:349)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.JavaOutputProcessor.createJavaFile(JavaOutputProcessor.java:118)
	at spoon.support.JavaOutputProcessor.process(JavaOutputProcessor.java:153)
	at spoon.support.JavaOutputProcessor.process(JavaOutputProcessor.java:46)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:74)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:174)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:148)
	at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:650)
	at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:102)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:182)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:174)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:148)
	at spoon.reflect.visitor.CtScanner.visitCtPackage(CtScanner.java:649)
	at spoon.support.reflect.declaration.CtPackageImpl.accept(CtPackageImpl.java:102)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:182)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:174)
	at spoon.reflect.visitor.CtScanner.visitCtModule(CtScanner.java:925)
	at spoon.reflect.factory.ModuleFactory$CtUnnamedModule.accept(ModuleFactory.java:105)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:182)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:124)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingTypes(JDTBasedSpoonCompiler.java:519)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:212)
	at spoon.Launcher.prettyprint(Launcher.java:786)
	at spoon.Launcher.run(Launcher.java:724)
	at spoon.test.ctClass.CtClassTest.testParentOfTheEnclosingClassOfStaticClass(CtClassTest.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
Caused by: java.lang.ClassNotFoundException: daikon.Runtime
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at spoon.support.reflect.reference.CtTypeReferenceImpl.findClass(CtTypeReferenceImpl.java:157)
	... 75 more
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.572 s - in spoon.test.ctClass.CtClassTest
[INFO] Running spoon.test.factory.FactoryTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.345 s - in spoon.test.factory.FactoryTest
[INFO] Running spoon.test.factory.ConstructorFactoryTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.092 s - in spoon.test.factory.ConstructorFactoryTest
[INFO] Running spoon.test.factory.ClassFactoryTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.005 s - in spoon.test.factory.ClassFactoryTest
[INFO] Running spoon.test.factory.CodeFactoryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.factory.CodeFactoryTest
[INFO] Running spoon.test.factory.ExecutableFactoryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.001 s - in spoon.test.factory.ExecutableFactoryTest
[INFO] Running spoon.test.factory.AnnotationFactoryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.106 s - in spoon.test.factory.AnnotationFactoryTest
[INFO] Running spoon.test.factory.TypeFactoryTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.283 s - in spoon.test.factory.TypeFactoryTest
[INFO] Running spoon.test.factory.FieldFactoryTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.256 s - in spoon.test.factory.FieldFactoryTest
[INFO] Running spoon.test.generics.GenericsTest
[INFO] Tests run: 45, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.334 s - in spoon.test.generics.GenericsTest
[INFO] Running spoon.test.trycatch.TryCatchTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.922 s - in spoon.test.trycatch.TryCatchTest
[INFO] Running spoon.test.visibility.VisibilityTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.802 s - in spoon.test.visibility.VisibilityTest
[INFO] Running spoon.test.fieldaccesses.FieldAccessTest
[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.991 s - in spoon.test.fieldaccesses.FieldAccessTest
[INFO] Running spoon.test.staticFieldAccess.StaticAccessTest
2018-07-03 07:39:52,213 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:202)
	at spoon.test.staticFieldAccess.StaticAccessTest.testProcessAndCompile(StaticAccessTest.java:58)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:52,216 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:202)
	at spoon.test.staticFieldAccess.StaticAccessTest.testProcessAndCompile(StaticAccessTest.java:58)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:39:52,218 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:202)
	at spoon.test.staticFieldAccess.StaticAccessTest.testProcessAndCompile(StaticAccessTest.java:58)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.215 s - in spoon.test.staticFieldAccess.StaticAccessTest
[INFO] Running spoon.test.jdtimportbuilder.ImportBuilderTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.665 s - in spoon.test.jdtimportbuilder.ImportBuilderTest
[INFO] Running spoon.test.strings.StringTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.069 s - in spoon.test.strings.StringTest
[INFO] Running spoon.test.strings.StringLiteralTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.067 s - in spoon.test.strings.StringLiteralTest
[INFO] Running spoon.test.processing.ProcessingTest
[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.764 s - in spoon.test.processing.ProcessingTest
[INFO] Running spoon.test.model.IncrementalLauncherTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.817 s - in spoon.test.model.IncrementalLauncherTest
[INFO] Running spoon.test.model.BlockTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.137 s - in spoon.test.model.BlockTest
[INFO] Running spoon.test.model.TypeTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.594 s - in spoon.test.model.TypeTest
[INFO] Running spoon.test.model.SwitchCaseTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.126 s - in spoon.test.model.SwitchCaseTest
[INFO] Running spoon.test.model.AnonymousExecutableTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.295 s - in spoon.test.model.AnonymousExecutableTest
[INFO] Running spoon.test.field.FieldTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.514 s - in spoon.test.field.FieldTest
[INFO] Running spoon.test.lambda.LambdaTest
2018-07-03 07:40:02,082 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable Strings at (/root/workspace/INRIA/spoon/399429949/src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java:6)
[INFO] Tests run: 23, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.83 s - in spoon.test.lambda.LambdaTest
[INFO] Running spoon.test.secondaryclasses.ClassesTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.754 s - in spoon.test.secondaryclasses.ClassesTest
[INFO] Running spoon.test.limits.utils.InternalTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.223 s - in spoon.test.limits.utils.InternalTest
[INFO] Running spoon.test.methodreference.MethodReferenceTest
[INFO] Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.731 s - in spoon.test.methodreference.MethodReferenceTest
[INFO] Running spoon.test.method_overriding.MethodOverriddingTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.245 s - in spoon.test.method_overriding.MethodOverriddingTest
[INFO] Running spoon.test.interfaces.InterfaceTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.453 s - in spoon.test.interfaces.InterfaceTest
[INFO] Running spoon.test.interfaces.TestInterfaceWithoutSetup
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.197 s - in spoon.test.interfaces.TestInterfaceWithoutSetup
[INFO] Running spoon.test.reference.ExecutableReferenceGenericTest
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.808 s - in spoon.test.reference.ExecutableReferenceGenericTest
[INFO] Running spoon.test.reference.ExecutableReferenceTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.757 s - in spoon.test.reference.ExecutableReferenceTest
[INFO] Running spoon.test.reference.TypeReferenceTest
[INFO] Tests run: 28, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.963 s - in spoon.test.reference.TypeReferenceTest
[INFO] Running spoon.test.reference.AnnotationFieldReferenceTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 s - in spoon.test.reference.AnnotationFieldReferenceTest
[INFO] Running spoon.test.reference.ElasticsearchStackoverflowTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.13 s - in spoon.test.reference.ElasticsearchStackoverflowTest
[INFO] Running spoon.test.reference.VariableAccessTest
2018-07-03 07:40:12,242 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable e at (/root/workspace/INRIA/spoon/399429949/src/test/resources/noclasspath/org/elasticsearch/indices/analysis/HunspellService.java:100)
[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.803 s - in spoon.test.reference.VariableAccessTest
[INFO] Running spoon.test.reference.CloneReferenceTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.149 s - in spoon.test.reference.CloneReferenceTest
[INFO] Running spoon.test.labels.TestLabels
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.069 s - in spoon.test.labels.TestLabels
[INFO] Running spoon.test.javadoc.JavaDocTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.154 s - in spoon.test.javadoc.JavaDocTest
[INFO] Running spoon.test.casts.CastTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.348 s - in spoon.test.casts.CastTest
[INFO] Running spoon.test.refactoring.MethodsRefactoringTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.052 s - in spoon.test.refactoring.MethodsRefactoringTest
[INFO] Running spoon.test.refactoring.CtRenameLocalVariableRefactoringTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 18.852 s - in spoon.test.refactoring.CtRenameLocalVariableRefactoringTest
[INFO] Running spoon.test.refactoring.RefactoringTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.938 s - in spoon.test.refactoring.RefactoringTest
[INFO] Running spoon.test.type.TypeTest
[INFO] Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.345 s - in spoon.test.type.TypeTest
[INFO] Running spoon.test.targeted.TargetedExpressionTest
[INFO] Tests run: 17, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.461 s - in spoon.test.targeted.TargetedExpressionTest
[INFO] Running spoon.test.comparison.EqualTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.456 s - in spoon.test.comparison.EqualTest
[INFO] Running spoon.test.properties.PropertiesTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.082 s - in spoon.test.properties.PropertiesTest
[INFO] Running spoon.test.invocations.InvocationTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.3 s - in spoon.test.invocations.InvocationTest
[INFO] Running spoon.test.compilation.CompilationTest
>> Hello: Bar <<
>> Hello: FooEx <<
>> Hello: IBar <<
>> Hello: SimpleProcessor <<
[INFO] Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 7.759 s - in spoon.test.compilation.CompilationTest
[INFO] Running spoon.test.filters.CUFilterTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.192 s - in spoon.test.filters.CUFilterTest
[INFO] Running spoon.test.filters.FilterTest
2018-07-03 07:40:45,793 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:45,794 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:45,796 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:45,797 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:45,797 INFO spoon.Launcher - start processing...
2018-07-03 07:40:45,884 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:45,885 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:46,212 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:46,213 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:46,214 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:46,214 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:46,214 INFO spoon.Launcher - start processing...
2018-07-03 07:40:46,292 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:46,293 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:46,538 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:46,539 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:46,540 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:46,540 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:46,541 INFO spoon.Launcher - start processing...
2018-07-03 07:40:46,614 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:46,614 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:46,984 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:46,984 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:46,985 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:46,986 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:46,986 INFO spoon.Launcher - start processing...
2018-07-03 07:40:47,053 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:47,053 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:47,203 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:47,204 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:47,205 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:47,205 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:47,205 INFO spoon.Launcher - start processing...
2018-07-03 07:40:47,285 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:47,286 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:47,953 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:47,954 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:47,955 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:47,955 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:47,955 INFO spoon.Launcher - start processing...
2018-07-03 07:40:48,031 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:48,031 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:48,103 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:48,103 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:48,471 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:48,471 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:48,472 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:48,472 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:48,473 INFO spoon.Launcher - start processing...
2018-07-03 07:40:48,558 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:48,558 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:48,930 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:48,930 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:48,931 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:48,931 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:48,932 INFO spoon.Launcher - start processing...
2018-07-03 07:40:49,012 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:49,013 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:49,087 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:49,087 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:49,088 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:49,088 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:49,088 INFO spoon.Launcher - start processing...
2018-07-03 07:40:49,170 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:49,171 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:49,378 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:49,379 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:49,380 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:49,380 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:49,380 INFO spoon.Launcher - start processing...
2018-07-03 07:40:49,435 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:49,435 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:49,576 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:49,576 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:49,577 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:49,577 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:49,577 INFO spoon.Launcher - start processing...
2018-07-03 07:40:49,653 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:49,653 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:49,711 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:49,711 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:49,712 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:49,712 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:49,713 INFO spoon.Launcher - start processing...
2018-07-03 07:40:49,781 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:49,781 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:50,349 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:50,350 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:50,351 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:50,351 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:50,352 INFO spoon.Launcher - start processing...
2018-07-03 07:40:50,431 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:50,431 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:50,497 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:50,498 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:50,499 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:50,499 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:50,499 INFO spoon.Launcher - start processing...
2018-07-03 07:40:50,574 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:50,574 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:51,101 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:40:51,102 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:40:51,103 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:40:51,103 INFO spoon.Launcher - running Spoon...
2018-07-03 07:40:51,103 INFO spoon.Launcher - start processing...
2018-07-03 07:40:51,179 INFO spoon.Launcher - end of processing: 
2018-07-03 07:40:51,180 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:40:51,183 INFO spoon.Launcher - Step filter CtClass only) spoon.reflect.CtModelImpl$CtRootPackage cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtRootPackage: unnamed package
2018-07-03 07:40:51,187 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon
2018-07-03 07:40:51,187 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon.test
2018-07-03 07:40:51,188 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon.test.filters
2018-07-03 07:40:51,188 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtPackageImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,188 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,189 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,189 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: AbstractTostada() {
}
2018-07-03 07:40:51,189 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,189 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,190 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.Object()
2018-07-03 07:40:51,190 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-07-03 07:40:51,190 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,190 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-07-03 07:40:51,190 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,191 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            super.prepare();
        }

        @java.lang.Override
        public spoon.test.filters.testclasses.ITostada make() {
            return super.make();
        }
    };
}
2018-07-03 07:40:51,191 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,191 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,191 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,191 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,192 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,192 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,192 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,192 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            super.prepare();
        }

        @java.lang.Override
        public spoon.test.filters.testclasses.ITostada make() {
            return super.make();
        }
    };
}
2018-07-03 07:40:51,192 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        super.prepare();
    }

    @java.lang.Override
    public spoon.test.filters.testclasses.ITostada make() {
        return super.make();
    }
}
2018-07-03 07:40:51,193 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtNewClassImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtNewClassImpl: new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        super.prepare();
    }

    @java.lang.Override
    public spoon.test.filters.testclasses.ITostada make() {
        return super.make();
    }
}
2018-07-03 07:40:51,193 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.AbstractTostada$1()
2018-07-03 07:40:51,194 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada.1
2018-07-03 07:40:51,195 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,195 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,195 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,195 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,195 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,195 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: 1() {
}
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada()
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,196 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,197 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,197 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    super.prepare();
}
2018-07-03 07:40:51,197 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,197 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,197 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,198 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,198 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,198 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,198 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    super.prepare();
}
2018-07-03 07:40:51,198 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.prepare()
2018-07-03 07:40:51,198 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: prepare()
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,199 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,200 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return super.make();
}
2018-07-03 07:40:51,200 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,200 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,200 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,200 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,201 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,201 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,201 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,201 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return super.make();
}
2018-07-03 07:40:51,201 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return super.make()
2018-07-03 07:40:51,201 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.make()
2018-07-03 07:40:51,202 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-07-03 07:40:51,202 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-07-03 07:40:51,202 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,202 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,202 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: make()
2018-07-03 07:40:51,202 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,203 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,203 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,249 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public abstract void prepare();
2018-07-03 07:40:51,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void honey() {
}
2018-07-03 07:40:51,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,250 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Antojito() {
}
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.AbstractTostada()
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,251 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    java.lang.System.out.println("Antojito");
}
2018-07-03 07:40:51,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,252 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    java.lang.System.out.println("Antojito");
}
2018-07-03 07:40:51,253 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("Antojito")
2018-07-03 07:40:51,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-07-03 07:40:51,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-07-03 07:40:51,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-07-03 07:40:51,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-07-03 07:40:51,254 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,255 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "Antojito"
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void prepare(java.lang.String ingredient) {
}
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtParameterImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtParameterImpl: java.lang.String ingredient
2018-07-03 07:40:51,256 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtFieldImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldImpl: private int myfield = 0;
2018-07-03 07:40:51,257 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-07-03 07:40:51,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: FieldAccessFilterTacos() {
    super();
    this.myfield = 0;
}
2018-07-03 07:40:51,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    super();
    this.myfield = 0;
}
2018-07-03 07:40:51,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,258 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.util.ArrayList()
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtAssignmentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAssignmentImpl: this.myfield = 0
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,259 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldWriteImpl: this.myfield
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: this
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: myfield
2018-07-03 07:40:51,260 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 0
2018-07-03 07:40:51,261 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void m() {
    myfield = super.size();
    java.lang.Object o = super.get(myfield);
}
2018-07-03 07:40:51,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,262 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    myfield = super.size();
    java.lang.Object o = super.get(myfield);
}
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtAssignmentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAssignmentImpl: myfield = super.size()
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldWriteImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldWriteImpl: myfield
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: 
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,263 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: myfield
2018-07-03 07:40:51,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,264 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.size()
2018-07-03 07:40:51,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-07-03 07:40:51,268 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-07-03 07:40:51,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: size()
2018-07-03 07:40:51,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,269 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: java.lang.Object o = super.get(myfield)
2018-07-03 07:40:51,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-07-03 07:40:51,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.get(myfield)
2018-07-03 07:40:51,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-07-03 07:40:51,270 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: get(int)
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,271 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: myfield
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtThisAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtThisAccessImpl: 
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,272 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: myfield
2018-07-03 07:40:51,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.FieldAccessFilterTacos
2018-07-03 07:40:51,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
2018-07-03 07:40:51,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtInterfaceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInterfaceImpl: interface Foo {}
2018-07-03 07:40:51,273 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtInterfaceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInterfaceImpl: interface Honey {
    void honey();
}
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: void honey();
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtInterfaceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInterfaceImpl: public interface ITostada extends spoon.test.filters.testclasses.Foo {
    spoon.test.filters.testclasses.ITostada make();
}
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Foo
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: spoon.test.filters.testclasses.ITostada make();
2018-07-03 07:40:51,274 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: SubTostada() {
}
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,275 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada()
2018-07-03 07:40:51,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,276 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    java.lang.System.out.println("SubTostada");
    super.prepare();
}
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,277 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    java.lang.System.out.println("SubTostada");
    super.prepare();
}
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: java.lang.System.out.println("SubTostada")
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtFieldReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReadImpl: java.lang.System.out
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtTypeAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeAccessImpl: java.lang.System
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,278 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtFieldReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtFieldReferenceImpl: java.lang.System.out
2018-07-03 07:40:51,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.System
2018-07-03 07:40:51,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-07-03 07:40:51,279 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-07-03 07:40:51,283 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: println(java.lang.String)
2018-07-03 07:40:51,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.io.PrintStream
2018-07-03 07:40:51,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.io
2018-07-03 07:40:51,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,284 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: "SubTostada"
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.prepare()
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,285 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: prepare()
2018-07-03 07:40:51,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
2018-07-03 07:40:51,286 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Tacos() {
}
2018-07-03 07:40:51,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.lang.Object()
2018-07-03 07:40:51,287 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Object
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return null;
}
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,288 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return null;
}
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return null
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: null
2018-07-03 07:40:51,289 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: <nulltype>
2018-07-03 07:40:51,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void prepare() {
    final java.util.ArrayList<java.lang.String> strings = new java.util.ArrayList<java.lang.String>();
    strings.size();
}
2018-07-03 07:40:51,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    final java.util.ArrayList<java.lang.String> strings = new java.util.ArrayList<java.lang.String>();
    strings.size();
}
2018-07-03 07:40:51,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: final java.util.ArrayList<java.lang.String> strings = new java.util.ArrayList<java.lang.String>()
2018-07-03 07:40:51,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList<java.lang.String>
2018-07-03 07:40:51,290 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtConstructorCallImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorCallImpl: new java.util.ArrayList<java.lang.String>()
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: java.util.ArrayList()
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList<java.lang.String>
2018-07-03 07:40:51,291 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: strings.size()
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtVariableReadImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtVariableReadImpl: strings
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: strings
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList<java.lang.String>
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,292 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: size()
2018-07-03 07:40:51,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.util.ArrayList
2018-07-03 07:40:51,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.util
2018-07-03 07:40:51,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,293 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
2018-07-03 07:40:51,294 INFO spoon.Launcher - Step 6) Skipped element, because CtFunction#accept(input) returned false
Parameter 1) CtMethodImpl: void honey();
2018-07-03 07:40:51,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Honey
2018-07-03 07:40:51,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,294 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: Tostada() {
}
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.AbstractTostada()
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.AbstractTostada
2018-07-03 07:40:51,295 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public spoon.test.filters.testclasses.ITostada make() {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            int a = 3;
            super.prepare();
        }
    };
}
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.ITostada
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,296 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return new spoon.test.filters.testclasses.Tostada() {
        @java.lang.Override
        public void prepare() {
            int a = 3;
            super.prepare();
        }
    };
}
2018-07-03 07:40:51,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        int a = 3;
        super.prepare();
    }
}
2018-07-03 07:40:51,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtNewClassImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtNewClassImpl: new spoon.test.filters.testclasses.Tostada() {
    @java.lang.Override
    public void prepare() {
        int a = 3;
        super.prepare();
    }
}
2018-07-03 07:40:51,297 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada$1()
2018-07-03 07:40:51,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada.1
2018-07-03 07:40:51,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,298 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtConstructorImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtConstructorImpl: 1() {
}
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super()
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: spoon.test.filters.testclasses.Tostada()
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,299 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
    int a = 3;
    super.prepare();
}
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    int a = 3;
    super.prepare();
}
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLocalVariableImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableImpl: int a = 3
2018-07-03 07:40:51,300 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,301 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: 3
2018-07-03 07:40:51,301 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: int
2018-07-03 07:40:51,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtInvocationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtInvocationImpl: super.prepare()
2018-07-03 07:40:51,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtSuperAccessImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtSuperAccessImpl: super
2018-07-03 07:40:51,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtLocalVariableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLocalVariableReferenceImpl: 
2018-07-03 07:40:51,305 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtExecutableReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtExecutableReferenceImpl: prepare()
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: spoon.test.filters.testclasses.Tostada
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: spoon.test.filters.testclasses
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void prepare() {
}
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,306 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public java.lang.String toString() {
    return "";
}
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,307 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
    return "";
}
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtReturnImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtReturnImpl: return ""
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtLiteralImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtLiteralImpl: ""
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.String
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,308 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: @java.lang.Override
public void honey() {
}
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtAnnotationImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtAnnotationImpl: @java.lang.Override
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: java.lang.Override
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtPackageReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtPackageReferenceImpl: java.lang
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.declaration.CtMethodImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtMethodImpl: public void foo() {
}
2018-07-03 07:40:51,309 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.reference.CtTypeReferenceImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtTypeReferenceImpl: void
2018-07-03 07:40:51,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtBlockImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtBlockImpl: {
}
2018-07-03 07:40:51,310 INFO spoon.Launcher - Step filter CtClass only) spoon.support.reflect.code.CtCommentImpl cannot be cast to spoon.reflect.declaration.CtClass
Parameter 1) CtCommentImpl: /**
 * Copyright (C) 2006-2015 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
[INFO] Tests run: 43, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.838 s - in spoon.test.filters.FilterTest
[INFO] Running spoon.test.parent.ContractOnSettersParametrizedTest
[INFO] Tests run: 67, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.98 s - in spoon.test.parent.ContractOnSettersParametrizedTest
[INFO] Running spoon.test.parent.SetParentTest
[INFO] Tests run: 67, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.077 s - in spoon.test.parent.SetParentTest
[INFO] Running spoon.test.parent.NullParentTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.561 s - in spoon.test.parent.NullParentTest
[INFO] Running spoon.test.parent.TopLevelTypeTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.099 s - in spoon.test.parent.TopLevelTypeTest
[INFO] Running spoon.test.parent.ParentTest
[WARNING] Tests run: 11, Failures: 0, Errors: 0, Skipped: 1, Time elapsed: 1.072 s - in spoon.test.parent.ParentTest
[INFO] Running spoon.test.replace.ReplaceParametrizedTest
[INFO] Tests run: 80, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.271 s - in spoon.test.replace.ReplaceParametrizedTest
[INFO] Running spoon.test.replace.ReplaceTest
[INFO] Tests run: 17, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.567 s - in spoon.test.replace.ReplaceTest
[INFO] Running spoon.test.parameters.ParameterTest
2018-07-03 07:40:57,443 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable typeRatingFilters at (/root/workspace/INRIA/spoon/399429949/src/test/resources/noclasspath/Tacos.java:4)
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.274 s - in spoon.test.parameters.ParameterTest
[INFO] Running spoon.test.support.ResourceTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.284 s - in spoon.test.support.ResourceTest
[INFO] Running spoon.test.serializable.SourcePositionTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.044 s - in spoon.test.serializable.SourcePositionTest
[INFO] Running spoon.test.serializable.ModelStreamerTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.788 s - in spoon.test.serializable.ModelStreamerTest
[INFO] Running spoon.test.serializable.SerializableTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.251 s - in spoon.test.serializable.SerializableTest
[INFO] Running spoon.test.eval.EvalTest
[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.312 s - in spoon.test.eval.EvalTest
[INFO] Running spoon.test.ctCase.SwitchCaseTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.127 s - in spoon.test.ctCase.SwitchCaseTest
[INFO] Running spoon.test.executable.ExecutableRefTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.415 s - in spoon.test.executable.ExecutableRefTest
[INFO] Running spoon.test.executable.ExecutableTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.284 s - in spoon.test.executable.ExecutableTest
[INFO] Running spoon.test.main.MainTest
[INFO] Tests run: 15, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 364.044 s - in spoon.test.main.MainTest
[INFO] Running spoon.test.ctType.CtTypeParameterTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.13 s - in spoon.test.ctType.CtTypeParameterTest
[INFO] Running spoon.test.ctType.CtTypeTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.736 s - in spoon.test.ctType.CtTypeTest
[INFO] Running spoon.test.staticFieldAccess2.ImplicitStaticFieldReferenceTest
[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.444 s - in spoon.test.staticFieldAccess2.ImplicitStaticFieldReferenceTest
[INFO] Running spoon.test.enums.EnumsTypeTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.095 s - in spoon.test.enums.EnumsTypeTest
[INFO] Running spoon.test.enums.EnumsTest
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.525 s - in spoon.test.enums.EnumsTest
[INFO] Running spoon.test.compilationunit.TestCompilationUnit
2018-07-03 07:47:11,039 ERROR spoon.Launcher - ChangeCollector was not attached to the Environment
spoon.SpoonException: ChangeCollector was not attached to the Environment
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.getChangeCollector(ChangesAwareDefaultJavaPrettyPrinter.java:61)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scanInternal(ChangesAwareDefaultJavaPrettyPrinter.java:194)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:179)
	at spoon.reflect.visitor.printer.change.ChangesAwareDefaultJavaPrettyPrinter.scan(ChangesAwareDefaultJavaPrettyPrinter.java:38)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.calculate(DefaultJavaPrettyPrinter.java:1954)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.getCompilationUnitInputStream(JDTBasedSpoonCompiler.java:678)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFilesUsingCUs(JDTBasedSpoonCompiler.java:582)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.generateProcessedSourceFiles(JDTBasedSpoonCompiler.java:215)
	at spoon.Launcher.prettyprint(Launcher.java:786)
	at spoon.test.compilationunit.TestCompilationUnit.testAddDeclaredTypeInCU(TestCompilationUnit.java:123)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[ERROR] Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.365 s <<< FAILURE! - in spoon.test.compilationunit.TestCompilationUnit
[ERROR] testAddDeclaredTypeInCU(spoon.test.compilationunit.TestCompilationUnit)  Time elapsed: 0.077 s  <<< FAILURE!
java.lang.AssertionError
	at spoon.test.compilationunit.TestCompilationUnit.testAddDeclaredTypeInCU(TestCompilationUnit.java:129)

[INFO] Running spoon.test.compilationunit.GetBinaryFilesTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.659 s - in spoon.test.compilationunit.GetBinaryFilesTest
[INFO] Running spoon.test.constructorcallnewclass.ConstructorCallTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.478 s - in spoon.test.constructorcallnewclass.ConstructorCallTest
[INFO] Running spoon.test.constructorcallnewclass.NewClassTest
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.877 s - in spoon.test.constructorcallnewclass.NewClassTest
[INFO] Running spoon.test.constructor.ConstructorTest
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.722 s - in spoon.test.constructor.ConstructorTest
[INFO] Running spoon.test.query_function.testclasses.VariableReferencesModelTest
[INFO] Tests run: 15, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 s - in spoon.test.query_function.testclasses.VariableReferencesModelTest
[INFO] Running spoon.test.query_function.VariableReferencesTest
2018-07-03 07:47:14,089 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,089 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,089 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,089 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,090 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,176 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,176 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,227 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,228 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,228 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,228 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,228 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,320 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,321 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,364 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,364 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,365 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,365 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,365 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,446 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,447 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,457 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,457 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,457 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,457 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,458 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,539 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,539 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,580 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,580 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,580 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,580 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,580 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,657 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,657 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,668 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,668 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,669 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,669 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,669 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,739 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,739 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,751 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,751 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,752 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,752 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,752 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,840 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,840 INFO spoon.Launcher - no errors, no warnings
2018-07-03 07:47:14,913 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:14,913 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:14,914 INFO spoon.Launcher - Spoon version 6.3.0-SNAPSHOT
2018-07-03 07:47:14,914 INFO spoon.Launcher - running Spoon...
2018-07-03 07:47:14,914 INFO spoon.Launcher - start processing...
2018-07-03 07:47:14,993 INFO spoon.Launcher - end of processing: 
2018-07-03 07:47:14,993 INFO spoon.Launcher - no errors, no warnings
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.994 s - in spoon.test.query_function.VariableReferencesTest
[INFO] Running spoon.test.control.ControlTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.123 s - in spoon.test.control.ControlTest
[INFO] Running spoon.test.arrays.ArraysTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.685 s - in spoon.test.arrays.ArraysTest
[INFO] Running spoon.test.condition.ConditionalTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.249 s - in spoon.test.condition.ConditionalTest
[INFO] Running spoon.test.delete.DeleteTest
[INFO] Tests run: 14, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.977 s - in spoon.test.delete.DeleteTest
[INFO] Running spoon.test.change.ChangeCollectorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.051 s - in spoon.test.change.ChangeCollectorTest
[INFO] Running spoon.test.jar.JarTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.164 s - in spoon.test.jar.JarTest
[INFO] Running spoon.test.role.TestCtRole
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.002 s - in spoon.test.role.TestCtRole
[INFO] Running spoon.test.literal.LiteralTest
2018-07-03 07:47:17,576 ERROR spoon.support.compiler.jdt.JDTTreeBuilder - Could not find declaration for variable Longs at (/root/workspace/INRIA/spoon/399429949/src/test/resources/noclasspath/SecondaryIndexManager.java:611)
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.863 s - in spoon.test.literal.LiteralTest
[INFO] Running spoon.test.ctBlock.TestCtBlock
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.222 s - in spoon.test.ctBlock.TestCtBlock
[INFO] Running spoon.test.ctElement.MetadataTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.061 s - in spoon.test.ctElement.MetadataTest
[INFO] Running spoon.test.ctElement.ElementTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.ctElement.ElementTest
[INFO] Running spoon.test.path.PathTest
[INFO] Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.681 s - in spoon.test.path.PathTest
[INFO] Running spoon.test.ctBodyHolder.CtBodyHolderTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.528 s - in spoon.test.ctBodyHolder.CtBodyHolderTest
[INFO] Running spoon.test.logging.LogTest
2018-07-03 07:47:19,745 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:19,745 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:19,745 DEBUG spoon.Launcher - destination: /root/workspace/INRIA/spoon/399429949/spooned-classes
2018-07-03 07:47:19,745 DEBUG spoon.Launcher - source classpath: null
2018-07-03 07:47:19,745 DEBUG spoon.Launcher - template classpath: []
2018-07-03 07:47:19,746 INFO spoon.Launcher - Log info
2018-07-03 07:47:19,746 WARN spoon.Launcher - Log warn
2018-07-03 07:47:19,746 ERROR spoon.Launcher - Log error
2018-07-03 07:47:19,746 DEBUG spoon.Launcher - Log debug
2018-07-03 07:47:19,747 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:19,747 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:19,747 DEBUG spoon.Launcher - destination: /root/workspace/INRIA/spoon/399429949/spooned-classes
2018-07-03 07:47:19,748 DEBUG spoon.Launcher - source classpath: null
2018-07-03 07:47:19,748 DEBUG spoon.Launcher - template classpath: []
2018-07-03 07:47:19,748 INFO spoon.Launcher - Log info
2018-07-03 07:47:19,748 WARN spoon.Launcher - Log warn
2018-07-03 07:47:19,748 ERROR spoon.Launcher - Log error
2018-07-03 07:47:19,748 DEBUG spoon.Launcher - Log debug
2018-07-03 07:47:19,749 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:19,749 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:19,750 INFO spoon.Launcher - Log info
2018-07-03 07:47:19,750 WARN spoon.Launcher - Log warn
2018-07-03 07:47:19,750 ERROR spoon.Launcher - Log error
2018-07-03 07:47:19,751 WARN spoon.Launcher - Spoon is now using the 'no classpath mode' by default. If you want to ensure using Spoon in full classpath mode, please use the new flag: --cpmode fullclasspath.
2018-07-03 07:47:19,751 WARN spoon.Launcher - Spoon now parse by default the comments. Consider using the option --disable-comments if you want the old behaviour.
2018-07-03 07:47:19,752 WARN spoon.Launcher - Log warn
2018-07-03 07:47:19,752 ERROR spoon.Launcher - Log error
2018-07-03 07:47:19,753 ERROR spoon.Launcher - Log error
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.012 s - in spoon.test.logging.LogTest
[INFO] Running spoon.test.signature.SignatureTest
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1 s - in spoon.test.signature.SignatureTest
[INFO] Running spoon.test.snippets.SnippetTest
[INFO] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.483 s - in spoon.test.snippets.SnippetTest
[INFO] Running spoon.test.varargs.VarArgsTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.063 s - in spoon.test.varargs.VarArgsTest
[INFO] Running spoon.test.architecture.SpoonArchitectureEnforcerTest
2018-07-03 07:47:53,319 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c2 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:14)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.Launcher.buildModel(Launcher.java:769)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:225)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:47:53,320 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c5 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:17)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.Launcher.buildModel(Launcher.java:769)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:225)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:47:53,321 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - /* c6 */ is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:18)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.Launcher.buildModel(Launcher.java:769)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:225)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
2018-07-03 07:47:53,322 ERROR spoon.support.compiler.jdt.JDTCommentBuilder - // c7 is not added into the AST
spoon.reflect.declaration.ParentNotInitializedException: parent not initialized for class spoon.support.reflect.code.CtCommentImpl (/root/workspace/INRIA/spoon/399429949/src/test/java/spoon/test/position/testclasses/Expressions.java:19)
	at spoon.support.reflect.declaration.CtElementImpl.getParent(CtElementImpl.java:365)
	at spoon.support.compiler.jdt.JDTCommentBuilder.insertCommentInAST(JDTCommentBuilder.java:485)
	at spoon.support.compiler.jdt.JDTCommentBuilder.buildComment(JDTCommentBuilder.java:156)
	at spoon.support.compiler.jdt.JDTCommentBuilder.build(JDTCommentBuilder.java:112)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildModel(JDTBasedSpoonCompiler.java:481)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildUnitsAndModel(JDTBasedSpoonCompiler.java:392)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.buildSources(JDTBasedSpoonCompiler.java:341)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:131)
	at spoon.support.compiler.jdt.JDTBasedSpoonCompiler.build(JDTBasedSpoonCompiler.java:114)
	at spoon.Launcher.buildModel(Launcher.java:769)
	at spoon.test.architecture.SpoonArchitectureEnforcerTest.testGoodTestClassNames(SpoonArchitectureEnforcerTest.java:225)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:365)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:273)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:238)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:159)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:379)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:340)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:125)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:413)
[INFO] Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 42.769 s - in spoon.test.architecture.SpoonArchitectureEnforcerTest
[INFO] Running spoon.test.reflect.visitor.ReferenceQueryTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.071 s - in spoon.test.reflect.visitor.ReferenceQueryTest
[INFO] Running spoon.test.OutputTypeTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.test.OutputTypeTest
[INFO] Running spoon.support.compiler.jdt.JDTBasedSpoonCompilerTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.2 s - in spoon.support.compiler.jdt.JDTBasedSpoonCompilerTest
[INFO] Running spoon.support.compiler.jdt.JDTBatchCompilerTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 s - in spoon.support.compiler.jdt.JDTBatchCompilerTest
[INFO] Running spoon.support.compiler.jdt.JDTBuilderTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.support.compiler.jdt.JDTBuilderTest
[INFO] Running spoon.support.compiler.jdt.ExtendedStringLiteralTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.076 s - in spoon.support.compiler.jdt.ExtendedStringLiteralTest
[INFO] Running spoon.support.compiler.classpath.ComputeClasspathTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 s - in spoon.support.compiler.classpath.ComputeClasspathTest
[INFO] Running spoon.support.visitor.java.JavaReflectionTreeBuilderTest
[INFO] Tests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.89 s - in spoon.support.visitor.java.JavaReflectionTreeBuilderTest
[INFO] Running spoon.reflect.declaration.UnknownDeclarationTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.068 s - in spoon.reflect.declaration.UnknownDeclarationTest
[INFO] Running spoon.reflect.declaration.CtTypeInformationTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.712 s - in spoon.reflect.declaration.CtTypeInformationTest
[INFO] Running spoon.reflect.visitor.CtInheritanceScannerMethodsTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.54 s - in spoon.reflect.visitor.CtInheritanceScannerMethodsTest
[INFO] Running spoon.reflect.visitor.CtVisitorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.473 s - in spoon.reflect.visitor.CtVisitorTest
[INFO] Running spoon.reflect.visitor.CtScannerTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 11.255 s - in spoon.reflect.visitor.CtScannerTest
[INFO] Running spoon.reflect.visitor.CtIteratorTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.295 s - in spoon.reflect.visitor.CtIteratorTest
[INFO] Running spoon.reflect.visitor.CtInheritanceScannerTest
[INFO] Tests run: 82, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.105 s - in spoon.reflect.visitor.CtInheritanceScannerTest
[INFO] Running spoon.reflect.ast.AstCheckerTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 11.457 s - in spoon.reflect.ast.AstCheckerTest
[INFO] Running spoon.reflect.ast.CloneTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 19.428 s - in spoon.reflect.ast.CloneTest
[INFO] Running spoon.testing.AbstractAssertTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.574 s - in spoon.testing.AbstractAssertTest
[INFO] Running spoon.testing.CtPackageAssertTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.235 s - in spoon.testing.CtPackageAssertTest
[INFO] Running spoon.testing.FileAssertTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.302 s - in spoon.testing.FileAssertTest
[INFO] Running spoon.testing.CtElementAssertTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.372 s - in spoon.testing.CtElementAssertTest
[INFO] Running spoon.processing.CtGenerationTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 60.349 s - in spoon.processing.CtGenerationTest
[INFO] Running spoon.processing.ProcessingTest
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.111 s - in spoon.processing.ProcessingTest
[INFO] Running spoon.MavenLauncherTest
2018-07-03 07:49:59,907 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,907 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-cas/3.0.0-SNAPSHOT
2018-07-03 07:49:59,908 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-saml/3.0.0-SNAPSHOT
2018-07-03 07:49:59,908 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:49:59,908 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oidc/3.0.0-SNAPSHOT
2018-07-03 07:49:59,908 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:49:59,908 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-http/3.0.0-SNAPSHOT
2018-07-03 07:49:59,909 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/zaxxer/HikariCP/2.6.1
2018-07-03 07:49:59,909 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:49:59,909 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:49:59,909 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:49:59,909 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,909 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,910 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,910 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:49:59,910 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/unboundid/unboundid-ldapsdk/3.2.1
2018-07-03 07:49:59,910 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:49:59,910 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,910 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-config/3.0.0-SNAPSHOT
2018-07-03 07:49:59,911 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:49:59,911 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-cas/3.0.0-SNAPSHOT
2018-07-03 07:49:59,911 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-openid/3.0.0-SNAPSHOT
2018-07-03 07:49:59,911 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-http/3.0.0-SNAPSHOT
2018-07-03 07:49:59,911 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-saml/3.0.0-SNAPSHOT
2018-07-03 07:49:59,912 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-gae/3.0.0-SNAPSHOT
2018-07-03 07:49:59,912 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oidc/3.0.0-SNAPSHOT
2018-07-03 07:49:59,912 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-jwt/3.0.0-SNAPSHOT
2018-07-03 07:49:59,912 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:49:59,912 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:49:59,913 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-mongo/3.0.0-SNAPSHOT
2018-07-03 07:49:59,913 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-couch/3.0.0-SNAPSHOT
2018-07-03 07:49:59,913 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-kerberos/3.0.0-SNAPSHOT
2018-07-03 07:49:59,913 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/slf4j-api/1.7.25
2018-07-03 07:49:59,913 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,914 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:49:59,914 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:49:59,914 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:49:59,914 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,914 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-test/4.3.7.RELEASE
2018-07-03 07:49:59,915 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.25
2018-07-03 07:49:59,916 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,916 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:49:59,916 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,916 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-cas/3.0.0-SNAPSHOT
2018-07-03 07:49:59,917 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-saml/3.0.0-SNAPSHOT
2018-07-03 07:49:59,917 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:49:59,917 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oidc/3.0.0-SNAPSHOT
2018-07-03 07:49:59,917 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:49:59,918 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-http/3.0.0-SNAPSHOT
2018-07-03 07:49:59,918 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/zaxxer/HikariCP/2.6.1
2018-07-03 07:49:59,918 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:49:59,918 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:49:59,918 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:49:59,918 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,919 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,919 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,919 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:49:59,919 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/unboundid/unboundid-ldapsdk/3.2.1
2018-07-03 07:49:59,919 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:49:59,920 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,920 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-codec/commons-codec/1.10
2018-07-03 07:49:59,920 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/github/scribejava/scribejava-apis/3.3.0
2018-07-03 07:49:59,920 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.8.7
2018-07-03 07:49:59,920 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,921 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,921 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,921 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,921 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,921 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/jasig/cas/client/cas-client-core/3.4.1
2018-07-03 07:49:59,921 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/jasig/cas/client/cas-client-support-saml/3.4.1
2018-07-03 07:49:59,922 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,922 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:49:59,922 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,922 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,922 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,923 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,923 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/openid4java/openid4java/1.0.0
2018-07-03 07:49:59,923 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.25
2018-07-03 07:49:59,923 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/xml-apis/xml-apis/2.0.2
2018-07-03 07:49:59,923 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,924 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,924 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,924 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,924 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,924 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-codec/commons-codec/1.10
2018-07-03 07:49:59,924 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.8.7
2018-07-03 07:49:59,925 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,925 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,925 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,925 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:49:59,925 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:49:59,926 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/nanohttpd/nanohttpd/2.3.1
2018-07-03 07:49:59,926 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,926 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-core/3.3.0
2018-07-03 07:49:59,926 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/net/shibboleth/utilities/java-support/7.3.0
2018-07-03 07:49:59,926 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-saml-api/3.3.0
2018-07-03 07:49:59,927 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-saml-impl/3.3.0
2018-07-03 07:49:59,927 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-soap-api/3.3.0
2018-07-03 07:49:59,927 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-xmlsec-api/3.3.0
2018-07-03 07:49:59,927 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-security-api/3.3.0
2018-07-03 07:49:59,927 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-security-impl/3.3.0
2018-07-03 07:49:59,928 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-profile-api/3.3.0
2018-07-03 07:49:59,928 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-profile-impl/3.3.0
2018-07-03 07:49:59,928 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-messaging-api/3.3.0
2018-07-03 07:49:59,928 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-messaging-impl/3.3.0
2018-07-03 07:49:59,928 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-xmlsec-impl/3.3.0
2018-07-03 07:49:59,928 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:49:59,929 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/cryptacular/cryptacular/1.1.0
2018-07-03 07:49:59,929 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/joda-time/joda-time/2.9.2
2018-07-03 07:49:59,929 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/xalan/xalan/2.7.2
2018-07-03 07:49:59,929 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/velocity/velocity/1.7
2018-07-03 07:49:59,929 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-collections/commons-collections/3.2.2
2018-07-03 07:49:59,929 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.25
2018-07-03 07:49:59,930 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,930 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-core/4.3.7.RELEASE
2018-07-03 07:49:59,930 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,930 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,930 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,931 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-test/4.3.7.RELEASE
2018-07-03 07:49:59,931 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-web/4.3.7.RELEASE
2018-07-03 07:49:59,931 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:49:59,931 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,931 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-api-1.0-sdk/1.9.50
2018-07-03 07:49:59,931 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-jsr107cache/1.9.50
2018-07-03 07:49:59,932 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/net/sf/jsr107cache/jsr107cache/1.1
2018-07-03 07:49:59,932 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,932 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,932 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,932 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,932 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-testing/1.9.50
2018-07-03 07:49:59,933 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-api-labs/1.9.50
2018-07-03 07:49:59,933 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-api-stubs/1.9.50
2018-07-03 07:49:59,933 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,933 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/nimbusds/oauth2-oidc-sdk/5.24.2
2018-07-03 07:49:59,933 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/nimbusds/nimbus-jose-jwt/4.35
2018-07-03 07:49:59,933 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,934 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,934 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,934 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,934 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/nimbusds/nimbus-jose-jwt/4.35
2018-07-03 07:49:59,934 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.56
2018-07-03 07:49:59,935 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,935 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,935 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,935 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:49:59,935 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,935 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/ldaptive/ldaptive/1.2.1
2018-07-03 07:49:59,936 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,936 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,936 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,936 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/unboundid/unboundid-ldapsdk/3.2.1
2018-07-03 07:49:59,936 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,936 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/jdbi/jdbi/2.78
2018-07-03 07:49:59,937 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,937 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,937 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:49:59,937 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/h2database/h2/1.4.194
2018-07-03 07:49:59,937 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,937 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mongodb/mongo-java-driver/3.4.2
2018-07-03 07:49:59,938 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,938 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,938 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,938 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:49:59,938 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/de/flapdoodle/embed/de.flapdoodle.embed.mongo/2.0.0
2018-07-03 07:49:59,939 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,939 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/ektorp/org.ektorp/1.4.4
2018-07-03 07:49:59,939 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.3.3
2018-07-03 07:49:59,939 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,939 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/io/bdrc/mcouch-ektorp/1.0.0
2018-07-03 07:49:59,940 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,940 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,940 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:49:59,940 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,940 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-core/4.3.7.RELEASE
2018-07-03 07:49:59,941 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:49:59,941 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:49:59,941 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:49:59,941 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:49:59,941 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:49:59,941 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/kerby-kdc/1.0.0
2018-07-03 07:49:59,942 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/kerb-simplekdc/1.0.0
2018-07-03 07:49:59,942 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/kerb-client/1.0.0
2018-07-03 07:49:59,942 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/token-provider/1.0.0
2018-07-03 07:49:59,942 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/integration-test/1.0.0
2018-07-03 07:50:00,003 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,004 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-config/3.0.0-SNAPSHOT
2018-07-03 07:50:00,004 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:50:00,004 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-cas/3.0.0-SNAPSHOT
2018-07-03 07:50:00,004 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-openid/3.0.0-SNAPSHOT
2018-07-03 07:50:00,004 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-http/3.0.0-SNAPSHOT
2018-07-03 07:50:00,005 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-saml/3.0.0-SNAPSHOT
2018-07-03 07:50:00,005 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-gae/3.0.0-SNAPSHOT
2018-07-03 07:50:00,005 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oidc/3.0.0-SNAPSHOT
2018-07-03 07:50:00,005 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-jwt/3.0.0-SNAPSHOT
2018-07-03 07:50:00,005 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:50:00,006 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:50:00,006 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-mongo/3.0.0-SNAPSHOT
2018-07-03 07:50:00,006 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-couch/3.0.0-SNAPSHOT
2018-07-03 07:50:00,006 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-kerberos/3.0.0-SNAPSHOT
2018-07-03 07:50:00,006 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/slf4j-api/1.7.25
2018-07-03 07:50:00,006 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,007 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:50:00,007 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:50:00,007 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:50:00,007 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,007 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-test/4.3.7.RELEASE
2018-07-03 07:50:00,014 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.25
2018-07-03 07:50:00,014 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,015 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:50:00,015 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,015 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-cas/3.0.0-SNAPSHOT
2018-07-03 07:50:00,015 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-saml/3.0.0-SNAPSHOT
2018-07-03 07:50:00,015 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:50:00,015 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oidc/3.0.0-SNAPSHOT
2018-07-03 07:50:00,016 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:50:00,016 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-http/3.0.0-SNAPSHOT
2018-07-03 07:50:00,016 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/zaxxer/HikariCP/2.6.1
2018-07-03 07:50:00,016 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:50:00,016 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:50:00,016 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:50:00,017 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,017 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,017 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,017 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-ldap/3.0.0-SNAPSHOT
2018-07-03 07:50:00,017 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/unboundid/unboundid-ldapsdk/3.2.1
2018-07-03 07:50:00,017 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-sql/3.0.0-SNAPSHOT
2018-07-03 07:50:00,018 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,018 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-codec/commons-codec/1.10
2018-07-03 07:50:00,018 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/github/scribejava/scribejava-apis/3.3.0
2018-07-03 07:50:00,018 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.8.7
2018-07-03 07:50:00,018 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,018 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,019 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,019 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,019 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,022 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/jasig/cas/client/cas-client-core/3.4.1
2018-07-03 07:50:00,022 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/jasig/cas/client/cas-client-support-saml/3.4.1
2018-07-03 07:50:00,022 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,023 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:50:00,023 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,023 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,023 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,023 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,023 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/openid4java/openid4java/1.0.0
2018-07-03 07:50:00,024 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.25
2018-07-03 07:50:00,024 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/xml-apis/xml-apis/2.0.2
2018-07-03 07:50:00,024 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,024 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,024 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,024 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,025 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,025 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-codec/commons-codec/1.10
2018-07-03 07:50:00,025 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.8.7
2018-07-03 07:50:00,025 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,025 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,026 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,026 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:50:00,026 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:50:00,026 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/nanohttpd/nanohttpd/2.3.1
2018-07-03 07:50:00,026 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,026 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-core/3.3.0
2018-07-03 07:50:00,027 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/net/shibboleth/utilities/java-support/7.3.0
2018-07-03 07:50:00,027 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-saml-api/3.3.0
2018-07-03 07:50:00,027 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-saml-impl/3.3.0
2018-07-03 07:50:00,027 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-soap-api/3.3.0
2018-07-03 07:50:00,027 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-xmlsec-api/3.3.0
2018-07-03 07:50:00,027 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-security-api/3.3.0
2018-07-03 07:50:00,028 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-security-impl/3.3.0
2018-07-03 07:50:00,028 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-profile-api/3.3.0
2018-07-03 07:50:00,028 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-profile-impl/3.3.0
2018-07-03 07:50:00,028 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-messaging-api/3.3.0
2018-07-03 07:50:00,028 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-messaging-impl/3.3.0
2018-07-03 07:50:00,028 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/opensaml/opensaml-xmlsec-impl/3.3.0
2018-07-03 07:50:00,029 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/guava/guava/21.0
2018-07-03 07:50:00,029 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/cryptacular/cryptacular/1.1.0
2018-07-03 07:50:00,029 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/joda-time/joda-time/2.9.2
2018-07-03 07:50:00,029 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/xalan/xalan/2.7.2
2018-07-03 07:50:00,029 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/velocity/velocity/1.7
2018-07-03 07:50:00,030 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-collections/commons-collections/3.2.2
2018-07-03 07:50:00,030 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.25
2018-07-03 07:50:00,030 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,030 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-core/4.3.7.RELEASE
2018-07-03 07:50:00,030 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,031 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,031 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,031 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-test/4.3.7.RELEASE
2018-07-03 07:50:00,031 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-web/4.3.7.RELEASE
2018-07-03 07:50:00,031 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:50:00,031 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-api-1.0-sdk/1.9.50
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-jsr107cache/1.9.50
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/net/sf/jsr107cache/jsr107cache/1.1
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,032 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,033 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-testing/1.9.50
2018-07-03 07:50:00,033 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-api-labs/1.9.50
2018-07-03 07:50:00,033 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/google/appengine/appengine-api-stubs/1.9.50
2018-07-03 07:50:00,033 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,033 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/nimbusds/oauth2-oidc-sdk/5.24.2
2018-07-03 07:50:00,033 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/nimbusds/nimbus-jose-jwt/4.35
2018-07-03 07:50:00,034 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,034 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,034 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,034 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,034 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/nimbusds/nimbus-jose-jwt/4.35
2018-07-03 07:50:00,034 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.56
2018-07-03 07:50:00,035 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,035 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,035 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,035 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-oauth/3.0.0-SNAPSHOT
2018-07-03 07:50:00,035 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,035 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/ldaptive/ldaptive/1.2.1
2018-07-03 07:50:00,036 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,036 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,036 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,036 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/unboundid/unboundid-ldapsdk/3.2.1
2018-07-03 07:50:00,036 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,036 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/jdbi/jdbi/2.78
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/security/spring-security-crypto/4.2.2.RELEASE
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/h2database/h2/1.4.194
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mongodb/mongo-java-driver/3.4.2
2018-07-03 07:50:00,037 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,038 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,038 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,038 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:50:00,038 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/de/flapdoodle/embed/de.flapdoodle.embed.mongo/2.0.0
2018-07-03 07:50:00,038 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,038 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/ektorp/org.ektorp/1.4.4
2018-07-03 07:50:00,039 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.3.3
2018-07-03 07:50:00,039 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,039 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/io/bdrc/mcouch-ektorp/1.0.0
2018-07-03 07:50:00,039 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,039 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/shiro/shiro-core/1.3.2
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/springframework/spring-core/4.3.7.RELEASE
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/pac4j/pac4j-core/3.0.0-SNAPSHOT
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/junit/junit/4.12
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/ch/qos/logback/logback-classic/1.2.2
2018-07-03 07:50:00,040 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/mockito/mockito-core/2.7.19
2018-07-03 07:50:00,041 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/javax/servlet/javax.servlet-api/3.1.0
2018-07-03 07:50:00,041 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/kerby-kdc/1.0.0
2018-07-03 07:50:00,041 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/kerb-simplekdc/1.0.0
2018-07-03 07:50:00,041 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/kerb-client/1.0.0
2018-07-03 07:50:00,041 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/token-provider/1.0.0
2018-07-03 07:50:00,041 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/kerby/integration-test/1.0.0
2018-07-03 07:50:00,130 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/eclipse/jdt/org.eclipse.jdt.core/3.13.102
2018-07-03 07:50:00,130 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/martiansoftware/jsap/2.1
2018-07-03 07:50:00,131 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/log4j/log4j/1.2.17
2018-07-03 07:50:00,131 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/commons-io/commons-io/2.5
2018-07-03 07:50:00,131 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/maven/maven-model/3.3.9
2018-07-03 07:50:00,131 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/org/apache/commons/commons-lang3/3.5
2018-07-03 07:50:00,131 ERROR spoon.Launcher - Dependency not found at /root/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.9.2
[ERROR] Tests run: 6, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.315 s <<< FAILURE! - in spoon.MavenLauncherTest
[ERROR] mavenLauncherTestMultiModulesAndVariables(spoon.MavenLauncherTest)  Time elapsed: 0.123 s  <<< FAILURE!
java.lang.AssertionError: Content of classpath: 
	at spoon.MavenLauncherTest.mavenLauncherTestMultiModulesAndVariables(MavenLauncherTest.java:76)

[ERROR] spoonMavenLauncherTest(spoon.MavenLauncherTest)  Time elapsed: 0.089 s  <<< FAILURE!
java.lang.AssertionError: expected:<23> but was:<0>
	at spoon.MavenLauncherTest.spoonMavenLauncherTest(MavenLauncherTest.java:20)

[INFO] Running spoon.LauncherTest
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.298 s - in spoon.LauncherTest
[INFO] 
[INFO] Results:
[INFO] 
[ERROR] Failures: 
[ERROR]   MavenLauncherTest.mavenLauncherTestMultiModulesAndVariables:76 Content of classpath: 
[ERROR]   MavenLauncherTest.spoonMavenLauncherTest:20 expected:<23> but was:<0>
[ERROR]   TestCompilationUnit.testAddDeclaredTypeInCU:129
[ERROR]   ImportTest.testmportInCu:1010
[ERROR]   PrintChangesTest.testPrintChanged:63 expected:<...inter.testclasses;

[import java.util.ArrayList;
import java.util.List;

/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

//and what about this comment? ]> but was:<...inter.testclasses;

[
import java.util.ArrayList;
import java.util.List;


/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String modified = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

//and what about this comment? 
]>
[ERROR]   PrintChangesTest.testPrintChangedReferenceBuilder:89 expected:<...port.compiler.jdt;

[import org.eclipse.jdt.core.compiler.CharOperation;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
import org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;
import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.Scope;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
import spoon.reflect.code.CtLambda;
import spoon.reflect.declaration.CtModule;
import spoon.reflect.declaration.CtPackage;
import spoon.reflect.declaration.CtParameter;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.PackageFactory;
import spoon.reflect.reference.CtArrayTypeReference;
import spoon.reflect.reference.CtCatchVariableReference;
import spoon.reflect.reference.CtExecutableReference;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtLocalVariableReference;
import spoon.reflect.reference.CtModuleReference;
import spoon.reflect.reference.CtPackageReference;
import spoon.reflect.reference.CtParameterReference;
import spoon.reflect.reference.CtReference;
import spoon.reflect.reference.CtTypeParameterReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.reference.CtVariableReference;
import spoon.support.reflect.CtExtendedModifier;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;

public class ReferenceBuilder {

	// Allow to detect circular references and to avoid endless recursivity
	// when resolving parameterizedTypes (e.g. Enum<E extends Enum<E>>)
	private Map<TypeBinding, CtTypeReference> exploringParameterizedBindings = new HashMap<>();

	private boolean bounds = false;

	private final JDTTreeBuilder jdtTreeBuilder;

	ReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {
		this.jdtTreeBuilder = jdtTreeBuilder;
	}

	private CtTypeReference<?> getBoundedTypeReference(TypeBinding binding) {
		bounds = true;
		CtTypeReference<?> ref = getTypeReference(binding);
		bounds = false;
		return ref;
	}

	/**
	 * Builds a type reference from a {@link TypeReference}.
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @param <T>   Type of the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope) {
		return buildTypeReference(type, scope, false);
	}
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<T> typeReference = this.<T>getTypeReference(type.resolvedType, type);
		return buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);
	}

	/**
	 * Builds a qualified type reference from a {@link TypeReference}.
	 *
	 * @param type Qualified type from JDT.
	 * @param scope Scope of the parent element.
	 * @return
	 */
	<T> CtTypeReference<T> buildTypeReference(QualifiedTypeReference type, Scope scope) {
		CtTypeReference<T> accessedType = buildTypeReference((TypeReference) type, scope);
		final TypeBinding receiverType = type != null ? type.resolvedType : null;
		if (receiverType != null) {
			final CtTypeReference<T> ref = getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {
				@Override
				public boolean onAccess(char[][] tokens, int index) {
					return true;
				}
			});
			if (ref != null) {
				accessedType = ref;
			}
		}
		return accessedType;
	}

	/**
	 * Builds a type parameter reference from a {@link TypeReference}
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @return a type parameter reference.
	 */
	private CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {
		if (type == null) {
			return null;
		}
		return (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);
	}


	private <T> CtTypeReference<T> buildTypeReferenceInternal(CtTypeReference<T> typeReference, TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<?> currentReference = typeReference;

		for (int position = type.getTypeName().length - 1; position >= 0; position--) {
			if (currentReference == null) {
				break;
			}
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = isTypeCast;
			this.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = false;
			if (type.annotations != null && type.annotations.length - 1 <= position && type.annotations[position] != null && type.annotations[position].length > 0) {
				for (Annotation annotation : type.annotations[position]) {
					if (scope instanceof ClassScope) {
						annotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);
					} else if (scope instanceof BlockScope) {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);
					} else {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) null);
					}
				}
			}
			if (type.getTypeArguments() != null && type.getTypeArguments().length - 1 <= position && type.getTypeArguments()[position] != null && type.getTypeArguments()[position].length > 0) {
				CtTypeReference<?> componentReference = getTypeReferenceOfArrayComponent(currentReference);
				componentReference.getActualTypeArguments().clear();
				for (TypeReference typeArgument : type.getTypeArguments()[position]) {
					if (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {
						componentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));
					} else {
						componentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));
					}
				}
			} else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)
					&& !isTypeArgumentExplicit(type.getTypeArguments())) {
				for (CtTypeReference<?> actualTypeArgument : currentReference.getActualTypeArguments()) {
					actualTypeArgument.setImplicit(true);
					if (actualTypeArgument instanceof CtArrayTypeReference) {
						((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);
					}
				}
			}
			if (type instanceof Wildcard && typeReference instanceof CtTypeParameterReference) {
				((CtTypeParameterReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));
			}
			this.jdtTreeBuilder.getContextBuilder().exit(type);
			currentReference = currentReference.getDeclaringType();
		}
		return typeReference;
	}

	private CtTypeReference<?> getTypeReferenceOfArrayComponent(CtTypeReference<?> currentReference) {
		while (currentReference instanceof CtArrayTypeReference) {
			currentReference = ((CtArrayTypeReference<?>) currentReference).getComponentType();
		}
		return currentReference;
	}

	private boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {
		if (typeArguments == null) {
			return true;
		}
		boolean isGenericTypeExplicit = true;
		// This loop is necessary because it is the only way to know if the generic type
		// is implicit or not.
		for (TypeReference[] typeArgument : typeArguments) {
			isGenericTypeExplicit = typeArgument != null && typeArgument.length > 0;
			if (isGenericTypeExplicit) {
				break;
			}
		}
		return isGenericTypeExplicit;
	}

	/**
	 * Builds a type reference from a qualified name when a type specified in the name isn't available.
	 *
	 * @param tokens        Qualified name.
	 * @param receiverType  Last type in the qualified name.
	 * @param enclosingType Enclosing type of the type name.
	 * @param listener      Listener to know if we must build the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {
		final List<CtExtendedModifier> listPublicProtected = Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));
		if (enclosingType != null && Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {
			String access = "";
			int i = 0;
			final CompilationUnitDeclaration[] units = ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;
			for (; i < tokens.length; i++) {
				final char[][] qualified = Arrays.copyOfRange(tokens, 0, i + 1);
				if (searchPackage(qualified, units) == null) {
					access = CharOperation.toString(qualified);
					break;
				}
			}
			if (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {
				access = searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);
			}
			final TypeBinding accessBinding = searchTypeBinding(access, units);
			if (accessBinding != null && listener.onAccess(tokens, i)) {
				final TypeBinding superClassBinding = searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));
				if (superClassBinding != null) {
					return this.getTypeReference(superClassBinding.clone(accessBinding));
				} else {
					return this.getTypeReference(receiverType);
				}
			} else {
				return this.getTypeReference(receiverType);
			}
		}
		return null;
	}

	/**
	 * Try to get the declaring reference (package or type) from imports of the current
	 * compilation unit declaration (current class). This method returns a CtReference
	 * which can be a CtTypeReference if it retrieves the information in an static import,
	 * a CtPackageReference if it retrieves the information in an standard import, otherwise
	 * it returns null.
	 *
	 * @param expectedName Name expected in imports.
	 * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.
	 */
	CtReference getDeclaringReferenceFromImports(char[] expectedName) {
		CompilationUnitDeclaration cuDeclaration = this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;
		LookupEnvironment environment = cuDeclaration.scope.environment;

		if (cuDeclaration != null && cuDeclaration.imports != null) {
			for (ImportReference anImport : cuDeclaration.imports) {
				if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {
					if (anImport.isStatic()) {
						int indexDeclaring = 2;
						if ((anImport.bits & ASTNode.OnDemand) != 0) {
							// With .*
							indexDeclaring = 1;
						}
						char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);
						char[][] className = CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));
						PackageBinding aPackage;
						try {
							if (packageName.length != 0) {
								aPackage = environment.createPackage(packageName);
							} else {
								aPackage = null;
							}
							final MissingTypeBinding declaringType = environment.createMissingType(aPackage, className);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = true;
							final CtTypeReference<Object> typeReference = getTypeReference(declaringType);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = false;
							return typeReference;
						} catch (NullPointerException e) {
							return null;
						}

					} else {
						PackageBinding packageBinding = null;
						char[][] chars = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);
						// `findImport(chars, false, false);` and `createPackage(chars)` require
						// an array with a minimum length of 1 and throw an
						// ArrayIndexOutOfBoundsException if `chars.length == 0`. Fixes #759.
						if (chars.length > 0) {
							Binding someBinding = cuDeclaration.scope.findImport(chars, false, false);
							if (someBinding != null && someBinding.isValidBinding() && someBinding instanceof PackageBinding) {
								packageBinding = (PackageBinding) someBinding;
							} else {
								try {
									packageBinding = environment.createPackage(chars);
								} catch (NullPointerException e) {
									packageBinding = null;
								}
							}
						}
						if (packageBinding == null || packageBinding instanceof ProblemPackageBinding) {
							// Big crisis here. We are already in noclasspath mode but JDT doesn't support always
							// creation of a package in this mode. So, if we are in this brace, we make the job of JDT...
							packageBinding = new PackageBinding(chars, null, environment, environment.module);
						}
						return getPackageReference(packageBinding);
					}
				}
			}
		}
		return null;
	}

	@SuppressWarnings("unchecked")
	<T> CtExecutableReference<T> getExecutableReference(MethodBinding exec) {
		if (exec == null) {
			return null;
		}
		final CtExecutableReference ref = this.jdtTreeBuilder.getFactory().Core().createExecutableReference();
		if (exec.isConstructor()) {
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);

			// in case of constructor of an array, it's the return type that we want
			if (exec.returnType instanceof VoidTypeBinding) {
				ref.setType(getTypeReference(exec.declaringClass));
			} else {
				ref.setType(getTypeReference(exec.returnType));
			}
		} else {
			ref.setSimpleName(new String(exec.selector));
			ref.setType(getTypeReference(exec.returnType));
		}
		if (exec instanceof ProblemMethodBinding) {
			if (exec.declaringClass != null && Arrays.asList(exec.declaringClass.methods()).contains(exec)) {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			} else {
				final CtReference declaringType = getDeclaringReferenceFromImports(exec.constantPoolName());
				if (declaringType instanceof CtTypeReference) {
					ref.setDeclaringType((CtTypeReference<?>) declaringType);
				}
			}
			if (exec.isConstructor()) {
				// super() invocation have a good declaring class.
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(true);
		} else {
			if (exec.isConstructor() && !(exec.returnType instanceof VoidTypeBinding)) {
				ref.setDeclaringType(getTypeReference(exec.returnType));
			} else {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(exec.isStatic());
		}

		if (exec.declaringClass instanceof ParameterizedTypeBinding) {
			ref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));
		}

		// original() method returns a result not null when the current method is generic.
		if (exec.original() != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>(exec.original().parameters.length);
			for (TypeBinding b : exec.original().parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		} else if (exec.parameters != null) {
			// This is a method without a generic argument.
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (TypeBinding b : exec.parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}

		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(AllocationExpression allocationExpression) {
		CtExecutableReference<T> ref;
		if (allocationExpression.binding != null) {
			ref = getExecutableReference(allocationExpression.binding);
		} else {
			ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);
			ref.setDeclaringType(getTypeReference(null, allocationExpression.type));

			final List<CtTypeReference<?>> parameters = new ArrayList<>(allocationExpression.argumentTypes.length);
			for (TypeBinding b : allocationExpression.argumentTypes) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}
		if (allocationExpression.type == null) {
			ref.setType(this.<T>getTypeReference(allocationExpression.expectedType()));
		}
		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(MessageSend messageSend) {
		if (messageSend.binding != null) {
			return getExecutableReference(messageSend.binding);
		}
		CtExecutableReference<T> ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
		ref.setSimpleName(CharOperation.charToString(messageSend.selector));
		ref.setType(this.<T>getTypeReference(messageSend.expectedType()));
		if (messageSend.receiver.resolvedType == null) {
			// It is crisis dude! static context, we don't have much more information.
			if (messageSend.receiver instanceof SingleNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());
			} else if (messageSend.receiver instanceof QualifiedNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());
			}
		} else {
			ref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));
		}
		if (messageSend.arguments != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (Expression expression : messageSend.arguments) {
				parameters.add(getTypeReference(expression.resolvedType));
			}
			ref.setParameters(parameters);
		}
		return ref;
	}

	private CtPackageReference getPackageReference(PackageBinding reference) {
		return getPackageReference(new String(reference.shortReadableName()));
	}

	public CtPackageReference getPackageReference(String name) {
		if (name.length() == 0) {
			return this.jdtTreeBuilder.getFactory().Package().topLevel();
		}
		CtPackageReference ref = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
		ref.setSimpleName(name);
		return ref;
	}

	final Map<TypeBinding, CtTypeReference> bindingCache = new HashMap<>();

	<T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<T> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		CtTypeReference<T> result = getTypeReference(ref);
		return result;
	}

	CtTypeReference<Object> getTypeParameterReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<Object> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			if (!(ctRef instanceof CtTypeParameterReference)) {
				CtTypeParameterReference typeParameterRef = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
				typeParameterRef.setSimpleName(ctRef.getSimpleName());
				typeParameterRef.setDeclaringType(ctRef.getDeclaringType());
				typeParameterRef.setPackage(ctRef.getPackage());
				ctRef = typeParameterRef;
			}
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		return getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));
	}

	/**
	 * In no classpath, the model of the super interface isn't always correct.
	 */
	private boolean isCorrectTypeReference(TypeReference ref) {
		if (ref.resolvedType == null) {
			return false;
		}
		if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {
			return true;
		}
		final String[] compoundName = CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);
		final String[] typeName = CharOperation.charArrayToStringArray(ref.getTypeName());
		if (compoundName.length == 0 || typeName.length == 0) {
			return false;
		}
		return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);
	}

	private <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {
		if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
			for (TypeReference[] typeReferences : original.getTypeArguments()) {
				if (typeReferences != null) {
					for (TypeReference typeReference : typeReferences) {
						type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));
					}
				}
			}
		}
	}

	/**
	 * JDT doesn't return a correct AST with the resolved type of the reference.
	 * This method try to build a correct Spoon AST from the name of the JDT
	 * reference, thanks to the parsing of the string, the name parameterized from
	 * the JDT reference and java convention.
	 * Returns a complete Spoon AST when the name is correct, otherwise a spoon type
	 * reference with a name that correspond to the name of the JDT type reference.
	 */
	<T> CtTypeReference<T> getTypeReference(TypeReference ref) {
		if (ref == null) {
			return null;
		}
		CtTypeReference<T> res = null;
		CtTypeReference inner = null;
		final String[] namesParameterized = CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());
		String nameParameterized = CharOperation.toString(ref.getParameterizedTypeName());
		String typeName = CharOperation.toString(ref.getTypeName());

		int index = namesParameterized.length - 1;
		for (; index >= 0; index--) {
			// Start at the end to get the class name first.
			CtTypeReference main = getTypeReference(namesParameterized[index]);
			if (main == null) {
				break;
			}
			if (res == null) {
				res = (CtTypeReference<T>) main;
			} else {
				inner.setDeclaringType((CtTypeReference<?>) main);
			}
			inner = main;
		}
		if (res == null) {
			return this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);
		}

		if (inner.getPackage() == null) {
			PackageFactory packageFactory = this.jdtTreeBuilder.getFactory().Package();
			CtPackageReference packageReference = index >= 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();
			inner.setPackage(packageReference);
		}
		if (!res.toString().replace(", ?", ",?").endsWith(nameParameterized)) {
			// verify that we did not match a class that have the same name in a different package
			return this.jdtTreeBuilder.getFactory().Type().createReference(typeName);
		}
		return res;
	}

	private String concatSubArray(String[] a, int endIndex) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < endIndex; i++) {
			sb.append(a[i]).append('.');
		}
		sb.append(a[endIndex]);
		return sb.toString();
	}

	/**
	 * Try to build a CtTypeReference from a simple name with specified generic types but
	 * returns null if the name doesn't correspond to a type (not start by an upper case).
	 */
	private <T> CtTypeReference<T> getTypeReference(String name) {
		CtTypeReference<T> main = null;
		if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (name.startsWith("?")) {
				main = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			if (m.find()) {
				main.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (Character.isUpperCase(name.charAt(0))) {
			if (name.endsWith("[]")) {
				main = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
				name = name.substring(0, name.length() - 2);
				((CtArrayTypeReference<T>) main).setComponentType(this.getTypeReference(name));
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			main.setSimpleName(name);
			final CtReference declaring = this.getDeclaringReferenceFromImports(name.toCharArray());
			setPackageOrDeclaringType(main, declaring);
		} else if (name.startsWith("?")) {
			return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		}
		return main;
	}

	/**
	 * Try to build a CtTypeParameterReference from a single name with specified generic types but
	 * keep in mind that if you give wrong data in the strong, reference will be wrong.
	 */
	private CtTypeReference<Object> getTypeParameterReference(String name) {
		CtTypeReference<Object> param = null;
		if (name.contains("extends") || name.contains("super")) {
			String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
			param = getTypeParameterReference(split[0].trim());
			((CtTypeParameterReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));
		} else if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (m.find()) {
				param = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
				param.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (name.contains("?")) {
			param = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		} else {
			param = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
			param.setSimpleName(name);
		}
		return param;
	}

	@SuppressWarnings("unchecked")
	<T> CtTypeReference<T> getTypeReference(TypeBinding binding) {
		if (binding == null) {
			return null;
		}

		CtTypeReference<?> ref = null;

		if (binding instanceof RawTypeBinding) {
			ref = getTypeReference(((ParameterizedTypeBinding) binding).genericType());
		} else if (binding instanceof ParameterizedTypeBinding) {
			if (binding.actualType() != null && binding.actualType() instanceof LocalTypeBinding) {
				// When we define a nested class in a method and when the enclosing class of this method
				// is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class
				// and hide the real class in actualType().
				ref = getTypeReference(binding.actualType());
			} else {
				ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
				this.exploringParameterizedBindings.put(binding, ref);
				if (binding.isAnonymousType()) {
					ref.setSimpleName("");
				} else {
					ref.setSimpleName(String.valueOf(binding.sourceName()));
					if (binding.enclosingType() != null) {
						ref.setDeclaringType(getTypeReference(binding.enclosingType()));
					} else {
						ref.setPackage(getPackageReference(binding.getPackage()));
					}
				}
			}
			if (binding.actualType() instanceof MissingTypeBinding) {
				ref = getTypeReference(binding.actualType());
			}

			if (((ParameterizedTypeBinding) binding).arguments != null) {
				for (TypeBinding b : ((ParameterizedTypeBinding) binding).arguments) {
					if (bindingCache.containsKey(b)) {
						ref.addActualTypeArgument(getCtCircularTypeReference(b));
					} else {
						if (!this.exploringParameterizedBindings.containsKey(b)) {
							this.exploringParameterizedBindings.put(b, null);
							CtTypeReference typeRefB = getTypeReference(b);
							this.exploringParameterizedBindings.put(b, typeRefB);
							ref.addActualTypeArgument(typeRefB);
						} else {
							CtTypeReference typeRefB = this.exploringParameterizedBindings.get(b);
							if (typeRefB != null) {
								ref.addActualTypeArgument(typeRefB.clone());
							}
						}
					}
				}
			}
		} else if (binding instanceof MissingTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(new String(binding.sourceName()));
			ref.setPackage(getPackageReference(binding.getPackage()));
			if (!this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports) {
				final CtReference declaring = this.getDeclaringReferenceFromImports(binding.sourceName());
				if (declaring instanceof CtPackageReference) {
					ref.setPackage((CtPackageReference) declaring);
				} else if (declaring instanceof CtTypeReference) {
					ref.setDeclaringType((CtTypeReference) declaring);
				}
			}
		} else if (binding instanceof BinaryTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			if (binding.enclosingType() != null) {
				ref.setDeclaringType(getTypeReference(binding.enclosingType()));
			} else {
				ref.setPackage(getPackageReference(binding.getPackage()));
			}
			ref.setSimpleName(new String(binding.sourceName()));
		} else if (binding instanceof TypeVariableBinding) {
			boolean oldBounds = bounds;

			if (binding instanceof CaptureBinding) {
				ref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
				bounds = true;
			} else {
				TypeVariableBinding typeParamBinding = (TypeVariableBinding) binding;
				ReferenceBinding superClass = typeParamBinding.superclass;
				ReferenceBinding[] superInterfaces = typeParamBinding.superInterfaces();

				CtTypeReference refSuperClass = null;

				// if the type parameter has a super class other than java.lang.Object, we get it
				// superClass.superclass() is null if it's java.lang.Object
				if (superClass != null && !(superClass.superclass() == null)) {

					// this case could happen with Enum<E extends Enum<E>> for example:
					// in that case we only want to have E -> Enum -> E
					// to conserve the same behavior as JavaReflectionTreeBuilder
					if (!(superClass instanceof ParameterizedTypeBinding) || !this.exploringParameterizedBindings.containsKey(superClass)) {
						refSuperClass = this.getTypeReference(superClass);
					}

				// if the type parameter has a super interface, then we'll get it too, as a superclass
				// type parameter can only extends an interface or a class, so we don't make the distinction
				// in Spoon. Moreover we can only have one extends in a type parameter.
				} else if (superInterfaces != null && superInterfaces.length == 1) {
					refSuperClass = this.getTypeReference(superInterfaces[0]);
				}

				ref = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
				ref.setSimpleName(new String(binding.sourceName()));

				if (refSuperClass != null) {
					((CtTypeParameterReference) ref).addBound(refSuperClass);
				}
			}
			TypeVariableBinding b = (TypeVariableBinding) binding;
			if (bounds) {
				if (b instanceof CaptureBinding && ((CaptureBinding) b).wildcard != null) {
					bounds = oldBounds;
					return getTypeReference(((CaptureBinding) b).wildcard);
				} else if (b.superclass != null && b.firstBound == b.superclass) {
					bounds = false;
					bindingCache.put(binding, ref);
					((CtTypeParameterReference) ref).setBoundingType(getTypeReference(b.superclass));
					bounds = oldBounds;
				}
			}
			if (bounds && b.superInterfaces != null && b.superInterfaces != Binding.NO_SUPERINTERFACES) {
				bounds = false;
				bindingCache.put(binding, ref);
				List<CtTypeReference<?>> bounds = new ArrayList<>();
				CtTypeParameterReference typeParameterReference = (CtTypeParameterReference) ref;
				if (!(typeParameterReference.isDefaultBoundingType())) { // if it's object we can ignore it
					bounds.add(typeParameterReference.getBoundingType());
				}
				for (ReferenceBinding superInterface : b.superInterfaces) {
					bounds.add(getTypeReference(superInterface));
				}
				((CtTypeParameterReference) ref).setBoundingType(this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds));
			}
			if (binding instanceof CaptureBinding) {
				bounds = false;
			}
		} else if (binding instanceof BaseTypeBinding) {
			String name = new String(binding.sourceName());
			//always create new TypeReference, because clonning from a cache clones invalid SourcePosition
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(name);
		} else if (binding instanceof WildcardBinding) {
			WildcardBinding wildcardBinding = (WildcardBinding) binding;
			ref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();

			if (wildcardBinding.boundKind == Wildcard.SUPER && ref instanceof CtTypeParameterReference) {
				((CtTypeParameterReference) ref).setUpper(false);
			}

			if (wildcardBinding.bound != null && ref instanceof CtTypeParameterReference) {
				if (bindingCache.containsKey(wildcardBinding.bound)) {
					((CtTypeParameterReference) ref).setBoundingType(getCtCircularTypeReference(wildcardBinding.bound));
				} else {


					((CtTypeParameterReference) ref).setBoundingType(getTypeReference(((WildcardBinding) binding).bound));
				}
			}
		} else if (binding instanceof LocalTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			if (binding.isAnonymousType()) {
				ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));
				ref.setDeclaringType(getTypeReference((binding.enclosingType())));
			} else {
				ref.setSimpleName(new String(binding.sourceName()));
				if (((LocalTypeBinding) binding).enclosingMethod == null && binding.enclosingType() != null && binding.enclosingType() instanceof LocalTypeBinding) {
					ref.setDeclaringType(getTypeReference(binding.enclosingType()));
				} else if (binding.enclosingMethod() != null) {
					ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));
					ref.setDeclaringType(getTypeReference(binding.enclosingType()));
				}
			}
		} else if (binding instanceof SourceTypeBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			if (binding.isAnonymousType()) {
				ref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));
				ref.setDeclaringType(getTypeReference((binding.enclosingType())));
			} else {
				ref.setSimpleName(new String(binding.sourceName()));
				if (binding.enclosingType() != null) {
					ref.setDeclaringType(getTypeReference(binding.enclosingType()));
				} else {
					ref.setPackage(getPackageReference(binding.getPackage()));
				}
				// if(((SourceTypeBinding) binding).typeVariables!=null &&
				// ((SourceTypeBinding) binding).typeVariables.length>0){
				// for (TypeBinding b : ((SourceTypeBinding)
				// binding).typeVariables) {
				// ref.getActualTypeArguments().add(getTypeReference(b));
				// }
				// }
			}
		} else if (binding instanceof ArrayBinding) {
			CtArrayTypeReference<Object> arrayref;
			arrayref = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
			ref = arrayref;
			for (int i = 1; i < binding.dimensions(); i++) {
				CtArrayTypeReference<Object> tmp = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
				arrayref.setComponentType(tmp);
				arrayref = tmp;
			}
			arrayref.setComponentType(getTypeReference(binding.leafComponentType()));
		} else if (binding instanceof PolyTypeBinding) {
			// JDT can't resolve the type of this binding and we only have a string.
			// In this case, we return a type Object because we can't know more about it.
			ref = this.jdtTreeBuilder.getFactory().Type().objectType();
		} else if (binding instanceof ProblemReferenceBinding) {
			// Spoon is able to analyze also without the classpath
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(new String(binding.readableName()));
			final CtReference declaring = this.getDeclaringReferenceFromImports(binding.sourceName());
			setPackageOrDeclaringType(ref, declaring);
		} else if (binding instanceof JDTTreeBuilder.SpoonReferenceBinding) {
			ref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			ref.setSimpleName(new String(binding.sourceName()));
			ref.setDeclaringType(getTypeReference(binding.enclosingType()));
		} else if (binding instanceof IntersectionTypeBinding18) {
			List<CtTypeReference<?>> bounds = new ArrayList<>();
			for (ReferenceBinding superInterface : binding.getIntersectingTypes()) {
				bounds.add(getTypeReference(superInterface));
			}
			ref = this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds);
		} else {
			throw new RuntimeException("Unknown TypeBinding: " + binding.getClass() + " " + binding);
		}
		bindingCache.remove(binding);
		this.exploringParameterizedBindings.remove(binding);
		return (CtTypeReference<T>) ref;
	}

	private CtTypeReference<?> getCtCircularTypeReference(TypeBinding b) {
		return bindingCache.get(b).clone();
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(MethodBinding methbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		ref.setSimpleName(new String(methbin.selector));
		ref.setType((CtTypeReference<T>) getTypeReference(methbin.returnType));

		if (methbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(methbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType());
		}
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding varbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (varbin == null) {
			return ref;
		}
		ref.setSimpleName(new String(varbin.name));
		ref.setType(this.<T>getTypeReference(varbin.type));

		if (varbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(varbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType() == null ? null : ref.getType().clone());
		}
		ref.setFinal(varbin.isFinal());
		ref.setStatic((varbin.modifiers & ClassFileConstants.AccStatic) != 0);
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding fieldBinding, char[] tokens) {
		final CtFieldReference<T> ref = getVariableReference(fieldBinding);
		if (fieldBinding != null) {
			return ref;
		}
		ref.setSimpleName(CharOperation.charToString(tokens));
		return ref;
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(VariableBinding varbin) {

		if (varbin instanceof FieldBinding) {
			return getVariableReference((FieldBinding) varbin);
		} else if (varbin instanceof LocalVariableBinding) {
			final LocalVariableBinding localVariableBinding = (LocalVariableBinding) varbin;
			if (localVariableBinding.declaration instanceof Argument && localVariableBinding.declaringScope instanceof MethodScope) {
				CtParameterReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createParameterReference();
				ref.setSimpleName(new String(varbin.name));
				ref.setType((CtTypeReference<T>) getTypeReference(varbin.type));
				final ReferenceContext referenceContext = localVariableBinding.declaringScope.referenceContext();
				return ref;
			} else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {
				CtCatchVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			} else {
				CtLocalVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			}
		} else {
			// unknown VariableBinding, the caller must do something
			return null;
		}
	}

	<T> CtVariableReference<T> getVariableReference(ProblemBinding binding) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (binding == null) {
			return ref;
		}
		ref.setSimpleName(new String(binding.name));
		ref.setType((CtTypeReference<T>) getTypeReference(binding.searchType));
		return ref;
	}

	List<CtTypeReference<?>> getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {
		List<CtTypeReference<?>> res = new ArrayList<>(genericTypeArguments.length);
		for (TypeBinding tb : genericTypeArguments) {
			res.add(getBoundedTypeReference(tb));
		}
		return res;
	}

	/**
	 * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type
	 */
	void setPackageOrDeclaringType(CtTypeReference<?> ref, CtReference declaring) {
		if (declaring instanceof CtPackageReference) {
			ref.setPackage((CtPackageReference) declaring);
		} else if (declaring instanceof CtTypeReference) {
			ref.setDeclaringType((CtTypeReference) declaring);
		} else if (declaring == null) {
			try {
				// sometimes JDT does not provide the information that ref comes from java.lang
				// it seems to occurs in particular with anonymous inner classes: see #1307
				// In that case, we try to load the class to check if it belongs to java.lang
				Class.forName("java.lang." + ref.getSimpleName());
				CtPackageReference javaLangPackageReference = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
				javaLangPackageReference.setSimpleName("java.lang");
				ref.setPackage(javaLangPackageReference);
			} catch (NoClassDefFoundError | ClassNotFoundException e) {
				// in that case we consider the package should be the same as the current one. Fix #1293
				ref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());
			}
		} else {
			throw new AssertionError("unexpected declaring type: " + declaring.getClass() + " of " + declaring);
		}
	}

	/**
	 * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression.
	 * Here, we make the job of JDT and bind their variables accesses to their parameters.
	 *
	 * @param singleNameReference Name of the variable access.
	 * @return executable reference which corresponds to the lambda.
	 */
	public CtExecutableReference<?> getLambdaExecutableReference(SingleNameReference singleNameReference) {
		ASTPair potentialLambda = null;
		for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {
			if (astPair.node instanceof LambdaExpression) {
				potentialLambda = astPair;
				// stop at innermost lambda, fixes #1100
				break;
			}
		}
		if (potentialLambda == null) {
			return null;
		}
		LambdaExpression lambdaJDT = (LambdaExpression) potentialLambda.node;
		for (Argument argument : lambdaJDT.arguments()) {
			if (CharOperation.equals(argument.name, singleNameReference.token)) {
				CtTypeReference<?> declaringType = null;
				if (lambdaJDT.enclosingScope instanceof MethodScope) {
					declaringType = jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());
				}
				CtLambda<?> ctLambda = (CtLambda<?>) potentialLambda.element;
				List<CtTypeReference<?>> parametersType = new ArrayList<>();
				List<CtParameter<?>> parameters = ctLambda.getParameters();
				for (CtParameter<?> parameter : parameters) {
					parametersType.add(parameter.getType() != null
							? parameter.getType().clone()
							// it's the best match :(
							: jdtTreeBuilder.getFactory().Type().OBJECT.clone()
					);
				}
				return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);
			}
		}
		return null;
	}

	public CtModuleReference getModuleReference(ModuleReference moduleReference) {
		String moduleName = new String(moduleReference.moduleName);
		CtModule module = this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);
		if (module == null) {
			CtModuleReference ctModuleReference = this.jdtTreeBuilder.getFactory().Core().createModuleReference();
			ctModuleReference.setSimpleName(moduleName);
			return ctModuleReference;
		} else {
			return module.getReference();
		}
	}
}]
> but was:<...port.compiler.jdt;

[
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.eclipse.jdt.core.compiler.CharOperation;
import org.eclipse.jdt.internal.compiler.Compiler;
import org.eclipse.jdt.internal.compiler.ast.ASTNode;
import org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;
import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
import org.eclipse.jdt.internal.compiler.ast.Annotation;
import org.eclipse.jdt.internal.compiler.ast.Argument;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;
import org.eclipse.jdt.internal.compiler.ast.ImportReference;
import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.ast.ModuleReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;
import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;
import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;
import org.eclipse.jdt.internal.compiler.ast.TypeReference;
import org.eclipse.jdt.internal.compiler.ast.Wildcard;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
import org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.Binding;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
import org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;
import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
import org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;
import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
import org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;
import org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;
import org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
import org.eclipse.jdt.internal.compiler.lookup.Scope;
import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
import org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;
import org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;
import spoon.reflect.code.CtLambda;
import spoon.reflect.declaration.CtModule;
import spoon.reflect.declaration.CtPackage;
import spoon.reflect.declaration.CtParameter;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.PackageFactory;
import spoon.reflect.factory.TypeFactory;
import spoon.reflect.reference.CtArrayTypeReference;
import spoon.reflect.reference.CtCatchVariableReference;
import spoon.reflect.reference.CtExecutableReference;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtLocalVariableReference;
import spoon.reflect.reference.CtModuleReference;
import spoon.reflect.reference.CtPackageReference;
import spoon.reflect.reference.CtParameterReference;
import spoon.reflect.reference.CtReference;
import spoon.reflect.reference.CtTypeParameterReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.reference.CtVariableReference;
import spoon.support.reflect.CtExtendedModifier;

import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;
import static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;


public class ReferenceBuilder {

	// Allow to detect circular references and to avoid endless recursivity
	// when resolving parameterizedTypes (e.g. Enum<E extends Enum<E>>)
	private Map<TypeBinding, CtTypeReference> exploringParameterizedBindings = new HashMap<>();

	private boolean bounds = false;

	private final JDTTreeBuilder jdtTreeBuilder;

	ReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {
		this.jdtTreeBuilder = jdtTreeBuilder;
	}

	private CtTypeReference<?> getBoundedTypeReference(TypeBinding binding) {
		bounds = true;
		CtTypeReference<?> ref = getTypeReference(binding);
		bounds = false;
		return ref;
	}

	/**
	 * Builds a type reference from a {@link TypeReference}.
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @param <T>   Type of the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope) {
		return buildTypeReference(type, scope, false);
	}
	<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<T> typeReference = this.<T>getTypeReference(type.resolvedType, type);
		return buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);
	}

	/**
	 * Builds a qualified type reference from a {@link TypeReference}.
	 *
	 * @param type Qualified type from JDT.
	 * @param scope Scope of the parent element.
	 * @return
	 */
	<T> CtTypeReference<T> buildTypeReference(QualifiedTypeReference type, Scope scope) {
		CtTypeReference<T> accessedType = buildTypeReference((TypeReference) type, scope);
		final TypeBinding receiverType = type != null ? type.resolvedType : null;
		if (receiverType != null) {
			final CtTypeReference<T> ref = getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {
				@Override
				public boolean onAccess(char[][] tokens, int index) {
					return true;
				}
			});
			if (ref != null) {
				accessedType = ref;
			}
		}
		return accessedType;
	}

	/**
	 * Builds a type parameter reference from a {@link TypeReference}
	 *
	 * @param type  Type from JDT.
	 * @param scope Scope of the parent element.
	 * @return a type parameter reference.
	 */
	private CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {
		if (type == null) {
			return null;
		}
		return (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);
	}


	private <T> CtTypeReference<T> buildTypeReferenceInternal(CtTypeReference<T> typeReference, TypeReference type, Scope scope, boolean isTypeCast) {
		if (type == null) {
			return null;
		}
		CtTypeReference<?> currentReference = typeReference;

		for (int position = type.getTypeName().length - 1; position >= 0; position--) {
			if (currentReference == null) {
				break;
			}
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = isTypeCast;
			this.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);
			this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = false;
			if (type.annotations != null && type.annotations.length - 1 <= position && type.annotations[position] != null && type.annotations[position].length > 0) {
				for (Annotation annotation : type.annotations[position]) {
					if (scope instanceof ClassScope) {
						annotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);
					} else if (scope instanceof BlockScope) {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);
					} else {
						annotation.traverse(this.jdtTreeBuilder, (BlockScope) null);
					}
				}
			}
			if (type.getTypeArguments() != null && type.getTypeArguments().length - 1 <= position && type.getTypeArguments()[position] != null && type.getTypeArguments()[position].length > 0) {
				CtTypeReference<?> componentReference = getTypeReferenceOfArrayComponent(currentReference);
				componentReference.getActualTypeArguments().clear();
				for (TypeReference typeArgument : type.getTypeArguments()[position]) {
					if (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {
						componentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));
					} else {
						componentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));
					}
				}
			} else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)
					&& !isTypeArgumentExplicit(type.getTypeArguments())) {
				for (CtTypeReference<?> actualTypeArgument : currentReference.getActualTypeArguments()) {
					actualTypeArgument.setImplicit(true);
					if (actualTypeArgument instanceof CtArrayTypeReference) {
						((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);
					}
				}
			}
			if (type instanceof Wildcard && typeReference instanceof CtTypeParameterReference) {
				((CtTypeParameterReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));
			}
			this.jdtTreeBuilder.getContextBuilder().exit(type);
			currentReference = currentReference.getDeclaringType();
		}
		return typeReference;
	}

	private CtTypeReference<?> getTypeReferenceOfArrayComponent(CtTypeReference<?> currentReference) {
		while (currentReference instanceof CtArrayTypeReference) {
			currentReference = ((CtArrayTypeReference<?>) currentReference).getComponentType();
		}
		return currentReference;
	}

	private boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {
		if (typeArguments == null) {
			return true;
		}
		boolean isGenericTypeExplicit = true;
		// This loop is necessary because it is the only way to know if the generic type
		// is implicit or not.
		for (TypeReference[] typeArgument : typeArguments) {
			isGenericTypeExplicit = typeArgument != null && typeArgument.length > 0;
			if (isGenericTypeExplicit) {
				break;
			}
		}
		return isGenericTypeExplicit;
	}

	/**
	 * Builds a type reference from a qualified name when a type specified in the name isn't available.
	 *
	 * @param tokens        Qualified name.
	 * @param receiverType  Last type in the qualified name.
	 * @param enclosingType Enclosing type of the type name.
	 * @param listener      Listener to know if we must build the type reference.
	 * @return a type reference.
	 */
	<T> CtTypeReference<T> getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {
		final List<CtExtendedModifier> listPublicProtected = Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));
		if (enclosingType != null && Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {
			String access = "";
			int i = 0;
			final CompilationUnitDeclaration[] units = ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;
			for (; i < tokens.length; i++) {
				final char[][] qualified = Arrays.copyOfRange(tokens, 0, i + 1);
				if (searchPackage(qualified, units) == null) {
					access = CharOperation.toString(qualified);
					break;
				}
			}
			if (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {
				access = searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);
			}
			final TypeBinding accessBinding = searchTypeBinding(access, units);
			if (accessBinding != null && listener.onAccess(tokens, i)) {
				final TypeBinding superClassBinding = searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));
				if (superClassBinding != null) {
					return this.getTypeReference(superClassBinding.clone(accessBinding));
				} else {
					return this.getTypeReference(receiverType);
				}
			} else {
				return this.getTypeReference(receiverType);
			}
		}
		return null;
	}

	/**
	 * Try to get the declaring reference (package or type) from imports of the current
	 * compilation unit declaration (current class). This method returns a CtReference
	 * which can be a CtTypeReference if it retrieves the information in an static import,
	 * a CtPackageReference if it retrieves the information in an standard import, otherwise
	 * it returns null.
	 *
	 * @param expectedName Name expected in imports.
	 * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.
	 */
	CtReference getDeclaringReferenceFromImports(char[] expectedName) {
		CompilationUnitDeclaration cuDeclaration = this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;
		LookupEnvironment environment = cuDeclaration.scope.environment;

		if (cuDeclaration != null && cuDeclaration.imports != null) {
			for (ImportReference anImport : cuDeclaration.imports) {
				if (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {
					if (anImport.isStatic()) {
						int indexDeclaring = 2;
						if ((anImport.bits & ASTNode.OnDemand) != 0) {
							// With .*
							indexDeclaring = 1;
						}
						char[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);
						char[][] className = CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));
						PackageBinding aPackage;
						try {
							if (packageName.length != 0) {
								aPackage = environment.createPackage(packageName);
							} else {
								aPackage = null;
							}
							final MissingTypeBinding declaringType = environment.createMissingType(aPackage, className);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = true;
							final CtTypeReference<Object> typeReference = getTypeReference(declaringType);
							this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = false;
							return typeReference;
						} catch (NullPointerException e) {
							return null;
						}

					} else {
						PackageBinding packageBinding = null;
						char[][] chars = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);
						// `findImport(chars, false, false);` and `createPackage(chars)` require
						// an array with a minimum length of 1 and throw an
						// ArrayIndexOutOfBoundsException if `chars.length == 0`. Fixes #759.
						if (chars.length > 0) {
							Binding someBinding = cuDeclaration.scope.findImport(chars, false, false);
							if (someBinding != null && someBinding.isValidBinding() && someBinding instanceof PackageBinding) {
								packageBinding = (PackageBinding) someBinding;
							} else {
								try {
									packageBinding = environment.createPackage(chars);
								} catch (NullPointerException e) {
									packageBinding = null;
								}
							}
						}
						if (packageBinding == null || packageBinding instanceof ProblemPackageBinding) {
							// Big crisis here. We are already in noclasspath mode but JDT doesn't support always
							// creation of a package in this mode. So, if we are in this brace, we make the job of JDT...
							packageBinding = new PackageBinding(chars, null, environment, environment.module);
						}
						return getPackageReference(packageBinding);
					}
				}
			}
		}
		return null;
	}

	@SuppressWarnings("unchecked")
	<T> CtExecutableReference<T> getExecutableReference(MethodBinding exec) {
		if (exec == null) {
			return null;
		}
		final CtExecutableReference ref = this.jdtTreeBuilder.getFactory().Core().createExecutableReference();
		if (exec.isConstructor()) {
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);

			// in case of constructor of an array, it's the return type that we want
			if (exec.returnType instanceof VoidTypeBinding) {
				ref.setType(getTypeReference(exec.declaringClass));
			} else {
				ref.setType(getTypeReference(exec.returnType));
			}
		} else {
			ref.setSimpleName(new String(exec.selector));
			ref.setType(getTypeReference(exec.returnType));
		}
		if (exec instanceof ProblemMethodBinding) {
			if (exec.declaringClass != null && Arrays.asList(exec.declaringClass.methods()).contains(exec)) {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			} else {
				final CtReference declaringType = getDeclaringReferenceFromImports(exec.constantPoolName());
				if (declaringType instanceof CtTypeReference) {
					ref.setDeclaringType((CtTypeReference<?>) declaringType);
				}
			}
			if (exec.isConstructor()) {
				// super() invocation have a good declaring class.
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(true);
		} else {
			if (exec.isConstructor() && !(exec.returnType instanceof VoidTypeBinding)) {
				ref.setDeclaringType(getTypeReference(exec.returnType));
			} else {
				ref.setDeclaringType(getTypeReference(exec.declaringClass));
			}
			ref.setStatic(exec.isStatic());
		}

		if (exec.declaringClass instanceof ParameterizedTypeBinding) {
			ref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));
		}

		// original() method returns a result not null when the current method is generic.
		if (exec.original() != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>(exec.original().parameters.length);
			for (TypeBinding b : exec.original().parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		} else if (exec.parameters != null) {
			// This is a method without a generic argument.
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (TypeBinding b : exec.parameters) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}

		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(AllocationExpression allocationExpression) {
		CtExecutableReference<T> ref;
		if (allocationExpression.binding != null) {
			ref = getExecutableReference(allocationExpression.binding);
		} else {
			ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
			ref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);
			ref.setDeclaringType(getTypeReference(null, allocationExpression.type));

			final List<CtTypeReference<?>> parameters = new ArrayList<>(allocationExpression.argumentTypes.length);
			for (TypeBinding b : allocationExpression.argumentTypes) {
				parameters.add(getTypeReference(b));
			}
			ref.setParameters(parameters);
		}
		if (allocationExpression.type == null) {
			ref.setType(this.<T>getTypeReference(allocationExpression.expectedType()));
		}
		return ref;
	}

	<T> CtExecutableReference<T> getExecutableReference(MessageSend messageSend) {
		if (messageSend.binding != null) {
			return getExecutableReference(messageSend.binding);
		}
		CtExecutableReference<T> ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();
		ref.setSimpleName(CharOperation.charToString(messageSend.selector));
		ref.setType(this.<T>getTypeReference(messageSend.expectedType()));
		if (messageSend.receiver.resolvedType == null) {
			// It is crisis dude! static context, we don't have much more information.
			if (messageSend.receiver instanceof SingleNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());
			} else if (messageSend.receiver instanceof QualifiedNameReference) {
				ref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());
			}
		} else {
			ref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));
		}
		if (messageSend.arguments != null) {
			final List<CtTypeReference<?>> parameters = new ArrayList<>();
			for (Expression expression : messageSend.arguments) {
				parameters.add(getTypeReference(expression.resolvedType));
			}
			ref.setParameters(parameters);
		}
		return ref;
	}

	private CtPackageReference getPackageReference(PackageBinding reference) {
		return getPackageReference(new String(reference.shortReadableName()));
	}

	public CtPackageReference getPackageReference(String name) {
		if (name.length() == 0) {
			return this.jdtTreeBuilder.getFactory().Package().topLevel();
		}
		CtPackageReference ref = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
		ref.setSimpleName(name);
		return ref;
	}

	final Map<TypeBinding, CtTypeReference> bindingCache = new HashMap<>();

	<T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<T> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		CtTypeReference<T> result = getTypeReference(ref);
		return result;
	}

	CtTypeReference<Object> getTypeParameterReference(TypeBinding binding, TypeReference ref) {
		CtTypeReference<Object> ctRef = getTypeReference(binding);
		if (ctRef != null && isCorrectTypeReference(ref)) {
			if (!(ctRef instanceof CtTypeParameterReference)) {
				CtTypeParameterReference typeParameterRef = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
				typeParameterRef.setSimpleName(ctRef.getSimpleName());
				typeParameterRef.setDeclaringType(ctRef.getDeclaringType());
				typeParameterRef.setPackage(ctRef.getPackage());
				ctRef = typeParameterRef;
			}
			insertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);
			return ctRef;
		}
		return getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));
	}

	/**
	 * In no classpath, the model of the super interface isn't always correct.
	 */
	private boolean isCorrectTypeReference(TypeReference ref) {
		if (ref.resolvedType == null) {
			return false;
		}
		if (!(ref.resolvedType instanceof ProblemReferenceBinding)) {
			return true;
		}
		final String[] compoundName = CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);
		final String[] typeName = CharOperation.charArrayToStringArray(ref.getTypeName());
		if (compoundName.length == 0 || typeName.length == 0) {
			return false;
		}
		return compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);
	}

	private <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {
		if (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {
			for (TypeReference[] typeReferences : original.getTypeArguments()) {
				if (typeReferences != null) {
					for (TypeReference typeReference : typeReferences) {
						type.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));
					}
				}
			}
		}
	}

	/**
	 * JDT doesn't return a correct AST with the resolved type of the reference.
	 * This method try to build a correct Spoon AST from the name of the JDT
	 * reference, thanks to the parsing of the string, the name parameterized from
	 * the JDT reference and java convention.
	 * Returns a complete Spoon AST when the name is correct, otherwise a spoon type
	 * reference with a name that correspond to the name of the JDT type reference.
	 */
	<T> CtTypeReference<T> getTypeReference(TypeReference ref) {
		if (ref == null) {
			return null;
		}
		CtTypeReference<T> res = null;
		CtTypeReference inner = null;
		final String[] namesParameterized = CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());
		String nameParameterized = CharOperation.toString(ref.getParameterizedTypeName());
		String typeName = CharOperation.toString(ref.getTypeName());

		int index = namesParameterized.length - 1;
		for (; index >= 0; index--) {
			// Start at the end to get the class name first.
			CtTypeReference main = getTypeReference(namesParameterized[index]);
			if (main == null) {
				break;
			}
			if (res == null) {
				res = (CtTypeReference<T>) main;
			} else {
				inner.setDeclaringType((CtTypeReference<?>) main);
			}
			inner = main;
		}
		if (res == null) {
			return this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);
		}

		if (inner.getPackage() == null) {
			PackageFactory packageFactory = this.jdtTreeBuilder.getFactory().Package();
			CtPackageReference packageReference = index >= 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();
			inner.setPackage(packageReference);
		}
		if (!res.toString().replace(", ?", ",?").endsWith(nameParameterized)) {
			// verify that we did not match a class that have the same name in a different package
			return this.jdtTreeBuilder.getFactory().Type().createReference(typeName);
		}
		return res;
	}

	private String concatSubArray(String[] a, int endIndex) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < endIndex; i++) {
			sb.append(a[i]).append('.');
		}
		sb.append(a[endIndex]);
		return sb.toString();
	}

	/**
	 * Try to build a CtTypeReference from a simple name with specified generic types but
	 * returns null if the name doesn't correspond to a type (not start by an upper case).
	 */
	private <T> CtTypeReference<T> getTypeReference(String name) {
		CtTypeReference<T> main = null;
		if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (name.startsWith("?")) {
				main = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			if (m.find()) {
				main.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					((CtTypeReference) main).addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (Character.isUpperCase(name.charAt(0))) {
			if (name.endsWith("[]")) {
				main = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();
				name = name.substring(0, name.length() - 2);
				((CtArrayTypeReference<T>) main).setComponentType(this.getTypeReference(name));
			} else {
				main = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
			}
			main.setSimpleName(name);
			final CtReference declaring = this.getDeclaringReferenceFromImports(name.toCharArray());
			setPackageOrDeclaringType(main, declaring);
		} else if (name.startsWith("?")) {
			return (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		}
		return main;
	}

	/**
	 * Try to build a CtTypeParameterReference from a single name with specified generic types but
	 * keep in mind that if you give wrong data in the strong, reference will be wrong.
	 */
	private CtTypeReference<Object> getTypeParameterReference(String name) {
		CtTypeReference<Object> param = null;
		if (name.contains("extends") || name.contains("super")) {
			String[] split = name.contains("extends") ? name.split("extends") : name.split("super");
			param = getTypeParameterReference(split[0].trim());
			((CtTypeParameterReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));
		} else if (name.matches(".*(<.+>)")) {
			Pattern pattern = Pattern.compile("([^<]+)<(.+)>");
			Matcher m = pattern.matcher(name);
			if (m.find()) {
				param = this.jdtTreeBuilder.getFactory().Core().createTypeReference();
				param.setSimpleName(m.group(1));
				final String[] split = m.group(2).split(",");
				for (String parameter : split) {
					param.addActualTypeArgument(getTypeParameterReference(parameter.trim()));
				}
			}
		} else if (name.contains("?")) {
			param = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();
		} else {
			param = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();
			param.setSimpleName(name);
		}
		return param;
	}

	@SuppressWarnings("unchecked")
	<T> CtTypeReference<T> getTypeReference(TypeBinding binding) 

	private CtTypeReference<?> getCtCircularTypeReference(TypeBinding b) {
		return bindingCache.get(b).clone();
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(MethodBinding methbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		ref.setSimpleName(new String(methbin.selector));
		ref.setType((CtTypeReference<T>) getTypeReference(methbin.returnType));

		if (methbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(methbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType());
		}
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding varbin) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (varbin == null) {
			return ref;
		}
		ref.setSimpleName(new String(varbin.name));
		ref.setType(this.<T>getTypeReference(varbin.type));

		if (varbin.declaringClass != null) {
			ref.setDeclaringType(getTypeReference(varbin.declaringClass));
		} else {
			ref.setDeclaringType(ref.getType() == null ? null : ref.getType().clone());
		}
		ref.setFinal(varbin.isFinal());
		ref.setStatic((varbin.modifiers & ClassFileConstants.AccStatic) != 0);
		return ref;
	}

	<T> CtFieldReference<T> getVariableReference(FieldBinding fieldBinding, char[] tokens) {
		final CtFieldReference<T> ref = getVariableReference(fieldBinding);
		if (fieldBinding != null) {
			return ref;
		}
		ref.setSimpleName(CharOperation.charToString(tokens));
		return ref;
	}

	@SuppressWarnings("unchecked")
	<T> CtVariableReference<T> getVariableReference(VariableBinding varbin) {

		if (varbin instanceof FieldBinding) {
			return getVariableReference((FieldBinding) varbin);
		} else if (varbin instanceof LocalVariableBinding) {
			final LocalVariableBinding localVariableBinding = (LocalVariableBinding) varbin;
			if (localVariableBinding.declaration instanceof Argument && localVariableBinding.declaringScope instanceof MethodScope) {
				CtParameterReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createParameterReference();
				ref.setSimpleName(new String(varbin.name));
				ref.setType((CtTypeReference<T>) getTypeReference(varbin.type));
				final ReferenceContext referenceContext = localVariableBinding.declaringScope.referenceContext();
				return ref;
			} else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {
				CtCatchVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			} else {
				CtLocalVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();
				ref.setSimpleName(new String(varbin.name));
				CtTypeReference<T> ref2 = getTypeReference(varbin.type);
				ref.setType(ref2);
				return ref;
			}
		} else {
			// unknown VariableBinding, the caller must do something
			return null;
		}
	}

	<T> CtVariableReference<T> getVariableReference(ProblemBinding binding) {
		CtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();
		if (binding == null) {
			return ref;
		}
		ref.setSimpleName(new String(binding.name));
		ref.setType((CtTypeReference<T>) getTypeReference(binding.searchType));
		return ref;
	}

	List<CtTypeReference<?>> getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {
		List<CtTypeReference<?>> res = new ArrayList<>(genericTypeArguments.length);
		for (TypeBinding tb : genericTypeArguments) {
			res.add(getBoundedTypeReference(tb));
		}
		return res;
	}

	/**
	 * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type
	 */
	void setPackageOrDeclaringType(CtTypeReference<?> ref, CtReference declaring) {
		if (declaring instanceof CtPackageReference) {
			ref.setPackage((CtPackageReference) declaring);
		} else if (declaring instanceof CtTypeReference) {
			ref.setDeclaringType((CtTypeReference) declaring);
		} else if (declaring == null) {
			try {
				// sometimes JDT does not provide the information that ref comes from java.lang
				// it seems to occurs in particular with anonymous inner classes: see #1307
				// In that case, we try to load the class to check if it belongs to java.lang
				Class.forName("java.lang." + ref.getSimpleName());
				CtPackageReference javaLangPackageReference = this.jdtTreeBuilder.getFactory().Core().createPackageReference();
				javaLangPackageReference.setSimpleName("java.lang");
				ref.setPackage(javaLangPackageReference);
			} catch (NoClassDefFoundError | ClassNotFoundException e) {
				// in that case we consider the package should be the same as the current one. Fix #1293
				ref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());
			}
		} else {
			throw new AssertionError("unexpected declaring type: " + declaring.getClass() + " of " + declaring);
		}
	}

	/**
	 * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression.
	 * Here, we make the job of JDT and bind their variables accesses to their parameters.
	 *
	 * @param singleNameReference Name of the variable access.
	 * @return executable reference which corresponds to the lambda.
	 */
	public CtExecutableReference<?> getLambdaExecutableReference(SingleNameReference singleNameReference) {
		ASTPair potentialLambda = null;
		for (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {
			if (astPair.node instanceof LambdaExpression) {
				potentialLambda = astPair;
				// stop at innermost lambda, fixes #1100
				break;
			}
		}
		if (potentialLambda == null) {
			return null;
		}
		LambdaExpression lambdaJDT = (LambdaExpression) potentialLambda.node;
		for (Argument argument : lambdaJDT.arguments()) {
			if (CharOperation.equals(argument.name, singleNameReference.token)) {
				CtTypeReference<?> declaringType = null;
				if (lambdaJDT.enclosingScope instanceof MethodScope) {
					declaringType = jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());
				}
				CtLambda<?> ctLambda = (CtLambda<?>) potentialLambda.element;
				List<CtTypeReference<?>> parametersType = new ArrayList<>();
				List<CtParameter<?>> parameters = ctLambda.getParameters();
				for (CtParameter<?> parameter : parameters) {
					parametersType.add(parameter.getType() != null
							? parameter.getType().clone()
							// it's the best match :(
							: jdtTreeBuilder.getFactory().Type().OBJECT.clone()
					);
				}
				return jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);
			}
		}
		return null;
	}

	public CtModuleReference getModuleReference(ModuleReference moduleReference) {
		String moduleName = new String(moduleReference.moduleName);
		CtModule module = this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);
		if (module == null) {
			CtModuleReference ctModuleReference = this.jdtTreeBuilder.getFactory().Core().createModuleReference();
			ctModuleReference.setSimpleName(moduleName);
			return ctModuleReference;
		} else {
			return module.getReference();
		}
	}
}
]
>
[ERROR]   PrintChangesTest.testPrintUnchaged:38 expected:<...inter.testclasses;

[import java.util.ArrayList;
import java.util.List;

/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

//and what about this comment? ]> but was:<...inter.testclasses;

[
/**
 * The content of this file 
 * 

 * 		should not be changed
 * Because DJPP should print only modified content again 
 */
public
@Deprecated
abstract class /* even this comment stays here together with all SPACES and EOLs*/ ToBeChanged<T, K> /*before extends*/ 
	extends ArrayList<T /* let's confuse > it */ > implements List<T>,
	Cloneable
{
	
	
	/**/
	final
	//
	private String string = "a"
			+ "b" + "c"+"d";
	
	//and spaces here are wanted too
	
	
	public <T, K> void andSomeOtherMethod(
			int param1,
			String param2         , List<?>[][] ... twoDArrayOfLists)
	{/**/
		System.out.println("aaa"
				+ "xyz");
	/*x*/}
	List<?>[][] twoDArrayOfLists = new List<?>[7][];
}

]>
[ERROR] Errors: 
[ERROR]   LinesTest.testIdenticalPrettyPrinter:102  IndexOutOfBounds Index: 2, Size: 2
[INFO] 
[ERROR] Tests run: 1545, Failures: 7, Errors: 1, Skipped: 4
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 13:46 min
[INFO] Finished at: 2018-07-03T07:50:01+02:00
[INFO] Final Memory: 27M/952M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.21.0:test (default-test) on project spoon-core: There are test failures.
[ERROR] 
[ERROR] Please refer to /root/workspace/INRIA/spoon/399429949/target/surefire-reports for the individual test results.
[ERROR] Please refer to dump files (if any exist) [date]-jvmRun[N].dump, [date].dumpstream and [date]-jvmRun[N].dumpstream.
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
