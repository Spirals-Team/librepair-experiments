<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Base64.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-jacoco-aggregate</a> &gt; <a href="../index.html" class="el_bundle">spf4j-core</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.base</a> &gt; <span class="el_source">Base64.java</span></div><h1>Base64.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.base;

import java.io.IOException;
import java.nio.CharBuffer;

/**
 * &quot;improved&quot; implementation based on DataTypeConverterImpl performance should be same/slightly faster than the JDK
 * equivalent But most importantly you can encode/decode parts of a String, which should reduce the need of copying
 * objects and reduce the amount of garbage created.
 *
 * @author zoly
 */
<span class="nc bnc" id="L44" title="All 2 branches missed.">public final class Base64 {</span>

<span class="nc" id="L46">  private static final byte[] DECODE_MAP = initDecodeMap();</span>

<span class="nc" id="L48">  private static final char[] ENCODE_MAP = initEncodeMap();</span>

  private static final byte PADDING = 127;

  private Base64() {
  }

  private static byte[] initDecodeMap() {
<span class="nc" id="L56">    byte[] map = new byte[128];</span>
    int i;
<span class="nc bnc" id="L58" title="All 2 branches missed.">    for (i = 0; i &lt; 128; i++) {</span>
<span class="nc" id="L59">      map[i] = -1;</span>
    }

<span class="nc bnc" id="L62" title="All 2 branches missed.">    for (i = 'A'; i &lt;= 'Z'; i++) {</span>
<span class="nc" id="L63">      map[i] = (byte) (i - 'A');</span>
    }
<span class="nc bnc" id="L65" title="All 2 branches missed.">    for (i = 'a'; i &lt;= 'z'; i++) {</span>
<span class="nc" id="L66">      map[i] = (byte) (i - 'a' + 26);</span>
    }
<span class="nc bnc" id="L68" title="All 2 branches missed.">    for (i = '0'; i &lt;= '9'; i++) {</span>
<span class="nc" id="L69">      map[i] = (byte) (i - '0' + 52);</span>
    }
<span class="nc" id="L71">    map['+'] = 62;</span>
<span class="nc" id="L72">    map['/'] = 63;</span>
<span class="nc" id="L73">    map['='] = PADDING;</span>

<span class="nc" id="L75">    return map;</span>
  }

  /**
   * computes the length of binary data speculatively.
   *
   * &lt;p&gt;
   * Our requirement is to create byte[] of the exact length to store the binary data. If we do this in a
   * straight-forward way, it takes two passes over the data. Experiments show that this is a non-trivial overhead (35%
   * or so is spent on the first pass in calculating the length.)
   *
   * &lt;p&gt;
   * So the approach here is that we compute the length speculatively, without looking at the whole contents. The
   * obtained speculative value is never less than the actual length of the binary data, but it may be bigger. So if the
   * speculation goes wrong, we'll pay the cost of reallocation and buffer copying.
   *
   * &lt;p&gt;
   * If the base64 text is tightly packed with no indentation nor illegal char (like what most web services produce),
   * then the speculation of this method will be correct, so we get the performance benefit.
   */
  private static int guessLength(final CharSequence text, final int from, final int len) {
<span class="nc" id="L96">    final int to = from + len;</span>

    // compute the tail '=' chars
<span class="nc" id="L99">    int j = to - 1;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    for (; j &gt;= 0; j--) {</span>
<span class="nc" id="L101">      byte code = DECODE_MAP[text.charAt(j)];</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">      if (code != PADDING) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (code == -1) { // most likely this base64 text is indented. go with the upper bound</span>
<span class="nc" id="L104">          return len / 4 * 3;</span>
        }
        break;
      }
    }

<span class="nc" id="L110">    j++;    // text.charAt(j) is now at some base64 char, so +1 to make it the size</span>
<span class="nc" id="L111">    int padSize = to - j;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">    if (padSize &gt; 2) { // something is wrong with base64. be safe and go with the upper bound</span>
<span class="nc" id="L113">      return len / 4 * 3;</span>
    }

    // so far this base64 looks like it's unindented tightly packed base64.
    // take a chance and create an array with the expected size
<span class="nc" id="L118">    return len / 4 * 3 - padSize;</span>
  }

  private static int guessLength(final char[] text, final int from, final int len) {
<span class="nc" id="L122">    final int to = from + len;</span>

    // compute the tail '=' chars
<span class="nc" id="L125">    int j = to - 1;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">    for (; j &gt;= 0; j--) {</span>
<span class="nc" id="L127">      byte code = DECODE_MAP[text[j]];</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">      if (code != PADDING) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (code == -1) { // most likely this base64 text is indented. go with the upper bound</span>
<span class="nc" id="L130">          return len / 4 * 3;</span>
        }
        break;
      }
    }

<span class="nc" id="L136">    j++;    // text.charAt(j) is now at some base64 char, so +1 to make it the size</span>
<span class="nc" id="L137">    int padSize = to - j;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (padSize &gt; 2) { // something is wrong with base64. be safe and go with the upper bound</span>
<span class="nc" id="L139">      return len / 4 * 3;</span>
    }

    // so far this base64 looks like it's unindented tightly packed base64.
    // take a chance and create an array with the expected size
<span class="nc" id="L144">    return len / 4 * 3 - padSize;</span>
  }

  public static byte[] decodeBase64(final CharSequence text) {
<span class="nc" id="L148">    return Base64.decodeBase64(text, 0, text.length());</span>
  }

  public static byte[] decodeBase64(final String text) {
<span class="nc" id="L152">    return Base64.decodeBase64(text, 0, text.length());</span>
  }

  public static byte[] decodeBase64(final String text, final int from, final int length) {
<span class="nc" id="L156">    return decodeBase64((CharSequence) text, from, length);</span>
  }

  public static byte[] decodeBase64V2(final String text, final int from, final int length) {
<span class="nc" id="L160">    char[] steal = Strings.steal(text);</span>
<span class="nc" id="L161">    return decodeBase64(steal, from, length);</span>
  }

  /**
   * @param text base64Binary data is likely to be long, and decoding requires each character to be accessed twice (once
   * for counting length, another for decoding.)
   * @param from the index of the first character in the sequence.
   * @param len - the number of characters to decode.
   * @return - the decoded byte array.
   *
   */
  public static byte[] decodeBase64(final CharSequence text, final int from, final int len) {
<span class="nc" id="L173">    final int buflen = guessLength(text, from, len);</span>
<span class="nc" id="L174">    final byte[] out = new byte[buflen];</span>
<span class="nc" id="L175">    int o = 0;</span>

    int i;

<span class="nc" id="L179">    final byte[] quadruplet = new byte[4];</span>
<span class="nc" id="L180">    int q = 0;</span>

    // convert each quadruplet to three bytes.
<span class="nc" id="L183">    int to = from + len;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">    for (i = from; i &lt; to; i++) {</span>
<span class="nc" id="L185">      char ch = text.charAt(i);</span>
<span class="nc" id="L186">      byte v = DECODE_MAP[ch];</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">      if (v != -1) {</span>
<span class="nc" id="L189">        quadruplet[q++] = v;</span>
      }

<span class="nc bnc" id="L192" title="All 2 branches missed.">      if (q == 4) {</span>
        // quadruplet is now filled.
<span class="nc" id="L194">        out[o++] = (byte) ((quadruplet[0] &lt;&lt; 2) | (quadruplet[1] &gt;&gt; 4));</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (quadruplet[2] != PADDING) {</span>
<span class="nc" id="L196">          out[o++] = (byte) ((quadruplet[1] &lt;&lt; 4) | (quadruplet[2] &gt;&gt; 2));</span>
        }
<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (quadruplet[3] != PADDING) {</span>
<span class="nc" id="L199">          out[o++] = (byte) ((quadruplet[2] &lt;&lt; 6) | (quadruplet[3]));</span>
        }
<span class="nc" id="L201">        q = 0;</span>
      }
    }

<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (buflen == o) { // speculation worked out to be OK</span>
<span class="nc" id="L206">      return out;</span>
    }

    // we overestimated, so need to create a new buffer
<span class="nc" id="L210">    byte[] nb = new byte[o];</span>
<span class="nc" id="L211">    System.arraycopy(out, 0, nb, 0, o);</span>
<span class="nc" id="L212">    return nb;</span>
  }

  public static byte[] decodeBase64(final char[] text, final int from, final int len) {
<span class="nc" id="L216">    final int buflen = guessLength(text, from, len);</span>
<span class="nc" id="L217">    final byte[] out = new byte[buflen];</span>
<span class="nc" id="L218">    int o = 0;</span>

    int i;

<span class="nc" id="L222">    final byte[] quadruplet = new byte[4];</span>
<span class="nc" id="L223">    int q = 0;</span>

    // convert each quadruplet to three bytes.
<span class="nc" id="L226">    int to = from + len;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    for (i = from; i &lt; to; i++) {</span>
<span class="nc" id="L228">      char ch = text[i];</span>
<span class="nc" id="L229">      byte v = DECODE_MAP[ch];</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (v != -1) {</span>
<span class="nc" id="L232">        quadruplet[q++] = v;</span>
      }

<span class="nc bnc" id="L235" title="All 2 branches missed.">      if (q == 4) {</span>
        // quadruplet is now filled.
<span class="nc" id="L237">        out[o++] = (byte) ((quadruplet[0] &lt;&lt; 2) | (quadruplet[1] &gt;&gt; 4));</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (quadruplet[2] != PADDING) {</span>
<span class="nc" id="L239">          out[o++] = (byte) ((quadruplet[1] &lt;&lt; 4) | (quadruplet[2] &gt;&gt; 2));</span>
        }
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (quadruplet[3] != PADDING) {</span>
<span class="nc" id="L242">          out[o++] = (byte) ((quadruplet[2] &lt;&lt; 6) | (quadruplet[3]));</span>
        }
<span class="nc" id="L244">        q = 0;</span>
      }
    }

<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (buflen == o) { // speculation worked out to be OK</span>
<span class="nc" id="L249">      return out;</span>
    }

    // we overestimated, so need to create a new buffer
<span class="nc" id="L253">    byte[] nb = new byte[o];</span>
<span class="nc" id="L254">    System.arraycopy(out, 0, nb, 0, o);</span>
<span class="nc" id="L255">    return nb;</span>
  }

  private static char[] initEncodeMap() {
<span class="nc" id="L259">    char[] map = new char[64];</span>
    int i;
<span class="nc bnc" id="L261" title="All 2 branches missed.">    for (i = 0; i &lt; 26; i++) {</span>
<span class="nc" id="L262">      map[i] = (char) ('A' + i);</span>
    }
<span class="nc bnc" id="L264" title="All 2 branches missed.">    for (i = 26; i &lt; 52; i++) {</span>
<span class="nc" id="L265">      map[i] = (char) ('a' + (i - 26));</span>
    }
<span class="nc bnc" id="L267" title="All 2 branches missed.">    for (i = 52; i &lt; 62; i++) {</span>
<span class="nc" id="L268">      map[i] = (char) ('0' + (i - 52));</span>
    }
<span class="nc" id="L270">    map[62] = '+';</span>
<span class="nc" id="L271">    map[63] = '/';</span>

<span class="nc" id="L273">    return map;</span>
  }

  public static char encode(final int i) {
<span class="nc" id="L277">    return ENCODE_MAP[i &amp; 0x3F];</span>
  }

  public static byte encodeByte(final int i) {
<span class="nc" id="L281">    return (byte) ENCODE_MAP[i &amp; 0x3F];</span>
  }

  public static String encodeBase64(final byte[] input) {
<span class="nc" id="L285">    return Base64.encodeBase64(input, 0, input.length);</span>
  }

  public static String encodeBase64(final byte[] input, final int offset, final int len) {
<span class="nc" id="L289">    char[] buf = TLScratch.getCharsTmp((((len + 2) / 3) * 4));</span>
<span class="nc" id="L290">    int ptr = Base64.encodeBase64(input, offset, len, buf, 0);</span>
<span class="nc" id="L291">    return new String(buf, 0, ptr);</span>
  }

  /**
   * Alternate implementation, should be better for large data.
   *
   * @param input - the byte array to encode
   * @param offset - the index of the first byte that is to be encoded.
   * @param len - the number of bytes to encode.
   * @return - the encoded String.
   */
  public static CharSequence encodeBase64V2(final byte[] input, final int offset, final int len) {
<span class="nc" id="L303">    char[] buf = new char[(((len + 2) / 3) * 4)];</span>
<span class="nc" id="L304">    int ptr = encodeBase64(input, offset, len, buf, 0);</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">    assert ptr == buf.length;</span>
<span class="nc" id="L306">    return CharBuffer.wrap(buf);</span>
  }

  public static void encodeBase64(final byte[] input, final int offset, final int len, final Appendable result)
          throws IOException {
<span class="nc bnc" id="L311" title="All 2 branches missed.">    for (int i = offset; i &lt; len; i += 3) {</span>
<span class="nc bnc" id="L312" title="All 3 branches missed.">      switch (len - i) {</span>
        case 1:
<span class="nc" id="L314">          result.append(encode(input[i] &gt;&gt; 2));</span>
<span class="nc" id="L315">          result.append(encode(((input[i]) &amp; 0x3) &lt;&lt; 4));</span>
<span class="nc" id="L316">          result.append(&quot;==&quot;);</span>
<span class="nc" id="L317">          break;</span>
        case 2:
<span class="nc" id="L319">          result.append(encode(input[i] &gt;&gt; 2));</span>
<span class="nc" id="L320">          result.append(encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF)));
<span class="nc" id="L323">          result.append(encode((input[i + 1] &amp; 0xF) &lt;&lt; 2));</span>
<span class="nc" id="L324">          result.append('=');</span>
<span class="nc" id="L325">          break;</span>
        default:
<span class="nc" id="L327">          result.append(encode(input[i] &gt;&gt; 2));</span>
<span class="nc" id="L328">          result.append(encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF)));
<span class="nc" id="L331">          result.append(encode(</span>
                  ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
                  | ((input[i + 2] &gt;&gt; 6) &amp; 0x3)));
<span class="nc" id="L334">          result.append(encode(input[i + 2] &amp; 0x3F));</span>
          break;
      }
    }
<span class="nc" id="L338">  }</span>

  /**
   * Encodes a byte array into a char array by doing base64 encoding.
   *
   * The caller must supply a big enough buffer.
   *
   * @param input - the byte array to encode.
   * @param offset - the index of the first byte to encode.
   * @param len - the number of bytes to encode.
   * @param output - the destination character array to encode to.
   * @param cptr - the index of the first character to encode to.
   * @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
   * bytes should be placed.
   */
  public static int encodeBase64(final byte[] input, final int offset,
          final int len, final char[] output, final int cptr) {
<span class="nc" id="L355">    int ptr = cptr;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">    for (int i = offset; i &lt; len; i += 3) {</span>
<span class="nc bnc" id="L357" title="All 3 branches missed.">      switch (len - i) {</span>
        case 1:
<span class="nc" id="L359">          output[ptr++] = encode(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L360">          output[ptr++] = encode(((input[i]) &amp; 0x3) &lt;&lt; 4);</span>
<span class="nc" id="L361">          output[ptr++] = '=';</span>
<span class="nc" id="L362">          output[ptr++] = '=';</span>
<span class="nc" id="L363">          break;</span>
        case 2:
<span class="nc" id="L365">          output[ptr++] = encode(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L366">          output[ptr++] = encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="nc" id="L369">          output[ptr++] = encode((input[i + 1] &amp; 0xF) &lt;&lt; 2);</span>
<span class="nc" id="L370">          output[ptr++] = '=';</span>
<span class="nc" id="L371">          break;</span>
        default:
<span class="nc" id="L373">          output[ptr++] = encode(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L374">          output[ptr++] = encode(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="nc" id="L377">          output[ptr++] = encode(</span>
                  ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
                  | ((input[i + 2] &gt;&gt; 6) &amp; 0x3));
<span class="nc" id="L380">          output[ptr++] = encode(input[i + 2] &amp; 0x3F);</span>
          break;
      }
    }
<span class="nc" id="L384">    return ptr;</span>
  }

  /**
   * Encodes a byte array into another byte array by first doing base64 encoding then encoding the result in ASCII.
   *
   * The caller must supply a big enough buffer.
   *
   * @param input - the byte array to encode.
   * @param offset - the index of the first byte to encode.
   * @param len - the number of bytes to encode.
   * @param out - the destination byte array that represents an ASCII string to encode to.
   * @param cptr - the index of the first byte in the destination array to encode to.
   * @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
   * bytes should be placed.
   */
  public static int encodeBase64(final byte[] input, final int offset, final int len,
          final byte[] out, final int cptr) {
<span class="nc" id="L402">    int ptr = cptr;</span>
<span class="nc" id="L403">    byte[] buf = out;</span>
<span class="nc" id="L404">    int max = len + offset;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">    for (int i = offset; i &lt; max; i += 3) {</span>
<span class="nc bnc" id="L406" title="All 3 branches missed.">      switch (max - i) {</span>
        case 1:
<span class="nc" id="L408">          buf[ptr++] = encodeByte(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L409">          buf[ptr++] = encodeByte(((input[i]) &amp; 0x3) &lt;&lt; 4);</span>
<span class="nc" id="L410">          buf[ptr++] = '=';</span>
<span class="nc" id="L411">          buf[ptr++] = '=';</span>
<span class="nc" id="L412">          break;</span>
        case 2:
<span class="nc" id="L414">          buf[ptr++] = encodeByte(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L415">          buf[ptr++] = encodeByte(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="nc" id="L418">          buf[ptr++] = encodeByte((input[i + 1] &amp; 0xF) &lt;&lt; 2);</span>
<span class="nc" id="L419">          buf[ptr++] = '=';</span>
<span class="nc" id="L420">          break;</span>
        default:
<span class="nc" id="L422">          buf[ptr++] = encodeByte(input[i] &gt;&gt; 2);</span>
<span class="nc" id="L423">          buf[ptr++] = encodeByte(</span>
                  ((input[i] &amp; 0x3) &lt;&lt; 4)
                  | ((input[i + 1] &gt;&gt; 4) &amp; 0xF));
<span class="nc" id="L426">          buf[ptr++] = encodeByte(</span>
                  ((input[i + 1] &amp; 0xF) &lt;&lt; 2)
                  | ((input[i + 2] &gt;&gt; 6) &amp; 0x3));
<span class="nc" id="L429">          buf[ptr++] = encodeByte(input[i + 2] &amp; 0x3F);</span>
          break;
      }
    }

<span class="nc" id="L434">    return ptr;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>