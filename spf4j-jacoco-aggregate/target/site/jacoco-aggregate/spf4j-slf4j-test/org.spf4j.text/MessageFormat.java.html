<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MessageFormat.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">spf4j-jacoco-aggregate</a> &gt; <a href="../index.html" class="el_bundle">spf4j-slf4j-test</a> &gt; <a href="index.source.html" class="el_package">org.spf4j.text</a> &gt; <span class="el_source">MessageFormat.java</span></div><h1>MessageFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001-2017, Zoltan Farkas All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * Additionally licensed with:
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.spf4j.text;
//CHECKSTYLE:OFF
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

 /*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.InvalidObjectException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.UncheckedIOException;
import java.text.AttributedCharacterIterator;
import java.text.CharacterIterator;
import java.text.ChoiceFormat;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.FieldPosition;
import java.text.Format;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.concurrent.NotThreadSafe;
import org.spf4j.base.CharSequences;

/**
 * Performance mutation of the JDK message formatter.
 * Lots things of things have been done:
 * 1) reduced the amount of garbage generated during formatting.
 * 2) made some method invocations static.
 * 3) made this more flexible and usable against StringBuilder not only StringBuffer...
 * 4) thrown exceptions provide more detail on what went wrong.
 * 5) cleaned up lots of static analisys reported issues.
 *
 * &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated messages in a language-neutral way. Use this to
 * construct messages displayed for end users.
 *
 * this implementation is based on java.text.MessageFormat with the goal to be a faster and more flexible implementation
 *
 * &lt;p&gt;
 * &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then inserts the formatted strings into the pattern
 * at the appropriate places.
 *
 * &lt;p&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt;
 * &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt; classes in that you create a
 * &lt;code&gt;MessageFormat&lt;/code&gt; object with one of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
 * method). The factory methods aren't necessary because &lt;code&gt;MessageFormat&lt;/code&gt; itself doesn't implement locale
 * specific behavior. Any locale specific behavior is defined by the pattern that you provide as well as the sub-formats
 * used for inserted arguments.
 *
 * &lt;h3&gt;&lt;a name=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
 *         &lt;i&gt;String&lt;/i&gt;
 *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
 *
 * &lt;i&gt;FormatElement:&lt;/i&gt;
 *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
 *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
 *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
 *
 * &lt;i&gt;FormatType: one of &lt;/i&gt;
 *         number date time choice
 *
 * &lt;i&gt;FormatStyle:&lt;/i&gt;
 *         short
 *         medium
 *         long
 *         full
 *         integer
 *         currency
 *         percent
 *         &lt;i&gt;SubformatPattern&lt;/i&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to quote any arbitrary characters except single quotes.
 * For example, pattern string &lt;code&gt;&quot;'{0}'&quot;&lt;/code&gt; represents string &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A
 * single quote itself must be represented by doubled single quotes {@code ''} throughout a
 * &lt;i&gt;String&lt;/i&gt;. For example, pattern string &lt;code&gt;&quot;'{''}'&quot;&lt;/code&gt; is interpreted as a sequence of &lt;code&gt;'{&lt;/code&gt;
 * (start of quoting and a left curly brace), &lt;code&gt;''&lt;/code&gt; (a single quote), and &lt;code&gt;}'&lt;/code&gt; (a right curly brace
 * and end of quoting),
 * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;'{'&lt;/code&gt; and &lt;code&gt;'}'&lt;/code&gt; (quoted left and right curly braces): representing string
 * &lt;code&gt;&quot;{'}&quot;&lt;/code&gt;,
 * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
 *
 * &lt;p&gt;
 * A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding sub-format, and sub-format-dependent pattern rules
 * apply. For example, pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$'#',##&lt;/u&gt;}&quot;&lt;/code&gt; (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline)
 * will produce a number format with the pound-sign quoted, with a result such as: {@code
 * &quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for details.
 *
 * &lt;p&gt;
 * Any unmatched quote is treated as closed at the end of the given pattern. For example, pattern string {@code &quot;'{0}&quot;}
 * is treated as pattern {@code &quot;'{0}'&quot;}.
 *
 * &lt;p&gt;
 * Any curly braces within an unquoted pattern must be balanced. For example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and
 * &lt;code&gt;&quot;ab '}' de&quot;&lt;/code&gt; are valid patterns, but &lt;code&gt;&quot;ab {0'}' de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt; and
 * &lt;code&gt;&quot;''{''&quot;&lt;/code&gt; are not.
 *
 * &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message format patterns unfortunately have shown to be
 * somewhat confusing. In particular, it isn't always obvious to localizers whether single quotes need to be doubled or
 * not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle
 * source files) which strings will be processed by {@code MessageFormat}. Note that localizers may need to use single
 * quotes in translated strings where the original version doesn't have them.
 * &lt;/dl&gt;
 * &lt;p&gt;
 * The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written using the digits {@code '0'} through {@code '9'},
 * and represents an index into the {@code arguments} array passed to the {@code format} methods or the result array
 * returned by the {@code parse} methods.
 * &lt;p&gt;
 * The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create a {@code Format} instance for the format
 * element. The following table shows how the values map to {@code Format} instances. Combinations not shown in the
 * table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must be a valid pattern string for the {@code Format} subclass used.
 *
 * &lt;table border=1 summary=&quot;Shows how FormatType and FormatStyle values map to Format instances&quot;&gt;
 * &lt;tr&gt;
 * &lt;th id=&quot;ft&quot; class=&quot;TableHeadingColor&quot;&gt;FormatType
 * &lt;th id=&quot;fs&quot; class=&quot;TableHeadingColor&quot;&gt;FormatStyle
 * &lt;th id=&quot;sc&quot; class=&quot;TableHeadingColor&quot;&gt;Subformat Created
 * &lt;tr&gt;
 * &lt;td headers=&quot;ft&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;null&lt;/code&gt;
 * &lt;tr&gt;
 * &lt;td headers=&quot;ft&quot; rowspan=5&gt;&lt;code&gt;number&lt;/code&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;integer&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;currency&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;percent&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@code new}
 * {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
 * &lt;tr&gt;
 * &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@code new}
 * {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@code new}
 * {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 * &lt;tr&gt;
 * &lt;td headers=&quot;ft&quot;&gt;&lt;code&gt;choice&lt;/code&gt;
 * &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 * &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 * &lt;/table&gt;
 *
 * &lt;h4&gt;Usage Information&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Here are some examples of usage. In real internationalized programs, the message format pattern and other static
 * strings will, of course, be obtained from resource bundles. Other parameters will be dynamically determined at
 * runtime.
 * &lt;p&gt;
 * The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;, which internally creates a
 * &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:
 * &lt;blockquote&gt;&lt;pre&gt;
 * int planet = 7;
 * String event = &quot;a disturbance in the Force&quot;;
 *
 * String result = MessageFormat.format(
 *     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
 *     planet, new Date(), event);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The output is:
 * &lt;blockquote&gt;&lt;pre&gt;
 * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that can be used repeatedly:
 * &lt;blockquote&gt;&lt;pre&gt;
 * int fileCount = 1273;
 * String diskName = &quot;MyDisk&quot;;
 * Object[] testArgs = {new Long(fileCount), diskName};
 *
 * MessageFormat form = new MessageFormat(
 *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
 *
 * System.out.println(form.format(testArgs));
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
 * &lt;blockquote&gt;&lt;pre&gt;
 * The disk &quot;MyDisk&quot; contains 0 file(s).
 * The disk &quot;MyDisk&quot; contains 1 file(s).
 * The disk &quot;MyDisk&quot; contains 1,273 file(s).
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt; to produce correct forms for singular and
 * plural:
 * &lt;blockquote&gt;&lt;pre&gt;
 * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 * double[] filelimits = {0,1,2};
 * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 * form.setFormatByArgumentIndex(0, fileform);
 *
 * int fileCount = 1273;
 * String diskName = &quot;MyDisk&quot;;
 * Object[] testArgs = {new Long(fileCount), diskName};
 *
 * System.out.println(form.format(testArgs));
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
 * &lt;blockquote&gt;&lt;pre&gt;
 * The disk &quot;MyDisk&quot; contains no files.
 * The disk &quot;MyDisk&quot; contains one file.
 * The disk &quot;MyDisk&quot; contains 1,273 files.
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the above example, or by using a pattern. See
 * {@link ChoiceFormat} for more information.
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * form.applyPattern(
 *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in
 * &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special; occurrences of '{' are used to indicate subformats, and cause
 * recursion. If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically (instead of
 * using the string patterns), then be careful not to produce a format that recurses on itself, which will cause an
 * infinite loop.
 * &lt;p&gt;
 * When a single argument is parsed more than once in the string, the last match will be the final result of the
 * parsing. For example,
 * &lt;blockquote&gt;&lt;pre&gt;
 * MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 * Object[] objs = {new Double(3.1415)};
 * String result = mf.format( objs );
 * // result now equals &quot;3.14, 3.1&quot;
 * objs = null;
 * objs = mf.parse(result, new ParsePosition(0));
 * // objs now equals {new Double(3.1)}
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * Likewise, parsing with a {@code MessageFormat} object using patterns containing multiple occurrences of the same
 * argument would return the last match. For example,
 * &lt;blockquote&gt;&lt;pre&gt;
 * MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 * String forParsing = &quot;x, y, z&quot;;
 * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 * // result now equals {new String(&quot;z&quot;)}
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Message formats are not synchronized. It is recommended to create separate format instances for each thread. If
 * multiple threads access a format concurrently, it must be synchronized externally.
 *
 * @see java.util.Locale
 * @see Format
 * @see NumberFormat
 * @see DecimalFormat
 * @see DecimalFormatSymbols
 * @see ChoiceFormat
 * @see DateFormat
 * @see SimpleDateFormat
 *
 * @author Mark Davis
 */
@SuppressFBWarnings(&quot;IMC_IMMATURE_CLASS_WRONG_FIELD_ORDER&quot;)
@NotThreadSafe
public final class MessageFormat extends Format {

  private static final long serialVersionUID = 1L;

  // Indices for segments
  private static final int SEG_RAW = 0;
  private static final int SEG_INDEX = 1;
  private static final int SEG_TYPE = 2;
  private static final int SEG_MODIFIER = 3; // modifier or subformat

  // Indices for type keywords
  private static final int TYPE_NULL = 0;
  private static final int TYPE_NUMBER = 1;
  private static final int TYPE_DATE = 2;
  private static final int TYPE_TIME = 3;
  private static final int TYPE_CHOICE = 4;

<span class="nc" id="L381">  private static final String[] TYPE_KEYWORDS = {</span>
    &quot;&quot;,
    &quot;number&quot;,
    &quot;date&quot;,
    &quot;time&quot;,
    &quot;choice&quot;
  };

  // Indices for number modifiers
  private static final int MODIFIER_DEFAULT = 0; // common in number and date-time
  private static final int MODIFIER_CURRENCY = 1;
  private static final int MODIFIER_PERCENT = 2;
  private static final int MODIFIER_INTEGER = 3;

<span class="nc" id="L395">  private static final String[] NUMBER_MODIFIER_KEYWORDS = {</span>
    &quot;&quot;,
    &quot;currency&quot;,
    &quot;percent&quot;,
    &quot;integer&quot;
  };

<span class="nc" id="L402">  private static final String[] DATE_TIME_MODIFIER_KEYWORDS = {</span>
    &quot;&quot;,
    &quot;short&quot;,
    &quot;medium&quot;,
    &quot;long&quot;,
    &quot;full&quot;
  };

  // Date-time style values corresponding to the date-time modifiers.
<span class="nc" id="L411">  private static final int[] DATE_TIME_MODIFIERS = {</span>
    DateFormat.DEFAULT,
    DateFormat.SHORT,
    DateFormat.MEDIUM,
    DateFormat.LONG,
    DateFormat.FULL,};



  // ===========================privates============================
  /**
   * The locale to use for formatting numbers and dates.
   *
   * @serial
   */
  private Locale locale;

  /**
   * The string that the formatted values are to be plugged into. In other words, this is the pattern supplied on
   * construction with all of the {} expressions taken out.
   *
   * @serial
   */
  private transient CharSequence pattern;

  /**
   * An array of formatters, which are used to format the arguments.
   *
   * @serial
   */
<span class="nc" id="L441">  private FormatInfo[] formats = {};</span>

  /**
   * One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;. Can also be thought of as the index of the
   * highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used. All of these arrays should have the same
   * number of elements being used as &lt;code&gt;offsets&lt;/code&gt; does, and so this variable suffices to tell us how many
   * entries are in all of them.
   *
   * @serial
   */
<span class="nc" id="L451">  private int maxOffset = -1;</span>


<span class="nc" id="L454">  private int hash = 0;</span>


  /**
   * Constructs a FastMessageFormat for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
   * specified pattern. The constructor first sets the locale, then parses the pattern and creates a list of subformats
   * for the format elements contained in it. Patterns and their interpretation are specified in the
   * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
   *
   * @param pattern the pattern for this message format
   * @exception IllegalArgumentException if the pattern is invalid
   */
<span class="nc" id="L466">  public MessageFormat(String pattern) {</span>
<span class="nc" id="L467">    this.locale = Locale.getDefault(Locale.Category.FORMAT);</span>
<span class="nc" id="L468">    applyPattern(pattern);</span>
<span class="nc" id="L469">  }</span>

  /**
   * Constructs a FastMessageFormat for the specified locale and pattern. The constructor first sets the locale, then
   * parses the pattern and creates a list of sub-formats for the format elements contained in it. Patterns and their
   * interpretation are specified in the
   * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
   *
   * @param pattern the pattern for this message format
   * @param locale the locale for this message format
   * @exception IllegalArgumentException if the pattern is invalid
   * @since 1.4
   */
<span class="nc" id="L482">  public MessageFormat(String pattern, Locale locale) {</span>
<span class="nc" id="L483">    this.locale = locale;</span>
<span class="nc" id="L484">    applyPattern(pattern);</span>
<span class="nc" id="L485">  }</span>

  /**
   * Sets the locale to be used when creating or comparing subformats. This affects subsequent calls
   * &lt;ul&gt;
   * &lt;li&gt;to the {@link #applyPattern applyPattern} and {@link #toPattern toPattern} methods if format elements specify a
   * format type and therefore have the subformats created in the &lt;code&gt;applyPattern&lt;/code&gt; method, as well as
   * &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and {@link #formatToCharacterIterator formatToCharacterIterator} methods if format
   * elements do not specify a format type and therefore have the subformats created in the formatting methods.
   * &lt;/ul&gt;
   * Subformats that have already been created are not affected.
   *
   * @param locale the locale to be used when creating or comparing subformats
   */
  public void setLocale(Locale locale) {
<span class="nc" id="L500">    this.locale = locale;</span>
<span class="nc" id="L501">  }</span>

  /**
   * Gets the locale that's used when creating or comparing subformats.
   *
   * @return the locale used when creating or comparing subformats
   */
  public Locale getLocale() {
<span class="nc" id="L509">    return locale;</span>
  }

  /**
   * Sets the pattern used by this message format. The method parses the pattern and creates a list of subformats for
   * the format elements contained in it. Patterns and their interpretation are specified in the
   * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
   *
   * @param pattern the pattern for this message format
   * @exception IllegalArgumentException if the pattern is invalid
   */
  @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
  @SuppressFBWarnings(&quot;CLI_CONSTANT_LIST_INDEX&quot;)
  public void applyPattern(String pattern) {
<span class="nc" id="L523">    StringBuilder[] segments = new StringBuilder[4];</span>
    // Allocate only segments[SEG_RAW] here. The rest are
    // allocated on demand.
<span class="nc" id="L526">    final int length = pattern.length();</span>
<span class="nc" id="L527">    segments[SEG_RAW] = new StringBuilder(length);</span>

<span class="nc" id="L529">    int part = SEG_RAW;</span>
<span class="nc" id="L530">    int formatNumber = 0;</span>
<span class="nc" id="L531">    boolean inQuote = false;</span>
<span class="nc" id="L532">    int braceStack = 0;</span>
<span class="nc" id="L533">    maxOffset = -1;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">    for (int i = 0; i &lt; length; ++i) {</span>
<span class="nc" id="L535">      char ch = pattern.charAt(i);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">      if (part == SEG_RAW) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (ch == '\'') {</span>
<span class="nc" id="L538">          int next = i + 1;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">          if (next &lt; length</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                  &amp;&amp; pattern.charAt(next) == '\'') {</span>
<span class="nc" id="L541">            segments[part].append(ch);  // handle doubles</span>
<span class="nc" id="L542">            i = next;</span>
          } else {
<span class="nc bnc" id="L544" title="All 2 branches missed.">            inQuote = !inQuote;</span>
          }
<span class="nc bnc" id="L546" title="All 4 branches missed.">        } else if (ch == '{' &amp;&amp; !inQuote) {</span>
<span class="nc" id="L547">          part = SEG_INDEX;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">          if (segments[part] == null) {</span>
<span class="nc" id="L549">            segments[part] = new StringBuilder();</span>
          }
        } else {
<span class="nc" id="L552">          segments[part].append(ch);</span>
        }
<span class="nc bnc" id="L554" title="All 2 branches missed.">      } else if (inQuote) {              // just copy quotes in parts</span>
<span class="nc" id="L555">        segments[part].append(ch);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (ch == '\'') {</span>
<span class="nc" id="L557">          inQuote = false;</span>
        }
      } else {
<span class="nc bnc" id="L560" title="All 6 branches missed.">        switch (ch) {</span>
          case ',':
<span class="nc bnc" id="L562" title="All 2 branches missed.">            if (part &lt; SEG_MODIFIER) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">              if (segments[++part] == null) {</span>
<span class="nc" id="L564">                segments[part] = new StringBuilder();</span>
              }
            } else {
<span class="nc" id="L567">              segments[part].append(ch);</span>
            }
<span class="nc" id="L569">            break;</span>
          case '{':
<span class="nc" id="L571">            ++braceStack;</span>
<span class="nc" id="L572">            segments[part].append(ch);</span>
<span class="nc" id="L573">            break;</span>
          case '}':
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (braceStack == 0) {</span>
<span class="nc" id="L576">              part = SEG_RAW;</span>
<span class="nc" id="L577">              makeFormat(formatNumber, segments);</span>
<span class="nc" id="L578">              formatNumber++;</span>
              // throw away other segments
<span class="nc" id="L580">              segments[SEG_INDEX] = null;</span>
<span class="nc" id="L581">              segments[SEG_TYPE] = null;</span>
<span class="nc" id="L582">              segments[SEG_MODIFIER] = null;</span>
            } else {
<span class="nc" id="L584">              --braceStack;</span>
<span class="nc" id="L585">              segments[part].append(ch);</span>
            }
<span class="nc" id="L587">            break;</span>
          case ' ':
            // Skip any leading space chars for SEG_TYPE.
<span class="nc bnc" id="L590" title="All 4 branches missed.">            if (part != SEG_TYPE || segments[SEG_TYPE].length() &gt; 0) {</span>
<span class="nc" id="L591">              segments[part].append(ch);</span>
            }
            break;
          case '\'':
<span class="nc" id="L595">            inQuote = true;</span>
          // fall through, so we keep quotes in other parts
          default:
<span class="nc" id="L598">            segments[part].append(ch);</span>
            break;
        }
      }
    }
<span class="nc bnc" id="L603" title="All 4 branches missed.">    if (braceStack == 0 &amp;&amp; part != 0) {</span>
<span class="nc" id="L604">      maxOffset = -1;</span>
<span class="nc" id="L605">      throw new IllegalArgumentException(&quot;Unmatched braces in the pattern: &quot; + pattern);</span>
    }
<span class="nc" id="L607">    this.pattern = segments[0];</span>
<span class="nc" id="L608">  }</span>

  /**
   * Returns a pattern representing the current state of the message format. The string is constructed from internal
   * information and therefore does not necessarily equal the previously applied pattern.
   *
   * @return a pattern representing the current state of the message format
   */
  @SuppressFBWarnings({&quot;CLI_CONSTANT_LIST_INDEX&quot;, &quot;ITC_INHERITANCE_TYPE_CHECKING&quot;})
  public String toPattern() {
    // later, make this more extensible
<span class="nc" id="L619">    int lastOffset = 0;</span>
<span class="nc" id="L620">    StringBuilder result = new StringBuilder();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxOffset; ++i) {</span>
<span class="nc" id="L622">      FormatInfo finfo = formats[i];</span>
<span class="nc" id="L623">      int offset = finfo.getOffset();</span>
<span class="nc" id="L624">      copyAndFixQuotes(pattern, lastOffset, offset, result);</span>
<span class="nc" id="L625">      lastOffset = offset;</span>
<span class="nc" id="L626">      result.append('{').append(finfo.getArgumentNumber());</span>
<span class="nc" id="L627">      Format fmt = finfo.getFormat();</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">      if (fmt instanceof NumberFormat) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (fmt.equals(NumberFormat.getInstance(locale))) {</span>
<span class="nc" id="L630">          result.append(&quot;,number&quot;);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {</span>
<span class="nc" id="L632">          result.append(&quot;,number,currency&quot;);</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">        } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {</span>
<span class="nc" id="L634">          result.append(&quot;,number,percent&quot;);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">        } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {</span>
<span class="nc" id="L636">          result.append(&quot;,number,integer&quot;);</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">        } else if (fmt instanceof DecimalFormat) {</span>
<span class="nc" id="L638">          result.append(&quot;,number,&quot;).append(((DecimalFormat) fmt).toPattern());</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        } else if (fmt instanceof ChoiceFormat) {</span>
<span class="nc" id="L640">          result.append(&quot;,choice,&quot;).append(((ChoiceFormat) fmt).toPattern());</span>
        } else {
<span class="nc" id="L642">          throw new UnsupportedOperationException(&quot;Unsupported format &quot; + fmt);</span>
        }
<span class="nc bnc" id="L644" title="All 2 branches missed.">      } else if (fmt instanceof DateFormat) {</span>
        int index;
<span class="nc bnc" id="L646" title="All 2 branches missed.">        for (index = MODIFIER_DEFAULT; index &lt; DATE_TIME_MODIFIERS.length; index++) {</span>
<span class="nc" id="L647">          DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index],</span>
                  locale);
<span class="nc bnc" id="L649" title="All 2 branches missed.">          if (fmt.equals(df)) {</span>
<span class="nc" id="L650">            result.append(&quot;,date&quot;);</span>
<span class="nc" id="L651">            break;</span>
          }
<span class="nc" id="L653">          df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index],</span>
                  locale);
<span class="nc bnc" id="L655" title="All 2 branches missed.">          if (fmt.equals(df)) {</span>
<span class="nc" id="L656">            result.append(&quot;,time&quot;);</span>
<span class="nc" id="L657">            break;</span>
          }
        }
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (index &gt;= DATE_TIME_MODIFIERS.length) {</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">          if (fmt instanceof SimpleDateFormat) {</span>
<span class="nc" id="L662">            result.append(&quot;,date,&quot;).append(((SimpleDateFormat) fmt).toPattern());</span>
          } else {
<span class="nc" id="L664">            throw new UnsupportedOperationException(&quot;Unsupported format &quot; + fmt);</span>
          }
<span class="nc bnc" id="L666" title="All 2 branches missed.">        } else if (index != MODIFIER_DEFAULT) {</span>
<span class="nc" id="L667">          result.append(',').append(DATE_TIME_MODIFIER_KEYWORDS[index]);</span>
        }
<span class="nc bnc" id="L669" title="All 2 branches missed.">      } else if (fmt != null) {</span>
<span class="nc" id="L670">        throw new UnsupportedOperationException(&quot;Unsupported format &quot; + fmt);</span>
      }
<span class="nc" id="L672">      result.append('}');</span>
    }
<span class="nc" id="L674">    copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);</span>
<span class="nc" id="L675">    return result.toString();</span>
  }

  /**
   * Sets the formats to use for the values passed into &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
   * methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt; correspond to the argument indices used in the
   * previously set pattern string. The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to the order of
   * elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
   * by the &lt;code&gt;parse&lt;/code&gt; methods.
   * &lt;p&gt;
   * If an argument index is used for more than one format element in the pattern string, then the corresponding new
   * format is used for all such format elements. If an argument index is not used for any format element in the pattern
   * string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the
   * formats for argument indices less than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.
   *
   * @param newFormats the new formats to use
   * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null
   * @since 1.4
   */
  public void setFormatsByArgumentIndex(Format[] newFormats) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxOffset; i++) {</span>
<span class="nc" id="L696">      final FormatInfo finfo = formats[i];</span>
<span class="nc" id="L697">      int j = finfo.getArgumentNumber();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">      if (j &lt; newFormats.length) {</span>
<span class="nc" id="L699">        formats[i] = new FormatInfo(newFormats[j], finfo.getOffset(), j);</span>
      }
    }
<span class="nc" id="L702">  }</span>

  /**
   * Sets the formats to use for the format elements in the previously set pattern string. The order of formats in
   * &lt;code&gt;newFormats&lt;/code&gt; corresponds to the order of format elements in the pattern string.
   * &lt;p&gt;
   * If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats
   * are provided than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt; formats are replaced.
   * &lt;p&gt;
   * Since the order of format elements in a pattern string often changes during localization, it is generally better to
   * use the {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex} method, which assumes an order of formats
   * corresponding to the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to the &lt;code&gt;format&lt;/code&gt;
   * methods or the result array returned by the &lt;code&gt;parse&lt;/code&gt; methods.
   *
   * @param newFormats the new formats to use
   * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null
   */
  public void setFormats(Format[] newFormats) {
<span class="nc" id="L720">    int runsToCopy = newFormats.length;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">    if (runsToCopy &gt; maxOffset + 1) {</span>
<span class="nc" id="L722">      runsToCopy = maxOffset + 1;</span>
    }
<span class="nc bnc" id="L724" title="All 2 branches missed.">    for (int i = 0; i &lt; runsToCopy; i++) {</span>
<span class="nc" id="L725">      FormatInfo finfo = formats[i];</span>
<span class="nc" id="L726">      formats[i] = new FormatInfo(newFormats[i], finfo.getOffset(), finfo.getArgumentNumber());</span>
    }
<span class="nc" id="L728">  }</span>

  /**
   * Sets the format to use for the format elements within the previously set pattern string that use the given argument
   * index. The argument index is part of the format element definition and represents an index into the
   * &lt;code&gt;arguments&lt;/code&gt; array passed to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by the
   * &lt;code&gt;parse&lt;/code&gt; methods.
   * &lt;p&gt;
   * If the argument index is used for more than one format element in the pattern string, then the new format is used
   * for all such format elements. If the argument index is not used for any format element in the pattern string, then
   * the new format is ignored.
   *
   * @param argumentIndex the argument index for which to use the new format
   * @param newFormat the new format to use
   * @since 1.4
   */
  public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
<span class="nc bnc" id="L745" title="All 2 branches missed.">    for (int j = 0; j &lt;= maxOffset; j++) {</span>
<span class="nc" id="L746">      FormatInfo finfo = formats[j];</span>
<span class="nc" id="L747">      int argNr = finfo.getArgumentNumber();</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">      if (argNr == argumentIndex) {</span>
<span class="nc" id="L749">        formats[j] = new FormatInfo(newFormat, finfo.getOffset(), argNr);</span>
      }
    }
<span class="nc" id="L752">  }</span>

  /**
   * Sets the format to use for the format element with the given format element index within the previously set pattern
   * string. The format element index is the zero-based number of the format element counting from the start of the
   * pattern string.
   * &lt;p&gt;
   * Since the order of format elements in a pattern string often changes during localization, it is generally better to
   * use the {@link #setFormatByArgumentIndex setFormatByArgumentIndex} method, which accesses format elements based on
   * the argument index they specify.
   *
   * @param formatElementIndex the index of a format element within the pattern
   * @param newFormat the format to use for the specified format element
   * @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or larger than the number of
   * format elements in the pattern string
   */
  public void setFormat(int formatElementIndex, Format newFormat) {
<span class="nc" id="L769">    FormatInfo finfo = formats[formatElementIndex];</span>
<span class="nc" id="L770">    formats[formatElementIndex] = new FormatInfo(newFormat, finfo.getOffset(), finfo.getArgumentNumber());</span>
<span class="nc" id="L771">  }</span>

  /**
   * Gets the formats used for the values passed into &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
   * methods. The indices of elements in the returned array correspond to the argument indices used in the previously
   * set pattern string. The order of formats in the returned array thus corresponds to the order of elements in the
   * &lt;code&gt;arguments&lt;/code&gt; array passed to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by the
   * &lt;code&gt;parse&lt;/code&gt; methods.
   * &lt;p&gt;
   * If an argument index is used for more than one format element in the pattern string, then the format used for the
   * last such format element is returned in the array. If an argument index is not used for any format element in the
   * pattern string, then null is returned in the array.
   *
   * @return the formats used for the arguments within the pattern
   * @since 1.4
   */
//    public Format[] getFormatsByArgumentIndex() {
//        int maximumArgumentNumber = -1;
//        for (int i = 0; i &lt;= maxOffset; i++) {
//            if (argumentNumbers[i] &gt; maximumArgumentNumber) {
//                maximumArgumentNumber = argumentNumbers[i];
//            }
//        }
//        Format[] resultArray = new Format[maximumArgumentNumber + 1];
//        for (int i = 0; i &lt;= maxOffset; i++) {
//            resultArray[argumentNumbers[i]] = formats[i];
//        }
//        return resultArray;
//    }
  /**
   * Gets the formats used for the format elements in the previously set pattern string. The order of formats in the
   * returned array corresponds to the order of format elements in the pattern string.
   * &lt;p&gt;
   * Since the order of format elements in a pattern string often changes during localization, it's generally better to
   * use the {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex} method, which assumes an order of formats
   * corresponding to the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to the &lt;code&gt;format&lt;/code&gt;
   * methods or the result array returned by the &lt;code&gt;parse&lt;/code&gt; methods.
   *
   * @return the formats used for the format elements in the pattern
   */
  public Format[] getFormats() {
<span class="nc" id="L812">    Format[] resultArray = new Format[maxOffset + 1];</span>
<span class="nc" id="L813">    System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);</span>
<span class="nc" id="L814">    return resultArray;</span>
  }

  /**
   * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;'s pattern, with format elements replaced by
   * the formatted objects, to the provided &lt;code&gt;StringBuffer&lt;/code&gt;.
   * &lt;p&gt;
   * The text substituted for the individual format elements is derived from the current subformat of the format element
   * and the &lt;code&gt;arguments&lt;/code&gt; element at the format element's argument index as indicated by the first matching
   * line of the following table. An argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
   * has fewer than argumentIndex+1 elements.
   *
   * &lt;table border=1 summary=&quot;Examples of subformat,argument,and formatted text&quot;&gt;
   * &lt;tr&gt;
   * &lt;th&gt;Subformat
   * &lt;th&gt;Argument
   * &lt;th&gt;Formatted Text
   * &lt;tr&gt;
   * &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
   * &lt;td&gt;&lt;i&gt;unavailable&lt;/i&gt;
   * &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
   * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;
   * &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
   * &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf('{') &amp;gt;= 0 ?&lt;br&gt;
   * (new MessageFormat(subformat.format(argument), getLocale())).format(argument) : subformat.format(argument)&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;code&gt;!= null&lt;/code&gt;
   * &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
   * &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;instanceof Number&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;instanceof Date&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;instanceof String&lt;/code&gt;
   * &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;
   * &lt;tr&gt;
   * &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
   * &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
   * &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;
   * &lt;/table&gt;
   * &lt;p&gt;
   * If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted
   * string will be returned.
   *
   * @param arguments an array of objects to be formatted and substituted.
   * @param result where text is appended.
   * @param pos On input: an alignment field, if desired. On output: the offsets of the alignment field.
   * @return the string buffer passed in as {@code result}, with formatted text appended
   * @exception IllegalArgumentException if an argument in the &lt;code&gt;arguments&lt;/code&gt; array is not of the type expected
   * by the format element(s) that use it.
   */
  public final &lt;T extends CharSequence &amp; Appendable&gt; T format(Object[] arguments, T result,
          @Nullable FieldPosition pos) throws IOException {
<span class="nc" id="L878">    return subformat(arguments, result, pos, null);</span>
  }

  public final &lt;T extends CharSequence &amp; Appendable&gt; T format(Object[] arguments, T result) throws IOException {
<span class="nc" id="L882">    return format(arguments, result, null);</span>
  }

  /**
   * Creates a MessageFormat with the given pattern and uses it to format the given arguments. This is equivalent to
   * &lt;blockquote&gt;
   * &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments,
   * new StringBuffer(), null).toString()&lt;/code&gt;
   * &lt;/blockquote&gt;
   *
   * @param pattern the pattern string
   * @param arguments object(s) to format
   * @return the formatted string
   * @exception IllegalArgumentException if the pattern is invalid, or if an argument in the &lt;code&gt;arguments&lt;/code&gt;
   * array is not of the type expected by the format element(s) that use it.
   */
  public static String format(String pattern, Object... arguments) {
<span class="nc" id="L899">    MessageFormat temp = new MessageFormat(pattern);</span>
<span class="nc" id="L900">    return temp.format(arguments);</span>
  }

  // Overrides
  /**
   * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;'s pattern, with format elements replaced by
   * the formatted objects, to the provided &lt;code&gt;StringBuffer&lt;/code&gt;. This is equivalent to
   * &lt;blockquote&gt;
   * &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[])
   * arguments, result, pos)&lt;/code&gt;
   * &lt;/blockquote&gt;
   *
   * @param arguments an array of objects to be formatted and substituted.
   * @param result where text is appended.
   * @param pos On input: an alignment field, if desired. On output: the offsets of the alignment field.
   * @exception IllegalArgumentException if an argument in the &lt;code&gt;arguments&lt;/code&gt; array is not of the type expected
   * by the format element(s) that use it.
   */
  public final &lt;T extends CharSequence &amp; Appendable&gt; T format(Object arguments, T result,
          FieldPosition pos) throws IOException {
<span class="nc bnc" id="L920" title="All 2 branches missed.">    if (arguments instanceof Object[]) {</span>
<span class="nc" id="L921">      return subformat((Object[]) arguments, result, pos, null);</span>
    } else {
<span class="nc" id="L923">      return subformat(new Object [] {arguments}, result, pos, null);</span>
    }
  }

  /**
   * Formats an array of objects and inserts them into the &lt;code&gt;MessageFormat&lt;/code&gt;'s pattern, producing an
   * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;. You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; to
   * build the resulting String, as well as to determine information about the resulting String.
   * &lt;p&gt;
   * The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is the same that would be returned by
   * &lt;blockquote&gt;
   * &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new
   * StringBuffer(), null).toString()&lt;/code&gt;
   * &lt;/blockquote&gt;
   * &lt;p&gt;
   * In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at least attributes indicating where text was
   * generated from an argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of type
   * &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the
   * &lt;code&gt;arguments&lt;/code&gt; array of the argument from which the text was generated.
   * &lt;p&gt;
   * The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt; instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will
   * also be placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;. This allows you to not only find where an
   * argument is placed in the resulting String, but also which fields it contains in turn.
   *
   * @param arguments an array of objects to be formatted and substituted.
   * @return AttributedCharacterIterator describing the formatted value.
   * @exception NullPointerException if &lt;code&gt;arguments&lt;/code&gt; is null.
   * @exception IllegalArgumentException if an argument in the &lt;code&gt;arguments&lt;/code&gt; array is not of the type expected
   * by the format element(s) that use it.
   * @since 1.4
   */
  public AttributedCharacterIterator formatToCharacterIterator(@Nonnull Object arguments) {
<span class="nc" id="L955">    StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L956">    ArrayList&lt;AttributedCharacterIterator&gt; iterators = new ArrayList&lt;&gt;();</span>
    try {
<span class="nc" id="L958">      subformat((Object[]) arguments, result, null, iterators);</span>
<span class="nc" id="L959">    } catch (IOException ex) {</span>
<span class="nc" id="L960">      throw new UncheckedIOException(ex);</span>
<span class="nc" id="L961">    }</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">    if (iterators.isEmpty()) {</span>
<span class="nc" id="L963">      return createAttributedCharacterIterator(&quot;&quot;);</span>
    }
<span class="nc" id="L965">    return new AttributedString(</span>
<span class="nc" id="L966">            iterators.toArray(</span>
<span class="nc" id="L967">                    new AttributedCharacterIterator[iterators.size()])).getIterator();</span>
  }

  /**
   * Parses the string.
   *
   * &lt;p&gt;
   * Caveats: The parse may fail in a number of circumstances. For example:
   * &lt;ul&gt;
   * &lt;li&gt;If one of the arguments does not occur in the pattern.
   * &lt;li&gt;If the format of an argument loses information, such as with a choice format where a large number formats to
   * &quot;many&quot;.
   * &lt;li&gt;Does not yet handle recursion (where the substituted strings contain {n} references.)
   * &lt;li&gt;Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the
   * pattern &quot;{1},{2}&quot; is used with the string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;. When the result is
   * parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
   * &lt;li&gt;If a single argument is parsed more than once in the string, then the later parse wins.
   * &lt;/ul&gt;
   * When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The
   * returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if
   * the parsing string &quot;AAA {0} BBB&quot; is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is 0. When an
   * error occurs, the call to this method will return null. If the source is null, return an empty array. (zoltan:
   * yuck)
   *
   *
   * @param source the string to parse
   * @param pos the parse position
   * @return an array of parsed objects
   */
  @Nullable
  @SuppressFBWarnings({&quot;PZLA_PREFER_ZERO_LENGTH_ARRAYS&quot;, &quot;STT_STRING_PARSING_A_FIELD&quot;}) // maintaining JDK behavior
  public Object[] parse(@Nullable String source, @Nonnull ParsePosition pos) {

<span class="nc bnc" id="L1000" title="All 2 branches missed.">    if (source == null) {</span>
<span class="nc" id="L1001">      return org.spf4j.base.Arrays.EMPTY_OBJ_ARRAY;</span>
    }

<span class="nc" id="L1004">    int maximumArgumentNumber = -1;</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxOffset; i++) {</span>
<span class="nc" id="L1006">      FormatInfo finfo = formats[i];</span>
<span class="nc" id="L1007">      final int argumentNumber = finfo.getArgumentNumber();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">      if (argumentNumber &gt; maximumArgumentNumber) {</span>
<span class="nc" id="L1009">        maximumArgumentNumber = argumentNumber;</span>
      }
    }
<span class="nc" id="L1012">    Object[] resultArray = new Object[maximumArgumentNumber + 1];</span>

<span class="nc" id="L1014">    int patternOffset = 0;</span>
<span class="nc" id="L1015">    int sourceOffset = pos.getIndex();</span>
<span class="nc" id="L1016">    ParsePosition tempStatus = new ParsePosition(0);</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxOffset; ++i) {</span>
      // match up to format
<span class="nc" id="L1019">      FormatInfo finfo = formats[i];</span>
<span class="nc" id="L1020">      int len = finfo.getOffset() - patternOffset;</span>
<span class="nc bnc" id="L1021" title="All 4 branches missed.">      if (len == 0 || CharSequences.regionMatches(pattern, patternOffset, source, sourceOffset, len)) {</span>
<span class="nc" id="L1022">        sourceOffset += len;</span>
<span class="nc" id="L1023">        patternOffset += len;</span>
      } else {
<span class="nc" id="L1025">        pos.setErrorIndex(sourceOffset);</span>
<span class="nc" id="L1026">        return null;</span>
      }

      // now use format
<span class="nc bnc" id="L1030" title="All 2 branches missed.">      if (finfo.getFormat() == null) {   // string format</span>
        // if at end, use longest possible match
        // otherwise uses first match to intervening string
        // does NOT recursively try all possibilities
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        int tempLength = (i != maxOffset) ? formats[i + 1].getOffset() : pattern.length();</span>

        int next;
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (patternOffset &gt;= tempLength) {</span>
<span class="nc" id="L1038">          next = source.length();</span>
        } else {
<span class="nc" id="L1040">          next = source.indexOf(pattern.subSequence(patternOffset, tempLength).toString(), sourceOffset);</span>
        }

<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (next &lt; 0) {</span>
<span class="nc" id="L1044">          pos.setErrorIndex(sourceOffset);</span>
<span class="nc" id="L1045">          return null;</span>
        } else {
<span class="nc" id="L1047">          String strValue = source.substring(sourceOffset, next);</span>
<span class="nc" id="L1048">          int argNr = finfo.getArgumentNumber();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">          if (!strValue.equals(&quot;{&quot; + argNr + &quot;}&quot;)) {</span>
<span class="nc" id="L1050">            resultArray[argNr] = source.substring(sourceOffset, next);</span>
          }
<span class="nc" id="L1052">          sourceOffset = next;</span>
        }
<span class="nc" id="L1054">      } else {</span>
<span class="nc" id="L1055">        tempStatus.setIndex(sourceOffset);</span>
<span class="nc" id="L1056">        resultArray[finfo.getArgumentNumber()] = finfo.getFormat().parseObject(source, tempStatus);</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">        if (tempStatus.getIndex() == sourceOffset) {</span>
<span class="nc" id="L1058">          pos.setErrorIndex(sourceOffset);</span>
<span class="nc" id="L1059">          return null; // leave index as is to signal error</span>
        }
<span class="nc" id="L1061">        sourceOffset = tempStatus.getIndex(); // update</span>
      }
    }
<span class="nc" id="L1064">    int len = pattern.length() - patternOffset;</span>
<span class="nc bnc" id="L1065" title="All 4 branches missed.">    if (len == 0 || CharSequences.regionMatches(pattern, patternOffset, source, sourceOffset, len)) {</span>
<span class="nc" id="L1066">      pos.setIndex(sourceOffset + len);</span>
    } else {
<span class="nc" id="L1068">      pos.setErrorIndex(sourceOffset);</span>
<span class="nc" id="L1069">      return null;</span>
    }
<span class="nc" id="L1071">    return resultArray;</span>
  }

  /**
   * Parses text from the beginning of the given string to produce an object array. The method may not use the entire
   * text of the given string.
   * &lt;p&gt;
   * See the {@link #parse(String, ParsePosition)} method for more information on message parsing.
   *
   * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.
   * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.
   * @exception ParseException if the beginning of the specified string cannot be parsed.
   */
  @Nullable
  public Object[] parse(String source) throws ParseException {
<span class="nc" id="L1086">    ParsePosition pos = new ParsePosition(0);</span>
<span class="nc" id="L1087">    Object[] result = parse(source, pos);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">    if (pos.getIndex() == 0) // unchanged, returned object is null</span>
    {
<span class="nc" id="L1090">      throw new ParseException(&quot;MessageFormat source = &quot; + source + &quot; parse error!&quot;, pos.getErrorIndex());</span>
    }

<span class="nc" id="L1093">    return result;</span>
  }

  /**
   * Parses text from a string to produce an object array.
   * &lt;p&gt;
   * The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the
   * index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use
   * all characters up to the end of the string), and the parsed object array is returned. The updated &lt;code&gt;pos&lt;/code&gt;
   * can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of
   * &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the
   * error occurred, and null is returned.
   * &lt;p&gt;
   * See the {@link #parse(String, ParsePosition)} method for more information on message parsing.
   *
   * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
   * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error index information as described above.
   * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of error, returns null.
   * @exception NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.
   */
  @Nullable
  public Object parseObject(String source, ParsePosition pos) {
<span class="nc" id="L1115">    return parse(source, pos);</span>
  }

  /**
   * Creates and returns a copy of this object.
   *
   * @return a clone of this instance.
   */
  public MessageFormat clone() {
<span class="nc" id="L1124">    MessageFormat other = (MessageFormat) super.clone();</span>

    // clone arrays. Can't do with utility because of bug in Cloneable
<span class="nc" id="L1127">    other.formats = formats.clone(); // shallow clone</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">    for (int i = 0; i &lt; formats.length; ++i) {</span>
<span class="nc" id="L1129">      FormatInfo finfo = formats[i];</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">      if (finfo != null) {</span>
<span class="nc" id="L1131">        other.formats[i] = finfo.clone();</span>
      }
    }
<span class="nc" id="L1134">    return other;</span>
  }

  /**
   * Equality comparison between two message format objects
   */
  public boolean equals(Object obj) {
<span class="nc bnc" id="L1141" title="All 2 branches missed.">    if (this == obj) // quick check</span>
    {
<span class="nc" id="L1143">      return true;</span>
    }
<span class="nc bnc" id="L1145" title="All 4 branches missed.">    if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L1146">      return false;</span>
    }
<span class="nc" id="L1148">    MessageFormat other = (MessageFormat) obj;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">    return (maxOffset == other.maxOffset</span>
<span class="nc bnc" id="L1150" title="All 4 branches missed.">            &amp;&amp; CharSequences.equals(pattern, other.pattern)</span>
<span class="nc bnc" id="L1151" title="All 6 branches missed.">            &amp;&amp; ((locale != null &amp;&amp; locale.equals(other.locale))</span>
            || (locale == null &amp;&amp; other.locale == null))
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            &amp;&amp; Arrays.equals(formats, other.formats));</span>
  }

  /**
   * Generates a hash code for the message format object.
   */
  public int hashCode() {
<span class="nc" id="L1160">    int h = hash;</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">    if (h == 0) {</span>
<span class="nc" id="L1162">      h = CharSequences.hashcode(pattern);</span>
<span class="nc" id="L1163">      hash = h;</span>
    }
<span class="nc" id="L1165">    return h;</span>
  }

  @Override
  public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    try {
<span class="nc" id="L1171">      return syntethicFormat(obj, toAppendTo, pos);</span>
<span class="nc" id="L1172">    } catch (IOException ex) {</span>
<span class="nc" id="L1173">      throw new UncheckedIOException(ex);</span>
    }
  }

  private &lt;T extends CharSequence &amp; Appendable&gt; T syntethicFormat(Object obj, T toAppendTo, FieldPosition pos)
          throws IOException {
<span class="nc" id="L1179">    return format(obj, toAppendTo, pos);</span>
  }


  /**
   * Internal routine used by format. If &lt;code&gt;characterIterators&lt;/code&gt; is non-null, AttributedCharacterIterator will
   * be created from the sub-formats as necessary. If &lt;code&gt;characterIterators&lt;/code&gt; is null and &lt;code&gt;fp&lt;/code&gt; is
   * non-null and identifies &lt;code&gt;Field.MESSAGE_ARGUMENT&lt;/code&gt;, the location of the first replaced argument will be
   * set in it.
   *
   * @exception IllegalArgumentException if an argument in the &lt;code&gt;arguments&lt;/code&gt; array is not of the type expected
   * by the format element(s) that use it.
   */
  @SuppressFBWarnings({&quot;PDP_POORLY_DEFINED_PARAMETER&quot;, &quot;PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS&quot;}) // Unfortunately I have no other way to write this
  // without code duplication to work for StringBuilder and StringBuffer....
   private &lt;T extends Appendable &amp; CharSequence&gt; T subformat(@Nullable Object[] arguments, @Nonnull T result,
          @Nullable FieldPosition fp,
          @Nullable List&lt;AttributedCharacterIterator&gt; characterIterators)
          throws IOException {
<span class="nc" id="L1198">    int lastOffset = 0;</span>
<span class="nc" id="L1199">    int last = result.length();</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxOffset; ++i) {</span>
<span class="nc" id="L1201">      FormatInfo finfo = formats[i];</span>
<span class="nc" id="L1202">      int offset = finfo.getOffset();</span>
<span class="nc" id="L1203">      result.append(pattern, lastOffset, offset);</span>
<span class="nc" id="L1204">      lastOffset = offset;</span>
<span class="nc" id="L1205">      int argumentNumber = finfo.getArgumentNumber();</span>
<span class="nc bnc" id="L1206" title="All 4 branches missed.">      if (arguments == null || argumentNumber &gt;= arguments.length) {</span>
<span class="nc" id="L1207">        result.append('{').append(Integer.toString(argumentNumber)).append('}');</span>
<span class="nc" id="L1208">        continue;</span>
      }
<span class="nc" id="L1210">      Object obj = arguments[argumentNumber];</span>
<span class="nc" id="L1211">      String arg = null;</span>
<span class="nc" id="L1212">      Format subFormatter = null;</span>
<span class="nc" id="L1213">      Format fmt = finfo.getFormat();</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">      if (obj == null) {</span>
<span class="nc" id="L1215">        arg = &quot;null&quot;;</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">      } else if (fmt != null) {</span>
<span class="nc" id="L1217">        subFormatter = fmt;</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (subFormatter instanceof ChoiceFormat) {</span>
<span class="nc" id="L1219">          arg = subFormatter.format(obj);</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">          if (arg.indexOf('{') &gt;= 0) {</span>
<span class="nc" id="L1221">            subFormatter = new MessageFormat(arg, locale);</span>
<span class="nc" id="L1222">            obj = arguments;</span>
<span class="nc" id="L1223">            arg = null;</span>
          }
        }
<span class="nc bnc" id="L1226" title="All 2 branches missed.">      } else if (obj instanceof Number) {</span>
        // format number if can
<span class="nc" id="L1228">        subFormatter = NumberFormat.getInstance(locale);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">      } else if (obj instanceof Date) {</span>
        // format a Date if can
<span class="nc" id="L1231">        subFormatter = DateFormat.getDateTimeInstance(</span>
                DateFormat.SHORT, DateFormat.SHORT, locale);//fix
<span class="nc bnc" id="L1233" title="All 2 branches missed.">      } else if (obj instanceof String) {</span>
<span class="nc" id="L1234">        arg = (String) obj;</span>

      } else {
<span class="nc" id="L1237">        arg = obj.toString();</span>
      }

      // At this point we are in two states, either subFormatter
      // is non-null indicating we should format obj using it,
      // or arg is non-null and we should use it as the value.
<span class="nc bnc" id="L1243" title="All 2 branches missed.">      if (characterIterators != null) {</span>
        // If characterIterators is non-null, it indicates we need
        // to get the CharacterIterator from the child formatter.
<span class="nc" id="L1246">        int cl = result.length();</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if (last != cl) {</span>
<span class="nc" id="L1248">          characterIterators.add(</span>
<span class="nc" id="L1249">                  createAttributedCharacterIterator(result.subSequence(last, cl).toString()));</span>
<span class="nc" id="L1250">          last = cl;</span>
        }
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if (subFormatter != null) {</span>
<span class="nc" id="L1253">          AttributedCharacterIterator subIterator</span>
<span class="nc" id="L1254">                  = subFormatter.formatToCharacterIterator(obj);</span>

<span class="nc" id="L1256">          append(result, subIterator);</span>
<span class="nc" id="L1257">          int cl2 = result.length();</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">          if (last != cl2) {</span>
<span class="nc" id="L1259">            characterIterators.add(</span>
<span class="nc" id="L1260">                    createAttributedCharacterIterator(</span>
                            subIterator, java.text.MessageFormat.Field.ARGUMENT,
<span class="nc" id="L1262">                            Integer.valueOf(argumentNumber)));</span>
<span class="nc" id="L1263">            last = cl2;</span>
          }
<span class="nc" id="L1265">          arg = null;</span>
        }
<span class="nc bnc" id="L1267" title="All 4 branches missed.">        if (arg != null &amp;&amp; arg.length() &gt; 0) {</span>
<span class="nc" id="L1268">          result.append(arg);</span>
<span class="nc" id="L1269">          characterIterators.add(</span>
<span class="nc" id="L1270">                  createAttributedCharacterIterator(</span>
                          arg, java.text.MessageFormat.Field.ARGUMENT,
<span class="nc" id="L1272">                          Integer.valueOf(argumentNumber)));</span>
<span class="nc" id="L1273">          last = result.length();</span>
        }
<span class="nc" id="L1275">      } else {</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if (subFormatter != null) {</span>
<span class="nc" id="L1277">          arg = subFormatter.format(obj);</span>
        }
<span class="nc" id="L1279">        last = result.length();</span>
<span class="nc" id="L1280">        result.append(arg);</span>
<span class="nc bnc" id="L1281" title="All 6 branches missed.">        if (i == 0 &amp;&amp; fp != null &amp;&amp; java.text.MessageFormat.Field.ARGUMENT.equals(</span>
<span class="nc" id="L1282">                fp.getFieldAttribute())) {</span>
<span class="nc" id="L1283">          fp.setBeginIndex(last);</span>
<span class="nc" id="L1284">          fp.setEndIndex(result.length());</span>
        }
<span class="nc" id="L1286">        last = result.length();</span>
      }

    }
<span class="nc" id="L1290">    result.append(pattern, lastOffset, pattern.length());</span>
<span class="nc bnc" id="L1291" title="All 4 branches missed.">    if (characterIterators != null &amp;&amp; last != result.length()) {</span>
<span class="nc" id="L1292">      characterIterators.add(createAttributedCharacterIterator(result.subSequence(last, result.length()).toString()));</span>
    }
<span class="nc" id="L1294">    return result;</span>
  }

  /**
   * Convenience method to append all the characters in &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.
   */
  private static void append(Appendable result, CharacterIterator iterator) throws IOException {
<span class="nc" id="L1301">    final char first = iterator.first();</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">    if (first != CharacterIterator.DONE) {</span>
<span class="nc" id="L1303">      result.append(first);</span>
      char aChar;
<span class="nc bnc" id="L1305" title="All 2 branches missed.">      while ((aChar = iterator.next()) != CharacterIterator.DONE) {</span>
<span class="nc" id="L1306">        result.append(aChar);</span>
      }
    }
<span class="nc" id="L1309">  }</span>


  @SuppressFBWarnings(&quot;CLI_CONSTANT_LIST_INDEX&quot;) //jdk inherited
  private void makeFormat(int offsetNumber, StringBuilder[] textSegments) {
<span class="nc" id="L1314">    String[] segments = new String[textSegments.length];</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">    for (int i = 0; i &lt; textSegments.length; i++) {</span>
<span class="nc" id="L1316">      StringBuilder oneseg = textSegments[i];</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">      segments[i] = (oneseg != null) ? oneseg.toString() : &quot;&quot;;</span>
    }

    // get the argument number
    int argumentNumber;
    try {
<span class="nc" id="L1323">      argumentNumber = Integer.parseInt(segments[SEG_INDEX]);</span>
<span class="nc" id="L1324">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L1325">      throw new IllegalArgumentException(&quot;can't parse argument number: &quot; + segments[SEG_INDEX], e);</span>
<span class="nc" id="L1326">    }</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">    if (argumentNumber &lt; 0) {</span>
<span class="nc" id="L1328">      throw new IllegalArgumentException(&quot;negative argument number: &quot; + argumentNumber);</span>
    }

    // resize format information arrays if necessary
<span class="nc bnc" id="L1332" title="All 2 branches missed.">    if (offsetNumber &gt;= formats.length) {</span>
<span class="nc" id="L1333">      int newLength = Math.max(4, formats.length &lt;&lt; 2);</span>
<span class="nc" id="L1334">      FormatInfo[] newFormats = new FormatInfo[newLength];</span>
<span class="nc" id="L1335">      System.arraycopy(formats, 0, newFormats, 0, maxOffset + 1);</span>
<span class="nc" id="L1336">      formats = newFormats;</span>
    }
<span class="nc" id="L1338">    int oldMaxOffset = maxOffset;</span>
<span class="nc" id="L1339">    maxOffset = offsetNumber;</span>

    // now get the format
<span class="nc" id="L1342">    Format newFormat = null;</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">    if (segments[SEG_TYPE].length() != 0) {</span>
<span class="nc" id="L1344">      int type = findKeyword(segments[SEG_TYPE], TYPE_KEYWORDS);</span>
<span class="nc bnc" id="L1345" title="All 5 branches missed.">      switch (type) {</span>
        case TYPE_NULL:
          // Type &quot;&quot; is allowed. e.g., &quot;{0,}&quot;, &quot;{0,,}&quot;, and &quot;{0,,#}&quot;
          // are treated as &quot;{0}&quot;.
<span class="nc" id="L1349">          break;</span>

        case TYPE_NUMBER:
<span class="nc bnc" id="L1352" title="All 5 branches missed.">          switch (findKeyword(segments[SEG_MODIFIER], NUMBER_MODIFIER_KEYWORDS)) {</span>
            case MODIFIER_DEFAULT:
<span class="nc" id="L1354">              newFormat = NumberFormat.getInstance(locale);</span>
<span class="nc" id="L1355">              break;</span>
            case MODIFIER_CURRENCY:
<span class="nc" id="L1357">              newFormat = NumberFormat.getCurrencyInstance(locale);</span>
<span class="nc" id="L1358">              break;</span>
            case MODIFIER_PERCENT:
<span class="nc" id="L1360">              newFormat = NumberFormat.getPercentInstance(locale);</span>
<span class="nc" id="L1361">              break;</span>
            case MODIFIER_INTEGER:
<span class="nc" id="L1363">              newFormat = NumberFormat.getIntegerInstance(locale);</span>
<span class="nc" id="L1364">              break;</span>
            default: // DecimalFormat pattern
              try {
<span class="nc" id="L1367">                newFormat = new DecimalFormat(segments[SEG_MODIFIER],</span>
<span class="nc" id="L1368">                        DecimalFormatSymbols.getInstance(locale));</span>
<span class="nc" id="L1369">              } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1370">                maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1371">                throw e;</span>
<span class="nc" id="L1372">              }</span>
              break;
          }
          break;

        case TYPE_DATE:
        case TYPE_TIME:
<span class="nc" id="L1379">          int mod = findKeyword(segments[SEG_MODIFIER], DATE_TIME_MODIFIER_KEYWORDS);</span>
<span class="nc bnc" id="L1380" title="All 4 branches missed.">          if (mod &gt;= 0 &amp;&amp; mod &lt; DATE_TIME_MODIFIER_KEYWORDS.length) {</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">            if (type == TYPE_DATE) {</span>
<span class="nc" id="L1382">              newFormat = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[mod],</span>
                      locale);
            } else {
<span class="nc" id="L1385">              newFormat = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[mod],</span>
                      locale);
            }
          } else {
            // SimpleDateFormat pattern
            try {
<span class="nc" id="L1391">              newFormat = new SimpleDateFormat(segments[SEG_MODIFIER], locale);</span>
<span class="nc" id="L1392">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1393">              maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1394">              throw e;</span>
<span class="nc" id="L1395">            }</span>
          }
          break;

        case TYPE_CHOICE:
          try {
            // ChoiceFormat pattern
<span class="nc" id="L1402">            newFormat = new ChoiceFormat(segments[SEG_MODIFIER]);</span>
<span class="nc" id="L1403">          } catch (Exception e) {</span>
<span class="nc" id="L1404">            maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1405">            throw new IllegalArgumentException(&quot;Choice Pattern incorrect: &quot;</span>
                    + segments[SEG_MODIFIER], e);
<span class="nc" id="L1407">          }</span>
          break;

        default:
<span class="nc" id="L1411">          maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1412">          throw new IllegalArgumentException(&quot;unknown format type: &quot; + segments[SEG_TYPE]);</span>
      }
    }
<span class="nc" id="L1415">    formats[offsetNumber] = new FormatInfo(newFormat, segments[SEG_RAW].length(), argumentNumber);</span>
<span class="nc" id="L1416">  }</span>

  @SuppressFBWarnings(value = {&quot;ES_COMPARING_STRINGS_WITH_EQ&quot;}, justification = &quot;optimization&quot;)
  private static final int findKeyword(String s, String[] list) {
<span class="nc bnc" id="L1420" title="All 2 branches missed.">    for (int i = 0; i &lt; list.length; ++i) {</span>
<span class="nc bnc" id="L1421" title="All 2 branches missed.">      if (s.equals(list[i])) {</span>
<span class="nc" id="L1422">        return i;</span>
      }
    }

    // Try trimmed lowercase.
<span class="nc" id="L1427">    String ls = s.trim();</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">    if (ls != s) {</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">      for (int i = 0; i &lt; list.length; ++i) {</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">        if (ls.equalsIgnoreCase(list[i])) {</span>
<span class="nc" id="L1431">          return i;</span>
        }
      }
    }
<span class="nc" id="L1435">    return -1;</span>
  }

  private static final void copyAndFixQuotes(CharSequence source, int start, int end,
          StringBuilder target) {
<span class="nc" id="L1440">    boolean quoted = false;</span>

<span class="nc bnc" id="L1442" title="All 2 branches missed.">    for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L1443">      char ch = source.charAt(i);</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">      if (ch == '{') {</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">        if (!quoted) {</span>
<span class="nc" id="L1446">          target.append('\'');</span>
<span class="nc" id="L1447">          quoted = true;</span>
        }
<span class="nc" id="L1449">        target.append(ch);</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">      } else if (ch == '\'') {</span>
<span class="nc" id="L1451">        target.append(&quot;''&quot;);</span>
      } else {
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        if (quoted) {</span>
<span class="nc" id="L1454">          target.append('\'');</span>
<span class="nc" id="L1455">          quoted = false;</span>
        }
<span class="nc" id="L1457">        target.append(ch);</span>
      }
    }
<span class="nc bnc" id="L1460" title="All 2 branches missed.">    if (quoted) {</span>
<span class="nc" id="L1461">      target.append('\'');</span>
    }
<span class="nc" id="L1463">  }</span>

    private void writeObject(final java.io.ObjectOutputStream s)
        throws IOException {
        // Write out element count, and any hidden stuff
<span class="nc" id="L1468">        s.defaultWriteObject();</span>
<span class="nc" id="L1469">        s.writeUTF(pattern.toString());</span>
<span class="nc" id="L1470">    }</span>


  /**
   * After reading an object from the input stream, do a simple verification to maintain class invariants.
   *
   * @throws InvalidObjectException if the objects read from the stream is invalid.
   */
  @SuppressFBWarnings({&quot;WEM_WEAK_EXCEPTION_MESSAGING&quot;, &quot;DESERIALIZATION_GADGET&quot;})
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L1480">    in.defaultReadObject();</span>
<span class="nc" id="L1481">    pattern = in.readUTF();</span>
<span class="nc bnc" id="L1482" title="All 4 branches missed.">    boolean isValid = maxOffset &gt;= -1</span>
            &amp;&amp; formats.length &gt; maxOffset;
<span class="nc bnc" id="L1484" title="All 2 branches missed.">    if (isValid) {</span>
<span class="nc" id="L1485">      int lastOffset = pattern.length() + 1;</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">      for (int i = maxOffset; i &gt;= 0; --i) {</span>
<span class="nc" id="L1487">        FormatInfo finfo = formats[i];</span>
<span class="nc" id="L1488">        int offset = finfo.getOffset();</span>
<span class="nc bnc" id="L1489" title="All 4 branches missed.">        if ((offset &lt; 0) || (offset &gt; lastOffset)) {</span>
<span class="nc" id="L1490">          isValid = false;</span>
<span class="nc" id="L1491">          break;</span>
        } else {
<span class="nc" id="L1493">          lastOffset = offset;</span>
        }
      }
    }
<span class="nc bnc" id="L1497" title="All 2 branches missed.">    if (!isValid) {</span>
<span class="nc" id="L1498">      throw new InvalidObjectException(&quot;Could not reconstruct MessageFormat from corrupt stream&quot;);</span>
    }
<span class="nc" id="L1500">  }</span>

  /**
   * Creates an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; for the String &lt;code&gt;s&lt;/code&gt;.
   *
   * @param s String to create AttributedCharacterIterator from
   * @return AttributedCharacterIterator wrapping s
   */
  static AttributedCharacterIterator createAttributedCharacterIterator(String s) {
<span class="nc" id="L1509">    return new java.text.AttributedString(s).getIterator();</span>
  }


  /**
   * Returns an AttributedCharacterIterator with the String &lt;code&gt;string&lt;/code&gt; and additional key/value pair
   * &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt;.
   *
   * @param string String to create AttributedCharacterIterator from
   * @param key Key for AttributedCharacterIterator
   * @param value Value associated with key in AttributedCharacterIterator
   * @return AttributedCharacterIterator wrapping args
   */
  static AttributedCharacterIterator createAttributedCharacterIterator(
          String string, AttributedCharacterIterator.Attribute key,
          Object value) {
<span class="nc" id="L1525">    java.text.AttributedString as = new java.text.AttributedString(string);</span>

<span class="nc" id="L1527">    as.addAttribute(key, value);</span>
<span class="nc" id="L1528">    return as.getIterator();</span>
  }

  /**
   * Creates an AttributedCharacterIterator with the contents of &lt;code&gt;iterator&lt;/code&gt; and the additional attribute
   * &lt;code&gt;key&lt;/code&gt; &lt;code&gt;value&lt;/code&gt;.
   *
   * @param iterator Initial AttributedCharacterIterator to add arg to
   * @param key Key for AttributedCharacterIterator
   * @param value Value associated with key in AttributedCharacterIterator
   * @return AttributedCharacterIterator wrapping args
   */
  AttributedCharacterIterator createAttributedCharacterIterator(
          AttributedCharacterIterator iterator,
          AttributedCharacterIterator.Attribute key, Object value) {
<span class="nc" id="L1543">    java.text.AttributedString as = new java.text.AttributedString(iterator);</span>

<span class="nc" id="L1545">    as.addAttribute(key, value);</span>
<span class="nc" id="L1546">    return as.getIterator();</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L1551">    return &quot;MessageFormat{&quot; + &quot;locale=&quot; + locale + &quot;, pattern=&quot; + pattern + '}';</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>