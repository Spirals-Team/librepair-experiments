<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Sat May 26 15:11:07 CEST 2018 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="spf4j-core-8.3.4"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /root/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/root/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/root/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/root/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /root/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/root/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/root/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/root/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname spf4j-core-8.3.4 -apidir /root/workspace/zolyfarkas/spf4j/384075336/spf4j-jdiff-maven-plugin/./target/1527340264506-0 -classpath /root/.m2/repository/javax/annotation/jsr250-api/1.0/jsr250-api-1.0.jar:/root/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/root/.m2/repository/net/sf/trove4j/trove4j/3.0.3/trove4j-3.0.3.jar:/root/.m2/repository/org/ow2/asm/asm-tree/5.1/asm-tree-5.1.jar:/root/.m2/repository/org/apache/avro/avro/1.8.1/avro-1.8.1.jar:/root/.m2/repository/javax/enterprise/cdi-api/1.0/cdi-api-1.0.jar:/root/.m2/repository/org/apache/maven/maven-model/3.3.9/maven-model-3.3.9.jar:/root/.m2/repository/com/google/errorprone/error_prone_annotations/2.0.18/error_prone_annotations-2.0.18.jar:/root/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/root/.m2/repository/org/tukaani/xz/1.5/xz-1.5.jar:/root/.m2/repository/org/ow2/asm/asm/5.1/asm-5.1.jar:/root/.m2/repository/args4j/args4j/2.33/args4j-2.33.jar:/root/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.14/animal-sniffer-annotations-1.14.jar:/root/.m2/repository/org/eclipse/sisu/org.eclipse.sisu.plexus/0.3.2/org.eclipse.sisu.plexus-0.3.2.jar:/root/.m2/repository/net/java/dev/jna/jna-platform/4.4.0/jna-platform-4.4.0.jar:/root/.m2/repository/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/root/.m2/repository/org/eclipse/sisu/org.eclipse.sisu.inject/0.3.2/org.eclipse.sisu.inject-0.3.2.jar:/root/.m2/repository/org/codehaus/plexus/plexus-classworlds/2.5.2/plexus-classworlds-2.5.2.jar:/root/.m2/repository/org/spf4j/spf4j-core/8.3.4/spf4j-core-8.3.4.jar:/root/.m2/repository/com/google/guava/guava/22.0/guava-22.0.jar:/root/.m2/repository/org/spf4j/spf4j-config-discovery-maven-plugin/8.3.4/spf4j-config-discovery-maven-plugin-8.3.4.jar:/root/.m2/repository/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar:/root/.m2/repository/org/ow2/asm/asm-commons/5.1/asm-commons-5.1.jar:/root/.m2/repository/org/spf4j/spf4j-asm/8.3.4/spf4j-asm-8.3.4.jar:/root/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/root/.m2/repository/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/root/.m2/repository/org/codehaus/plexus/plexus-utils/3.0.22/plexus-utils-3.0.22.jar:/root/.m2/repository/net/java/dev/jna/jna/4.4.0/jna-4.4.0.jar:/root/.m2/repository/org/apache/maven/maven-artifact/3.3.9/maven-artifact-3.3.9.jar:/root/.m2/repository/joda-time/joda-time/2.9.9/joda-time-2.9.9.jar:/root/.m2/repository/com/google/code/findbugs/findbugs-annotations/3.0.1/findbugs-annotations-3.0.1.jar:/root/.m2/repository/org/apache/maven/maven-plugin-api/3.3.9/maven-plugin-api-3.3.9.jar:/root/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar:/root/.m2/repository/com/google/code/findbugs/annotations/2.0.3/annotations-2.0.3.jar:/root/.m2/repository/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar -sourcepath /root/workspace/zolyfarkas/spf4j/384075336/spf4j-jdiff-maven-plugin/./target/jdiff7684774898144826589/spf4j-core/8.3.4/sources -->
<package name="org.spf4j.concurrent">
  <!-- start class org.spf4j.concurrent.AtomicReferenceExt -->
  <class name="AtomicReferenceExt" extends="java.util.concurrent.atomic.AtomicReference"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomicReferenceExt" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AtomicReferenceExt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="update" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="java.util.function.UnaryOperator"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.AtomicReferenceExt -->
  <!-- start class org.spf4j.concurrent.Atomics -->
  <class name="Atomics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="update" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ar" type="java.util.concurrent.atomic.AtomicReference"/>
      <param name="function" type="java.util.function.UnaryOperator"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.Atomics -->
  <!-- start class org.spf4j.concurrent.AtomicSequence -->
  <class name="AtomicSequence" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Sequence"/>
    <constructor name="AtomicSequence" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="next" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.AtomicSequence -->
  <!-- start class org.spf4j.concurrent.ConcurrentReferenceHashMap -->
  <class name="ConcurrentReferenceHashMap" extends="java.util.AbstractMap"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ConcurrentMap"/>
    <implements name="java.io.Serializable"/>
    <constructor name="ConcurrentReferenceHashMap" type="int, float, int, org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType, org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType, java.util.EnumSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty map with the specified initial
 capacity, reference types, load factor and concurrency level.

 Behavioral changing options such as {@link Option#IDENTITY_COMPARISONS}
 can also be specified.

 @param initialCapacity the initial capacity. The implementation
 performs internal sizing to accommodate this many elements.
 @param loadFactor  the load factor threshold, used to control resizing.
 Resizing may be performed when the average number of elements per
 bin exceeds this threshold.
 @param concurrencyLevel the estimated number of concurrently
 updating threads. The implementation performs internal sizing
 to try to accommodate this many threads.
 @param keyType the reference type to use for keys
 @param valueType the reference type to use for values
 @param options the behavioral options
 @throws IllegalArgumentException if the initial capacity is
 negative or the load factor or concurrencyLevel are
 nonpositive.]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="int, float, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty map with the specified initial
 capacity, load factor and concurrency level.

 @param initialCapacity the initial capacity. The implementation
 performs internal sizing to accommodate this many elements.
 @param loadFactor  the load factor threshold, used to control resizing.
 Resizing may be performed when the average number of elements per
 bin exceeds this threshold.
 @param concurrencyLevel the estimated number of concurrently
 updating threads. The implementation performs internal sizing
 to try to accommodate this many threads.
 @throws IllegalArgumentException if the initial capacity is
 negative or the load factor or concurrencyLevel are
 nonpositive.]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="int, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty map with the specified initial capacity
 and load factor and with the default reference types (weak keys,
 strong values), and concurrencyLevel (16).

 @param initialCapacity The implementation performs internal
 sizing to accommodate this many elements.
 @param loadFactor  the load factor threshold, used to control resizing.
 Resizing may be performed when the average number of elements per
 bin exceeds this threshold.
 @throws IllegalArgumentException if the initial capacity of
 elements is negative or the load factor is nonpositive

 @since 1.6]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="int, org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType, org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty map with the specified initial capacity,
 reference types and with default load factor (0.75) and concurrencyLevel (16).

 @param initialCapacity the initial capacity. The implementation
 performs internal sizing to accommodate this many elements.
 @param keyType the reference type to use for keys
 @param valueType the reference type to use for values
 @throws IllegalArgumentException if the initial capacity of
 elements is negative.]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType, org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty reference map with the specified key
 and value reference types.

 @param keyType the reference type to use for keys
 @param valueType the reference type to use for values
 @throws IllegalArgumentException if the initial capacity of
 elements is negative.]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType, org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType, java.util.EnumSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty reference map with the specified reference types
 and behavioral options.

 @param keyType the reference type to use for keys
 @param valueType the reference type to use for values
 @throws IllegalArgumentException if the initial capacity of
 elements is negative.]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty map with the specified initial capacity,
 and with default reference types (weak keys, strong values),
 load factor (0.75) and concurrencyLevel (16).

 @param initialCapacity the initial capacity. The implementation
 performs internal sizing to accommodate this many elements.
 @throws IllegalArgumentException if the initial capacity of
 elements is negative.]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new, empty map with a default initial capacity (16),
 reference types (weak keys, strong values), default
 load factor (0.75) and concurrencyLevel (16).]]>
      </doc>
    </constructor>
    <constructor name="ConcurrentReferenceHashMap" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new map with the same mappings as the given map.
 The map is created with a capacity of 1.5 times the number
 of mappings in the given map or 16 (whichever is greater),
 and a default load factor (0.75) and concurrencyLevel (16).

 @param m the map]]>
      </doc>
    </constructor>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <tt>true</tt> if this map contains no key-value mappings.

 @return <tt>true</tt> if this map contains no key-value mappings]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of key-value mappings in this map.  If the
 map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns
 <tt>Integer.MAX_VALUE</tt>.

 @return the number of key-value mappings in this map]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the value to which the specified key is mapped,
 or {@code null} if this map contains no mapping for the key.

 <p>More formally, if this map contains a mapping from a key
 {@code k} to a value {@code v} such that {@code key.equals(k)},
 then this method returns {@code v}; otherwise it returns
 {@code null}.  (There can be at most one such mapping.)

 @throws NullPointerException if the specified key is null]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Tests if the specified object is a key in this table.

 @param  key   possible key
 @return <tt>true</tt> if and only if the specified object
         is a key in this table, as determined by the
         <tt>equals</tt> method; <tt>false</tt> otherwise.
 @throws NullPointerException if the specified key is null]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns <tt>true</tt> if this map maps one or more keys to the
 specified value. Note: This method requires a full internal
 traversal of the hash table, and so is much slower than
 method <tt>containsKey</tt>.

 @param value value whose presence in this map is to be tested
 @return <tt>true</tt> if this map maps one or more keys to the
         specified value
 @throws NullPointerException if the specified value is null]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Legacy method testing if some key maps into the specified value
 in this table.  This method is identical in functionality to
 {@link #containsValue}, and exists solely to ensure
 full compatibility with class {@link java.util.Hashtable},
 which supported this method prior to introduction of the
 Java Collections framework.

 @param  value a value to search for
 @return <tt>true</tt> if and only if some key maps to the
         <tt>value</tt> argument in this table as
         determined by the <tt>equals</tt> method;
         <tt>false</tt> otherwise
 @throws NullPointerException if the specified value is null]]>
      </doc>
    </method>
    <method name="put" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Maps the specified key to the specified value in this table.
 Neither the key nor the value can be null.

 <p> The value can be retrieved by calling the <tt>get</tt> method
 with a key that is equal to the original key.

 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with <tt>key</tt>, or
         <tt>null</tt> if there was no mapping for <tt>key</tt>
 @throws NullPointerException if the specified key or value is null]]>
      </doc>
    </method>
    <method name="putIfAbsent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @return the previous value associated with the specified key,
         or <tt>null</tt> if there was no mapping for the key
 @throws NullPointerException if the specified key or value is null]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
      <doc>
      <![CDATA[Copies all of the mappings from the specified map to this one.
 These mappings replace any mappings that this map had for any of the
 keys currently in the specified map.

 @param m mappings to be stored in this map]]>
      </doc>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the key (and its corresponding value) from this map.
 This method does nothing if the key is not in the map.

 @param  key the key that needs to be removed
 @return the previous value associated with <tt>key</tt>, or
         <tt>null</tt> if there was no mapping for <tt>key</tt>
 @throws NullPointerException if the specified key is null]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws NullPointerException if the specified key is null]]>
      </doc>
    </method>
    <method name="replace" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="oldValue" type="java.lang.Object"/>
      <param name="newValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @throws NullPointerException if any of the arguments are null]]>
      </doc>
    </method>
    <method name="replace" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}

 @return the previous value associated with the specified key,
         or <tt>null</tt> if there was no mapping for the key
 @throws NullPointerException if the specified key or value is null]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all of the mappings from this map.]]>
      </doc>
    </method>
    <method name="purgeStaleEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes any stale entries whose keys have been finalized. Use of this
 method is normally not necessary since stale entries are automatically
 removed lazily, when blocking operations are required. However, there
 are some cases where this operation should be performed eagerly, such
 as cleaning up old references to a ClassLoader in a multi-classloader
 environment.

 Note: this method will acquire locks, one at a time, across all segments
 of this table, so if it is to be used, it should be used sparingly.]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Set} view of the keys contained in this map.
 The set is backed by the map, so changes to the map are
 reflected in the set, and vice-versa.  The set supports element
 removal, which removes the corresponding mapping from this map,
 via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
 <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
 operations.  It does not support the <tt>add</tt> or
 <tt>addAll</tt> operations.

 <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator
 that will never throw {@link ConcurrentModificationException},
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Collection} view of the values contained in this map.
 The collection is backed by the map, so changes to the map are
 reflected in the collection, and vice-versa.  The collection
 supports element removal, which removes the corresponding
 mapping from this map, via the <tt>Iterator.remove</tt>,
 <tt>Collection.remove</tt>, <tt>removeAll</tt>,
 <tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not
 support the <tt>add</tt> or <tt>addAll</tt> operations.

 <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator
 that will never throw {@link ConcurrentModificationException},
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a {@link Set} view of the mappings contained in this map.
 The set is backed by the map, so changes to the map are
 reflected in the set, and vice-versa.  The set supports element
 removal, which removes the corresponding mapping from the map,
 via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
 <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
 operations.  It does not support the <tt>add</tt> or
 <tt>addAll</tt> operations.

 <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator
 that will never throw {@link ConcurrentModificationException},
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.]]>
      </doc>
    </method>
    <method name="keys" return="java.util.Enumeration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an enumeration of the keys in this table.

 @return an enumeration of the keys in this table
 @see #keySet()]]>
      </doc>
    </method>
    <method name="elements" return="java.util.Enumeration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an enumeration of the values in this table.

 @return an enumeration of the values in this table
 @see #values()]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An advanced hash table supporting configurable garbage collection semantics
 of keys and values, optional referential-equality, full concurrency of
 retrievals, and adjustable expected concurrency for updates.

 This table is designed around specific advanced use-cases. If there is any
 doubt whether this table is for you, you most likely should be using
 {@link java.util.concurrent.ConcurrentHashMap} instead.

 This table supports strong, weak, and soft keys and values. By default keys
 are weak, and values are strong. Such a configuration offers similar behavior
 to {@link java.util.WeakHashMap}, entries of this table are periodically
 removed once their corresponding keys are no longer referenced outside of
 this table. In other words, this table will not prevent a key from being
 discarded by the garbage collector. Once a key has been discarded by the
 collector, the corresponding entry is no longer visible to this table;
 however, the entry may occupy space until a future table operation decides to
 reclaim it. For this reason, summary functions such as <tt>size</tt> and
 <tt>isEmpty</tt> might return a value greater than the observed number of
 entries. In order to support a high level of concurrency, stale entries are
 only reclaimed during blocking (usually mutating) operations.

 Enabling soft keys allows entries in this table to remain until their space
 is absolutely needed by the garbage collector. This is unlike weak keys which
 can be reclaimed as soon as they are no longer referenced by a normal strong
 reference. The primary use case for soft keys is a cache, which ideally
 occupies memory that is not in use for as long as possible.

 By default, values are held using a normal strong reference. This provides
 the commonly desired guarantee that a value will always have at least the
 same life-span as it's key. For this reason, care should be taken to ensure
 that a value never refers, either directly or indirectly, to its key, thereby
 preventing reclamation. If this is unavoidable, then it is recommended to use
 the same reference type in use for the key. However, it should be noted that
 non-strong values may disappear before their corresponding key.

 While this table does allow the use of both strong keys and values, it is
 recommended to use {@link java.util.concurrent.ConcurrentHashMap} for such a
 configuration, since it is optimized for that case.

 Just like {@link java.util.concurrent.ConcurrentHashMap}, this class obeys
 the same functional specification as {@link java.util.Hashtable}, and
 includes versions of methods corresponding to each method of
 <tt>Hashtable</tt>. However, even though all operations are thread-safe,
 retrieval operations do <em>not</em> entail locking, and there is
 <em>not</em> any support for locking the entire table in a way that
 prevents all access. This class is fully interoperable with
 <tt>Hashtable</tt> in programs that rely on its thread safety but not on
 its synchronization details.

 <p>
 Retrieval operations (including <tt>get</tt>) generally do not block, so
 may overlap with update operations (including <tt>put</tt> and
 <tt>remove</tt>). Retrievals reflect the results of the most recently
 <em>completed</em> update operations holding upon their onset. For
 aggregate operations such as <tt>putAll</tt> and <tt>clear</tt>,
 concurrent retrievals may reflect insertion or removal of only some entries.
 Similarly, Iterators and Enumerations return elements reflecting the state of
 the hash table at some point at or since the creation of the
 iterator/enumeration. They do <em>not</em> throw
 {@link ConcurrentModificationException}. However, iterators are designed to
 be used by only one thread at a time.

 <p>
 The allowed concurrency among update operations is guided by the optional
 <tt>concurrencyLevel</tt> constructor argument (default <tt>16</tt>),
 which is used as a hint for internal sizing. The table is internally
 partitioned to try to permit the indicated number of concurrent updates
 without contention. Because placement in hash tables is essentially random,
 the actual concurrency will vary. Ideally, you should choose a value to
 accommodate as many threads as will ever concurrently modify the table. Using
 a significantly higher value than you need can waste space and time, and a
 significantly lower value can lead to thread contention. But overestimates
 and underestimates within an order of magnitude do not usually have much
 noticeable impact. A value of one is appropriate when it is known that only
 one thread will modify and all others will only read. Also, resizing this or
 any other kind of hash table is a relatively slow operation, so, when
 possible, it is a good idea to provide estimates of expected table sizes in
 constructors.

 <p>
 This class and its views and iterators implement all of the <em>optional</em>
 methods of the {@link Map} and {@link Iterator} interfaces.

 <p>
 Like {@link Hashtable} but unlike {@link HashMap}, this class does
 <em>not</em> allow <tt>null</tt> to be used as a key or value.

 <p>
 This class is a member of the <a href="{@docRoot}/../technotes/guides/collections/index.html">
 Java Collections Framework</a>.

 @author Doug Lea
 @author Jason T. Greene
 @param <K> the type of keys maintained by this map
 @param <V> the type of mapped values]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ConcurrentReferenceHashMap -->
  <!-- start class org.spf4j.concurrent.ConcurrentReferenceHashMap.Option -->
  <class name="ConcurrentReferenceHashMap.Option" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.concurrent.ConcurrentReferenceHashMap.Option[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.concurrent.ConcurrentReferenceHashMap.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="IDENTITY_COMPARISONS" type="org.spf4j.concurrent.ConcurrentReferenceHashMap.Option"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates that referential-equality (== instead of .equals()) should
 be used when locating keys. This offers similar behavior to {@link IdentityHashMap}]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.concurrent.ConcurrentReferenceHashMap.Option -->
  <!-- start class org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType -->
  <class name="ConcurrentReferenceHashMap.ReferenceType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="STRONG" type="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates a normal Java strong reference should be used]]>
      </doc>
    </field>
    <field name="WEAK" type="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates a {@link WeakReference} should be used]]>
      </doc>
    </field>
    <field name="SOFT" type="org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates a {@link SoftReference} should be used]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An option specifying which Java reference type should be used to refer
 to a key and/or value.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ConcurrentReferenceHashMap.ReferenceType -->
  <!-- start class org.spf4j.concurrent.CustomThreadFactory -->
  <class name="CustomThreadFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ThreadFactory"/>
    <constructor name="CustomThreadFactory" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CustomThreadFactory" type="java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The default thread factory]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.CustomThreadFactory -->
  <!-- start class org.spf4j.concurrent.DefaultExecutor -->
  <class name="DefaultExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="INSTANCE" type="java.util.concurrent.ExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This executor aims to be a general purpose executor for async tasks. (equivalent to ForkJoinPool.commonPool())

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultExecutor -->
  <!-- start class org.spf4j.concurrent.DefaultScheduler -->
  <class name="DefaultScheduler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="scheduleAllignedAtFixedRateMillis" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="millisInterval" type="long"/>
      <doc>
      <![CDATA[this will schedule a runnable aligned to the hour or day at a fixed rate.

 @param command - the Runnable to execute.
 @param millisInterval - the schedule interval in milliseconds.
 @return - Future that allows to cancel the schedule.]]>
      </doc>
    </method>
    <field name="INSTANCE" type="java.util.concurrent.ScheduledExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LISTENABLE_INSTANCE" type="com.google.common.util.concurrent.ListeningScheduledExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultScheduler -->
  <!-- start class org.spf4j.concurrent.FileBasedLock -->
  <class name="FileBasedLock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.locks.Lock"/>
    <implements name="java.io.Closeable"/>
    <method name="getLock" return="org.spf4j.concurrent.FileBasedLock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a FileBasedLock implementation.

 FileBasedLock will hold onto a File Descriptor during the entire life of the instance.
 FileBasedLock is a reentrant lock. (it can be acquired multiple times by the same thread)

 @param lockFile the file to lock on.
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lockInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newCondition" return="java.util.concurrent.locks.Condition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[will release lock if owned, will not nothing if not owned.]]>
      </doc>
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Throwable" type="java.lang.Throwable"/>
    </method>
    <method name="getContextInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLocalHoldCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isHeldByCurrentThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[File based Lock implementation, that can be used as IPC method.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.FileBasedLock -->
  <!-- start class org.spf4j.concurrent.FutureBean -->
  <class name="FutureBean" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future"/>
    <constructor name="FutureBean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResultStore" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="processResult" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.spf4j.base.Either"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="setExceptionResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[bean like implementation of a future
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.FutureBean -->
  <!-- start class org.spf4j.concurrent.Futures -->
  <class name="Futures" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="iterator" type="java.util.Iterator"/>
    </method>
    <method name="getAll" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
      <doc>
      <![CDATA[Gets all futures resuls.

 @param deadlineNanos
 @param futures
 @return]]>
      </doc>
    </method>
    <method name="getAll" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.Futures -->
  <!-- start interface org.spf4j.concurrent.LifoThreadPool -->
  <interface name="LifoThreadPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <method name="exportJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadPriority" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[See LifoThreadPoolBuilder for creating lifo  thread pools.

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.LifoThreadPool -->
  <!-- start class org.spf4j.concurrent.LifoThreadPoolBuilder -->
  <class name="LifoThreadPoolBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withPoolName" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="poolName" type="java.lang.String"/>
    </method>
    <method name="withCoreSize" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coreSize" type="int"/>
    </method>
    <method name="withMaxSize" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxSize" type="int"/>
    </method>
    <method name="withMaxIdleTimeMillis" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="withTaskQueue" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskQueue" type="java.util.Queue"/>
    </method>
    <method name="withQueueSizeLimit" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="withDaemonThreads" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="withSpinLockCount" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spinLockCount" type="int"/>
    </method>
    <method name="withRejectionHandler" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rejectionHandler" type="org.spf4j.concurrent.RejectedExecutionHandler"/>
    </method>
    <method name="withThreadPriority" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <method name="mutable" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enableJmx" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.spf4j.concurrent.LifoThreadPool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildMutable" return="org.spf4j.concurrent.MutableLifoThreadPool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LifoThreadPoolBuilder -->
  <!-- start class org.spf4j.concurrent.LifoThreadPoolExecutorSQP -->
  <class name="LifoThreadPoolExecutorSQP" extends="java.util.concurrent.AbstractExecutorService"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.LifoThreadPool"/>
    <constructor name="LifoThreadPoolExecutorSQP" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="exportJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadPriority" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Lifo scheduled java thread pool, based on talk: http://applicative.acm.org/speaker-BenMaurer.html This implementation
 behaves differently compared with a java Thread pool in that it prefers to spawn a thread if possible instead of
 queueing tasks.

 See LifoThreadPoolBuilder for conveniently constructing pools

 There are 3 data structures involved in the transfer of tasks to Threads.

 1) Task Queue - a classic FIFO queue. RW controlled by a reentrant lock. only non-blockng read operations are done on
 this queue 2) Available Thread Queue - a classic LIFO queue, a thread end up here when there is nothing to process.
 3) A "UnitQueue", is a queue with a capacity on 1, which a thread will listen on while in the available thread queue.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LifoThreadPoolExecutorSQP -->
  <!-- start class org.spf4j.concurrent.LocalSemaphore -->
  <class name="LocalSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="LocalSemaphore" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A process level semaphore implementation based on the JDK semaphore.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LocalSemaphore -->
  <!-- start class org.spf4j.concurrent.LockRuntimeException -->
  <class name="LockRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LockRuntimeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LockRuntimeException -->
  <!-- start interface org.spf4j.concurrent.MutableLifoThreadPool -->
  <interface name="MutableLifoThreadPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.LifoThreadPool"/>
    <method name="setDaemonThreads"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="setMaxIdleTimeMillis"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="setMaxThreadCount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxThreadCount" type="int"/>
    </method>
    <method name="setQueueSizeLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="setThreadPriority"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.MutableLifoThreadPool -->
  <!-- start class org.spf4j.concurrent.MutableLifoThreadPoolExecutorSQP -->
  <class name="MutableLifoThreadPoolExecutorSQP" extends="java.util.concurrent.AbstractExecutorService"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.MutableLifoThreadPool"/>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="exportJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setMaxThreadCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxThreadCount" type="int"/>
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDaemonThreads"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQueueSizeLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="getThreadPriority" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setThreadPriority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setMaxIdleTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Lifo scheduled java thread pool, based on talk: http://applicative.acm.org/speaker-BenMaurer.html This implementation
 behaves differently compared with a java Thread pool in that it prefers to spawn a thread if possible instead of
 queueing tasks.

 See LifoThreadPoolBuilder for conveniently constructing pools


 This pool allows changing most parameters on the fly. This comes at the cost of using some volatile vars.

 There are 3 data structures involved in the transfer of tasks to Threads.

 1) Task Queue - a classic FIFO queue. RW controlled by a reentrant lock. only non-blockng read operations are done on
 this queue 2) Available Thread Queue - a classic LIFO queue, a thread end up here when there is nothing to process.
 3) A "UnitQueue", is a queue with a capacity on 1, which a thread will listen on while in the available thread queue.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.MutableLifoThreadPoolExecutorSQP -->
  <!-- start interface org.spf4j.concurrent.RejectedExecutionHandler -->
  <interface name="RejectedExecutionHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="rejectedExecution"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
      <param name="executor" type="org.spf4j.concurrent.LifoThreadPool"/>
    </method>
    <field name="REJECT_EXCEPTION_EXEC_HANDLER" type="org.spf4j.concurrent.RejectedExecutionHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RUN_IN_CALLER_EXEC_HANDLER" type="org.spf4j.concurrent.RejectedExecutionHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.RejectedExecutionHandler -->
  <!-- start interface org.spf4j.concurrent.RestartableService -->
  <interface name="RestartableService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <implements name="java.lang.AutoCloseable"/>
    <method name="getServiceName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[THis is only a marker interface that will let you know that this Guava service is restartable.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.RestartableService -->
  <!-- start class org.spf4j.concurrent.RestartableServiceImpl -->
  <class name="RestartableServiceImpl" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.RestartableService"/>
    <constructor name="RestartableServiceImpl" type="com.google.common.base.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerToJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.RestartableServiceImpl -->
  <!-- start class org.spf4j.concurrent.RetryExecutor -->
  <class name="RetryExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RetryExecutor" type="java.util.concurrent.ExecutorService, org.spf4j.base.ParameterizedSupplier, java.util.concurrent.BlockingQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RetryExecutor" type="java.util.concurrent.ExecutorService, org.spf4j.base.ParameterizedSupplier, org.spf4j.base.ParameterizedSupplier, java.util.concurrent.BlockingQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="org.spf4j.base.Callables.TimeoutCallable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="org.spf4j.base.TimeoutRunnable"/>
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="org.spf4j.base.TimeoutRunnable"/>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.spf4j.base.TimeoutRunnable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_RETRY_SUPPLIER" type="org.spf4j.base.ParameterizedSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Executor that will execute Callables with retry. This executor cannot be used inside a Completion service.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.RetryExecutor -->
  <!-- start class org.spf4j.concurrent.ScalableSequence -->
  <class name="ScalableSequence" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Sequence"/>
    <constructor name="ScalableSequence" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="next" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ScalableSequence -->
  <!-- start interface org.spf4j.concurrent.Semaphore -->
  <interface name="Semaphore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Acquire one permit.
 @param timeout  time to wait for permit to become available.
 @param unit  units of time.
 @throws InterruptedException - operation interrupted.
 @throws TimeoutException - timed out.]]>
      </doc>
    </method>
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Acquire a arbitrary number of permits.
 @param nrPermits - numer of permits to acquire.
 @param timeout - time to wait for permit to become available.
 @param unit - units of time.
 @throws InterruptedException - operation interrupted.
 @throws TimeoutException - timed out.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[try to acquire a permit.
 @param timeout  time to wait for permit to become available.
 @param unit  units of time.
 @return  true if permit acquired, false if timed out.
 @throws InterruptedException - operation interrupted.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[try to acquire a number of permits.
 @param nrPermits  number of permits to acquire.
 @param timeout  time to wait for permits to become available.
 @param unit  units of time.
 @return  true if permits acquired, false if timed out.
 @throws InterruptedException - operation interrupted.]]>
      </doc>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[release 1 permit.]]>
      </doc>
    </method>
    <method name="release"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <doc>
      <![CDATA[release a number of permits.
 @param nrPermits  the number of permits to release.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A interface that abstracts a semaphore.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.Semaphore -->
  <!-- start interface org.spf4j.concurrent.Sequence -->
  <interface name="Sequence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="next" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return next number in sequence. if result is negative an overflow happened.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.concurrent.Sequence -->
  <!-- start class org.spf4j.concurrent.ThreadLocalBufferedConsumer -->
  <class name="ThreadLocalBufferedConsumer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <implements name="java.io.Closeable"/>
    <constructor name="ThreadLocalBufferedConsumer" type="int, java.util.function.Consumer, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ThreadLocalBufferedConsumer -->
  <!-- start class org.spf4j.concurrent.UIDGenerator -->
  <class name="UIDGenerator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, com.google.common.io.BaseEncoding, long, char, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a UID Generator

 @param sequence
 @param baseEncoding - if null MAC address based ID will not be included.]]>
      </doc>
    </constructor>
    <method name="getMaxSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Unique ID Generator Based on the assumptions: 1. host MAC address is used. (each network interface has a Unique ID)
 (encoded with provided encoder) 2. process id is used + current epoch seconds. it is assumed the PID is not recycled
 within a second. 3. A process sequence is used. UIDs will cycle after Long.MaxValue is reached.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UIDGenerator -->
  <!-- start class org.spf4j.concurrent.UnboundedLoadingCache -->
  <class name="UnboundedLoadingCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedLoadingCache" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeysLoaded" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[custom build high performance implementation for a unbounded guava cache: UnboundedLoadingCache is implemented with
 JDK concurrent map UnboundedLoadingCache2 is using the JDK 1.8 computing map functionality, but benchmarks show worse
 performance.

 Benchmark Mode Cnt Score Error Units CacheBenchmark.guavaCache thrpt 15 29011674.275 # 710672.413 ops/s
 CacheBenchmark.spf4j2Cache thrpt 15 30567248.015 # 807965.535 ops/s CacheBenchmark.spf4jCache thrpt 15 37961593.882 #
 1136244.254 ops/s CacheBenchmark.spf4jRacyCache thrpt 15 37553655.751 # 855349.501 ops/s

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedLoadingCache -->
  <!-- start class org.spf4j.concurrent.UnboundedLoadingCache2 -->
  <class name="UnboundedLoadingCache2" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedLoadingCache2" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache2" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Simple adapter that adapts a java ConcurrentMap to a guava cache.
 See UnboundedLoadingCache for rationale and benchmark data to see
 why this is not the default implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedLoadingCache2 -->
  <!-- start class org.spf4j.concurrent.UnboundedRacyLoadingCache -->
  <class name="UnboundedRacyLoadingCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="use UnboundedLoadingCache instead.">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedRacyLoadingCache" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedRacyLoadingCache" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly
 @deprecated use UnboundedLoadingCache instead.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedRacyLoadingCache -->
  <!-- start class org.spf4j.concurrent.UnitQueuePU -->
  <class name="UnitQueuePU" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnitQueuePU" type="java.lang.Thread"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutNanos" type="long"/>
      <param name="spinCount" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offer" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Special purpose queue for a single value Custom designed for the LifoThreadPool

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnitQueuePU -->
  <!-- start class org.spf4j.concurrent.UpdateResult -->
  <class name="UpdateResult" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="updated" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="same" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="isObjectUpdated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getObj" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UpdateResult -->
</package>

</api>
