<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon May 28 19:43:41 CEST 2018 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="spf4j-core-8.3.18"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /root/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/root/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/root/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/root/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -doclet jdiff.JDiff -docletpath /root/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/root/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/root/.m2/repository/xml-resolver/xml-resolver/1.2/xml-resolver-1.2.jar:/root/.m2/repository/jdiff/jdiff/1.0.9/jdiff-1.0.9.jar -apiname spf4j-core-8.3.18 -apidir /root/workspace/zolyfarkas/spf4j/384834061/spf4j-jdiff-maven-plugin/target/jdiff -classpath /root/.m2/repository/org/spf4j/spf4j-config-discovery-maven-plugin/8.3.18/spf4j-config-discovery-maven-plugin-8.3.18.jar:/root/.m2/repository/net/sf/trove4j/trove4j/3.0.3/trove4j-3.0.3.jar:/root/.m2/repository/org/apache/avro/avro/1.8.1/avro-1.8.1.jar:/root/.m2/repository/javax/enterprise/cdi-api/1.0/cdi-api-1.0.jar:/root/.m2/repository/org/apache/maven/maven-model/3.3.9/maven-model-3.3.9.jar:/root/.m2/repository/commons-chain/commons-chain/1.1/commons-chain-1.1.jar:/root/.m2/repository/org/apache/struts/struts-taglib/1.3.8/struts-taglib-1.3.8.jar:/root/.m2/repository/commons-beanutils/commons-beanutils/1.8.3/commons-beanutils-1.8.3.jar:/root/.m2/repository/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3.jar:/root/.m2/repository/org/spf4j/spf4j-asm/8.3.18/spf4j-asm-8.3.18.jar:/root/.m2/repository/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/root/.m2/repository/org/eclipse/sisu/org.eclipse.sisu.inject/0.3.2/org.eclipse.sisu.inject-0.3.2.jar:/root/.m2/repository/commons-digester/commons-digester/1.8.1/commons-digester-1.8.1.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-module-fml/1.6/doxia-module-fml-1.6.jar:/root/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/root/.m2/repository/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar:/root/.m2/repository/org/eclipse/aether/aether-transport-file/1.1.0/aether-transport-file-1.1.0.jar:/root/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/root/.m2/repository/org/apache/maven/maven-artifact/3.3.9/maven-artifact-3.3.9.jar:/root/.m2/repository/org/eclipse/aether/aether-transport-http/1.1.0/aether-transport-http-1.1.0.jar:/root/.m2/repository/org/apache/maven/maven-artifact-manager/2.2.1/maven-artifact-manager-2.2.1.jar:/root/.m2/repository/org/apache/maven/maven-core/3.3.9/maven-core-3.3.9.jar:/root/.m2/repository/org/apache/maven/maven-repository-metadata/3.3.9/maven-repository-metadata-3.3.9.jar:/root/.m2/repository/org/apache/maven/maven-plugin-api/3.3.9/maven-plugin-api-3.3.9.jar:/root/.m2/repository/org/apache/httpcomponents/httpclient/4.5.1/httpclient-4.5.1.jar:/root/.m2/repository/net/java/dev/jna/jna-platform/4.5.0/jna-platform-4.5.0.jar:/root/.m2/repository/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/root/.m2/repository/javax/annotation/jsr250-api/1.0/jsr250-api-1.0.jar:/root/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/root/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/root/.m2/repository/org/apache/velocity/velocity/1.5/velocity-1.5.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-decoration-model/1.6/doxia-decoration-model-1.6.jar:/root/.m2/repository/com/google/errorprone/error_prone_annotations/2.0.18/error_prone_annotations-2.0.18.jar:/root/.m2/repository/classworlds/classworlds/1.1-alpha-2/classworlds-1.1-alpha-2.jar:/root/.m2/repository/org/tukaani/xz/1.5/xz-1.5.jar:/root/.m2/repository/org/codehaus/mojo/animal-sniffer-annotations/1.14/animal-sniffer-annotations-1.14.jar:/root/.m2/repository/com/google/inject/guice/4.0/guice-4.0-no_aop.jar:/root/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.6/plexus-component-annotations-1.6.jar:/root/.m2/repository/backport-util-concurrent/backport-util-concurrent/3.1/backport-util-concurrent-3.1.jar:/root/.m2/repository/org/codehaus/plexus/plexus-classworlds/2.5.2/plexus-classworlds-2.5.2.jar:/root/.m2/repository/org/apache/maven/reporting/maven-reporting-impl/2.4/maven-reporting-impl-2.4.jar:/root/.m2/repository/org/apache/maven/maven-profile/2.2.1/maven-profile-2.2.1.jar:/root/.m2/repository/org/apache/struts/struts-tiles/1.3.8/struts-tiles-1.3.8.jar:/root/.m2/repository/org/ow2/asm/asm-commons/5.1/asm-commons-5.1.jar:/root/.m2/repository/antlr/antlr/2.7.2/antlr-2.7.2.jar:/root/.m2/repository/org/apache/maven/maven-model-builder/3.3.9/maven-model-builder-3.3.9.jar:/root/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/root/.m2/repository/org/eclipse/aether/aether-connector-basic/1.1.0/aether-connector-basic-1.1.0.jar:/root/.m2/repository/org/codehaus/plexus/plexus-utils/3.0.22/plexus-utils-3.0.22.jar:/root/.m2/repository/org/apache/maven/maven-settings/3.3.9/maven-settings-3.3.9.jar:/root/.m2/repository/org/eclipse/aether/aether-spi/1.0.2.v20150114/aether-spi-1.0.2.v20150114.jar:/root/.m2/repository/org/apache/maven/reporting/maven-reporting-api/3.0/maven-reporting-api-3.0.jar:/root/.m2/repository/joda-time/joda-time/2.9.9/joda-time-2.9.9.jar:/root/.m2/repository/org/codehaus/plexus/plexus-i18n/1.0-beta-7/plexus-i18n-1.0-beta-7.jar:/root/.m2/repository/org/apache/maven/shared/maven-shared-utils/0.6/maven-shared-utils-0.6.jar:/root/.m2/repository/org/ow2/asm/asm-tree/5.1/asm-tree-5.1.jar:/root/.m2/repository/org/apache/maven/maven-plugin-registry/2.2.1/maven-plugin-registry-2.2.1.jar:/root/.m2/repository/junit/junit/3.8.1/junit-3.8.1.jar:/root/.m2/repository/dom4j/dom4j/1.1/dom4j-1.1.jar:/root/.m2/repository/xmlunit/xmlunit/1.5/xmlunit-1.5.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-site-renderer/1.6/doxia-site-renderer-1.6.jar:/root/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/root/.m2/repository/org/ow2/asm/asm/5.1/asm-5.1.jar:/root/.m2/repository/org/apache/maven/maven-settings-builder/3.3.9/maven-settings-builder-3.3.9.jar:/root/.m2/repository/org/apache/velocity/velocity-tools/2.0/velocity-tools-2.0.jar:/root/.m2/repository/org/spf4j/spf4j-jdiff-maven-plugin/8.3.18/spf4j-jdiff-maven-plugin-8.3.18.jar:/root/.m2/repository/org/apache/maven/wagon/wagon-provider-api/1.0-beta-6/wagon-provider-api-1.0-beta-6.jar:/root/.m2/repository/org/spf4j/spf4j-core/8.3.18/spf4j-core-8.3.18.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-module-xhtml/1.6/doxia-module-xhtml-1.6.jar:/root/.m2/repository/org/apache/struts/struts-core/1.3.8/struts-core-1.3.8.jar:/root/.m2/repository/org/eclipse/aether/aether-api/1.0.2.v20150114/aether-api-1.0.2.v20150114.jar:/root/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-logging-api/1.6/doxia-logging-api-1.6.jar:/root/.m2/repository/org/eclipse/aether/aether-impl/1.1.0/aether-impl-1.1.0.jar:/root/.m2/repository/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/root/.m2/repository/org/codehaus/plexus/plexus-velocity/1.1.7/plexus-velocity-1.1.7.jar:/root/.m2/repository/com/google/guava/guava/23.3-jre/guava-23.3-jre.jar:/root/.m2/repository/commons-codec/commons-codec/1.9/commons-codec-1.9.jar:/root/.m2/repository/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4.jar:/root/.m2/repository/com/google/code/findbugs/annotations/2.0.3/annotations-2.0.3.jar:/root/.m2/repository/org/codehaus/plexus/plexus-interpolation/1.21/plexus-interpolation-1.21.jar:/root/.m2/repository/org/eclipse/aether/aether-util/1.0.2.v20150114/aether-util-1.0.2.v20150114.jar:/root/.m2/repository/org/apache/maven/maven-builder-support/3.3.9/maven-builder-support-3.3.9.jar:/root/.m2/repository/args4j/args4j/2.33/args4j-2.33.jar:/root/.m2/repository/sslext/sslext/1.2-0/sslext-1.2-0.jar:/root/.m2/repository/org/apache/maven/maven-aether-provider/3.3.9/maven-aether-provider-3.3.9.jar:/root/.m2/repository/org/eclipse/sisu/org.eclipse.sisu.plexus/0.3.2/org.eclipse.sisu.plexus-0.3.2.jar:/root/.m2/repository/net/java/dev/jna/jna/4.5.0/jna-4.5.0.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-core/1.6/doxia-core-1.6.jar:/root/.m2/repository/org/apache/maven/maven-project/2.2.1/maven-project-2.2.1.jar:/root/.m2/repository/commons-lang/commons-lang/2.4/commons-lang-2.4.jar:/root/.m2/repository/org/codehaus/plexus/plexus-container-default/1.0-alpha-9-stable-1/plexus-container-default-1.0-alpha-9-stable-1.jar:/root/.m2/repository/org/apache/httpcomponents/httpcore/4.4.3/httpcore-4.4.3.jar:/root/.m2/repository/oro/oro/2.0.8/oro-2.0.8.jar:/root/.m2/repository/org/slf4j/jcl-over-slf4j/1.6.2/jcl-over-slf4j-1.6.2.jar:/root/.m2/repository/com/google/code/findbugs/findbugs-annotations/3.0.1/findbugs-annotations-3.0.1.jar:/root/.m2/repository/commons-validator/commons-validator/1.4.1/commons-validator-1.4.1.jar:/root/.m2/repository/org/apache/maven/doxia/doxia-sink-api/1.6/doxia-sink-api-1.6.jar:/root/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar -sourcepath /root/workspace/zolyfarkas/spf4j/384834061/spf4j-jdiff-maven-plugin/./target/jdiff3243323436043226756/spf4j-core/8.3.18/sources -->
<package name="org.spf4j.perf.impl.ms">
  <!-- start class org.spf4j.perf.impl.ms.Flusher -->
  <class name="Flusher" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="flushEvery"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="intervalMillis" type="int"/>
      <param name="store" type="org.spf4j.perf.MeasurementStore"/>
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.Flusher -->
  <!-- start class org.spf4j.perf.impl.ms.Id2Info -->
  <class name="Id2Info" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getId" return="long"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.spf4j.perf.MeasurementsInfo"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="long"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.Id2Info -->
  <!-- start class org.spf4j.perf.impl.ms.MultiStore -->
  <class name="MultiStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="MultiStore" type="org.spf4j.perf.MeasurementStore[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getStores" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.MultiStore -->
  <!-- start interface org.spf4j.perf.impl.ms.StoreFactory -->
  <interface name="StoreFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="create" return="org.spf4j.perf.MeasurementStore"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.impl.ms.StoreFactory -->
  <!-- start class org.spf4j.perf.impl.ms.StoreType -->
  <class name="StoreType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.perf.impl.ms.StoreType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.perf.impl.ms.StoreType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="create" return="org.spf4j.perf.MeasurementStore"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <field name="TSDB" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TSDB_TXT" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GRAPHITE_UDP" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GRAPHITE_TCP" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOP_STORE" type="org.spf4j.perf.impl.ms.StoreType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.StoreType -->
</package>
<package name="org.spf4j.perf.io">
  <!-- start class org.spf4j.perf.io.MeasuredInputStream -->
  <class name="MeasuredInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MeasuredInputStream" type="java.io.InputStream, java.lang.String, org.spf4j.perf.MeasurementRecorderSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.io.MeasuredInputStream -->
  <!-- start class org.spf4j.perf.io.MeasuredOutputStream -->
  <class name="MeasuredOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MeasuredOutputStream" type="java.io.OutputStream, java.lang.String, org.spf4j.perf.MeasurementRecorderSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.io.MeasuredOutputStream -->
  <!-- start class org.spf4j.perf.io.OpenFilesSampler -->
  <class name="OpenFilesSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
      <param name="shutdownOnError" type="boolean"/>
    </method>
    <method name="getWarnLsofDetail" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
      <param name="warnThreshold" type="long"/>
      <param name="errorThreshold" type="long"/>
      <param name="shutdownOnError" type="boolean"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="long"/>
      <param name="warnThreshold" type="long"/>
      <param name="errorThreshold" type="long"/>
      <param name="shutdownOnError" type="boolean"/>
      <param name="aggTimeMillis" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLsof" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxNrOpenFiles" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrOpenFiles" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWarnThreshold" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getErrorThreshold" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class allows you to poll and recordAt to a file the heap commited and heap used for your java process. start
 data recording by calling the startMemoryUsageSampling method, stop the data recording by calling the method:
 startMemoryUsageSampling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.io.OpenFilesSampler -->
</package>
<package name="org.spf4j.net">
  <!-- start class org.spf4j.net.SntpClient -->
  <class name="SntpClient" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="requestTimeHA" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="int"/>
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="requestTimeHA" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="int"/>
      <param name="ntpResponseTimeoutMillis" type="int"/>
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Request NTP time with retries.

 @param hosts NTP server hosts.
 @param timeoutMillis Max time to attempt to get NTP time
 @param ntpResponseTimeoutMillis the time after which if we do not receive a response from the NTP server,
 we consider the call failed (and will retry until timeoutMillis.
 @return Ntp timing info.
 @throws IOException - thrown in case of time server connectivity issues.
 @throws InterruptedException - thrown if exec interrupted.]]>
      </doc>
    </method>
    <method name="requestTime" return="org.spf4j.net.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="timeoutMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get NTP time.

 @param host - NTP server host name.
 @param timeoutMillis - the socket timeout.
 @return - NTP server timing info.
 @throws IOException - thrown in case of time server connectivity issues.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple NTP client. Inspired by Android Sntp client. For how to use, see SntpClientTest.java.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.net.SntpClient -->
  <!-- start class org.spf4j.net.Timing -->
  <class name="Timing" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Timing" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNtpTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNtpTimeReference" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRoundTripTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current Time based on the NTP timing info.
 @return current time, as number of millis since EPOCH.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.net.Timing -->
</package>
<package name="org.spf4j.io.appenders">
  <!-- start class org.spf4j.io.appenders.CalendarAppender -->
  <class name="CalendarAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="CalendarAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instant" type="java.util.Calendar"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.CalendarAppender -->
  <!-- start class org.spf4j.io.appenders.CharsequenceAppender -->
  <class name="CharsequenceAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="CharsequenceAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.CharSequence"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.CharsequenceAppender -->
  <!-- start class org.spf4j.io.appenders.DateAppender -->
  <class name="DateAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="DateAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="java.util.Date"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.DateAppender -->
  <!-- start class org.spf4j.io.appenders.GenericRecordAppender -->
  <class name="GenericRecordAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="GenericRecordAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.apache.avro.generic.GenericRecord"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.GenericRecordAppender -->
  <!-- start class org.spf4j.io.appenders.InstantAppender -->
  <class name="InstantAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="InstantAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.joda.time.ReadableInstant"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="FMT" type="org.joda.time.format.DateTimeFormatter"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.InstantAppender -->
  <!-- start class org.spf4j.io.appenders.LocalDateAppender -->
  <class name="LocalDateAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="LocalDateAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="org.joda.time.LocalDate"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="FMT" type="org.joda.time.format.DateTimeFormatter"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.LocalDateAppender -->
  <!-- start class org.spf4j.io.appenders.SpecificRecordAppender -->
  <class name="SpecificRecordAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SpecificRecordAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.apache.avro.specific.SpecificRecord"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.SpecificRecordAppender -->
  <!-- start class org.spf4j.io.appenders.SpecificRecordBaseAppender -->
  <class name="SpecificRecordBaseAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SpecificRecordBaseAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.apache.avro.specific.SpecificRecordBase"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.SpecificRecordBaseAppender -->
  <!-- start class org.spf4j.io.appenders.SqlDateAppender -->
  <class name="SqlDateAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="SqlDateAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="date" type="java.sql.Date"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.SqlDateAppender -->
  <!-- start class org.spf4j.io.appenders.WriteableAppender -->
  <class name="WriteableAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppender"/>
    <constructor name="WriteableAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.base.Writeable"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.appenders.WriteableAppender -->
</package>
<package name="org.spf4j.perf.impl.ms.graphite">
  <!-- start class org.spf4j.perf.impl.ms.graphite.GraphiteTcpStore -->
  <class name="GraphiteTcpStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="GraphiteTcpStore" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
    </constructor>
    <constructor name="GraphiteTcpStore" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="GraphiteTcpStore" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="GraphiteTcpStore" type="java.lang.String, int, javax.net.SocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.graphite.GraphiteTcpStore -->
  <!-- start class org.spf4j.perf.impl.ms.graphite.GraphiteUdpStore -->
  <class name="GraphiteUdpStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="GraphiteUdpStore" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
    </constructor>
    <constructor name="GraphiteUdpStore" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="GraphiteUdpStore" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMetric"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementInfo" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="measurementName" type="java.lang.String"/>
      <param name="measurement" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="os" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write with the plaintext protocol: https://graphite.readthedocs.io/en/0.9.10/feeding-carbon.html

 @param measurementInfo measuremrnt info
 @param measurementName measurement name
 @param measurement measurement value
 @param timeStampMillis timestamp millis since epoch.
 @param os the output writer to write to.
 @throws IOException]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="MAX_UDP_MSG_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.graphite.GraphiteUdpStore -->
</package>
<package name="org.spf4j.recyclable.impl">
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers -->
  <class name="ArraySuppliers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers -->
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers.Bytes -->
  <class name="ArraySuppliers.Bytes" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="TL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_NEW" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers.Bytes -->
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers.Chars -->
  <class name="ArraySuppliers.Chars" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="TL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_NEW" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers.Chars -->
  <!-- start class org.spf4j.recyclable.impl.ArraySuppliers.Objects -->
  <class name="ArraySuppliers.Objects" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="TL_SUPPLIER" type="org.spf4j.recyclable.SizedRecyclingSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ArraySuppliers.Objects -->
  <!-- start class org.spf4j.recyclable.impl.LeaseImpl -->
  <class name="LeaseImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Lease"/>
    <constructor name="LeaseImpl" type="org.spf4j.recyclable.RecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.LeaseImpl -->
  <!-- start class org.spf4j.recyclable.impl.ObjectHolder -->
  <class name="ObjectHolder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getObj" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="borrowOrCreateObjectIfPossible" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="borrowObjectIfAvailable" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="returnObject"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
    </method>
    <method name="validateObjectIfNotBorrowed"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="disposeIfNotBorrowed" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[this is not a thread safe implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ObjectHolder -->
  <!-- start class org.spf4j.recyclable.impl.ObjectHolderFactory -->
  <class name="ObjectHolderFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.RecyclingSupplier.Factory"/>
    <constructor name="ObjectHolderFactory" type="int, org.spf4j.recyclable.RecyclingSupplier.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="ObjectHolderFactory" type="org.spf4j.recyclable.RecyclingSupplier.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="org.spf4j.recyclable.impl.ObjectHolder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.recyclable.impl.ObjectHolder"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="validate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="org.spf4j.recyclable.impl.ObjectHolder"/>
      <param name="e" type="java.lang.Exception"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.ObjectHolderFactory -->
  <!-- start class org.spf4j.recyclable.impl.Powerof2SizedGlobalRecyclingSupplier -->
  <class name="Powerof2SizedGlobalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.SizedRecyclingSupplier"/>
    <constructor name="Powerof2SizedGlobalRecyclingSupplier" type="org.spf4j.recyclable.SizedRecyclingSupplier.Factory, org.spf4j.base.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[recycling supplier that allows you to recycle objects.
 Recycling objects is dangerous business, care should be used.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.Powerof2SizedGlobalRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.impl.Powerof2ThreadLocalRecyclingSupplier -->
  <class name="Powerof2ThreadLocalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.SizedRecyclingSupplier"/>
    <constructor name="Powerof2ThreadLocalRecyclingSupplier" type="org.spf4j.recyclable.SizedRecyclingSupplier.Factory, org.spf4j.base.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[recycling supplier that allows you to recycle objects.
 Recycling objects is dangerous business, care should be used.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.Powerof2ThreadLocalRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.impl.RecyclingSupplierBuilder -->
  <class name="RecyclingSupplierBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="RecyclingSupplierBuilder" type="int, org.spf4j.recyclable.RecyclingSupplier.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="unfair" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withInitialSize" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pinitialSize" type="int"/>
    </method>
    <method name="withMaintenance" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pexec" type="java.util.concurrent.ScheduledExecutorService"/>
      <param name="pmaintenanceIntervalMillis" type="long"/>
      <param name="pcollectBorrowed" type="boolean"/>
    </method>
    <method name="withGetHook" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="phook" type="org.spf4j.base.Handler"/>
    </method>
    <method name="withRecycleHook" return="org.spf4j.recyclable.impl.RecyclingSupplierBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="phook" type="org.spf4j.base.Handler"/>
    </method>
    <method name="build" return="org.spf4j.recyclable.RecyclingSupplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.RecyclingSupplierBuilder -->
  <!-- start class org.spf4j.recyclable.impl.SharingObjectPool -->
  <class name="SharingObjectPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.RecyclingSupplier"/>
    <constructor name="SharingObjectPool" type="org.spf4j.recyclable.RecyclingSupplier.Factory, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <constructor name="SharingObjectPool" type="org.spf4j.recyclable.RecyclingSupplier.Factory, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="tryDispose" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[a object sharing pool. this pool allows for non exclusive object sharing. TODO: synchronization is too coarse, can be
 improved.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.SharingObjectPool -->
  <!-- start class org.spf4j.recyclable.impl.SharingObjectPool.SharedObject -->
  <class name="SharingObjectPool.SharedObject" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SharedObject" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SharedObject" type="java.lang.Object, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrTimesShared" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.recyclable.impl.SharingObjectPool.SharedObject -->
  <!-- start class org.spf4j.recyclable.impl.SizedThreadLocalRecyclingSupplier -->
  <class name="SizedThreadLocalRecyclingSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.SizedRecyclingSupplier"/>
    <constructor name="SizedThreadLocalRecyclingSupplier" type="org.spf4j.recyclable.SizedRecyclingSupplier.Factory, org.spf4j.base.ReferenceType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[recycling supplier that allows you to recycle objects.
 Recycling objects is dangerous business, care should be used.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.impl.SizedThreadLocalRecyclingSupplier -->
</package>
<package name="org.spf4j.perf.memory">
  <!-- start class org.spf4j.perf.memory.GCUsageSampler -->
  <class name="GCUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGCTimeDiff" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gcBeans" type="java.util.List"/>
      <param name="lastValues" type="gnu.trove.map.TObjectLongMap"/>
    </method>
    <method name="getGCTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gcBeans" type="java.util.List"/>
    </method>
    <method name="getGCTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class allows you to poll and recordAt to a file the heap commited and heap used for your java process. start
 data recording by calling the startMemoryUsageSampling method, stop the data recording by calling the method:
 startMemoryUsageSampling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.memory.GCUsageSampler -->
  <!-- start class org.spf4j.perf.memory.MemoryUsageSampler -->
  <class name="MemoryUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMilis" type="long"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMilis" type="int"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMilis" type="int"/>
      <param name="accumulateIntervalMillis" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="dumpHeap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="liveObjectOnly" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHotspotDiagnosticBean" return="com.sun.management.HotSpotDiagnosticMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class allows you to poll and recordAt to a file the heap committed and heap used for your java process. start
 data recording by calling the startMemoryUsageSampling method, stop the data recording by calling the method:
 startMemoryUsageSampling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.memory.MemoryUsageSampler -->
</package>
<package name="org.spf4j.io.csv">
  <!-- start class org.spf4j.io.csv.CharSeparatedValues -->
  <class name="CharSeparatedValues" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharSeparatedValues" type="char"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow2"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="long[]"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Iterable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="java.lang.Iterable"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvRowHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readNoBom" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
      <param name="handler" type="org.spf4j.io.csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[reads CSV format until EOF of reader.

 @param <T>
 @param preader
 @param handler
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="asIterable" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <doc>
      <![CDATA[read a CSV stream, as a Iterable over rows.
 the List<String> instance is reused during iteration, you will need to copy content into
 own data structure.
 @param preader
 @return]]>
      </doc>
    </method>
    <method name="reader" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readerNoBOM" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
    </method>
    <method name="writeCsvElement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeQuotedCsvElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toCsvElement" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
    </method>
    <method name="readCsvElement" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="addElemTo" type="java.lang.StringBuilder"/>
      <param name="lineNr" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[returns next character.

 @param reader
 @param addElemTo
 @return - next character or -1 if eof has been reached.
 @throws IOException]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="UTF_BOM" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[http://unicode.org/faq/utf_bom.html#BOM]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Supports Character Separated values format as described at: https://en.wikipedia.org/wiki/Comma-separated_values.
 either of \n \r or \r\n generalized to custom separator character.
 are valid end of line delimiters

 why another implementation? because I need one that is as fast as possible, and as flexible as possible.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.CharSeparatedValues -->
  <!-- start interface org.spf4j.io.csv.CsvHandler -->
  <interface name="CsvHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="startRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rowNr" type="int"/>
    </method>
    <method name="startRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="element"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[@param elem - the CharSequence instance is being reused, between invocations. value should be copied or parsed into
 a new object.]]>
      </doc>
    </method>
    <method name="endRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="eof" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvHandler -->
  <!-- start interface org.spf4j.io.csv.CsvMapHandler -->
  <interface name="CsvMapHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="row"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="row" type="java.util.Map"/>
    </method>
    <method name="eof" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvMapHandler -->
  <!-- start class org.spf4j.io.csv.CsvParseException -->
  <class name="CsvParseException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CsvParseException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvParseException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvParseException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvParseException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.CsvParseException -->
  <!-- start interface org.spf4j.io.csv.CsvReader -->
  <interface name="CsvReader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="next" return="org.spf4j.io.csv.CsvReader.TokenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[read next CSV element, and return its type.

 @return return CSV element type.
 @throws IOException exception is something goes wrong.]]>
      </doc>
    </method>
    <method name="getElement" return="java.lang.CharSequence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the CSV element string. the underlying instance is reused, so you will need to make a copy of this if planning to
 use it.

 @return CharSequence representing a csv cell.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Char separated value file Reader.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvReader -->
  <!-- start class org.spf4j.io.csv.CsvReader.TokenType -->
  <class name="CsvReader.TokenType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.io.csv.CsvReader.TokenType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.io.csv.CsvReader.TokenType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="ELEMENT" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="END_ROW" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="END_DOCUMENT" type="org.spf4j.io.csv.CsvReader.TokenType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.csv.CsvReader.TokenType -->
  <!-- start class org.spf4j.io.csv.CsvReader2Iterator -->
  <class name="CsvReader2Iterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <constructor name="CsvReader2Iterator" type="org.spf4j.io.csv.CsvReader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.csv.CsvReader2Iterator -->
  <!-- start interface org.spf4j.io.csv.CsvRowHandler -->
  <interface name="CsvRowHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="element"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
    </method>
    <method name="eof" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.csv.CsvRowHandler -->
  <!-- start class org.spf4j.io.csv.CsvRuntimeException -->
  <class name="CsvRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CsvRuntimeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CsvRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.CsvRuntimeException -->
  <!-- start class org.spf4j.io.csv.UncheckedCsvParseException -->
  <class name="UncheckedCsvParseException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UncheckedCsvParseException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedCsvParseException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedCsvParseException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UncheckedCsvParseException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.csv.UncheckedCsvParseException -->
</package>
<package name="org.spf4j.test2.avro">
  <!-- start class org.spf4j.test2.avro.SampleNode -->
  <class name="SampleNode" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="SampleNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="SampleNode" type="java.lang.Integer, org.spf4j.test2.avro.SampleNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param count The new value for count
 @param subNodes The new value for subNodes]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getCount" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'count' field.
 @return The value of the 'count' field.]]>
      </doc>
    </method>
    <method name="setCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'count' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getSubNodes" return="org.spf4j.test2.avro.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subNodes' field.
 @return The value of the 'subNodes' field.]]>
      </doc>
    </method>
    <method name="setSubNodes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test2.avro.SampleNode"/>
      <doc>
      <![CDATA[Sets the value of the 'subNodes' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new SampleNode RecordBuilder.
 @return A new SampleNode RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test2.avro.SampleNode.Builder"/>
      <doc>
      <![CDATA[Creates a new SampleNode RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new SampleNode RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test2.avro.SampleNode"/>
      <doc>
      <![CDATA[Creates a new SampleNode RecordBuilder by copying an existing SampleNode instance.
 @param other The existing instance to copy.
 @return A new SampleNode RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="count" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="subNodes" type="org.spf4j.test2.avro.SampleNode"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.test2.avro.SampleNode -->
  <!-- start class org.spf4j.test2.avro.SampleNode.Builder -->
  <class name="SampleNode.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getCount" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'count' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setCount" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'count' field.
 @param value The value of 'count'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'count' field has been set.
 @return True if the 'count' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearCount" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'count' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="getSubNodes" return="org.spf4j.test2.avro.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subNodes' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setSubNodes" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test2.avro.SampleNode"/>
      <doc>
      <![CDATA[Sets the value of the 'subNodes' field.
 @param value The value of 'subNodes'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasSubNodes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subNodes' field has been set.
 @return True if the 'subNodes' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="getSubNodesBuilder" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Builder instance for the 'subNodes' field and creates one if it doesn't exist yet.
 @return This builder.]]>
      </doc>
    </method>
    <method name="setSubNodesBuilder" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test2.avro.SampleNode.Builder"/>
      <doc>
      <![CDATA[Sets the Builder instance for the 'subNodes' field
 @param value The builder instance that must be set.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasSubNodesBuilder" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subNodes' field has an active Builder instance
 @return True if the 'subNodes' field has an active Builder instance]]>
      </doc>
    </method>
    <method name="clearSubNodes" return="org.spf4j.test2.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subNodes' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.test2.avro.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for SampleNode instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.test2.avro.SampleNode.Builder -->
</package>
<package name="org.spf4j.stackmonitor">
  <!-- start class org.spf4j.stackmonitor.AbstractStackCollector -->
  <class name="AbstractStackCollector" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.stackmonitor.StackCollector"/>
    <constructor name="AbstractStackCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="applyOnSamples" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="java.util.function.Function"/>
    </method>
    <method name="clear" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addSample"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrNodes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.AbstractStackCollector -->
  <!-- start class org.spf4j.stackmonitor.FastStackCollector -->
  <class name="FastStackCollector" extends="org.spf4j.stackmonitor.AbstractStackCollector"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FastStackCollector" type="boolean, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FastStackCollector" type="boolean, boolean, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FastStackCollector" type="java.util.function.Predicate"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param threadFilter when returns true the thread is being ignored]]>
      </doc>
    </constructor>
    <method name="createNameBasedFilter" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collectRunnableThreadsOnly" type="boolean"/>
      <param name="collectForMain" type="boolean"/>
      <param name="xtraIgnoredThreads" type="java.lang.String[]"/>
    </method>
    <method name="getThreads" return="java.lang.Thread[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStackTraces" return="java.lang.StackTraceElement[][]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threads" type="java.lang.Thread[]"/>
    </method>
    <method name="dumpToPrintStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.PrintStream"/>
    </method>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignore" type="java.lang.Thread"/>
    </method>
    <doc>
    <![CDATA[This is a high performance sampling collector. The goal is for the sampling overhead to be minimal. This is better
 than the SimpleStackCollector in 2 ways: 1) No HashMap is created during sampling. Resulting in less garbage
 generated by sampling. 2) Stack trace for the sampling Thread is not created at all, saving some time and creating
 less garbage.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.FastStackCollector -->
  <!-- start class org.spf4j.stackmonitor.FastStackCollector.ThreadNamesPredicate -->
  <class name="FastStackCollector.ThreadNamesPredicate" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Predicate"/>
    <constructor name="ThreadNamesPredicate" type="java.util.Set"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.Thread"/>
    </method>
  </class>
  <!-- end class org.spf4j.stackmonitor.FastStackCollector.ThreadNamesPredicate -->
  <!-- start class org.spf4j.stackmonitor.InvokedMethod -->
  <class name="InvokedMethod" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="InvokedMethod" type="org.spf4j.base.Method, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getMethod" return="org.spf4j.base.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withId" return="org.spf4j.stackmonitor.InvokedMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="int"/>
    </method>
    <method name="withNewId" return="org.spf4j.stackmonitor.InvokedMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="ROOT" type="org.spf4j.stackmonitor.InvokedMethod"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Class used in the invocation graph to represent a invoked method.

 for example in the stack:

 C.m1 -> C.m2 -> C.m1 -> C.m3

 C.m1 is invoked recursively and they will be assigned different invocation IDs. (incremental)

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.InvokedMethod -->
  <!-- start class org.spf4j.stackmonitor.Monitor -->
  <class name="Monitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <exception name="NoSuchMethodException" type="java.lang.NoSuchMethodException"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
      <exception name="InvocationTargetException" type="java.lang.reflect.InvocationTargetException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.Monitor -->
  <!-- start class org.spf4j.stackmonitor.MxStackCollector -->
  <class name="MxStackCollector" extends="org.spf4j.stackmonitor.AbstractStackCollector"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MxStackCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignore" type="java.lang.Thread"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.MxStackCollector -->
  <!-- start class org.spf4j.stackmonitor.ObservableOnlyStackCollector -->
  <class name="ObservableOnlyStackCollector" extends="org.spf4j.stackmonitor.AbstractStackCollector"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObservableOnlyStackCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerConsumer" return="java.util.function.Consumer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <method name="unregisterConsumer" return="java.util.function.Consumer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
    </method>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignore" type="java.lang.Thread"/>
    </method>
  </class>
  <!-- end class org.spf4j.stackmonitor.ObservableOnlyStackCollector -->
  <!-- start class org.spf4j.stackmonitor.ObservableStackCollector -->
  <class name="ObservableStackCollector" extends="org.spf4j.stackmonitor.AbstractStackCollector"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObservableStackCollector" type="boolean, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObservableStackCollector" type="java.util.function.Predicate"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerConsumer" return="java.util.function.Consumer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <method name="unregisterConsumer" return="java.util.function.Consumer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
    </method>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignore" type="java.lang.Thread"/>
    </method>
  </class>
  <!-- end class org.spf4j.stackmonitor.ObservableStackCollector -->
  <!-- start class org.spf4j.stackmonitor.SampleNode -->
  <class name="SampleNode" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="SampleNode" type="java.lang.StackTraceElement[], int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SampleNode" type="int, gnu.trove.map.TMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSampleNode" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="addToSampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="clone" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="aggregate" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node1" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="node2" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="cloneSubNodes" return="gnu.trove.map.TMap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="putAllClones"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="gnu.trove.map.TMap"/>
      <param name="destination" type="gnu.trove.map.TMap"/>
    </method>
    <method name="getSampleCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSubNodes" return="gnu.trove.map.TMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="height" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrNodes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="filteredBy" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="java.util.function.Predicate"/>
    </method>
    <method name="forEach"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.stackmonitor.SampleNode.InvocationHandler"/>
      <param name="from" type="org.spf4j.base.Method"/>
      <param name="to" type="org.spf4j.base.Method"/>
      <param name="ancestors" type="java.util.Map"/>
    </method>
    <method name="toGraph" return="org.spf4j.ds.Graph"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rootNode" type="org.spf4j.stackmonitor.SampleNode"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.SampleNode -->
  <!-- start class org.spf4j.stackmonitor.SampleNode.InvocationCount -->
  <class name="SampleNode.InvocationCount" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvocationCount" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.stackmonitor.SampleNode.InvocationCount -->
  <!-- start interface org.spf4j.stackmonitor.SampleNode.InvocationHandler -->
  <interface name="SampleNode.InvocationHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="org.spf4j.base.Method"/>
      <param name="to" type="org.spf4j.base.Method"/>
      <param name="sampleCount" type="int"/>
      <param name="ancestors" type="java.util.Map"/>
      <doc>
      <![CDATA[handler for SampleNode tree traversal for each invocation.
 @param from method
 @param to method
 @param sampleCount number of samples
 @param ancestors]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.stackmonitor.SampleNode.InvocationHandler -->
  <!-- start class org.spf4j.stackmonitor.Sampler -->
  <class name="Sampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Sampler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="org.spf4j.stackmonitor.StackCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int, org.spf4j.stackmonitor.StackCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Sampler" type="int, int, org.spf4j.stackmonitor.StackCollector, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="dumpToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dumpToFile" return="java.io.File"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Dumps the sampled stacks to file. the collected samples are reset

 @param id - id will be added to file name returns the name of the file.
 @return - the file name where the data was persisted or null if there was no data to persist.
 @throws IOException - io issues while persisting data.]]>
      </doc>
    </method>
    <method name="dumpToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getSampleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setSampleTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="isStopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStackCollector" return="org.spf4j.stackmonitor.StackCollector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getDumpTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDumpTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dumpTimeMillis" type="int"/>
    </method>
    <field name="DEFAULT_SS_DUMP_FOLDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_SS_DUMP_FILE_NAME_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility to sample stack traces. Stack traces can be persisted for later analysis.

 please read http://sape.inf.usi.ch/sites/default/files/publication/pldi10.pdf pure java stack sampling will probably
 have safepoint bias.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.Sampler -->
  <!-- start class org.spf4j.stackmonitor.SimpleStackCollector -->
  <class name="SimpleStackCollector" extends="org.spf4j.stackmonitor.AbstractStackCollector"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleStackCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignore" type="java.lang.Thread"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.SimpleStackCollector -->
  <!-- start class org.spf4j.stackmonitor.Spf4jProfilerException -->
  <class name="Spf4jProfilerException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Spf4jProfilerException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Spf4jProfilerException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Spf4jProfilerException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Spf4jProfilerException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.Spf4jProfilerException -->
  <!-- start interface org.spf4j.stackmonitor.StackCollector -->
  <interface name="StackCollector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="applyOnSamples" return="org.spf4j.stackmonitor.SampleNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transform" type="java.util.function.Function"/>
      <doc>
      <![CDATA[Apply function on the collected samples.

 @param transform - the function to apply on samples.
 @return - sample node before function was applied.]]>
      </doc>
    </method>
    <method name="clear" return="org.spf4j.stackmonitor.SampleNode"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="sample"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignore" type="java.lang.Thread"/>
    </method>
    <method name="addSample"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.stackmonitor.StackCollector -->
  <!-- start class org.spf4j.stackmonitor.StackTrace -->
  <class name="StackTrace" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="StackTrace" type="java.lang.StackTraceElement[], int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="org.spf4j.stackmonitor.StackTrace"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stackTrace" type="java.lang.StackTraceElement[]"/>
      <param name="relevantFramesStart" type="int"/>
    </method>
    <method name="getStackTrace" return="java.lang.StackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="EMPTY_STACK_TRACE" type="java.lang.StackTraceElement[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.StackTrace -->
  <!-- start class org.spf4j.stackmonitor.StackVisualizer -->
  <class name="StackVisualizer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="generateHtmlTable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="m" type="org.spf4j.base.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="tableWidth" type="int"/>
      <param name="maxDepth" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="generateSvg"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="m" type="org.spf4j.base.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="width" type="int"/>
      <param name="maxDepth" type="int"/>
      <param name="idPfx" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="generateSubSvg"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="m" type="org.spf4j.base.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="x" type="int"/>
      <param name="y" type="int"/>
      <param name="width" type="int"/>
      <param name="maxDepth" type="int"/>
      <param name="idPfx" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[utility class to generate svg and html out of stack samples.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.stackmonitor.StackVisualizer -->
</package>
<package name="org.spf4j.ssdump2">
  <!-- start class org.spf4j.ssdump2.Converter -->
  <class name="Converter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="org.spf4j.base.Method"/>
      <param name="node" type="org.spf4j.stackmonitor.SampleNode"/>
      <param name="parentId" type="int"/>
      <param name="id" type="int"/>
      <param name="handler" type="org.spf4j.base.Handler"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="convert" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samples" type="java.util.Iterator"/>
    </method>
    <method name="save"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="collected" type="org.spf4j.stackmonitor.SampleNode"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="load" return="org.spf4j.stackmonitor.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ssdump2.Converter -->
</package>
<package name="org.spf4j.ssdump2.avro">
  <!-- start class org.spf4j.ssdump2.avro.AMethod -->
  <class name="AMethod" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="AMethod"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="AMethod" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param declaringClass the declaring class of the method.
 @param name the name of the method]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getDeclaringClass" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'declaringClass' field.
 @return the declaring class of the method.]]>
      </doc>
    </method>
    <method name="setDeclaringClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'declaringClass' field.
 the declaring class of the method.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.
 @return the name of the method]]>
      </doc>
    </method>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field.
 the name of the method
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new AMethod RecordBuilder.
 @return A new AMethod RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.ssdump2.avro.AMethod.Builder"/>
      <doc>
      <![CDATA[Creates a new AMethod RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new AMethod RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.ssdump2.avro.AMethod"/>
      <doc>
      <![CDATA[Creates a new AMethod RecordBuilder by copying an existing AMethod instance.
 @param other The existing instance to copy.
 @return A new AMethod RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="declaringClass" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the declaring class of the method.]]>
      </doc>
    </field>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the name of the method]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.ssdump2.avro.AMethod -->
  <!-- start class org.spf4j.ssdump2.avro.AMethod.Builder -->
  <class name="AMethod.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getDeclaringClass" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'declaringClass' field.
 the declaring class of the method.
 @return The value.]]>
      </doc>
    </method>
    <method name="setDeclaringClass" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'declaringClass' field.
 the declaring class of the method.
 @param value The value of 'declaringClass'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasDeclaringClass" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'declaringClass' field has been set.
 the declaring class of the method.
 @return True if the 'declaringClass' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearDeclaringClass" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'declaringClass' field.
 the declaring class of the method.
 @return This builder.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.
 the name of the method
 @return The value.]]>
      </doc>
    </method>
    <method name="setName" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field.
 the name of the method
 @param value The value of 'name'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'name' field has been set.
 the name of the method
 @return True if the 'name' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearName" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'name' field.
 the name of the method
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.ssdump2.avro.AMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for AMethod instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ssdump2.avro.AMethod.Builder -->
  <!-- start class org.spf4j.ssdump2.avro.ASample -->
  <class name="ASample" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="ASample"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="ASample" type="java.lang.Integer, java.lang.Integer, java.lang.Integer, org.spf4j.ssdump2.avro.AMethod"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param id the id of the sample
 @param parentId the parent sample where current method was executed from.
 @param count the number of time this records method has been caught in execution
 @param method the method caught in execution]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getId" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'id' field.
 @return the id of the sample]]>
      </doc>
    </method>
    <method name="setId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'id' field.
 the id of the sample
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getParentId" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'parentId' field.
 @return the parent sample where current method was executed from.]]>
      </doc>
    </method>
    <method name="setParentId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'parentId' field.
 the parent sample where current method was executed from.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getCount" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'count' field.
 @return the number of time this records method has been caught in execution]]>
      </doc>
    </method>
    <method name="setCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'count' field.
 the number of time this records method has been caught in execution
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getMethod" return="org.spf4j.ssdump2.avro.AMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'method' field.
 @return the method caught in execution]]>
      </doc>
    </method>
    <method name="setMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.ssdump2.avro.AMethod"/>
      <doc>
      <![CDATA[Sets the value of the 'method' field.
 the method caught in execution
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ASample RecordBuilder.
 @return A new ASample RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.ssdump2.avro.ASample.Builder"/>
      <doc>
      <![CDATA[Creates a new ASample RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new ASample RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.ssdump2.avro.ASample"/>
      <doc>
      <![CDATA[Creates a new ASample RecordBuilder by copying an existing ASample instance.
 @param other The existing instance to copy.
 @return A new ASample RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="id" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the id of the sample]]>
      </doc>
    </field>
    <field name="parentId" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the parent sample where current method was executed from.]]>
      </doc>
    </field>
    <field name="count" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the number of time this records method has been caught in execution]]>
      </doc>
    </field>
    <field name="method" type="org.spf4j.ssdump2.avro.AMethod"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the method caught in execution]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.ssdump2.avro.ASample -->
  <!-- start class org.spf4j.ssdump2.avro.ASample.Builder -->
  <class name="ASample.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getId" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'id' field.
 the id of the sample
 @return The value.]]>
      </doc>
    </method>
    <method name="setId" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'id' field.
 the id of the sample
 @param value The value of 'id'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'id' field has been set.
 the id of the sample
 @return True if the 'id' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearId" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'id' field.
 the id of the sample
 @return This builder.]]>
      </doc>
    </method>
    <method name="getParentId" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'parentId' field.
 the parent sample where current method was executed from.
 @return The value.]]>
      </doc>
    </method>
    <method name="setParentId" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'parentId' field.
 the parent sample where current method was executed from.
 @param value The value of 'parentId'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasParentId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'parentId' field has been set.
 the parent sample where current method was executed from.
 @return True if the 'parentId' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearParentId" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'parentId' field.
 the parent sample where current method was executed from.
 @return This builder.]]>
      </doc>
    </method>
    <method name="getCount" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'count' field.
 the number of time this records method has been caught in execution
 @return The value.]]>
      </doc>
    </method>
    <method name="setCount" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'count' field.
 the number of time this records method has been caught in execution
 @param value The value of 'count'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'count' field has been set.
 the number of time this records method has been caught in execution
 @return True if the 'count' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearCount" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'count' field.
 the number of time this records method has been caught in execution
 @return This builder.]]>
      </doc>
    </method>
    <method name="getMethod" return="org.spf4j.ssdump2.avro.AMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'method' field.
 the method caught in execution
 @return The value.]]>
      </doc>
    </method>
    <method name="setMethod" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.ssdump2.avro.AMethod"/>
      <doc>
      <![CDATA[Sets the value of the 'method' field.
 the method caught in execution
 @param value The value of 'method'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasMethod" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'method' field has been set.
 the method caught in execution
 @return True if the 'method' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="getMethodBuilder" return="org.spf4j.ssdump2.avro.AMethod.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Builder instance for the 'method' field and creates one if it doesn't exist yet.
 the method caught in execution
 @return This builder.]]>
      </doc>
    </method>
    <method name="setMethodBuilder" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.ssdump2.avro.AMethod.Builder"/>
      <doc>
      <![CDATA[Sets the Builder instance for the 'method' field
 the method caught in execution
 @param value The builder instance that must be set.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasMethodBuilder" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'method' field has an active Builder instance
 the method caught in execution
 @return True if the 'method' field has an active Builder instance]]>
      </doc>
    </method>
    <method name="clearMethod" return="org.spf4j.ssdump2.avro.ASample.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'method' field.
 the method caught in execution
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.ssdump2.avro.ASample"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for ASample instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ssdump2.avro.ASample.Builder -->
  <!-- start interface org.spf4j.ssdump2.avro.Ssdump2 -->
  <interface name="Ssdump2"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="PROTOCOL" type="org.apache.avro.Protocol"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.ssdump2.avro.Ssdump2 -->
  <!-- start interface org.spf4j.ssdump2.avro.Ssdump2.Callback -->
  <interface name="Ssdump2.Callback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.ssdump2.avro.Ssdump2"/>
    <field name="PROTOCOL" type="org.apache.avro.Protocol"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.ssdump2.avro.Ssdump2.Callback -->
</package>
<package name="org.spf4j.concurrent">
  <!-- start class org.spf4j.concurrent.AtomicReferenceExt -->
  <class name="AtomicReferenceExt" extends="java.util.concurrent.atomic.AtomicReference"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AtomicReferenceExt" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AtomicReferenceExt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="update" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="function" type="java.util.function.UnaryOperator"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.AtomicReferenceExt -->
  <!-- start class org.spf4j.concurrent.Atomics -->
  <class name="Atomics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="update" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ar" type="java.util.concurrent.atomic.AtomicReference"/>
      <param name="function" type="java.util.function.UnaryOperator"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.Atomics -->
  <!-- start class org.spf4j.concurrent.AtomicSequence -->
  <class name="AtomicSequence" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Sequence"/>
    <constructor name="AtomicSequence" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="next" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.AtomicSequence -->
  <!-- start class org.spf4j.concurrent.CustomThreadFactory -->
  <class name="CustomThreadFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ThreadFactory"/>
    <constructor name="CustomThreadFactory" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CustomThreadFactory" type="java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The default thread factory]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.CustomThreadFactory -->
  <!-- start class org.spf4j.concurrent.DefaultExecutor -->
  <class name="DefaultExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="INSTANCE" type="java.util.concurrent.ExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This executor aims to be a general purpose executor for async tasks. (equivalent to ForkJoinPool.commonPool())

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultExecutor -->
  <!-- start class org.spf4j.concurrent.DefaultScheduler -->
  <class name="DefaultScheduler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="scheduleAllignedAtFixedRateMillis" return="java.util.concurrent.ScheduledFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
      <param name="millisInterval" type="long"/>
      <doc>
      <![CDATA[this will schedule a runnable aligned to the hour or day at a fixed rate.

 @param command - the Runnable to execute.
 @param millisInterval - the schedule interval in milliseconds.
 @return - Future that allows to cancel the schedule.]]>
      </doc>
    </method>
    <field name="INSTANCE" type="java.util.concurrent.ScheduledExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LISTENABLE_INSTANCE" type="com.google.common.util.concurrent.ListeningScheduledExecutorService"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.DefaultScheduler -->
  <!-- start class org.spf4j.concurrent.FileBasedLock -->
  <class name="FileBasedLock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.locks.Lock"/>
    <implements name="java.io.Closeable"/>
    <method name="extractPosixPermissions" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileAttributes" type="java.nio.file.attribute.FileAttribute[]"/>
    </method>
    <method name="getLock" return="org.spf4j.concurrent.FileBasedLock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockFile" type="java.io.File"/>
      <param name="fileAttributes" type="java.nio.file.attribute.FileAttribute[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a FileBasedLock implementation.

 FileBasedLock will hold onto a File Descriptor during the entire life of the instance.
 FileBasedLock is a reentrant lock. (it can be acquired multiple times by the same thread)

 @param lockFile the file to lock on.
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLock" return="org.spf4j.concurrent.FileBasedLock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lockFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lockInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newCondition" return="java.util.concurrent.locks.Condition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[will release lock if owned, will not nothing if not owned.]]>
      </doc>
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Throwable" type="java.lang.Throwable"/>
    </method>
    <method name="getContextInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLocalHoldCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isHeldByCurrentThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_FILE_ATTRS" type="java.nio.file.attribute.FileAttribute[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[File based Lock implementation, that can be used as IPC method.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.FileBasedLock -->
  <!-- start class org.spf4j.concurrent.FutureBean -->
  <class name="FutureBean" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Future"/>
    <constructor name="FutureBean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="cancel" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterruptIfRunning" type="boolean"/>
    </method>
    <method name="isCancelled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDone" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResultStore" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="processResult" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="org.spf4j.base.Either"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="setResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="setExceptionResult"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="result" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[bean like implementation of a future
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.FutureBean -->
  <!-- start class org.spf4j.concurrent.Futures -->
  <class name="Futures" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="cancelAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mayInterrupt" type="boolean"/>
      <param name="iterator" type="java.util.Iterator"/>
    </method>
    <method name="getAll" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.util.concurrent.Future[]"/>
      <doc>
      <![CDATA[Gets all futures resuls.

 @param deadlineNanos
 @param futures
 @return]]>
      </doc>
    </method>
    <method name="getAll" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <method name="getAllWithDeadlineNanos" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <param name="futures" type="java.lang.Iterable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.Futures -->
  <!-- start interface org.spf4j.concurrent.LifoThreadPool -->
  <interface name="LifoThreadPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.ExecutorService"/>
    <method name="exportJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadPriority" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[See LifoThreadPoolBuilder for creating lifo  thread pools.

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.LifoThreadPool -->
  <!-- start class org.spf4j.concurrent.LifoThreadPoolBuilder -->
  <class name="LifoThreadPoolBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newBuilder" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withPoolName" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="poolName" type="java.lang.String"/>
    </method>
    <method name="withCoreSize" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coreSize" type="int"/>
    </method>
    <method name="withMaxSize" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxSize" type="int"/>
    </method>
    <method name="withMaxIdleTimeMillis" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="withTaskQueue" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskQueue" type="java.util.Queue"/>
    </method>
    <method name="withQueueSizeLimit" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="withDaemonThreads" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="withSpinLockCount" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spinLockCount" type="int"/>
    </method>
    <method name="withRejectionHandler" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rejectionHandler" type="org.spf4j.concurrent.RejectedExecutionHandler"/>
    </method>
    <method name="withThreadPriority" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <method name="mutable" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enableJmx" return="org.spf4j.concurrent.LifoThreadPoolBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.spf4j.concurrent.LifoThreadPool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildMutable" return="org.spf4j.concurrent.MutableLifoThreadPool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LifoThreadPoolBuilder -->
  <!-- start class org.spf4j.concurrent.LifoThreadPoolExecutorSQP -->
  <class name="LifoThreadPoolExecutorSQP" extends="java.util.concurrent.AbstractExecutorService"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.LifoThreadPool"/>
    <constructor name="LifoThreadPoolExecutorSQP" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="exportJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadPriority" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Lifo scheduled java thread pool, based on talk: http://applicative.acm.org/speaker-BenMaurer.html This implementation
 behaves differently compared with a java Thread pool in that it prefers to spawn a thread if possible instead of
 queueing tasks.

 See LifoThreadPoolBuilder for conveniently constructing pools

 There are 3 data structures involved in the transfer of tasks to Threads.

 1) Task Queue - a classic FIFO queue. RW controlled by a reentrant lock. only non-blockng read operations are done on
 this queue 2) Available Thread Queue - a classic LIFO queue, a thread end up here when there is nothing to process.
 3) A "UnitQueue", is a queue with a capacity on 1, which a thread will listen on while in the available thread queue.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LifoThreadPoolExecutorSQP -->
  <!-- start class org.spf4j.concurrent.LocalSemaphore -->
  <class name="LocalSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="LocalSemaphore" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A process level semaphore implementation based on the JDK semaphore.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LocalSemaphore -->
  <!-- start class org.spf4j.concurrent.LockRuntimeException -->
  <class name="LockRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LockRuntimeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LockRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.LockRuntimeException -->
  <!-- start interface org.spf4j.concurrent.MutableLifoThreadPool -->
  <interface name="MutableLifoThreadPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.LifoThreadPool"/>
    <method name="setDaemonThreads"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="setMaxIdleTimeMillis"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="setMaxThreadCount"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxThreadCount" type="int"/>
    </method>
    <method name="setQueueSizeLimit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="setThreadPriority"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.MutableLifoThreadPool -->
  <!-- start class org.spf4j.concurrent.MutableLifoThreadPoolExecutorSQP -->
  <class name="MutableLifoThreadPoolExecutorSQP" extends="java.util.concurrent.AbstractExecutorService"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.MutableLifoThreadPool"/>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableLifoThreadPoolExecutorSQP" type="java.lang.String, int, int, int, java.util.Queue, int, boolean, int, org.spf4j.concurrent.RejectedExecutionHandler, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="exportJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.Runnable"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxThreadCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setMaxThreadCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxThreadCount" type="int"/>
    </method>
    <method name="isDaemonThreads" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDaemonThreads"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daemonThreads" type="boolean"/>
    </method>
    <method name="getStateLock" return="java.util.concurrent.locks.ReentrantLock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrQueuedTasks" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQueueSizeLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQueueSizeLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueSizeLimit" type="int"/>
    </method>
    <method name="getThreadPriority" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setThreadPriority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="threadPriority" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTaskQueue" return="java.util.Queue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxIdleTimeMillis" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setMaxIdleTimeMillis"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxIdleTimeMillis" type="int"/>
    </method>
    <method name="getPoolName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Lifo scheduled java thread pool, based on talk: http://applicative.acm.org/speaker-BenMaurer.html This implementation
 behaves differently compared with a java Thread pool in that it prefers to spawn a thread if possible instead of
 queueing tasks.

 See LifoThreadPoolBuilder for conveniently constructing pools


 This pool allows changing most parameters on the fly. This comes at the cost of using some volatile vars.

 There are 3 data structures involved in the transfer of tasks to Threads.

 1) Task Queue - a classic FIFO queue. RW controlled by a reentrant lock. only non-blockng read operations are done on
 this queue 2) Available Thread Queue - a classic LIFO queue, a thread end up here when there is nothing to process.
 3) A "UnitQueue", is a queue with a capacity on 1, which a thread will listen on while in the available thread queue.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.MutableLifoThreadPoolExecutorSQP -->
  <!-- start interface org.spf4j.concurrent.RejectedExecutionHandler -->
  <interface name="RejectedExecutionHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="rejectedExecution"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="java.lang.Runnable"/>
      <param name="executor" type="org.spf4j.concurrent.LifoThreadPool"/>
    </method>
    <field name="REJECT_EXCEPTION_EXEC_HANDLER" type="org.spf4j.concurrent.RejectedExecutionHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RUN_IN_CALLER_EXEC_HANDLER" type="org.spf4j.concurrent.RejectedExecutionHandler"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.RejectedExecutionHandler -->
  <!-- start interface org.spf4j.concurrent.RestartableService -->
  <interface name="RestartableService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.util.concurrent.Service"/>
    <implements name="java.lang.AutoCloseable"/>
    <method name="getServiceName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[THis is only a marker interface that will let you know that this Guava service is restartable.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.RestartableService -->
  <!-- start class org.spf4j.concurrent.RestartableServiceImpl -->
  <class name="RestartableServiceImpl" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.RestartableService"/>
    <constructor name="RestartableServiceImpl" type="com.google.common.base.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerToJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRunning" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="state" return="com.google.common.util.concurrent.Service.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopAsync" return="com.google.common.util.concurrent.Service"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitRunning"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTerminated"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="failureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.common.util.concurrent.Service.Listener"/>
      <param name="executor" type="java.util.concurrent.Executor"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.RestartableServiceImpl -->
  <!-- start class org.spf4j.concurrent.RetryExecutor -->
  <class name="RetryExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RetryExecutor" type="java.util.concurrent.ExecutorService, org.spf4j.base.ParameterizedSupplier, java.util.concurrent.BlockingQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RetryExecutor" type="java.util.concurrent.ExecutorService, org.spf4j.base.ParameterizedSupplier, org.spf4j.base.ParameterizedSupplier, java.util.concurrent.BlockingQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownNow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isShutdown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="awaitTermination" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="org.spf4j.base.Callables.TimeoutCallable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.util.concurrent.Callable"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="org.spf4j.base.TimeoutRunnable"/>
      <param name="result" type="java.lang.Object"/>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="org.spf4j.base.TimeoutRunnable"/>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.spf4j.base.TimeoutRunnable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_RETRY_SUPPLIER" type="org.spf4j.base.ParameterizedSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Executor that will execute Callables with retry. This executor cannot be used inside a Completion service.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.RetryExecutor -->
  <!-- start class org.spf4j.concurrent.ScalableSequence -->
  <class name="ScalableSequence" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Sequence"/>
    <constructor name="ScalableSequence" type="long, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="next" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ScalableSequence -->
  <!-- start interface org.spf4j.concurrent.Semaphore -->
  <interface name="Semaphore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Acquire one permit.
 @param timeout  time to wait for permit to become available.
 @param unit  units of time.
 @throws InterruptedException - operation interrupted.
 @throws TimeoutException - timed out.]]>
      </doc>
    </method>
    <method name="acquire"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Acquire a arbitrary number of permits.
 @param nrPermits - numer of permits to acquire.
 @param timeout - time to wait for permit to become available.
 @param unit - units of time.
 @throws InterruptedException - operation interrupted.
 @throws TimeoutException - timed out.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[try to acquire a permit.
 @param timeout  time to wait for permit to become available.
 @param unit  units of time.
 @return  true if permit acquired, false if timed out.
 @throws InterruptedException - operation interrupted.]]>
      </doc>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[try to acquire a number of permits.
 @param nrPermits  number of permits to acquire.
 @param timeout  time to wait for permits to become available.
 @param unit  units of time.
 @return  true if permits acquired, false if timed out.
 @throws InterruptedException - operation interrupted.]]>
      </doc>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[release 1 permit.]]>
      </doc>
    </method>
    <method name="release"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <doc>
      <![CDATA[release a number of permits.
 @param nrPermits  the number of permits to release.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A interface that abstracts a semaphore.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.concurrent.Semaphore -->
  <!-- start interface org.spf4j.concurrent.Sequence -->
  <interface name="Sequence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="next" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return next number in sequence. if result is negative an overflow happened.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.concurrent.Sequence -->
  <!-- start class org.spf4j.concurrent.ThreadLocalBufferedConsumer -->
  <class name="ThreadLocalBufferedConsumer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <implements name="java.io.Closeable"/>
    <constructor name="ThreadLocalBufferedConsumer" type="int, java.util.function.Consumer, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.ThreadLocalBufferedConsumer -->
  <!-- start class org.spf4j.concurrent.UIDGenerator -->
  <class name="UIDGenerator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UIDGenerator" type="org.spf4j.concurrent.Sequence, com.google.common.io.BaseEncoding, long, char, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a UID Generator

 @param sequence
 @param baseEncoding - if null MAC address based ID will not be included.]]>
      </doc>
    </constructor>
    <method name="generateIdBase" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="separator" type="char"/>
    </method>
    <method name="generateIdBase" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="separator" type="char"/>
      <param name="customEpoch" type="long"/>
    </method>
    <method name="generateIdBase" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <param name="baseEncoding" type="com.google.common.io.BaseEncoding"/>
      <param name="separator" type="char"/>
      <param name="customEpoch" type="long"/>
    </method>
    <method name="getMaxSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Unique ID Generator Based on the assumptions: 1. host MAC address is used. (each network interface has a Unique ID)
 (encoded with provided encoder) 2. process id is used + current epoch seconds. it is assumed the PID is not recycled
 within a second. 3. A process sequence is used. UIDs will cycle after Long.MaxValue is reached.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UIDGenerator -->
  <!-- start class org.spf4j.concurrent.UnboundedLoadingCache -->
  <class name="UnboundedLoadingCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedLoadingCache" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache" type="java.util.Comparator, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Will use a ConcurrentSkipListMap to store the underlying data.
 @param comparator
 @param loader]]>
      </doc>
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeysLoaded" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[custom build high performance implementation for a unbounded guava cache: UnboundedLoadingCache is implemented with
 JDK concurrent map UnboundedLoadingCache2 is using the JDK 1.8 computing map functionality, but benchmarks show worse
 performance.

 Benchmark Mode Cnt Score Error Units CacheBenchmark.guavaCache thrpt 15 29011674.275 # 710672.413 ops/s
 CacheBenchmark.spf4j2Cache thrpt 15 30567248.015 # 807965.535 ops/s CacheBenchmark.spf4jCache thrpt 15 37961593.882 #
 1136244.254 ops/s CacheBenchmark.spf4jRacyCache thrpt 15 37553655.751 # 855349.501 ops/s

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedLoadingCache -->
  <!-- start class org.spf4j.concurrent.UnboundedLoadingCache2 -->
  <class name="UnboundedLoadingCache2" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedLoadingCache2" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedLoadingCache2" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Simple adapter that adapts a java ConcurrentMap to a guava cache.
 See UnboundedLoadingCache for rationale and benchmark data to see
 why this is not the default implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedLoadingCache2 -->
  <!-- start class org.spf4j.concurrent.UnboundedRacyLoadingCache -->
  <class name="UnboundedRacyLoadingCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="use UnboundedLoadingCache instead.">
    <implements name="com.google.common.cache.LoadingCache"/>
    <constructor name="UnboundedRacyLoadingCache" type="int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnboundedRacyLoadingCache" type="int, int, com.google.common.cache.CacheLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getUnchecked" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getAll" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="apply" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="asMap" return="java.util.concurrent.ConcurrentMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIfPresent" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="valueLoader" type="java.util.concurrent.Callable"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
    </method>
    <method name="getAllPresent" return="com.google.common.collect.ImmutableMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.Map"/>
    </method>
    <method name="invalidate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.lang.Iterable"/>
    </method>
    <method name="invalidateAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stats" return="com.google.common.cache.CacheStats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="cleanUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly
 @deprecated use UnboundedLoadingCache instead.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnboundedRacyLoadingCache -->
  <!-- start class org.spf4j.concurrent.UnitQueuePU -->
  <class name="UnitQueuePU" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnitQueuePU" type="java.lang.Thread"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutNanos" type="long"/>
      <param name="spinCount" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offer" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Special purpose queue for a single value Custom designed for the LifoThreadPool

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UnitQueuePU -->
  <!-- start class org.spf4j.concurrent.UpdateResult -->
  <class name="UpdateResult" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="updated" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="same" return="org.spf4j.concurrent.UpdateResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="isObjectUpdated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getObj" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.UpdateResult -->
</package>
<package name="org.spf4j.base">
  <!-- start class org.spf4j.base.AbstractRunnable -->
  <class name="AbstractRunnable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="AbstractRunnable" type="boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create runnable lenient or not with a specific thread name during its execution.

 @param lenient - If lenient is true, it means that nobody is waiting for this runnable's result(finish) so To not
 loose the exception, the runnable will LOG it as an error, and not retrow it
 @param threadName - the thread name during the execution of this runnable.]]>
      </doc>
    </constructor>
    <constructor name="AbstractRunnable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[create runnable.

 @param lenient - If lenient is true, it means that nobody is waiting for this runnable's result(finish) so To not
 loose the exception, the runnable will LOG it as an error, and not retrow it]]>
      </doc>
    </constructor>
    <constructor name="AbstractRunnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractRunnable" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doRun"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="ERROR_EXIT_CODE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NOP" type="java.lang.Runnable"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.AbstractRunnable -->
  <!-- start class org.spf4j.base.AggregateTranslator -->
  <class name="AggregateTranslator" extends="org.spf4j.base.CharSequenceTranslator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AggregateTranslator" type="org.spf4j.base.CharSequenceTranslator[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="translate" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.AggregateTranslator -->
  <!-- start class org.spf4j.base.AlmostSafe -->
  <class name="AlmostSafe" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="USF" type="sun.misc.Unsafe"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Expose
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.AlmostSafe -->
  <!-- start class org.spf4j.base.ArrayBuilder -->
  <class name="ArrayBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayBuilder" type="int, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ArrayBuilder -->
  <!-- start class org.spf4j.base.Arrays -->
  <class name="Arrays" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getColumnAsDoubles" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="long[][]"/>
      <param name="columnNumber" type="int"/>
    </method>
    <method name="getColumn" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="double[][]"/>
      <param name="columnNumber" type="int"/>
    </method>
    <method name="toDoubleArray" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="larr" type="long[]"/>
    </method>
    <method name="toObjectArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="larr" type="long[]"/>
    </method>
    <method name="divide" return="double[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arr1" type="double[]"/>
      <param name="arr2" type="double[]"/>
    </method>
    <method name="deepEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a1" type="java.lang.Object[]"/>
      <param name="a2" type="java.lang.Object[]"/>
      <param name="starting" type="int"/>
    </method>
    <method name="deepEquals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a1" type="java.lang.Object[]"/>
      <param name="a2" type="java.lang.Object[]"/>
      <param name="starting" type="int"/>
      <param name="ending" type="int"/>
    </method>
    <method name="search" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="c" type="char"/>
    </method>
    <method name="moveOfRange" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="original" type="java.lang.Object[]"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
    </method>
    <method name="concat" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arrays" type="java.lang.Object[][]"/>
    </method>
    <method name="indexOf" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="content" type="java.lang.Object"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="byte[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[implementation which significantly faster for large arrays (> 500).]]>
      </doc>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="java.lang.Object[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[implementation which is significantly faster for large arrays (> 500).
 Bechmark results:
 Benchmark                                      Mode Cnt Score            Error           Units
 ArraysBenchmark.testSpf4jFillSmall(10)         thrpt 10 1048892782.375   # 29976629.818  ops/s
 ArraysBenchmark.testjdkFillSmall(10)           thrpt 10 1046330835.509   # 47577260.717  ops/s
 ArraysBenchmark.testSpf4jFillMedium(100)       thrpt 10 123724912.161    # 4049077.779   ops/s
 ArraysBenchmark.testjdkFillMedium(100)         thrpt 10 124143139.498    # 2044760.427   ops/s
 ArraysBenchmark.testSpf4jFillLarge(1000)       thrpt 10 20335282.192     # 592359.181    ops/s
 ArraysBenchmark.testjdkFillLarge(1000)         thrpt 10 12661975.522     # 170457.046    ops/s
 ArraysBenchmark.testSpf4jFillVeryLarge(10000)  thrpt 10 2767351.098      # 74871.147     ops/s
 ArraysBenchmark.testjdkFillVeryLarge(10000     thrpt 10 1045099.669      # 30044.505     ops/s]]>
      </doc>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="char[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="char"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="int[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="int"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="long[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="long"/>
    </method>
    <method name="fill"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="double[]"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
      <param name="value" type="double"/>
    </method>
    <field name="EMPTY_OBJ_ARRAY" type="java.lang.Object[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_STRING_ARRAY" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_BYTE_ARRAY" type="byte[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_LONG_ARRAY" type="long[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_INT_ARRAY" type="int[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Array utilities.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Arrays -->
  <!-- start class org.spf4j.base.Base64 -->
  <class name="Base64" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <param name="from" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="decodeBase64V2" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <param name="from" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.CharSequence"/>
      <param name="from" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[@param text base64Binary data is likely to be long, and decoding requires each character to be accessed twice (once
 for counting length, another for decoding.)
 @param from the index of the first character in the sequence.
 @param len - the number of characters to decode.
 @return - the decoded byte array.]]>
      </doc>
    </method>
    <method name="decodeBase64" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="char[]"/>
      <param name="from" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="encode" return="char"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="encodeByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="encodeBase64" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
    </method>
    <method name="encodeBase64" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="encodeBase64V2" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Alternate implementation, should be better for large data.

 @param input - the byte array to encode
 @param offset - the index of the first byte that is to be encoded.
 @param len - the number of bytes to encode.
 @return - the encoded String.]]>
      </doc>
    </method>
    <method name="encodeBase64"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="result" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="encodeBase64" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="output" type="char[]"/>
      <param name="cptr" type="int"/>
      <doc>
      <![CDATA[Encodes a byte array into a char array by doing base64 encoding.

 The caller must supply a big enough buffer.

 @param input - the byte array to encode.
 @param offset - the index of the first byte to encode.
 @param len - the number of bytes to encode.
 @param output - the destination character array to encode to.
 @param cptr - the index of the first character to encode to.
 @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
 bytes should be placed.]]>
      </doc>
    </method>
    <method name="encodeBase64" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="out" type="byte[]"/>
      <param name="cptr" type="int"/>
      <doc>
      <![CDATA[Encodes a byte array into another byte array by first doing base64 encoding then encoding the result in ASCII.

 The caller must supply a big enough buffer.

 @param input - the byte array to encode.
 @param offset - the index of the first byte to encode.
 @param len - the number of bytes to encode.
 @param out - the destination byte array that represents an ASCII string to encode to.
 @param cptr - the index of the first byte in the destination array to encode to.
 @return the value of {@code ptr+((len+2)/3)*4}, which is the new offset in the output buffer where the further
 bytes should be placed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA["improved" implementation based on DataTypeConverterImpl performance should be same/slightly faster than the JDK
 equivalent But most importantly you can encode/decode parts of a String, which should reduce the need of copying
 objects and reduce the amount of garbage created.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Base64 -->
  <!-- start class org.spf4j.base.Callables -->
  <class name="Callables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitMillis" type="int"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxWaitMillis" type="int"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[After the immediate retries are done, delayed retry with randomized Fibonacci values up to the specified max is
 executed.

 @param <T> - the type returned by the Callable that is retried.
 @param <EX> - the Exception thrown by the retried callable.
 @param what - the callable to retry.
 @param nrImmediateRetries - the number of immediate retries.
 @param maxWaitMillis - maximum wait time in between retries.
 @param retryOnReturnVal - predicate to control retry on return value;
 @param retryOnException - predicate to retry on thrown exception.
 @return the result of the callable.
 @throws java.lang.InterruptedException - thrown if interrupted.
 @throws EX - the exception declared to be thrown by the callable.]]>
      </doc>
    </method>
    <method name="rootClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.lang.Exception"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.Callables.TimeoutCallable"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pwhat" type="org.spf4j.base.Callables.CheckedCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.Callables.RetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.RetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Naive implementation of execution with retry logic. a callable will be executed and retry attempted in current
 thread if the result and exception predicates. before retry, a callable can be executed that can abort the retry
 and finish the function with the previous result.

 @param <T> - The type of callable to retry result;
 @param <EX> - the exception thrown by the callable to retry.
 @param pwhat - the callable to retry.
 @param retryOnReturnVal - the predicate to control retry on return value.
 @param retryOnException - the predicate to return on retry value.
 @return the result of the retried callable if successful.
 @throws java.lang.InterruptedException - thrown if retry interrupted.
 @throws EX - the exception thrown by callable.]]>
      </doc>
    </method>
    <method name="synchronize" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="withName" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[This is a duplicate of guava Callables.threadRenaming ... will have to review for deprecation/removal.]]>
      </doc>
    </method>
    <method name="overflowSafeAdd" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="currentTime" type="long"/>
      <param name="timeout" type="long"/>
    </method>
    <field name="RETRY_FOR_NULL_RESULT" type="org.spf4j.base.Callables.SimpleRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_EXCEPTION_RETRY" type="org.spf4j.base.Callables.AdvancedRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A decent default retry predicate. It might retry exceptions that might not be retriable.. (like IO exceptions
 thrown by parser libraries for parsing issues...)]]>
      </doc>
    </field>
    <field name="DEFAULT_EXCEPTION_RETRY_PREDICATE" type="java.util.function.Predicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility class for executing stuff with retry logic.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Callables -->
  <!-- start class org.spf4j.base.Callables.AdvancedAction -->
  <class name="Callables.AdvancedAction" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Callables.AdvancedAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Callables.AdvancedAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="RETRY" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RETRY_IMMEDIATE" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RETRY_DELAYED" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ABORT" type="org.spf4j.base.Callables.AdvancedAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.Callables.AdvancedAction -->
  <!-- start interface org.spf4j.base.Callables.AdvancedRetryPredicate -->
  <interface name="Callables.AdvancedRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="org.spf4j.base.Callables.AdvancedAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="deadline" type="long"/>
    </method>
    <method name="apply" return="org.spf4j.base.Callables.AdvancedAction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="NO_RETRY" type="org.spf4j.base.Callables.AdvancedRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.base.Callables.AdvancedRetryPredicate -->
  <!-- start interface org.spf4j.base.Callables.CheckedCallable -->
  <interface name="Callables.CheckedCallable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Callable"/>
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[the method that is retried.

 @return
 @throws EX
 @throws InterruptedException
 @throws java.util.concurrent.TimeoutException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A callable that will be retried.

 @param <T> - the type of the object returned by this callable.
 @param <EX> - the exception type returned by this callable.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Callables.CheckedCallable -->
  <!-- start class org.spf4j.base.Callables.FibonacciBackoffRetryPredicate -->
  <class name="Callables.FibonacciBackoffRetryPredicate" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Callables.RetryPredicate"/>
    <constructor name="FibonacciBackoffRetryPredicate" type="org.spf4j.base.Callables.AdvancedRetryPredicate, int, long, long, java.util.function.Function, long, java.util.function.LongSupplier, java.util.concurrent.TimeUnit"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
  </class>
  <!-- end class org.spf4j.base.Callables.FibonacciBackoffRetryPredicate -->
  <!-- start class org.spf4j.base.Callables.RetryDecision -->
  <class name="Callables.RetryDecision" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="abort" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Exception"/>
    </method>
    <method name="retry" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="retryMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="abort" return="org.spf4j.base.Callables.RetryDecision"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecisionType" return="org.spf4j.base.Callables.RetryDecision.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDelayMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getException" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNewCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Callables.RetryDecision -->
  <!-- start class org.spf4j.base.Callables.RetryDecision.Type -->
  <class name="Callables.RetryDecision.Type" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Callables.RetryDecision.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Callables.RetryDecision.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="Abort" type="org.spf4j.base.Callables.RetryDecision.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="Retry" type="org.spf4j.base.Callables.RetryDecision.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.Callables.RetryDecision.Type -->
  <!-- start interface org.spf4j.base.Callables.RetryPredicate -->
  <interface name="Callables.RetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <doc>
      <![CDATA[the number or millis of delay until the next retry, or -1 for abort.

 @param value
 @return]]>
      </doc>
    </method>
    <field name="NORETRY_DELAY_PREDICATE" type="org.spf4j.base.Callables.RetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.base.Callables.RetryPredicate -->
  <!-- start class org.spf4j.base.Callables.SimpleAction -->
  <class name="Callables.SimpleAction" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Callables.SimpleAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Callables.SimpleAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="RETRY" type="org.spf4j.base.Callables.SimpleAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ABORT" type="org.spf4j.base.Callables.SimpleAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.Callables.SimpleAction -->
  <!-- start interface org.spf4j.base.Callables.SimpleRetryPredicate -->
  <interface name="Callables.SimpleRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="apply" return="org.spf4j.base.Callables.SimpleAction"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.base.Callables.SimpleRetryPredicate -->
  <!-- start class org.spf4j.base.Callables.TimeoutCallable -->
  <class name="Callables.TimeoutCallable" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Callables.CheckedCallable"/>
    <constructor name="TimeoutCallable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimeoutCallable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadline" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@param deadline millis since epoch.]]>
      </doc>
    </method>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Callables.TimeoutCallable -->
  <!-- start interface org.spf4j.base.Callables.TimeoutRetryPredicate -->
  <interface name="Callables.TimeoutRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="deadlineMillis" type="long"/>
      <param name="what" type="java.util.concurrent.Callable"/>
    </method>
    <field name="NORETRY_FOR_RESULT" type="org.spf4j.base.Callables.TimeoutRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.base.Callables.TimeoutRetryPredicate -->
  <!-- start class org.spf4j.base.CallablesNano -->
  <class name="CallablesNano" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitNanos" type="long"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitNanos" type="long"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxWaitNanos" type="long"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[After the immediate retries are done, delayed retry with randomized Fibonacci values up to the specified max is
 executed.

 @param <T> - the type returned by the Callable that is retried.
 @param <EX> - the Exception thrown by the retried callable.
 @param what - the callable to retry.
 @param nrImmediateRetries - the number of immediate retries.
 @param maxWaitNanos - maximum wait time in between retries.
 @param retryOnReturnVal - predicate to control retry on return value;
 @param retryOnException - predicate to retry on thrown exception.
 @return the result of the callable.
 @throws java.lang.InterruptedException - thrown if interrupted.
 @throws EX - the exception declared to be thrown by the callable.]]>
      </doc>
    </method>
    <method name="toDeadlineNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutNanos" type="long"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="retryOnException" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <doc>
    <![CDATA[Utility class for executing stuff with retry logic.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CallablesNano -->
  <!-- start class org.spf4j.base.CallablesNano.NanoTimeoutCallable -->
  <class name="CallablesNano.NanoTimeoutCallable" extends="org.spf4j.base.Callables.TimeoutCallable"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NanoTimeoutCallable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadline" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@param deadline System.nanoTime deadline.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.spf4j.base.CallablesNano.NanoTimeoutCallable -->
  <!-- start interface org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate -->
  <interface name="CallablesNano.TimeoutNanoRetryPredicate"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.Callables.TimeoutRetryPredicate"/>
    <method name="getDecision" return="org.spf4j.base.Callables.RetryDecision"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <param name="deadlineNanos" type="long"/>
      <param name="what" type="java.util.concurrent.Callable"/>
    </method>
    <field name="NORETRY_FOR_RESULT" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate -->
  <!-- start class org.spf4j.base.CallablesNanoNonInterrupt -->
  <class name="CallablesNanoNonInterrupt" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitNanos" type="long"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxRetryWaitNanos" type="long"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="maxWaitNanos" type="long"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.Callables.AdvancedRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[After the immediate retries are done,
 delayed retry with randomized Fibonacci values up to the specified max is executed.
 @param <T> - the type returned by the Callable that is retried.
 @param <EX> - the Exception thrown by the retried callable.
 @param what - the callable to retry.
 @param nrImmediateRetries - the number of immediate retries.
 @param maxWaitNanos - maximum wait time in between retries.
 @param retryOnReturnVal - predicate to control retry on return value;
 @param retryOnException - predicate to retry on thrown exception.
 @return the result of the callable.
 @throws EX - the exception declared to be thrown by the callable.]]>
      </doc>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="retryOnReturnVal" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="retryOnException" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="executeWithRetry" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="org.spf4j.base.CallablesNano.NanoTimeoutCallable"/>
      <param name="retryOnException" type="org.spf4j.base.CallablesNano.TimeoutNanoRetryPredicate"/>
      <param name="exceptionClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Utility class for executing stuff with retry logic.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CallablesNanoNonInterrupt -->
  <!-- start class org.spf4j.base.CharSequences -->
  <class name="CharSequences" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="distance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s1" type="java.lang.CharSequence"/>
      <param name="s2" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[function that calculates the number of operations that are needed to transform s1 into s2. operations are: char
 add, char delete, char modify

 @param s1
 @param s2
 @return the number of operations required to transfor s1 into s2]]>
      </doc>
    </method>
    <method name="distance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c1" type="char"/>
      <param name="c2" type="char"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use compare.">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[compare s to t.

 @param s
 @param t
 @return
 @deprecated use compare.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="sLength" type="int"/>
      <param name="t" type="java.lang.CharSequence"/>
      <param name="tLength" type="int"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="sFrom" type="int"/>
      <param name="sLength" type="int"/>
      <param name="t" type="java.lang.CharSequence"/>
      <param name="tFrom" type="int"/>
      <param name="tLength" type="int"/>
      <doc>
      <![CDATA[compare 2 CharSequence fragments.

 @param s the charsequence to compare
 @param sFrom the index for the first chars to compare.
 @param sLength the number of characters to compare.
 @param t the charsequence to compare to
 @param tFrom the index for the first character to compare to.
 @param tLength the number of characters to compare to.
 @return]]>
      </doc>
    </method>
    <method name="equalsNullables" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="hashcode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <method name="subSequence" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
    </method>
    <method name="endsWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qc" type="java.lang.CharSequence"/>
      <param name="with" type="java.lang.CharSequence"/>
    </method>
    <method name="lineNumbered" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="lineNumbered" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="appendable" type="java.lang.Appendable"/>
      <param name="ia" type="org.spf4j.base.IntAppender"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toLineNumbered" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="source" type="java.lang.CharSequence"/>
    </method>
    <method name="toLineNumbered" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startLineNr" type="int"/>
      <param name="source" type="java.lang.CharSequence"/>
      <param name="ia" type="org.spf4j.base.IntAppender"/>
    </method>
    <method name="parseInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[A more flexible version of Integer.parseInt.

 @see java.lang.Integer.parseInt]]>
      </doc>
    </method>
    <method name="parseInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[A more flexible version of Integer.parseInt.

 @see java.lang.Integer.parseInt]]>
      </doc>
    </method>
    <method name="parseLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[A more flexible version of Long.parseLong.

 @see java.lang.Long.parseLong]]>
      </doc>
    </method>
    <method name="parseLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
      <param name="radix" type="int"/>
      <doc>
      <![CDATA[A more flexible version of Long.parseLong.

 @see java.lang.Long.parseLong]]>
      </doc>
    </method>
    <method name="containsAnyChar" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.CharSequence"/>
      <param name="chars" type="char[]"/>
    </method>
    <method name="isValidFileName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.CharSequence"/>
    </method>
    <method name="validatedFileName" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.CharSequence"/>
    </method>
    <method name="regionMatches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
      <param name="other" type="java.lang.CharSequence"/>
      <param name="ooffset" type="int"/>
      <param name="plen" type="int"/>
      <doc>
      <![CDATA[Equivalent to String.regionMatches.]]>
      </doc>
    </method>
    <method name="regionMatchesIgnoreCase" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ta" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
      <param name="pa" type="java.lang.CharSequence"/>
      <param name="ooffset" type="int"/>
      <param name="plen" type="int"/>
      <doc>
      <![CDATA[Equivalent/based on to String.regionMatches.]]>
      </doc>
    </method>
    <method name="match" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wildcard" type="java.lang.CharSequence"/>
      <param name="cs2Match" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[regular wildcard matcher.
 * matches any number of consecutive characters.
 ? matches any single character.
 @param wildcard
 @param cs2Match
 @return]]>
      </doc>
    </method>
    <method name="getJavaRegexpStr" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wildcard" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Transform a wildcard expression 2 a java regular expression.
 * matches any number of consecutive characters.
 ? matches any single character.
 @param wildcard
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Special methods to use for character sequences...

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CharSequences -->
  <!-- start class org.spf4j.base.CharSequenceTranslator -->
  <class name="CharSequenceTranslator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CharSequenceTranslator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="translate" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="translate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
    </method>
    <method name="translate"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hex" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codepoint" type="int"/>
      <doc>
      <![CDATA[<p>Returns an upper case hexadecimal <code>String</code> for the given
 character.</p>

 @param codepoint The codepoint to convert.
 @return An upper case hexadecimal <code>String</code>]]>
      </doc>
    </method>
  </class>
  <!-- end class org.spf4j.base.CharSequenceTranslator -->
  <!-- start class org.spf4j.base.CheckedRunnable -->
  <class name="CheckedRunnable" extends="org.spf4j.base.AbstractRunnable"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CheckedRunnable" type="boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CheckedRunnable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CheckedRunnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CheckedRunnable" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doRun"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CheckedRunnable -->
  <!-- start class org.spf4j.base.CloneFailedException -->
  <class name="CloneFailedException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CloneFailedException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CloneFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CloneFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CloneFailedException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.CloneFailedException -->
  <!-- start class org.spf4j.base.Closeables -->
  <class name="Closeables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.lang.AutoCloseable[]"/>
    </method>
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.lang.Exception"/>
      <param name="closeables" type="java.lang.AutoCloseable[]"/>
    </method>
    <method name="closeAll" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.io.Closeable[]"/>
    </method>
    <method name="closeAll" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.lang.Exception"/>
      <param name="closeables" type="java.io.Closeable[]"/>
    </method>
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="closeables" type="java.lang.Iterable"/>
    </method>
    <method name="closeAll" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.lang.Exception"/>
      <param name="closeables" type="java.lang.Iterable"/>
    </method>
    <method name="closeSelectorChannels" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="selector" type="java.nio.channels.Selector"/>
    </method>
    <method name="closeSelectorChannels" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propagate" type="java.io.IOException"/>
      <param name="selector" type="java.nio.channels.Selector"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Closeables -->
  <!-- start class org.spf4j.base.ComparablePair -->
  <class name="ComparablePair" extends="org.spf4j.base.SerializablePair"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="ComparablePair" type="java.lang.Comparable, java.lang.Comparable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.ComparablePair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable"/>
      <param name="second" type="java.lang.Comparable"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.base.ComparablePair"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ComparablePair -->
  <!-- start class org.spf4j.base.Comparables -->
  <class name="Comparables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="min" return="java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrs" type="java.lang.Object[]"/>
    </method>
    <method name="max" return="java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrs" type="java.lang.Object[]"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable"/>
      <param name="second" type="java.lang.Comparable"/>
    </method>
    <method name="compareArrays" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable[]"/>
      <param name="second" type="java.lang.Comparable[]"/>
    </method>
    <method name="compareArrays" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Comparable[]"/>
      <param name="second" type="java.lang.Comparable[]"/>
      <param name="from" type="int"/>
      <param name="to" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Comparables -->
  <!-- start class org.spf4j.base.Either -->
  <class name="Either" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isLeft" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRight" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeft" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRight" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="left" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
    </method>
    <method name="right" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="java.lang.Object"/>
    </method>
    <field name="value" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Either -->
  <!-- start class org.spf4j.base.Either.Left -->
  <class name="Either.Left" extends="org.spf4j.base.Either"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Left" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isLeft" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeft" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRight" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Either.Left -->
  <!-- start class org.spf4j.base.Either.Right -->
  <class name="Either.Right" extends="org.spf4j.base.Either"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Right" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isLeft" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLeft" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRight" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Either.Right -->
  <!-- start class org.spf4j.base.EqualsPredicate -->
  <class name="EqualsPredicate" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Predicate"/>
    <constructor name="EqualsPredicate" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="test" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.EqualsPredicate -->
  <!-- start class org.spf4j.base.EscapeJsonStringAppendableWrapper -->
  <class name="EscapeJsonStringAppendableWrapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Appendable"/>
    <constructor name="EscapeJsonStringAppendableWrapper" type="java.lang.Appendable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.EscapeJsonStringAppendableWrapper -->
  <!-- start class org.spf4j.base.ExitException -->
  <class name="ExitException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExitException" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ExitException -->
  <!-- start interface org.spf4j.base.Handler -->
  <interface name="Handler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="deadlineMillis" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Handler -->
  <!-- start interface org.spf4j.base.HandlerNano -->
  <interface name="HandlerNano"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="deadlineNanos" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.HandlerNano -->
  <!-- start class org.spf4j.base.Holder -->
  <class name="Holder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Holder" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Holder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="of" return="org.spf4j.base.Holder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="OF_NULL" type="org.spf4j.base.Holder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Holder -->
  <!-- start class org.spf4j.base.InstrumentationHelper -->
  <class name="InstrumentationHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="premain"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String"/>
      <param name="inst" type="java.lang.instrument.Instrumentation"/>
    </method>
    <method name="getObjectSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.InstrumentationHelper -->
  <!-- start interface org.spf4j.base.IntAppender -->
  <interface name="IntAppender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="append"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.IntAppender -->
  <!-- start class org.spf4j.base.IntAppender.CommentNumberAppender -->
  <class name="IntAppender.CommentNumberAppender" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntAppender"/>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.base.IntAppender.CommentNumberAppender"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.IntAppender.CommentNumberAppender -->
  <!-- start class org.spf4j.base.IntAppender.SimplePrefixNumberAppender -->
  <class name="IntAppender.SimplePrefixNumberAppender" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntAppender"/>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="INSTANCE" type="org.spf4j.base.IntAppender.SimplePrefixNumberAppender"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.IntAppender.SimplePrefixNumberAppender -->
  <!-- start class org.spf4j.base.IntMath -->
  <class name="IntMath" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="closestPowerOf2" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
    </method>
    <method name="closestPowerOf2Number" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.IntMath -->
  <!-- start class org.spf4j.base.IntMath.XorShift128 -->
  <class name="IntMath.XorShift128" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntSequence"/>
    <constructor name="XorShift128"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift128 -->
  <!-- start class org.spf4j.base.IntMath.XorShift32 -->
  <class name="IntMath.XorShift32" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.base.IntSequence"/>
    <constructor name="XorShift32"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A very fast Pseudo random generator.
 use of this random is appropriate when you need the fastest random that you plan to use in a single
 thread.
 If you need a thread-safe random, please use JDK ThreadLocalRandom, which will be your best option.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift32 -->
  <!-- start class org.spf4j.base.IntMath.XorShift32ThreadSafe -->
  <class name="IntMath.XorShift32ThreadSafe" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="please use JDK java.util.concurrent.ThreadLocalRandom instead.
 The JDK implementation uses local fields in the Thread class instead of a classic ThreadLocal,
 which makes it faster...">
    <implements name="org.spf4j.base.IntSequence"/>
    <constructor name="XorShift32ThreadSafe"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="nextInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated please use JDK java.util.concurrent.ThreadLocalRandom instead.
 The JDK implementation uses local fields in the Thread class instead of a classic ThreadLocal,
 which makes it faster...]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift32ThreadSafe -->
  <!-- start class org.spf4j.base.IntMath.XorShift32ThreadSafe.Singleton -->
  <class name="IntMath.XorShift32ThreadSafe.Singleton" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Singleton"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="INSTANCE" type="org.spf4j.base.IntMath.XorShift32ThreadSafe"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.IntMath.XorShift32ThreadSafe.Singleton -->
  <!-- start interface org.spf4j.base.IntSequence -->
  <interface name="IntSequence"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="nextInt" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.IntSequence -->
  <!-- start interface org.spf4j.base.Invocation -->
  <interface name="Invocation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="invoke" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Invocation -->
  <!-- start class org.spf4j.base.Iterables -->
  <class name="Iterables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="forAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itterable" type="java.lang.Iterable"/>
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <method name="forAll2"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="itterable" type="java.lang.Iterable"/>
      <param name="consumer" type="java.util.function.Consumer"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Iterables -->
  <!-- start class org.spf4j.base.JavaUtils -->
  <class name="JavaUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isJavaIdentifier" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.JavaUtils -->
  <!-- start class org.spf4j.base.LookupTranslator -->
  <class name="LookupTranslator" extends="org.spf4j.base.CharSequenceTranslator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LookupTranslator" type="java.lang.CharSequence[][]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="translate" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Translates a value using a lookup table.

 @since 3.0
 @version $Id$]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.LookupTranslator -->
  <!-- start class org.spf4j.base.MemorizedCallable -->
  <class name="MemorizedCallable" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Callable"/>
    <constructor name="MemorizedCallable" type="java.util.concurrent.Callable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.MemorizedCallable -->
  <!-- start class org.spf4j.base.Method -->
  <class name="Method" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="Method" type="java.lang.StackTraceElement"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Method" type="java.lang.Class, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Method" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDeclaringClass" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethodName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="w" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toHtmlWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="w" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMethod" return="org.spf4j.base.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.StackTraceElement"/>
    </method>
    <method name="getMethod" return="org.spf4j.base.Method"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
      <param name="methodName" type="java.lang.String"/>
    </method>
    <field name="ROOT" type="org.spf4j.base.Method"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Method -->
  <!-- start class org.spf4j.base.MutableHolder -->
  <class name="MutableHolder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="MutableHolder" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MutableHolder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.MutableHolder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.base.MutableHolder"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.MutableHolder -->
  <!-- start class org.spf4j.base.MutableInteger -->
  <class name="MutableInteger" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableInteger" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.MutableInteger -->
  <!-- start class org.spf4j.base.NameValue -->
  <class name="NameValue" extends="org.spf4j.base.Pair"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NameValue" type="java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.NameValue"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.NameValue -->
  <!-- start class org.spf4j.base.NoExitSecurityManager -->
  <class name="NoExitSecurityManager" extends="java.lang.SecurityManager"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoExitSecurityManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="java.security.Permission"/>
    </method>
    <method name="checkPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="java.security.Permission"/>
      <param name="context" type="java.lang.Object"/>
    </method>
    <method name="checkExit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.NoExitSecurityManager -->
  <!-- start class org.spf4j.base.Objects -->
  <class name="Objects" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="clone" return="java.io.Serializable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Objects -->
  <!-- start class org.spf4j.base.OctalUnescaper -->
  <class name="OctalUnescaper" extends="org.spf4j.base.CharSequenceTranslator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OctalUnescaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="translate" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
  </class>
  <!-- end class org.spf4j.base.OctalUnescaper -->
  <!-- start class org.spf4j.base.Pair -->
  <class name="Pair" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map.Entry"/>
    <implements name="org.spf4j.base.Writeable"/>
    <constructor name="Pair" type="java.lang.Object, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.lang.Object"/>
      <param name="second" type="java.lang.Object"/>
    </method>
    <method name="from" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stringPair" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a pair from a str1,str2 pair.

 @param stringPair - pair in the format (a,b) csv pair.
 @return null if this is not a pair.]]>
      </doc>
    </method>
    <method name="getFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSecond" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toList" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pairs" type="org.spf4j.base.Pair[]"/>
    </method>
    <method name="getKey" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <field name="first" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="second" type="java.lang.Object"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Pair -->
  <!-- start interface org.spf4j.base.ParameterizedSupplier -->
  <interface name="ParameterizedSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameter" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ParameterizedSupplier -->
  <!-- start interface org.spf4j.base.ReferenceFactory -->
  <interface name="ReferenceFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.ref.Reference"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.ReferenceFactory -->
  <!-- start class org.spf4j.base.ReferenceType -->
  <class name="ReferenceType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.ReferenceType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.ReferenceType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="create" return="java.lang.ref.Reference"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <field name="WEAK" type="org.spf4j.base.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SOFT" type="org.spf4j.base.ReferenceType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.ReferenceType -->
  <!-- start class org.spf4j.base.Reflections -->
  <class name="Reflections" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getParameterTypes" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Optimized alternative of Method.getParameterTypes that steals the parameterTypeArry from method
 instead of copying it.

 Here is the benchmark comparison for a 5 arg method:

 Benchmark                                       Mode  Cnt           Score          Error  Units
 ReflectionsBenchmark.normalGetTypes            thrpt   10   227015245.933 #  2725143.765  ops/s
 ReflectionsBenchmark.optimizedGetTypes         thrpt   10  1159407471.306 # 21204385.301  ops/s

 @param m
 @return]]>
      </doc>
    </method>
    <method name="getParameterTypes" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Constructor"/>
    </method>
    <method name="primitiveToWrapper" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="primitiveToWrapper" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="wrapperToPrimitive" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="isWrappableOrWrapper" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <method name="getAnnotationAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annot" type="java.lang.annotation.Annotation"/>
      <param name="attributeName" type="java.lang.String"/>
    </method>
    <method name="getMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Equivalent to Class.getDeclaredMethod which returns a null instead of throwing an exception.
 returned method is also made accessible.

 @param c
 @param methodName
 @param paramTypes
 @return]]>
      </doc>
    </method>
    <method name="getConstructor" return="java.lang.reflect.Constructor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Equivalent to Class.getDeclaredConstructor, only that it does not throw an exception if no constructor,
 it returns null instead, also makes all constructors accessible..]]>
      </doc>
    </method>
    <method name="getCompatibleMethod" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Method lookup utility that looks up a method declaration that is compatible. (taking in consideration boxed
 primitives and varargs)

 @param c
 @param methodName
 @param paramTypes
 @return]]>
      </doc>
    </method>
    <method name="getCompatibleMethodHandle" return="java.lang.invoke.MethodHandle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.reflect.Method"/>
      <param name="object" type="java.lang.Object"/>
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
      <exception name="InvocationTargetException" type="java.lang.reflect.InvocationTargetException"/>
    </method>
    <method name="canAssign" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Class"/>
      <param name="from" type="java.lang.Class"/>
    </method>
    <method name="getCompatibleMethodCached" return="java.lang.reflect.Method"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
    </method>
    <method name="getCompatibleMethodHandleCached" return="java.lang.invoke.MethodHandle"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="paramTypes" type="java.lang.Class[]"/>
    </method>
    <method name="getJarSourceUrl" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Useful to get the jar URL where a particular class is located.

 @param clasz
 @return]]>
      </doc>
    </method>
    <method name="getManifest" return="java.util.jar.Manifest"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jarUrl" type="java.net.URL"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the manifest of a jar file.

 @param jarUrl
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="getPackageInfoDirect" return="org.spf4j.base.Reflections.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="getPackageInfoDirect" return="org.spf4j.base.Reflections.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aClass" type="java.lang.Class"/>
    </method>
    <method name="getPackageInfo" return="org.spf4j.base.Reflections.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="implementStatic" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="target" type="java.lang.Class"/>
      <doc>
      <![CDATA[create a proxy instance that will proxy interface methods to static methods on the target class.
 @param <T>
 @param clasz
 @param target
 @return]]>
      </doc>
    </method>
    <method name="implement" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
      <param name="target" type="java.lang.Object"/>
    </method>
    <method name="getLoadedClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cl" type="java.lang.ClassLoader"/>
      <param name="className" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.spf4j.base.Reflections -->
  <!-- start class org.spf4j.base.Reflections.PackageInfo -->
  <class name="Reflections.PackageInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="PackageInfo" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasInfo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.Reflections.PackageInfo -->
  <!-- start class org.spf4j.base.Runnables -->
  <class name="Runnables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="runAll" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnables" type="java.lang.Runnable[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Runnables -->
  <!-- start class org.spf4j.base.Runtime -->
  <class name="Runtime" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="goDownWithError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exitCode" type="org.spf4j.base.SysExits"/>
    </method>
    <method name="goDownWithError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="exitCode" type="org.spf4j.base.SysExits"/>
    </method>
    <method name="goDownWithError"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="exitCode" type="int"/>
    </method>
    <method name="isMacOsx" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isWindows" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTestFramework" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="haveJnaPlatform" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="haveJnaPlatformClib" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrOpenFiles" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.getOpenFileDescriptorCount() instead">
      <doc>
      <![CDATA[get the number of open files by current java process.

 @return -1 if cannot get nr of open files
 @deprecated use OperatingSystem.getOpenFileDescriptorCount() instead]]>
      </doc>
    </method>
    <method name="getLsofOutput" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use Lsof.getLsofOutput instead.">
      <doc>
      <![CDATA[@deprecated use Lsof.getLsofOutput instead.]]>
      </doc>
    </method>
    <method name="run" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.forkExec.">
      <param name="command" type="java.lang.String[]"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.forkExec.]]>
      </doc>
    </method>
    <method name="killProcess" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.killProcess.">
      <param name="proc" type="java.lang.Process"/>
      <param name="terminateTimeoutMillis" type="long"/>
      <param name="forceTerminateTimeoutMillis" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.killProcess.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.forkExec instead.">
      <param name="command" type="java.lang.String[]"/>
      <param name="handler" type="org.spf4j.base.Runtime.ProcOutputHandler"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.forkExec instead.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use OperatingSystem.forkExec instead.">
      <param name="command" type="java.lang.String[]"/>
      <param name="handler" type="org.spf4j.base.Runtime.ProcOutputHandler"/>
      <param name="timeoutMillis" type="long"/>
      <param name="terminationTimeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[@deprecated use OperatingSystem.forkExec instead.]]>
      </doc>
    </method>
    <method name="queueHookAtBeginning"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="queueHookAtEnd"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="queueHook"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="int"/>
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="removeQueuedShutdownHook" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="runnable" type="java.lang.Runnable"/>
    </method>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="millisToDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="setDeadline"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadline" type="long"/>
    </method>
    <method name="gc" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <doc>
      <![CDATA[Attempts to run the GC in a verifiable way.

 @param timeoutMillis - timeout for GC attempt
 @return true if GC executed for sure, false otherwise, gc might have been executed though, but we cannot be sure.]]>
      </doc>
    </method>
    <method name="jrun" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="timeoutMillis" type="long"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="jrun" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="classPath" type="java.lang.String"/>
      <param name="timeoutMillis" type="long"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="jrun" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classWithMain" type="java.lang.Class"/>
      <param name="classPath" type="java.lang.String"/>
      <param name="timeoutMillis" type="long"/>
      <param name="jvmArgs" type="java.lang.String[]"/>
      <param name="arguments" type="java.lang.String[]"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMainThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the main Thread.
 @return null if there is no main thread (can happen when calling this is a shutdown hook)]]>
      </doc>
    </method>
    <method name="getMainClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return null if main class cannot be found.]]>
      </doc>
    </method>
    <field name="IS_LITTLE_ENDIAN" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WAIT_FOR_SHUTDOWN_MILLIS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TMP_FOLDER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_HOME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_HOME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEADLINE" type="java.lang.ThreadLocal"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PID" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unix PID identifying your process in the OC image it is running.]]>
      </doc>
    </field>
    <field name="OS_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PROCESS_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PROCESS_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a unique ID for this JVM process.
 PID@HOSTNAME:HEXNR]]>
      </doc>
    </field>
    <field name="NR_PROCESSORS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JAVA_PLATFORM" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Runtime -->
  <!-- start class org.spf4j.base.Runtime.Jmx -->
  <class name="Runtime.Jmx" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Jmx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPackageInfo" return="org.spf4j.base.Reflections.PackageInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
    </method>
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.spf4j.base.Runtime.Jmx -->
  <!-- start interface org.spf4j.base.Runtime.ProcOutputHandler -->
  <interface name="Runtime.ProcOutputHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="use Processhandler">
    <method name="handleStdOut"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
    </method>
    <method name="stdOutDone"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="handleStdErr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
    </method>
    <method name="stdErrDone"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated use Processhandler]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Runtime.ProcOutputHandler -->
  <!-- start class org.spf4j.base.Runtime.Version -->
  <class name="Runtime.Version" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Runtime.Version[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Runtime.Version"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="fromSpecVersion" return="org.spf4j.base.Runtime.Version"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specVersion" type="java.lang.String"/>
    </method>
    <field name="V1_0" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_1" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_2" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_3" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_4" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_5" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_6" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_7" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_8" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="V1_9_PLUSZ" type="org.spf4j.base.Runtime.Version"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.base.Runtime.Version -->
  <!-- start class org.spf4j.base.SerializablePair -->
  <class name="SerializablePair" extends="org.spf4j.base.Pair"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="SerializablePair" type="java.io.Serializable, java.io.Serializable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="org.spf4j.base.SerializablePair"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="first" type="java.io.Serializable"/>
      <param name="second" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.SerializablePair -->
  <!-- start class org.spf4j.base.Slf4jMessageFormatter -->
  <class name="Slf4jMessageFormatter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param argArray the message arguments.
 @return the number of arguments used in the message.
 @throws IOException]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param argArray the message arguments.
 @return the number of arguments used in the message.
 @throws IOException]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param argArray the message arguments.
 @return the number of arguments used in the message.
 @throws IOException something wend wrong while writing to the appendable.]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firstArgIdx" type="int"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param firstArgIdx the index of the first parameter.
 @param argArray the message arguments.
 @return the index of the last arguments used in the message + 1.
 @throws IOException something wend wrong while writing to the appendable.]]>
      </doc>
    </method>
    <method name="format" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="safe" type="boolean"/>
      <param name="firstArgIdx" type="int"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="messagePattern" type="java.lang.String"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <param name="argArray" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Slf4j message formatter.

 @param safe - if true recoverable exception will be caught when writing arguments, and a error will be appended
 instead.
 @param to Appendable to put formatted message to.
 @param messagePattern see org.slf4j.helpers.MessageFormatter for format.
 @param appSupplier a supplier that will provide the serialization method for a particular argument type.
 @param firstArgIdx the index of the first parameter.
 @param argArray the message arguments.
 @return the index of the last arguments used in the message + 1.
 @throws IOException something wend wrong while writing to the appendable.]]>
      </doc>
    </method>
    <method name="safeObjectAppend"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="safe" type="boolean"/>
      <param name="sbuf" type="java.lang.Appendable"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="appSupplier" type="org.spf4j.io.ObjectAppenderSupplier"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A more flexible implementation of the SLF4j message formatter (org.slf4j.helpers.MessageFormatter). the following
 improvements:

 1) Allow to format to a procvided destination (Appendable) allowing you to reduce the amount of garbage generated in
 a custom formatter... 2) Lets you know which arguments have been used in the message allowing you to implement extra
 logic to handle the unused ones 3) Lets you plug custom formatters for argument types. (you can get better
 performance and more flexibility) 4) Processing arguments that are arrays is sligtly faster than the slf4j formatter.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Slf4jMessageFormatter -->
  <!-- start class org.spf4j.base.Strings -->
  <class name="Strings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="distance" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.distance instead.">
      <param name="s1" type="java.lang.String"/>
      <param name="s2" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.distance instead.]]>
      </doc>
    </method>
    <method name="unescape" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="chars" type="char[]"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.containsAnyChar instead.">
      <param name="string" type="java.lang.CharSequence"/>
      <param name="chars" type="char[]"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.containsAnyChar instead.]]>
      </doc>
    </method>
    <method name="withFirstCharLower" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
    </method>
    <method name="writeReplaceWhitespaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="replacement" type="char"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="steal" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Steal the underlying character array of a String.

 @param str
 @return]]>
      </doc>
    </method>
    <method name="wrap" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chars" type="char[]"/>
      <doc>
      <![CDATA[Create a String based on the provided character array. No copy of the array is made.

 @param chars
 @return]]>
      </doc>
    </method>
    <method name="createUtf8Encoder" return="java.nio.charset.CharsetEncoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createUtf8Decoder" return="java.nio.charset.CharsetDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUTF8CharsetEncoder" return="java.nio.charset.CharsetEncoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUTF8CharsetDecoder" return="java.nio.charset.CharsetDecoder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="encode" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ce" type="java.nio.charset.CharsetEncoder"/>
      <param name="ca" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="getmaxNrBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ce" type="java.nio.charset.CharsetEncoder"/>
      <param name="nrChars" type="int"/>
    </method>
    <method name="encode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ce" type="java.nio.charset.CharsetEncoder"/>
      <param name="ca" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <param name="targetArray" type="byte[]"/>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cd" type="java.nio.charset.CharsetDecoder"/>
      <param name="ba" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="fromUtf8" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Optimized UTF8 decoder.

 Here is a benchmark comparison with the JDK implementation (see EncodingBenchmark.java in the benchmark project):

 EncodingBenchmark.stringDecode thrpt 10 16759798.463 # 343505.144 ops/s EncodingBenchmark.fastStringDecode thrpt 10
 17413298.464 # 301756.867 ops/s


 @param bytes
 @return]]>
      </doc>
    </method>
    <method name="fromUtf8" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="startIdx" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="toUtf8" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Optimized UTF8 string encoder.

 comparison with the stock JDK implementation (see EncodingBenchmark.java in the benchmark project):

 EncodingBenchmark.stringEncode thrpt 10 9481668.776 # 252543.135 ops/s EncodingBenchmark.fastStringEncode thrpt 10
 22469383.612 # 898677.892 ops/s

 @param str
 @return]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.compare">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.compare]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.CharSequence"/>
      <param name="t" type="java.lang.CharSequence"/>
    </method>
    <method name="hashcode" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cs" type="java.lang.CharSequence"/>
    </method>
    <method name="subSequence" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seq" type="java.lang.CharSequence"/>
      <param name="startIdx" type="int"/>
      <param name="endIdx" type="int"/>
    </method>
    <method name="endsWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qc" type="java.lang.CharSequence"/>
      <param name="with" type="java.lang.CharSequence"/>
    </method>
    <method name="escapeJsonString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toEscape" type="java.lang.String"/>
      <param name="jsonString" type="java.lang.StringBuilder"/>
      <doc>
      <![CDATA[Utility method to escape java strings to json strings.

 @param toEscape - the java string to escape.
 @param jsonString - the destination json String builder.]]>
      </doc>
    </method>
    <method name="escapeJsonString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toEscape" type="java.lang.String"/>
      <param name="jsonString" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendJsonStringEscapedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="jsonString" type="java.lang.StringBuilder"/>
    </method>
    <method name="appendJsonStringEscapedChar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <param name="jsonString" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendUnsignedString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="long"/>
      <param name="shift" type="int"/>
    </method>
    <method name="appendUnsignedString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
    </method>
    <method name="appendUnsignedStringPadded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.StringBuilder"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
      <param name="padTo" type="int"/>
    </method>
    <method name="appendUnsignedStringPadded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sb" type="java.lang.Appendable"/>
      <param name="nr" type="int"/>
      <param name="shift" type="int"/>
      <param name="padTo" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendSpaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="nrSpaces" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="appendSpaces"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.StringBuilder"/>
      <param name="nrSpaces" type="int"/>
    </method>
    <method name="regionMatches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use CharSequences.regionMatches.">
      <param name="t" type="java.lang.CharSequence"/>
      <param name="toffset" type="int"/>
      <param name="other" type="java.lang.CharSequence"/>
      <param name="ooffset" type="int"/>
      <param name="plen" type="int"/>
      <doc>
      <![CDATA[@deprecated use CharSequences.regionMatches.]]>
      </doc>
    </method>
    <method name="truncate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="length" type="int"/>
    </method>
    <method name="commonPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strs" type="java.lang.String[]"/>
    </method>
    <field name="EOL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Strings -->
  <!-- start class org.spf4j.base.SuppressedThrowable -->
  <class name="SuppressedThrowable" extends="java.lang.Throwable"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SuppressedThrowable" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="fillInStackTrace" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.base.SuppressedThrowable -->
  <!-- start class org.spf4j.base.SysExits -->
  <class name="SysExits" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.SysExits[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.SysExits"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="exitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isOk" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isError" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fromCode" return="org.spf4j.base.SysExits"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exitCode" type="int"/>
      <doc>
      <![CDATA[@param exitCode
 @return corresponding enum.]]>
      </doc>
    </method>
    <field name="OK" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Everything is OK.]]>
      </doc>
    </field>
    <field name="EX_GENERAL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Catch all for general errors.]]>
      </doc>
    </field>
    <field name="EX_SHELL_BUILTIN_MISSUSE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shell build in miss-use.]]>
      </doc>
    </field>
    <field name="EX_USAGE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The command was used incorrectly, e.g., with the wrong number of arguments, a bad flag, a bad syntax in a
 parameter, or whatever.]]>
      </doc>
    </field>
    <field name="EX_DATAERR" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The input data was incorrect in some way. This should only be used for user's data and not system files.]]>
      </doc>
    </field>
    <field name="EX_NOINPUT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An input file (not a system file) did not exist or was not readable. This could also include errors like ``No
 message'' to a mailer (if it cared to catch it).]]>
      </doc>
    </field>
    <field name="EX_NOUSER" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The user specified did not exist. This might be used for mail addresses or remote logins.]]>
      </doc>
    </field>
    <field name="EX_NOHOST" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The host specified did not exist. This is used in mail addresses or network requests.]]>
      </doc>
    </field>
    <field name="EX_UNAVAILABLE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A service is unavailable. This can occur if a support program or file does not exist. This can also be used as a
 catchall message when something you wanted to do doesn't work, but you don't know why.]]>
      </doc>
    </field>
    <field name="EX_SOFTWARE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An internal software error has been detected. This should be limited to non-operating system related errors as
 possible.]]>
      </doc>
    </field>
    <field name="EX_OSERR" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An operating system error has been detected. This is intended to be used for such things as ``cannot fork'',
 ``cannot create pipe'', or the like. It includes things like getuid returning a user that does not exist in the
 passwd file.]]>
      </doc>
    </field>
    <field name="EX_OSFILE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some system file (e.g., /etc/passwd, /var/run/utmp,etc.) does not exist, cannot be opened, or has some sort of
 error (e.g., syntax error).]]>
      </doc>
    </field>
    <field name="EX_CANTCREAT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A (user specified) output file cannot be created.]]>
      </doc>
    </field>
    <field name="EX_IOERR" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An error occurred while doing I/O on some file.]]>
      </doc>
    </field>
    <field name="EX_TEMPFAIL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Temporary failure, indicating something that is not really an error. In sendmail, this means that a mailer (e.g.)
 could not create a connection, and the request should be reattempted later.]]>
      </doc>
    </field>
    <field name="EX_PROTOCOL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The remote system returned something that was ``not possible'' during a protocol exchange.]]>
      </doc>
    </field>
    <field name="EX_NOPERM" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[You did not have sufficient permission to perform the operation. This is not intended for file system problems,
 which should use EX_NOINPUT or EX_CANTCREAT, but rather for higher level permissions.]]>
      </doc>
    </field>
    <field name="EX_CONFIG" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Something was found in an unconfigured or misconfigured state.]]>
      </doc>
    </field>
    <field name="EX_CANNOT_EXEC_CMD" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[cannot execute invoked command.]]>
      </doc>
    </field>
    <field name="EX_CMD_NOT_FOUND" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Command not found.]]>
      </doc>
    </field>
    <field name="EX_INVALID_ARG_TO_EXIT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invalid argument to exit.]]>
      </doc>
    </field>
    <field name="EX_SIG_HUP" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Section caused by exit due to signal.
 where signal name is same on Linux, Solaris and MacOS enum has the appropriate name.
 for linux see: http://man7.org/linux/man-pages/man7/signal.7.html
 or run man signal on you OS of choice.]]>
      </doc>
    </field>
    <field name="EX_SIG_INT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_QUIT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_ILL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_TRAP" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_ABRT" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_7" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_FPE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_KILL" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_10" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_11" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_12" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_PIPE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_ALRM" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_TERM" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_16" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_17" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_18" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_19" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_20" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_21" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_22" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_23" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_24" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_25" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_26" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_27" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_28" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_29" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_30" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_SIG_31" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_STATUS_OUT_OF_RANGE" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EX_UNKNOWN" type="org.spf4j.base.SysExits"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Any return codes not explicitly defined will be associated with "EX_UNKNOWN"]]>
      </doc>
    </field>
    <doc>
    <![CDATA[some "standard" process exit codes from:
 http://tldp.org/LDP/abs/html/index.html
 https://www.freebsd.org/cgi/man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+4.3-RELEASE&format=html
 http://journal.thobe.org/2013/02/jvms-and-kill-signals.html
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.SysExits -->
  <!-- start class org.spf4j.base.Throwables -->
  <class name="Throwables" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="isRetryable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Exception"/>
      <doc>
      <![CDATA[figure out if a Exception is retry-able or not.
 If while executing a operation a exception is returned, that exception is retryable if retrying the operation
 can potentially succeed.
 @param value
 @return]]>
      </doc>
    </method>
    <method name="getIsRetryablePredicate" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setIsRetryablePredicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isRetryablePredicate" type="java.util.function.Predicate"/>
    </method>
    <method name="getNrSuppressedExceptions" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="getNrRecursiveSuppressedExceptions" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="removeOldestSuppressedRecursive" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="removeOldestSuppressed" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="chain" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="newRootCause" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[This method will clone the exception t and will set a new root cause.

 @param <T>
 @param t
 @param newRootCause
 @return]]>
      </doc>
    </method>
    <method name="chain" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="newRootCause" type="java.lang.Throwable"/>
      <param name="maxChained" type="int"/>
    </method>
    <method name="trimCausalChain"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="maxSize" type="int"/>
    </method>
    <method name="suppress" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="suppressed" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Functionality similar for java 1.7 Throwable.addSuppressed. 2 extra things happen:

 1) limit to nr of exceptions suppressed. 2) Suppression does not mutate Exception, it clones it.

 @param <T>
 @param t
 @param suppressed
 @return]]>
      </doc>
    </method>
    <method name="suppress" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="suppressed" type="java.lang.Throwable"/>
      <param name="maxSuppressed" type="int"/>
    </method>
    <method name="getSuppressed" return="java.lang.Throwable[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Utility to get suppressed exceptions.

 In java 1.7 it will return t.getSuppressed() + in case it is Iterable<Throwable> any other linked exceptions (see
 SQLException)

 java 1.6 behavior is deprecated.

 @param t
 @return]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.StackTraceElement"/>
      <param name="previous" type="java.lang.StackTraceElement"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
    </method>
    <method name="toStringBuilder" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
    </method>
    <method name="toStringBuilder" return="java.lang.StringBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.io.PrintStream"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.io.PrintStream"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeMessageString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Appendable"/>
      <param name="t" type="java.lang.Throwable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.lang.StackTraceElement[]"/>
      <param name="to" type="java.lang.Appendable"/>
      <param name="detail" type="org.spf4j.base.Throwables.PackageDetail"/>
      <param name="abbreviatedTraceElement" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="commonFrames" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trace" type="java.lang.StackTraceElement[]"/>
      <param name="enclosingTrace" type="java.lang.StackTraceElement[]"/>
    </method>
    <method name="isNonRecoverable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Is this Throwable a JVM non-recoverable exception. (Oom, VMError, etc...)
 @param t
 @return]]>
      </doc>
    </method>
    <method name="containsNonRecoverable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Does this Throwable contain a JVM non-recoverable exception. (Oom, VMError, etc...)
 @param t
 @return]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[checks in the throwable + children (both causal and suppressed) contain a throwable that
 respects the Predicate.
 @param t the throwable
 @param predicate the predicate
 @return true if a Throwable matching the predicate is found.]]>
      </doc>
    </method>
    <method name="first" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="clasz" type="java.lang.Class"/>
      <doc>
      <![CDATA[return first Exception in the causal chain Assignable to clasz.
 @param <T>
 @param t
 @param clasz
 @return]]>
      </doc>
    </method>
    <method name="first" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[Returns the first Throwable that matches the predicate in the causal and suppressed chain.
 @param t the Throwable
 @param predicate the Predicate
 @return the Throwable the first matches the predicate or null is none matches.]]>
      </doc>
    </method>
    <method name="firstCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="throwable" type="java.lang.Throwable"/>
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[Returns first Throwable in the causality chain that is matching the provided predicate.
 @param throwable the Throwable to go through.
 @param predicate the predicate to apply
 @return the first Throwable from the chain that the predicate matches.]]>
      </doc>
    </method>
    <method name="getNonRecoverablePredicate" return="java.util.function.Predicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNonRecoverablePredicate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="java.util.function.Predicate"/>
      <doc>
      <![CDATA[Overwrite the default non-recoverable predicate.
 @param predicate]]>
      </doc>
    </method>
    <method name="writeAbreviatedClassName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="className" type="java.lang.String"/>
      <param name="writeTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="throwException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ex" type="java.lang.Exception"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <field name="SUPPRESSED_CAPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Caption for labeling suppressed exception stack traces]]>
      </doc>
    </field>
    <field name="CAUSE_CAPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Caption for labeling causative exception stack traces]]>
      </doc>
    </field>
    <field name="MAX_THROWABLE_CHAIN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[utility class for throwables.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Throwables -->
  <!-- start class org.spf4j.base.Throwables.PackageDetail -->
  <class name="Throwables.PackageDetail" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.base.Throwables.PackageDetail[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.base.Throwables.PackageDetail"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="NONE" type="org.spf4j.base.Throwables.PackageDetail"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No jar info or version info.]]>
      </doc>
    </field>
    <field name="SHORT" type="org.spf4j.base.Throwables.PackageDetail"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[jar file name + manifest version.]]>
      </doc>
    </field>
    <field name="LONG" type="org.spf4j.base.Throwables.PackageDetail"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[complete jar path + manifest version.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[enum describing the PackageDetail level to be logged in the stack trace.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Throwables.PackageDetail -->
  <!-- start class org.spf4j.base.TimeoutRunnable -->
  <class name="TimeoutRunnable" extends="org.spf4j.base.CheckedRunnable"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Callable"/>
    <constructor name="TimeoutRunnable" type="long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimeoutRunnable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doRun"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="doRun"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pdeadlineMillis" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="getDeadlineMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="call" return="java.lang.Void"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.TimeoutRunnable -->
  <!-- start class org.spf4j.base.Timing -->
  <class name="Timing" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromNanoTimeToEpochMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nanoTime" type="long"/>
    </method>
    <method name="getCurrentTiming" return="org.spf4j.base.Timing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Utility class that allows for quick conversion between nanotime and epoch relative time.
 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Timing -->
  <!-- start class org.spf4j.base.TLScratch -->
  <class name="TLScratch" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getBytesTmp" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[returns a thread local byte array of at least the size requested. use only for temporary purpose. This method needs
 to be carefully used!

 @param size - the minimum size of the temporary buffer requested.
 @return - the temporary buffer.]]>
      </doc>
    </method>
    <method name="getCharsTmp" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[returns a thread local char array of at least the requested size. Use only for temporary purpose.

 @param size - the minimum size of the temporary buffer requested.
 @return - the temporary buffer.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.TLScratch -->
  <!-- start class org.spf4j.base.UnicodeUnescaper -->
  <class name="UnicodeUnescaper" extends="org.spf4j.base.CharSequenceTranslator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnicodeUnescaper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="translate" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.lang.CharSequence"/>
      <param name="index" type="int"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
  </class>
  <!-- end class org.spf4j.base.UnicodeUnescaper -->
  <!-- start class org.spf4j.base.Version -->
  <class name="Version" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="Version" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Version" type="java.lang.CharSequence"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.base.Version"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getImage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getComponents" return="java.lang.Comparable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getComponent" return="java.lang.Comparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="int"/>
    </method>
    <method name="getMajor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMinor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPatch" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrComponents" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.base.Version -->
  <!-- start interface org.spf4j.base.Writeable -->
  <interface name="Writeable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeTo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="java.lang.StringBuilder"/>
    </method>
    <doc>
    <![CDATA[Interface for Objects that can write themselves to a appendable.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.base.Writeable -->
</package>
<package name="org.spf4j.unix">
  <!-- start interface org.spf4j.unix.CLibrary -->
  <interface name="CLibrary"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.sun.jna.platform.unix.LibCAPI"/>
    <implements name="com.sun.jna.Library"/>
    <method name="fork" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="kill" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="int"/>
      <param name="signum" type="int"/>
    </method>
    <method name="setsid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setuid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newuid" type="short"/>
    </method>
    <method name="setgid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newgid" type="short"/>
    </method>
    <method name="umask" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mask" type="int"/>
    </method>
    <method name="getpid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getppid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="chdir" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.lang.String"/>
    </method>
    <method name="execv" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="args" type="com.sun.jna.StringArray"/>
    </method>
    <method name="execvp" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="args" type="com.sun.jna.StringArray"/>
    </method>
    <method name="setenv" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="perror"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="msg" type="java.lang.String"/>
    </method>
    <method name="strerror" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errno" type="int"/>
    </method>
    <method name="sysctlbyname" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="oldp" type="com.sun.jna.Pointer"/>
      <param name="oldlenp" type="com.sun.jna.ptr.IntByReference"/>
      <param name="newp" type="com.sun.jna.Pointer"/>
      <param name="newlen" type="com.sun.jna.ptr.IntByReference"/>
    </method>
    <method name="sysctl" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mib" type="int[]"/>
      <param name="nameLen" type="int"/>
      <param name="oldp" type="com.sun.jna.Pointer"/>
      <param name="oldlenp" type="com.sun.jna.ptr.IntByReference"/>
      <param name="newp" type="com.sun.jna.Pointer"/>
      <param name="newlen" type="com.sun.jna.ptr.IntByReference"/>
    </method>
    <method name="sysctlnametomib" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="mibp" type="com.sun.jna.Pointer"/>
      <param name="size" type="com.sun.jna.ptr.IntByReference"/>
    </method>
    <method name="fopen" return="org.spf4j.unix.CLibrary.FILE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <param name="mode" type="java.lang.String"/>
    </method>
    <method name="freopen" return="org.spf4j.unix.CLibrary.FILE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <param name="mode" type="java.lang.String"/>
      <param name="stream" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="fseek" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
      <param name="offset" type="long"/>
      <param name="whence" type="int"/>
    </method>
    <method name="ftell" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="fread" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="com.sun.jna.Pointer"/>
      <param name="size" type="int"/>
      <param name="count" type="int"/>
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="fclose" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.spf4j.unix.CLibrary.FILE"/>
    </method>
    <method name="getdtablesize" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fcntl" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="int"/>
      <param name="command" type="int"/>
    </method>
    <method name="fcntl" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="int"/>
      <param name="command" type="int"/>
      <param name="flags" type="int"/>
    </method>
    <method name="readlink" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="buffer" type="com.sun.jna.Memory"/>
      <param name="size" type="com.sun.jna.NativeLong"/>
      <doc>
      <![CDATA[Read a symlink. The name will be copied into the specified memory, and returns the number of bytes copied. The
 string is not null-terminated.

 @return if the return value equals size, the caller needs to retry with a bigger buffer. If -1, error.]]>
      </doc>
    </method>
    <field name="INSTANCE" type="org.spf4j.unix.CLibrary"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="F_GETFD" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="F_SETFD" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FD_CLOEXEC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[GNU C library.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.unix.CLibrary -->
  <!-- start class org.spf4j.unix.CLibrary.FILE -->
  <class name="CLibrary.FILE" extends="com.sun.jna.PointerType"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FILE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FILE" type="com.sun.jna.Pointer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.spf4j.unix.CLibrary.FILE -->
  <!-- start class org.spf4j.unix.JVMArguments -->
  <class name="JVMArguments" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JVMArguments" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="JVMArguments" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExecutable" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeSystemProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the first System property.
 @param pname the name of the system property to remove.
 @return the value of the removed system property. or null if there is no such property.]]>
      </doc>
    </method>
    <method name="hasSystemProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
    </method>
    <method name="removeAllSystemPropertiesStartingWith" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pname" type="java.lang.String"/>
      <doc>
      <![CDATA[remove all system properties starting with a prefix.
 @param pname the prefix
 @return number of system properties removed.]]>
      </doc>
    </method>
    <method name="setSystemProperty"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="setVMArgument"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="removeVMArgument" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="hasVMArgument" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argument" type="java.lang.String"/>
    </method>
    <method name="hasVMArgumentStartingWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argumentPrefix" type="java.lang.String"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arg" type="java.lang.String"/>
    </method>
    <method name="removeTail"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Removes the n items from the end. Useful for removing all the Java arguments to rebuild them.]]>
      </doc>
    </method>
    <method name="toStringArray" return="com.sun.jna.StringArray"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="current" return="org.spf4j.unix.JVMArguments"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the process argument list of the current process.]]>
      </doc>
    </method>
    <method name="of" return="org.spf4j.unix.JVMArguments"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the process argument list of the specified process ID.

 @param pid -1 to indicate the current process.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[List of arguments for Java VM and application. based on class from akuma lib (http://akuma.kohsuke.org).]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.JVMArguments -->
  <!-- start class org.spf4j.unix.Lsof -->
  <class name="Lsof" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getNrOpenFiles" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="getLsofOutput" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.Lsof -->
  <!-- start class org.spf4j.unix.Ulimit -->
  <class name="Ulimit" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="see UnixResources for better/faster alternative.">
    <method name="runUlimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="options" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param options
 @return number of max open files for the current process. If unable to find out System Max Limit this value will be
 Integer.MAX_VALUE]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@deprecated see UnixResources for better/faster alternative.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.Ulimit -->
  <!-- start class org.spf4j.unix.UnixConstants -->
  <class name="UnixConstants" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="O_RDONLY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_WRONLY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_RDWR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_APPEND" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_CREAT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_EXCL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_TRUNC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_SYNC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_DSYNC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="O_NOFOLLOW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IAMB" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IRUSR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IWUSR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IXUSR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IRGRP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IWGRP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IXGRP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IROTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IWOTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IXOTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFMT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFREG" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFLNK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFCHR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFBLK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="S_IFIFO" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="R_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="W_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="X_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="F_OK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOENT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EACCES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EEXIST" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOTDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EINVAL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EXDEV" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EISDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOTEMPTY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOSPC" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EAGAIN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENOSYS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ELOOP" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EROFS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENODATA" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ERANGE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AT_SYMLINK_NOFOLLOW" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="AT_REMOVEDIR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixConstants -->
  <!-- start class org.spf4j.unix.UnixException -->
  <class name="UnixException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnixException" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="errno" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="errorString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="translateToIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <param name="other" type="java.lang.String"/>
      <doc>
      <![CDATA[Map well known errors to specific exceptions where possible; otherwise return more general FileSystemException.]]>
      </doc>
    </method>
    <method name="rethrowAsIOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Internal exception thrown by native methods when error detected.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixException -->
  <!-- start class org.spf4j.unix.UnixResources -->
  <class name="UnixResources" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.unix.UnixResources[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.unix.UnixResources"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getMacId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGnuId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSoftLimit" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <method name="setSoftLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="limit" type="long"/>
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <method name="setLimits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="softLimit" type="long"/>
      <param name="hardlimit" type="long"/>
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <method name="getHardLimit" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnixException" type="org.spf4j.unix.UnixException"/>
    </method>
    <field name="RLIMIT_CPU" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[0 Per-process CPU limit, in seconds.]]>
      </doc>
    </field>
    <field name="RLIMIT_FSIZE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[1 Largest file that can be created, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_DATA" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[2 Maximum size of data segment, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_STACK" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[3 Maximum size of stack segment, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_CORE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[4 Largest core file that can be created, in bytes.]]>
      </doc>
    </field>
    <field name="RLIMIT_RSS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[5 Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size
 will be more likely to have physical memory taken from them.]]>
      </doc>
    </field>
    <field name="RLIMIT_NPROC" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[6 Number of processes.]]>
      </doc>
    </field>
    <field name="RLIMIT_NOFILE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[7 Number of open files.]]>
      </doc>
    </field>
    <field name="RLIMIT_MEMLOCK" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[8 Locked-in-memory address space.]]>
      </doc>
    </field>
    <field name="RLIMIT_AS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[9 Address space limit.]]>
      </doc>
    </field>
    <field name="RLIMIT_LOCKS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[10 Maximum number of file locks.]]>
      </doc>
    </field>
    <field name="RLIMIT_SIGPENDING" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[11 Maximum number of pending signals.]]>
      </doc>
    </field>
    <field name="RLIMIT_MSGQUEUE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[12 Maximum bytes in POSIX message queues.]]>
      </doc>
    </field>
    <field name="RLIMIT_NICE" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[13 Maximum nice priority allowed to raise to. Nice levels 19 .. -20 correspond to 0 .. 39 values of this resource
 limit.]]>
      </doc>
    </field>
    <field name="RLIMIT_RTPRIO" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[14]]>
      </doc>
    </field>
    <field name="RLIMIT_RTTIME" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[15 Maximum CPU time in microseconds that a process scheduled under a real-time scheduling policy may consume
 without making a blocking system call before being forcibly de-scheduled.]]>
      </doc>
    </field>
    <field name="RLIMIT_NLIMITS" type="org.spf4j.unix.UnixResources"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[16 Number of {@code rlimit} values]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Possible values of the first parameter to getrlimit()/setrlimit()
 A combination of com.sun.jna.platform.unix.Resource and MACOSX resource.h
 this class requires jna-platforn which is a optional dependency.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixResources -->
  <!-- start class org.spf4j.unix.UnixRuntime -->
  <class name="UnixRuntime" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restart current process with same arguments except -Dspf4j.restart which is added/updated.
 @throws IOException]]>
      </doc>
    </method>
    <method name="restart"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newArguments" type="org.spf4j.unix.JVMArguments"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restart current process.
 This will issue a "exec" system call after closing all existing open files.
 @param newArguments new process arguments. spf4j has a system property: spf4j.restart that will automatically add
 or update to indicate a process was restarted and how many times.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.unix.UnixRuntime -->
</package>
<package name="org.spf4j.trace.avro">
</package>
<package name="org.spf4j.perf.cpu">
  <!-- start class org.spf4j.perf.cpu.CpuUsageSampler -->
  <class name="CpuUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getProcessCpuTimeNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.cpu.CpuUsageSampler -->
  <!-- start class org.spf4j.perf.cpu.ThreadUsageSampler -->
  <class name="ThreadUsageSampler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writePeakThreadInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintStream"/>
    </method>
    <method name="getPeakThreadInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCurrentAliveThreadInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleTime" type="int"/>
      <param name="withStackTraces" type="boolean"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.cpu.ThreadUsageSampler -->
</package>
<package name="org.spf4j.concurrent.jdbc">
  <!-- start class org.spf4j.concurrent.jdbc.HeartBeatError -->
  <class name="HeartBeatError" extends="java.lang.Error"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HeartBeatError"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HeartBeatError" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HeartBeatError" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HeartBeatError" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A Error specifying that a Heartbeat cannot be done.
 THis should be handled as a unrecoverable error in a distributed environment.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.HeartBeatError -->
  <!-- start class org.spf4j.concurrent.jdbc.HeartBeatTableDesc -->
  <class name="HeartBeatTableDesc" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="HeartBeatTableDesc" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.spf4j.jdbc.DbType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntervalColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastHeartbeatColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDbType" return="org.spf4j.jdbc.DbType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withDbType" return="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pdbType" type="org.spf4j.jdbc.DbType"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.HeartBeatTableDesc -->
  <!-- start class org.spf4j.concurrent.jdbc.JdbcHeartBeat -->
  <class name="JdbcHeartBeat" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getBeatDurationNanos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addLyfecycleHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
    </method>
    <method name="removeLifecycleHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
    </method>
    <method name="removeDeadHeartBeatRows" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="removeDeadHeartBeatRowsAsyncNoReturn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
    </method>
    <method name="removeDeadHeartBeatRowsAsync" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
    </method>
    <method name="scheduleHeartbeat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="beat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getLastRunDB" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getIntervalMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRunMillis" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRunTimeStampString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeartBeatAndSubscribe" return="org.spf4j.concurrent.jdbc.JdbcHeartBeat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataSource" type="javax.sql.DataSource"/>
      <param name="hbTableDesc" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"/>
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[Get a reference to the hearbeat instance.
 @param dataSource  the datasource the hearbeat goes against.
 @param hbTableDesc - heartbeat table description.
 @param hook  a hook to notify when heartbeat fails.
 @return the heartbeat instance.]]>
      </doc>
    </method>
    <method name="getHeartBeatAndSubscribe" return="org.spf4j.concurrent.jdbc.JdbcHeartBeat"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataSource" type="javax.sql.DataSource"/>
      <param name="hbTableDesc" type="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"/>
      <param name="hook" type="org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook"/>
      <param name="heartBeatIntevalMillis" type="int"/>
      <param name="jdbcTimeoutSeconds" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="stopHeartBeats"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHbTableDesc" return="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that does "heartbeats" (at a arbitrary inteval) to a database table.
 This is to detect the death of a process.
 The process is considered dead when: currentTime - lastheartbeat > beatInterval * 2
 When this class mechanism detects that it cannot perform the heartbeats it throws a Error.
 The sensible this for the process is to go down (and restart if it is a daemon).
 This is typically done by registering a default uncaught exception handler with:
 Thread.setDefaultUncaughtExceptionHandler


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.JdbcHeartBeat -->
  <!-- start interface org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook -->
  <interface name="JdbcHeartBeat.LifecycleHook"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Error"/>
    </method>
    <method name="onClose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.concurrent.jdbc.JdbcHeartBeat.LifecycleHook -->
  <!-- start class org.spf4j.concurrent.jdbc.JdbcLock -->
  <class name="JdbcLock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.locks.Lock"/>
    <implements name="java.lang.AutoCloseable"/>
    <constructor name="JdbcLock" type="javax.sql.DataSource, org.spf4j.concurrent.jdbc.SemaphoreTablesDesc, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </constructor>
    <method name="lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lockInterruptibly"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryLock" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="unlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newCondition" return="java.util.concurrent.locks.Condition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Jdbc Lock implementation.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.JdbcLock -->
  <!-- start class org.spf4j.concurrent.jdbc.JdbcSemaphore -->
  <class name="JdbcSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[@param dataSource  the jdbc data source with the Semaphores table. Please be sensible, no "test on borrow" pools.
 @param semaphoreName  number of initial permits, if semaphore already exists the existing nr of permits is kept.
 @param nrPermits  the number of initial permits.]]>
      </doc>
    </constructor>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, java.lang.String, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[create a JDBC Semaphore. create one instance / process.

 @param dataSource  the data source to use for sync.
 @param semaphoreName  the semaphore name.
 @param nrPermits  number of initial permits.
 @param strict  if true, if semaphore already exists and the total permits is different that param nrPermits an
 IllegalArgumentException will be thrown.]]>
      </doc>
    </constructor>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, org.spf4j.concurrent.jdbc.SemaphoreTablesDesc, java.lang.String, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </constructor>
    <constructor name="JdbcSemaphore" type="javax.sql.DataSource, org.spf4j.concurrent.jdbc.SemaphoreTablesDesc, java.lang.String, int, int, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </constructor>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unregisterJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrReservations" type="int"/>
    </method>
    <method name="releaseAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="availablePermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="permitsOwned" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="totalPermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="getDeadOwnerPermits" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wishPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="releaseDeadOwnerPermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="wishPermits" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <doc>
      <![CDATA[Attempts to release permits for this semaphore owned by dead owners.

 @param wishPermits - How many permits we would like to get released.
 @return - the number of permits we actually released.
 @throws SQLException - something went wrong with the db.
 @throws InterruptedException - thrown if thread is interrupted.]]>
      </doc>
    </method>
    <method name="updatePermits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="reducePermits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="increasePermits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="removeDeadHeartBeatAndNotOwnerRows" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutSeconds" type="long"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getJdbcTimeoutSeconds" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isIsHealthy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A jdbc table based semaphore implementation. Similar with a semaphore implemented with zookeeper, we rely on
 heartbeats to detect dead members. If you have a zookeeper instance accessible you should probably use a semaphore
 implemented with it... If you are already connecting to a database. this should be a reliable and low overhead (no
 calls from DBA) implementation. (at leat that is my goal) Using a crappy database will give you crappy results.

 There are 3 tables involved:

 SEMAPHORES - keep track of available and total permits by semaphore.
 PERMITS_BY_OWNER - keeps track of all permits by
 owner.
 HEARTBEATS - keeps heartbeats by owner to detect - dead owners.

 All table names and columns are customizable to adapt this implementation to different naming conventions.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.JdbcSemaphore -->
  <!-- start class org.spf4j.concurrent.jdbc.OwnerPermits -->
  <class name="OwnerPermits" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="OwnerPermits" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNrPermits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.OwnerPermits -->
  <!-- start class org.spf4j.concurrent.jdbc.ProcessLimitedJdbcSemaphore -->
  <class name="ProcessLimitedJdbcSemaphore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.concurrent.Semaphore"/>
    <constructor name="ProcessLimitedJdbcSemaphore" type="org.spf4j.concurrent.jdbc.JdbcSemaphore, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrReservations" type="int"/>
    </method>
    <method name="tryAcquire" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nrPermits" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.ProcessLimitedJdbcSemaphore -->
  <!-- start class org.spf4j.concurrent.jdbc.SemaphoreTablesDesc -->
  <class name="SemaphoreTablesDesc" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="SemaphoreTablesDesc" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSemaphoreTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSemNameColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAvailablePermitsColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTotalPermitsColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastModifiedByColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastModifiedAtColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPermitsByOwnerTableName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOwnerPermitsColumn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeartBeatTableDesc" return="org.spf4j.concurrent.jdbc.HeartBeatTableDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withDbType" return="org.spf4j.concurrent.jdbc.SemaphoreTablesDesc"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dbType" type="org.spf4j.jdbc.DbType"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT" type="org.spf4j.concurrent.jdbc.SemaphoreTablesDesc"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.concurrent.jdbc.SemaphoreTablesDesc -->
</package>
<package name="org.spf4j.tsdb2">
  <!-- start class org.spf4j.tsdb2.TimeSeries -->
  <class name="TimeSeries" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimeSeries" type="long[], long[][]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTimeStamps" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValues" return="long[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TimeSeries -->
  <!-- start class org.spf4j.tsdb2.TSDBQuery -->
  <class name="TSDBQuery" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getAllTables" return="com.google.common.collect.ListMultimap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTables" return="com.google.common.collect.ListMultimap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tables" type="java.util.Set"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAllTablesWithDataRanges" return="com.google.common.collect.ListMultimap"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTableDef" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTimeSeries" return="org.spf4j.tsdb2.TimeSeries"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsdbFile" type="java.io.File"/>
      <param name="tableIds" type="long[]"/>
      <param name="startTimeMillis" type="long"/>
      <param name="endTimeMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getIds" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableDefs" type="java.util.Collection"/>
    </method>
    <method name="writeCsvTable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsDB" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <param name="output" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeAsCsv"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="tsDB" type="java.io.File"/>
      <param name="tableName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvTables"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tsDB" type="java.io.File"/>
      <param name="tableNames" type="java.util.Set"/>
      <param name="output" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getColumnDefIfExists" return="org.spf4j.tsdb2.avro.ColumnDef"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
      <param name="columnName" type="java.lang.String"/>
    </method>
    <method name="getColumnDef" return="org.spf4j.tsdb2.avro.ColumnDef"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
      <param name="columnName" type="java.lang.String"/>
    </method>
    <method name="getColumnIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
      <param name="columnName" type="java.lang.String"/>
    </method>
    <method name="getColumnNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
    </method>
    <method name="getColumnUnitsOfMeasurement" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="td" type="org.spf4j.tsdb2.avro.TableDef"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBQuery -->
  <!-- start class org.spf4j.tsdb2.TSDBQuery.TableDefEx -->
  <class name="TSDBQuery.TableDefEx" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TableDefEx" type="org.spf4j.tsdb2.avro.TableDef, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTableDef" return="org.spf4j.tsdb2.avro.TableDef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEndTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setStartTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="startTime" type="long"/>
    </method>
    <method name="setEndTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="endTime" type="long"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBQuery.TableDefEx -->
  <!-- start class org.spf4j.tsdb2.TSDBReader -->
  <class name="TSDBReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TSDBReader" type="java.io.File, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="reReadSize" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[method useful when implementing tailing.
 @return true if size changed.
 @throws IOException]]>
      </doc>
    </method>
    <method name="read" return="org.spf4j.base.Either"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getSize" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeader" return="org.spf4j.tsdb2.avro.Header"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stopWatching"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="bgWatch" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
    </method>
    <method name="watch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="es" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="readAll"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBReader -->
  <!-- start class org.spf4j.tsdb2.TSDBReader.EventSensitivity -->
  <class name="TSDBReader.EventSensitivity" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.tsdb2.TSDBReader.EventSensitivity[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="HIGH" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MEDIUM" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOW" type="org.spf4j.tsdb2.TSDBReader.EventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBReader.EventSensitivity -->
  <!-- start class org.spf4j.tsdb2.TSDBWriter -->
  <class name="TSDBWriter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="java.io.Flushable"/>
    <constructor name="TSDBWriter" type="java.io.File, int, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="writeTableDef" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableDef" type="org.spf4j.tsdb2.avro.TableDef"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDataRow"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timestamp" type="long"/>
      <param name="data" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pvalue" type="long"/>
      <param name="bytes" type="byte[]"/>
      <param name="idx" type="int"/>
    </method>
    <method name="toOutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pvalue" type="long"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Commits the data to disk.

 @throws IOException]]>
      </doc>
    </method>
    <method name="getHeader" return="org.spf4j.tsdb2.avro.Header"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="FILE_RECORD_SCHEMA" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Second generation Time-Series database format. The linked list structure from first generation is dropped to reduce
 write overhead.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.TSDBWriter -->
</package>
<package name="org.spf4j.io.tcp">
  <!-- start class org.spf4j.io.tcp.AcceptorSelectorEventHandler -->
  <class name="AcceptorSelectorEventHandler" extends="org.spf4j.io.tcp.SelectorEventHandler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AcceptorSelectorEventHandler" type="java.nio.channels.ServerSocketChannel, org.spf4j.io.tcp.ClientHandler, java.nio.channels.Selector, java.util.concurrent.ExecutorService, java.util.concurrent.BlockingQueue, org.spf4j.ds.UpdateablePriorityQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="canRunAsync" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
    </method>
    <method name="initialInterestRegistration" return="java.nio.channels.SelectionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.AcceptorSelectorEventHandler -->
  <!-- start interface org.spf4j.io.tcp.ClientHandler -->
  <interface name="ClientHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverSelector" type="java.nio.channels.Selector"/>
      <param name="clientChannel" type="java.nio.channels.SocketChannel"/>
      <param name="exec" type="java.util.concurrent.ExecutorService"/>
      <param name="tasksToRunBySelector" type="java.util.concurrent.BlockingQueue"/>
      <param name="deadlineActions" type="org.spf4j.ds.UpdateablePriorityQueue"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.tcp.ClientHandler -->
  <!-- start class org.spf4j.io.tcp.DeadlineAction -->
  <class name="DeadlineAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DeadlineAction" type="long, java.lang.Runnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAction" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="COMPARATOR" type="java.util.Comparator"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.DeadlineAction -->
  <!-- start class org.spf4j.io.tcp.SelectorEventHandler -->
  <class name="SelectorEventHandler" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SelectorEventHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialInterestRegistration" return="java.nio.channels.SelectionKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
      <doc>
      <![CDATA[Method must be invoked in selector thread.
 THis will register this handler to Selector + channel.
 @return
 @throws ClosedChannelException]]>
      </doc>
    </method>
    <method name="canRunAsync" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.SelectorEventHandler -->
  <!-- start class org.spf4j.io.tcp.TcpServer -->
  <class name="TcpServer" extends="org.spf4j.concurrent.RestartableServiceImpl"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TcpServer" type="java.util.concurrent.ExecutorService, org.spf4j.io.tcp.ClientHandler, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TcpServer" type="java.util.concurrent.ExecutorService, org.spf4j.io.tcp.ClientHandler, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.TcpServer -->
  <!-- start class org.spf4j.io.tcp.TcpServer.TcpServerGuavaService -->
  <class name="TcpServer.TcpServerGuavaService" extends="com.google.common.util.concurrent.AbstractExecutionThreadService"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TcpServerGuavaService" type="java.util.concurrent.ExecutorService, org.spf4j.io.tcp.ClientHandler, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="startUp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="executor" return="java.util.concurrent.Executor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="serviceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="triggerShutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.tcp.TcpServer.TcpServerGuavaService -->
</package>
<package name="org.spf4j.pool.jdbc">
  <!-- start class org.spf4j.pool.jdbc.JdbcConnectionFactory -->
  <class name="JdbcConnectionFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.RecyclingSupplier.Factory"/>
    <constructor name="JdbcConnectionFactory" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.sql.Connection"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
    </method>
    <method name="validate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.sql.Connection"/>
      <param name="e" type="java.lang.Exception"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.pool.jdbc.JdbcConnectionFactory -->
  <!-- start class org.spf4j.pool.jdbc.PooledDataSource -->
  <class name="PooledDataSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.sql.DataSource"/>
    <implements name="java.lang.AutoCloseable"/>
    <constructor name="PooledDataSource" type="int, int, java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </constructor>
    <method name="getConnection" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getConnection" return="java.sql.Connection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="username" type="java.lang.String"/>
      <param name="password" type="java.lang.String"/>
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="getLogWriter" return="java.io.PrintWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="setLogWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintWriter"/>
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="setLoginTimeout"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seconds" type="int"/>
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="getLoginTimeout" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="unwrap" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="isWrapperFor" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
    </method>
    <method name="getParentLogger" return="java.util.logging.Logger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SQLFeatureNotSupportedException" type="java.sql.SQLFeatureNotSupportedException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.pool.jdbc.PooledDataSource -->
</package>
<package name="org.spf4j.io">
  <!-- start class org.spf4j.io.AppendableLimiterWithOverflow -->
  <class name="AppendableLimiterWithOverflow" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Appendable"/>
    <implements name="java.io.Closeable"/>
    <constructor name="AppendableLimiterWithOverflow" type="int, java.io.File, java.lang.CharSequence, java.nio.charset.Charset, java.lang.Appendable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AppendableLimiterWithOverflow" type="int, java.lang.Appendable, org.spf4j.io.AppendableLimiterWithOverflow.OverflowSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.lang.Appendable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOverflowIfNeeded"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility class that limits the nr of characters written to a particular Appender.
 if nr of characters exceed the limit the character above the limit + entire message are written to
 the specified file.
 THe destination appender will contain the chars that fit the limit + a reference to the overflow file
 if overflow happened.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.AppendableLimiterWithOverflow -->
  <!-- start interface org.spf4j.io.AppendableLimiterWithOverflow.OverflowSupplier -->
  <interface name="AppendableLimiterWithOverflow.OverflowSupplier"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOverflowReference" return="java.lang.CharSequence"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return - a string that you can use to reference the overflow. (file name, url...)
 this string is used as a suffix for the appender that is being limited.]]>
      </doc>
    </method>
    <method name="getOverflowWriter" return="java.io.Writer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return - a writer to write the overflow.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[provide the overflow.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.AppendableLimiterWithOverflow.OverflowSupplier -->
  <!-- start class org.spf4j.io.AppendableOutputStream -->
  <class name="AppendableOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.CharsetDecoder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.

 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.CharsetDecoder, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.

 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @param bufferSize the size of the output buffer in number of characters
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.

 @param writer the target {@link Writer}
 @param charset the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.

 @param writer the target {@link Writer}
 @param charset the charset encoding]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.

 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="AppendableOutputStream" type="java.lang.Appendable, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.

 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="poff" type="int"/>
      <param name="plen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write bytes from the specified byte array to the stream.

 @param b the byte array containing the bytes to write
 @param poff the start offset in the byte array
 @param plen the number of bytes to write
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write bytes from the specified byte array to the stream.

 @param b the byte array containing the bytes to write
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a single byte to the stream.

 @param b the byte to write
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#flush()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#close()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="processInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="endOfInput" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decode the contents of the input ByteBuffer into a CharBuffer.

 @param endOfInput indicates end of input
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="flushOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the output.

 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="decoderOut" type="java.nio.CharBuffer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[CharBuffer used as output for the decoder. It should be
 somewhat larger as we write from this buffer to the
 underlying Writer.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[{@link OutputStream} implementation that transforms a byte stream to a
 character stream using a specified character set encoding and writes the resulting
 stream to a {@link Writer}. The stream is transformed using a
 {@link CharsetDecoder} object, guaranteeing that all character set
 encodings supported by the JRE are handled correctly.
 <p>
 The output of the {@link CharsetDecoder} is buffered using a fixed size buffer.
 This implies that the data is written to the underlying {@link Writer} in chunks
 that are no larger than the size of this buffer. By default, the buffer is
 flushed only when it overflows or when {@link #flush()} or {@link #close()}
 is called. In general there is therefore no need to wrap the underlying {@link Writer}
 in a {@link java.io.BufferedWriter}. {@link WriterOutputStream} can also
 be instructed to flush the buffer after each write operation. In this case, all
 available data is written immediately to the underlying {@link Writer}, implying that
 the current position of the {@link Writer} is correlated to the current position
 of the {@link AppendableOutputStream}.
 <p>
 {@link AppendableOutputStream} implements the inverse transformation of {@link java.io.OutputStreamWriter};
 in the following example, writing to {@code out2} would have the same result as writing to
 {@code out} directly (provided that the byte sequence is legal with respect to the
 character set encoding):
 <pre>
 OutputStream out = ...
 Charset cs = ...
 OutputStreamWriter writer = new OutputStreamWriter(out, cs);
 AppendableOutputStream out2 = new AppendableOutputStream(writer, cs);</pre>
 {@link WriterOutputStream} implements the same transformation as {@link java.io.InputStreamReader},
 except that the control flow is reversed: both classes transform a byte stream
 into a character stream, but {@link java.io.InputStreamReader} pulls data from the underlying stream,
 while {@link AppendableOutputStream} pushes it to the underlying stream.
 <p>
 Note that while there are use cases where there is no alternative to using
 this class, very often the need to use this class is an indication of a flaw
 in the design of the code. This class is typically used in situations where an existing
 API only accepts an {@link OutputStream} object, but where the stream is known to represent
 character data that must be decoded for further use.
 <p>
 Instances of {@link AppendableOutputStream} are not thread safe.

 @see org.apache.commons.io.input.ReaderInputStream

 @since 7.2.25]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.AppendableOutputStream -->
  <!-- start class org.spf4j.io.AppendableWriter -->
  <class name="AppendableWriter" extends="java.io.Writer"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AppendableWriter" type="java.lang.Appendable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="char"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility class to adapt a Appendable to a Writer.
 this is a faster version of guava: CharStreams.asWriter
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.AppendableWriter -->
  <!-- start class org.spf4j.io.BufferedInputStream -->
  <class name="BufferedInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="BufferedInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedInputStream" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedInputStream" type="java.io.InputStream, int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.BufferedInputStream -->
  <!-- start class org.spf4j.io.BufferedOutputStream -->
  <class name="BufferedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="BufferedOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedOutputStream" type="java.io.OutputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BufferedOutputStream" type="java.io.OutputStream, int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Better that the JDK outputstream, no exception swallowing...
 and ability to recycle underlying byte array.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.BufferedOutputStream -->
  <!-- start class org.spf4j.io.ByteArrayBuilder -->
  <class name="ByteArrayBuilder" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteArrayBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteArrayBuilder" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteArrayBuilder" type="int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new byte array output stream, with a buffer capacity of
 the specified size, in bytes.

 @param   size   the initial size.
 @exception  IllegalArgumentException if size is negative.]]>
      </doc>
    </constructor>
    <method name="getBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <doc>
      <![CDATA[Writes the specified byte to this byte array output stream.

 @param   b   the byte to be written.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Writes <code>len</code> bytes from the specified byte array
 starting at offset <code>off</code> to this byte array output stream.

 @param   b     the data.
 @param   off   the start offset in the data.
 @param   len   the number of bytes to write.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the complete contents of this byte array output stream to
 the specified output stream argument, as if by calling the output
 stream's write method using <code>out.write(buf, 0, count)</code>.

 @param      out   the output stream to which to write the data.
 @exception  IOException  if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the <code>count</code> field of this byte array output
 stream to zero, so that all currently accumulated output in the
 output stream is discarded. The output stream can be used again,
 reusing the already allocated buffer space.

 @see     java.io.ByteArrayInputStream#count]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a newly allocated byte array. Its size is the current
 size of this output stream and the valid contents of the buffer
 have been copied into it.

 @return  the current contents of this output stream, as a byte array.
 @see     java.io.ByteArrayOutputStream#size()]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current size of the buffer.

 @return  the value of the <code>count</code> field, which is the number
          of valid bytes in this output stream.
 @see     java.io.ByteArrayOutputStream#count]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Converts the buffer's contents into a string decoding bytes using the
 platform's default character set. The length of the new <tt>String</tt>
 is a function of the character set, and hence may not be equal to the
 size of the buffer.

 <p> This method always replaces malformed-input and unmappable-character
 sequences with the default replacement string for the platform's
 default character set. The {@linkplain java.nio.charset.CharsetDecoder}
 class should be used when more control over the decoding process is
 required.

 @return String decoded from the buffer's contents.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charset" type="java.nio.charset.Charset"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an <tt>IOException</tt>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class to avoid replicating byte arrays for no good reason.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ByteArrayBuilder -->
  <!-- start class org.spf4j.io.ConfigurableAppenderSupplier -->
  <class name="ConfigurableAppenderSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.ObjectAppenderSupplier"/>
    <constructor name="ConfigurableAppenderSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConfigurableAppenderSupplier" type="boolean, java.util.function.Predicate, org.spf4j.io.ObjectAppender[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAppenderType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appender" type="org.spf4j.io.ObjectAppender"/>
    </method>
    <method name="register" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="appenders" type="org.spf4j.io.ObjectAppender[]"/>
    </method>
    <method name="replace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="replace" type="java.util.function.Function"/>
    </method>
    <method name="unregister" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
    </method>
    <method name="get" return="org.spf4j.io.ObjectAppender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ConfigurableAppenderSupplier -->
  <!-- start class org.spf4j.io.Crc32C -->
  <class name="Crc32C" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.zip.Checksum"/>
    <constructor name="Crc32C"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new PureJavaCrc32 object.]]>
      </doc>
    </constructor>
    <method name="maskedCrc32c" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
    </method>
    <method name="maskedCrc32c" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
    </method>
    <method name="mask" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="crc" type="int"/>
      <doc>
      <![CDATA[Return a masked representation of crc.
 <p/>
 Motivation: it is problematic to compute the CRC of a string that contains embedded CRCs.
 Therefore we recommend
 that CRCs stored somewhere (e.g., in files) should be masked before being stored.]]>
      </doc>
    </method>
    <method name="unmask" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maskedCrc" type="int"/>
      <doc>
      <![CDATA[Return the crc whose masked representation is masked_crc.]]>
      </doc>
    </method>
    <method name="getMaskedValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="localCrc" type="int"/>
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A pure-java implementation of the CRC32 checksum that uses the CRC32-C polynomial, the same polynomial used by iSCSI
 and implemented on many Intel chipsets supporting SSE4.2.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.Crc32C -->
  <!-- start class org.spf4j.io.Csv -->
  <class name="Csv" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow2"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="elems" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="long[]"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRow"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.lang.Appendable"/>
      <param name="elems" type="java.lang.Iterable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCsvRowNoEOL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elems" type="java.lang.Iterable"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="charset" type="java.nio.charset.Charset"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvMapHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readRow" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvRowHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="read" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
    </method>
    <method name="readNoBom" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
      <param name="handler" type="org.spf4j.io.Csv.CsvHandler"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="CsvParseException" type="org.spf4j.io.csv.CsvParseException"/>
      <doc>
      <![CDATA[reads CSV format until EOF of reader.

 @param <T>
 @param preader
 @param handler
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="asIterable" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <doc>
      <![CDATA[read a CSV stream, as a Iterable over rows.
 the List<String> instance is reused during iteration, you will need to copy content into
 own data structure.
 @param preader
 @return]]>
      </doc>
    </method>
    <method name="reader" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preader" type="java.io.Reader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readerNoBOM" return="org.spf4j.io.csv.CsvReader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.spf4j.io.PushbackReader"/>
    </method>
    <method name="writeCsvElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeQuotedCsvElement"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
      <param name="writer" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toCsvElement" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.CharSequence"/>
    </method>
    <method name="readCsvElement" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="java.io.Reader"/>
      <param name="addElemTo" type="java.lang.StringBuilder"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[returns next character.

 @param reader
 @param addElemTo
 @return - next character or -1 if eof has been reached.
 @throws IOException]]>
      </doc>
    </method>
    <field name="CSV" type="org.spf4j.io.csv.CharSeparatedValues"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Supports CSV format as described at: https://en.wikipedia.org/wiki/Comma-separated_values. either of \n \r or \r\n
 are valid end of line delimiters

 why another implementation? because I need one that is as fast as possible, and as flexible as possible.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.Csv -->
  <!-- start interface org.spf4j.io.Csv.CsvHandler -->
  <interface name="Csv.CsvHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.csv.CsvHandler"/>
  </interface>
  <!-- end interface org.spf4j.io.Csv.CsvHandler -->
  <!-- start interface org.spf4j.io.Csv.CsvMapHandler -->
  <interface name="Csv.CsvMapHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.csv.CsvMapHandler"/>
  </interface>
  <!-- end interface org.spf4j.io.Csv.CsvMapHandler -->
  <!-- start interface org.spf4j.io.Csv.CsvRowHandler -->
  <interface name="Csv.CsvRowHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.csv.CsvRowHandler"/>
  </interface>
  <!-- end interface org.spf4j.io.Csv.CsvRowHandler -->
  <!-- start class org.spf4j.io.DeletingVisitor -->
  <class name="DeletingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.nio.file.FileVisitor"/>
    <constructor name="DeletingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitFile" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="postVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="preVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
    </method>
    <method name="visitFileFailed" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.DeletingVisitor -->
  <!-- start class org.spf4j.io.EmptyInputStream -->
  <class name="EmptyInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="EMPTY" type="java.io.InputStream"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.EmptyInputStream -->
  <!-- start class org.spf4j.io.FSWatchEventSensitivity -->
  <class name="FSWatchEventSensitivity" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.io.FSWatchEventSensitivity[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.io.FSWatchEventSensitivity"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="HIGH" type="org.spf4j.io.FSWatchEventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MEDIUM" type="org.spf4j.io.FSWatchEventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOW" type="org.spf4j.io.FSWatchEventSensitivity"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.FSWatchEventSensitivity -->
  <!-- start class org.spf4j.io.IOTimeoutException -->
  <class name="IOTimeoutException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOTimeoutException" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMillisAfterDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.IOTimeoutException -->
  <!-- start class org.spf4j.io.LazyOutputStreamWrapper -->
  <class name="LazyOutputStreamWrapper" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LazyOutputStreamWrapper" type="java.util.function.Supplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A utility class that allows you to delay any writes made in the constructor of a particular writer (headers).
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.LazyOutputStreamWrapper -->
  <!-- start class org.spf4j.io.MemorizingBufferedInputStream -->
  <class name="MemorizingBufferedInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MemorizingBufferedInputStream" type="java.io.InputStream, int, int, org.spf4j.recyclable.SizedRecyclingSupplier, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getReadBytesFromBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnreadBytesFromBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReadBytes" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <doc>
    <![CDATA[Why another buffered input stream?
 Main use case if for troubleshooting.
 Allows you to get more detail on where your stream processing failed.

 Implementation is a circular byte buffer, where you have 2 sizes to control the behavior:

 buffer size - the total sie of the buffer.
 read size - the maximum number of read bytes kept in the buffer.


 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.MemorizingBufferedInputStream -->
  <!-- start interface org.spf4j.io.ObjectAppender -->
  <interface name="ObjectAppender"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="append"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="appendTo" type="java.lang.Appendable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="TOSTRING_APPENDER" type="org.spf4j.io.ObjectAppender"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly
 @param <T> - type of object to append.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.ObjectAppender -->
  <!-- start interface org.spf4j.io.ObjectAppenderSupplier -->
  <interface name="ObjectAppenderSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Function"/>
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <method name="apply" return="org.spf4j.io.ObjectAppender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clasz" type="java.lang.Class"/>
    </method>
    <field name="TO_STRINGER" type="org.spf4j.io.ObjectAppenderSupplier"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.ObjectAppenderSupplier -->
  <!-- start class org.spf4j.io.PathsIOException -->
  <class name="PathsIOException" extends="java.io.IOException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathsIOException" type="java.nio.file.Path, java.io.IOException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.nio.file.Path"/>
      <param name="ex" type="java.io.IOException"/>
    </method>
    <method name="getPaths" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.PathsIOException -->
  <!-- start class org.spf4j.io.PipedOutputStream -->
  <class name="PipedOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PipedOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int, org.spf4j.recyclable.SizedRecyclingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PipedOutputStream" type="int, org.spf4j.recyclable.SizedRecyclingSupplier, java.lang.Long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDeadline" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeUntil"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <param name="deadline" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeUntil"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <param name="deadline" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnreadBytesFromBuffer" return="byte[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Equivalent to Java piped input/output stream.

 This implementation supports timeouts, timeout are specified by setting the org.spf4j.base.runtime.DEADLINE thread
 local.

 Implementation supports multiple readers and writers.

 Data is available to readers only after it is flushed. (happens automatically when buffer is full)

 This implementation should be slightly faster than the JDK implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.PipedOutputStream -->
  <!-- start class org.spf4j.io.PushbackInputStreamEx -->
  <class name="PushbackInputStreamEx" extends="java.io.PushbackInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PushbackInputStreamEx" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PushbackInputStreamEx" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnderlyingStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[a extended implementation that improves the safety of unread and provides a better toString.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.PushbackInputStreamEx -->
  <!-- start class org.spf4j.io.PushbackReader -->
  <class name="PushbackReader" extends="java.io.FilterReader"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PushbackReader" type="java.io.Reader, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PushbackReader" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="poff" type="int"/>
      <param name="plen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cbuf" type="char[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="ready" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readAheadLimit" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pn" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.io.PushbackReader -->
  <!-- start class org.spf4j.io.ReaderInputStream -->
  <class name="ReaderInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReaderInputStream" type="java.io.Reader, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new input stream that will encode the characters from {@code reader} into bytes using
 the given character set. Malformed input and unmappable characters will be replaced.

 @param reader input source
 @param charset character set used for encoding chars to bytes
 @param bufferSize size of internal input and output buffers
 @throws IllegalArgumentException if bufferSize is non-positive]]>
      </doc>
    </constructor>
    <constructor name="ReaderInputStream" type="java.io.Reader, java.nio.charset.CharsetEncoder, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new input stream that will encode the characters from {@code reader} into bytes using
 the given character set encoder.

 @param reader input source
 @param encoder character set encoder used for encoding chars to bytes
 @param bufferSize size of internal input and output buffers
 @throws IllegalArgumentException if bufferSize is non-positive]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An {@link InputStream} that converts characters from a {@link Reader} into bytes using an
 arbitrary Charset.

 <p>This is an alternative to copying the data to an {@code OutputStream} via a {@code Writer},
 which is necessarily blocking. By implementing an {@code InputStream} it allows consumers to
 "pull" as much data as they can handle, which is more convenient when dealing with flow
 controlled, async APIs.

 @author Chris Nokleberg

 Notes by Z: THis class in its current state is not ready for prime time. Here is why:
 1) Since it buffers, there needs to be capability to access the unconsumed bytes/chars.
 2) Buffer sizing could be smarter? char buffer and byte buffers are not "byte size equivalent"(just made this up :-))]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.ReaderInputStream -->
  <!-- start class org.spf4j.io.SetFilesReadOnlyVisitor -->
  <class name="SetFilesReadOnlyVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.nio.file.FileVisitor"/>
    <constructor name="SetFilesReadOnlyVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="preVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
    </method>
    <method name="visitFile" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="attrs" type="java.nio.file.attribute.BasicFileAttributes"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="visitFileFailed" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="postVisitDirectory" return="java.nio.file.FileVisitResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.nio.file.Path"/>
      <param name="exc" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.spf4j.io.SetFilesReadOnlyVisitor -->
  <!-- start class org.spf4j.io.Streams -->
  <class name="Streams" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[see copy(final InputStream is, final OutputStream os, final int buffSize) for detail.

 @param is
 @param os
 @return
 @throws IOException]]>
      </doc>
    </method>
    <method name="copy" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="os" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Equivalent to guava ByteStreams.copy, with one special behavior: if is has no bytes immediately available for
 read, the os is flushed prior to the next read that will probably block.

 I believe this behavior will yield better performance in most scenarios. This method also makes use of:
 Arrays.getBytesTmp. THis method should not be invoked from any context making use of Arrays.getBytesTmp.

 @param is
 @param os
 @param buffSize
 @throws IOException]]>
      </doc>
    </method>
    <method name="asWriter" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appendable" type="java.lang.Appendable"/>
      <doc>
      <![CDATA[faster variant than guava CharStreams.asWriter.
 @param appendable - the appendable to transform.
 @return - the writer that will write to the appendable.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.Streams -->
  <!-- start class org.spf4j.io.WriterOutputStream -->
  <class name="WriterOutputStream" extends="org.spf4j.io.AppendableOutputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.CharsetDecoder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.
 
 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.CharsetDecoder, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.
 
 @param writer the target {@link Writer}
 @param decoder the charset decoder
 @param bufferSize the size of the output buffer in number of characters
 @since 2.1]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.Charset, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.
 
 @param writer the target {@link Writer}
 @param charset the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.nio.charset.Charset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.
 
 @param writer the target {@link Writer}
 @param charset the charset encoding]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream}.
 
 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding
 @param bufferSize the size of the output buffer in number of characters]]>
      </doc>
    </constructor>
    <constructor name="WriterOutputStream" type="java.io.Writer, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new {@link WriterOutputStream} with a default output buffer size of
 1024 characters. The output buffer will only be flushed when it overflows or when
 {@link #flush()} or {@link #close()} is called.
 
 @param writer the target {@link Writer}
 @param charsetName the name of the charset encoding]]>
      </doc>
    </constructor>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#flush()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the stream. Any remaining content accumulated in the output buffer
 will be written to the underlying {@link Writer}. After that
 {@link Writer#close()} will be called.
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="flushOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush the output.
 
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[{@link OutputStream} implementation that transforms a byte stream to a
 character stream using a specified character set encoding and writes the resulting
 stream to a {@link Writer}. The stream is transformed using a
 {@link CharsetDecoder} object, guaranteeing that all character set
 encodings supported by the JRE are handled correctly.
 <p>
 The output of the {@link CharsetDecoder} is buffered using a fixed size buffer.
 This implies that the data is written to the underlying {@link Writer} in chunks
 that are no larger than the size of this buffer. By default, the buffer is
 flushed only when it overflows or when {@link #flush()} or {@link #close()}
 is called. In general there is therefore no need to wrap the underlying {@link Writer}
 in a {@link java.io.BufferedWriter}. {@link WriterOutputStream} can also
 be instructed to flush the buffer after each write operation. In this case, all
 available data is written immediately to the underlying {@link Writer}, implying that
 the current position of the {@link Writer} is correlated to the current position
 of the {@link WriterOutputStream}.
 <p>
 {@link WriterOutputStream} implements the inverse transformation of {@link java.io.OutputStreamWriter};
 in the following example, writing to {@code out2} would have the same result as writing to
 {@code out} directly (provided that the byte sequence is legal with respect to the
 character set encoding):
 <pre>
 OutputStream out = ...
 Charset cs = ...
 OutputStreamWriter writer = new OutputStreamWriter(out, cs);
 WriterOutputStream out2 = new WriterOutputStream(writer, cs);</pre>
 {@link WriterOutputStream} implements the same transformation as {@link java.io.InputStreamReader},
 except that the control flow is reversed: both classes transform a byte stream
 into a character stream, but {@link java.io.InputStreamReader} pulls data from the underlying stream,
 while {@link WriterOutputStream} pushes it to the underlying stream.
 <p>
 Note that while there are use cases where there is no alternative to using
 this class, very often the need to use this class is an indication of a flaw
 in the design of the code. This class is typically used in situations where an existing
 API only accepts an {@link OutputStream} object, but where the stream is known to represent
 character data that must be decoded for further use.
 <p>
 Instances of {@link WriterOutputStream} are not thread safe.
 
 @see org.apache.commons.io.input.ReaderInputStream
 
 @since 7.2.25]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.WriterOutputStream -->
</package>
<package name="org.spf4j.perf.impl">
  <!-- start class org.spf4j.perf.impl.AbstractMeasurementAccumulator -->
  <class name="AbstractMeasurementAccumulator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementAccumulator"/>
    <constructor name="AbstractMeasurementAccumulator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="recordAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long"/>
    </method>
    <method name="getMinTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.AbstractMeasurementAccumulator -->
  <!-- start class org.spf4j.perf.impl.CountingAccumulator -->
  <class name="CountingAccumulator" extends="org.spf4j.perf.impl.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingAccumulator" type="java.lang.Object, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.CountingAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.impl.CountingAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.CountingAccumulator -->
  <!-- start class org.spf4j.perf.impl.DirectRecorderSource -->
  <class name="DirectRecorderSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <constructor name="DirectRecorderSource" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.DirectRecorderSource -->
  <!-- start class org.spf4j.perf.impl.DirectStoreAccumulator -->
  <class name="DirectStoreAccumulator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorder"/>
    <implements name="java.io.Closeable"/>
    <constructor name="DirectStoreAccumulator" type="java.lang.Object, java.lang.String, java.lang.String, int, org.spf4j.perf.MeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="recordAt"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long"/>
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRecorded" return="org.spf4j.perf.impl.DirectStoreAccumulator.RecordedValue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.DirectStoreAccumulator -->
  <!-- start class org.spf4j.perf.impl.DirectStoreAccumulator.RecordedValue -->
  <class name="DirectStoreAccumulator.RecordedValue" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="RecordedValue" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTs" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.DirectStoreAccumulator.RecordedValue -->
  <!-- start class org.spf4j.perf.impl.DirectStoreMultiAccumulator -->
  <class name="DirectStoreMultiAccumulator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MultiMeasurementRecorder"/>
    <implements name="java.io.Closeable"/>
    <constructor name="DirectStoreMultiAccumulator" type="org.spf4j.perf.MeasurementsInfo, org.spf4j.perf.MeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long[]"/>
    </method>
    <method name="recordAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long[]"/>
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastRecorded" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.DirectStoreMultiAccumulator -->
  <!-- start class org.spf4j.perf.impl.MeasurementsInfoImpl -->
  <class name="MeasurementsInfoImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementsInfo"/>
    <constructor name="MeasurementsInfoImpl" type="java.lang.Object, java.lang.String, java.lang.String[], java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMeasuredEntity" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNumberOfMeasurements" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementUnits" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getMeasurementUnit" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.MeasurementsInfoImpl -->
  <!-- start class org.spf4j.perf.impl.MinMaxAvgAccumulator -->
  <class name="MinMaxAvgAccumulator" extends="org.spf4j.perf.impl.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MinMaxAvgAccumulator" type="java.lang.Object, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.MinMaxAvgAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.impl.MinMaxAvgAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.MinMaxAvgAccumulator -->
  <!-- start class org.spf4j.perf.impl.NopMeasurementRecorder -->
  <class name="NopMeasurementRecorder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorder"/>
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="recordAt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
      <param name="timestampMillis" type="long"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="org.spf4j.perf.impl.NopMeasurementRecorder"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.NopMeasurementRecorder -->
  <!-- start class org.spf4j.perf.impl.NopMeasurementRecorderSource -->
  <class name="NopMeasurementRecorderSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="org.spf4j.perf.impl.NopMeasurementRecorderSource"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.NopMeasurementRecorderSource -->
  <!-- start class org.spf4j.perf.impl.NopMeasurementStore -->
  <class name="NopMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="NopMeasurementStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.NopMeasurementStore -->
  <!-- start class org.spf4j.perf.impl.Quanta -->
  <class name="Quanta" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="Quanta" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Quanta" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIntervalEnd" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIntervalStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClosestToZero" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.perf.impl.Quanta"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[this class ordering is based on start Interval ordering]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.Quanta -->
  <!-- start class org.spf4j.perf.impl.QuantizedAccumulator -->
  <class name="QuantizedAccumulator" extends="org.spf4j.perf.impl.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="QuantizedAccumulator" type="java.lang.Object, java.lang.String, java.lang.String, int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a quantized accumulator.
 factor = 10
 lowMagnitude = -2
 higherMagnitude = 2
 quantasPerMagnitude = 10

 results in -100 -90 -80 .. -10 -9 -8  .. -1 0 1 2 .. 9 10 20 30 .. 100

 @param measuredEntity - and object representing the thing we accumulate measurements for.
 @param description - description of the thing we accumulate measurements for.
 @param unitOfMeasurement - unit of measurement.
 @param factor
 @param lowerMagnitude the lower end of the quantized recording (lowerMagnitude/lowerMagnitude) * factor ^
 |lowerMagnitude|
 @param higherMagnitude the higher end of the quantized recording (higherMagnitude/higherMagnitude) * factor ^
 |higherMagnitude|
 @param quantasPerMagnitude number of buckets / magnitude]]>
      </doc>
    </constructor>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="record"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.impl.QuantizedAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.impl.QuantizedAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxMeasurement" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementCount" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementTotal" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMinMeasurement" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQuatizedMeasurements" return="long[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[inspired by DTrace LLQUANTIZE

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.QuantizedAccumulator -->
  <!-- start class org.spf4j.perf.impl.RecorderFactory -->
  <class name="RecorderFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasurementStore" return="org.spf4j.perf.MeasurementStore"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fromString" return="org.spf4j.perf.MeasurementStore"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="createScalableQuantizedRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="factor" type="int"/>
      <param name="lowerMagnitude" type="int"/>
      <param name="higherMagnitude" type="int"/>
      <param name="quantasPerMagnitude" type="int"/>
      <doc>
      <![CDATA[Create a Quantized Measurement recorder. (see concept at http://dtrace.org/blogs/bmc/2011/02/08/llquantize/ )

 A quantized measurement recorder is appropriate for low overhead measurement recording with good detail
 using quantized data resolution.
 For lower overhead recorder see createScalableMinMaxAvgRecorder.

 example : createScalableQuantizedRecorder("response time", "ms", 60000, 10, -3, 3, 5)
 will aggregate and persist measurements every minute.
 will have the following measurement buckets:

 QNI_-1000, Q-1000_-800, Q-800_-600, Q-600_-400, Q-400_-100, Q-100_-80, Q-80_-60, Q-60_-40, Q-40_-10, Q-10_-8,
 Q-8_-6, Q-6_-4, Q-4_-2, Q-2_0, Q0_2, Q2_4, Q4_6,
 Q6_8, Q8_10, Q10_40, Q40_60, Q60_80, Q80_100, Q100_400, Q400_600, Q600_800, Q800_1000, Q1000_PI

 where A_B equivalent Math notation is [A,B)
 where NI = negative infinity
 where PI is positive infinity

 @param forWhat an object identifying what is being measured, ex: "response time"
 @param unitOfMeasurement the unit of measurement of the measurements, ex "milliseconds"
 @param sampleTimeMillis the sampling (accumulating interval) ex: 60000 for minute level detail.
 @param factor the log factor of the magnitudes, ex: 10 for 0-1,1-10,10-100,100 - 1000 magnitudes.
 @param lowerMagnitude the lowest magnitude. ex: 10 for 10 * factor min bucket limit value.
 @param higherMagnitude th highest magnitude. ex 10 for 10 * factor max bucket limit value.
 @param quantasPerMagnitude number of equally divided measurement buckets per magnitude. ex: 10
 @return a measurement recorder that]]>
      </doc>
    </method>
    <method name="createScalableCountingRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableMinMaxAvgRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableQuantizedRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
      <param name="factor" type="int"/>
      <param name="lowerMagnitude" type="int"/>
      <param name="higherMagnitude" type="int"/>
      <param name="quantasPerMagnitude" type="int"/>
    </method>
    <method name="createScalableCountingRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createScalableMinMaxAvgRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.MultiMeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measuredEntity" type="java.lang.Object"/>
      <param name="description" type="java.lang.String"/>
      <param name="measurementNames" type="java.lang.String[]"/>
      <param name="measurementUnits" type="java.lang.String[]"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
    </method>
    <method name="createDirectRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="createDirectRecorderSource" return="org.spf4j.perf.MeasurementRecorderSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
    </method>
    <method name="createDirectGraphiteUdpRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="graphiteHost" type="java.lang.String"/>
      <param name="graphitePort" type="int"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <method name="createDirectGraphiteTcpRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <param name="unitOfMeasurement" type="java.lang.String"/>
      <param name="graphiteHost" type="java.lang.String"/>
      <param name="graphitePort" type="int"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
    </method>
    <field name="MEASUREMENT_STORE" type="org.spf4j.perf.MeasurementStore"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.RecorderFactory -->
  <!-- start class org.spf4j.perf.impl.ScalableMeasurementRecorder -->
  <class name="ScalableMeasurementRecorder" extends="org.spf4j.perf.impl.AbstractMeasurementAccumulator"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
    </method>
    <method name="get" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementsAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ScalableMeasurementRecorder -->
  <!-- start class org.spf4j.perf.impl.ScalableMeasurementRecorderSource -->
  <class name="ScalableMeasurementRecorderSource" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorderSource"/>
    <implements name="org.spf4j.perf.MeasurementsSource"/>
    <implements name="java.io.Closeable"/>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
    </method>
    <method name="getEntitiesMeasurements" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitiesMeasurementsAndReset" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerJmx"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementsAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurements" return="javax.management.openmbean.CompositeDataSupport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.perf.impl.ScalableMeasurementRecorderSource -->
</package>
<package name="org.spf4j.os">
  <!-- start class org.spf4j.os.OperatingSystem -->
  <class name="OperatingSystem" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getOSMbean" return="java.lang.management.OperatingSystemMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSunJdkOSMBean" return="com.sun.management.OperatingSystemMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnixOsMBean" return="com.sun.management.UnixOperatingSystemMXBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOpenFileDescriptorCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaxFileDescriptorCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="killProcess" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proc" type="java.lang.Process"/>
      <param name="terminateTimeoutMillis" type="long"/>
      <param name="forceTerminateTimeoutMillis" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="forkExec" return="org.spf4j.os.ProcessResponse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String[]"/>
      <param name="handler" type="org.spf4j.os.ProcessHandler"/>
      <param name="timeoutMillis" type="long"/>
      <param name="terminationTimeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="forkExec" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="java.lang.String[]"/>
      <param name="timeoutMillis" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <field name="MAX_NR_OPENFILES" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility to wrap access to JDK specific Operating system Mbean attributes.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.OperatingSystem -->
  <!-- start interface org.spf4j.os.ProcessHandler -->
  <interface name="ProcessHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleStdOut" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleStdErr" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stderr" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStdIn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stdout" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.os.ProcessHandler -->
  <!-- start class org.spf4j.os.ProcessResponse -->
  <class name="ProcessResponse" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getResponseCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResponseExitCode" return="org.spf4j.base.SysExits"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOutput" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getErrOutput" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.ProcessResponse -->
  <!-- start class org.spf4j.os.StdOutLineCountProcessHandler -->
  <class name="StdOutLineCountProcessHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.os.ProcessHandler"/>
    <constructor name="StdOutLineCountProcessHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handleStdOut" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.StdOutLineCountProcessHandler -->
  <!-- start class org.spf4j.os.StdOutToStringProcessHandler -->
  <class name="StdOutToStringProcessHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.os.ProcessHandler"/>
    <constructor name="StdOutToStringProcessHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handleStdOut" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stdout" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.os.StdOutToStringProcessHandler -->
</package>
<package name="org.spf4j.jdbc">
  <!-- start class org.spf4j.jdbc.DbType -->
  <class name="DbType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.jdbc.DbType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.jdbc.DbType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getCurrTSSqlFn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dbType" type="org.spf4j.jdbc.DbType"/>
      <exception name="ExceptionInInitializerError" type="java.lang.ExceptionInInitializerError"/>
      <doc>
      <![CDATA[Return the SQL for a current time millis since a EPOCH...

 @param dbType - the database type.
 @return - the sql fragment taht returns the current sql millis.
 @throws ExceptionInInitializerError]]>
      </doc>
    </method>
    <method name="getCurrTSSqlFn" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ExceptionInInitializerError" type="java.lang.ExceptionInInitializerError"/>
      <doc>
      <![CDATA[Return the SQL for a current time millis since a EPOCH...

 @param dbType - the database type.
 @return - the sql fragment taht returns the current sql millis.
 @throws ExceptionInInitializerError]]>
      </doc>
    </method>
    <field name="ORACLE" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="H2" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SYBASE_ASE" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SYBASE_IQ" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MSSQL" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MYSQL" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="POSTGRES" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COCKROACH_DB" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT" type="org.spf4j.jdbc.DbType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default database type to use in all jdbc APIs if a DBtype is not provided.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jdbc.DbType -->
  <!-- start class org.spf4j.jdbc.JdbcTemplate -->
  <class name="JdbcTemplate" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JdbcTemplate" type="javax.sql.DataSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkJdbcObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.CharSequence"/>
    </method>
    <method name="transactOnConnection" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="transactOnConnectionNonInterrupt" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.HandlerNano"/>
      <param name="timeout" type="long"/>
      <param name="tu" type="java.util.concurrent.TimeUnit"/>
      <exception name="SQLException" type="java.sql.SQLException"/>
    </method>
    <method name="getTimeoutToDeadlineSeconds" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deadlineNanos" type="long"/>
      <doc>
      <![CDATA[@param deadlineNanos the deadline relative to the same as System.nanoTime()
 @return]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A very simple JdbTemplate.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jdbc.JdbcTemplate -->
</package>
<package name="org.spf4j.test.avro">
  <!-- start class org.spf4j.test.avro.Method -->
  <class name="Method" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="Method"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="Method" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param declaringClass The new value for declaringClass
 @param methodName The new value for methodName]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getDeclaringClass" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'declaringClass' field.
 @return The value of the 'declaringClass' field.]]>
      </doc>
    </method>
    <method name="setDeclaringClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'declaringClass' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getMethodName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'methodName' field.
 @return The value of the 'methodName' field.]]>
      </doc>
    </method>
    <method name="setMethodName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'methodName' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new Method RecordBuilder.
 @return A new Method RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test.avro.Method.Builder"/>
      <doc>
      <![CDATA[Creates a new Method RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new Method RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test.avro.Method"/>
      <doc>
      <![CDATA[Creates a new Method RecordBuilder by copying an existing Method instance.
 @param other The existing instance to copy.
 @return A new Method RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="declaringClass" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="methodName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.test.avro.Method -->
  <!-- start class org.spf4j.test.avro.Method.Builder -->
  <class name="Method.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getDeclaringClass" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'declaringClass' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setDeclaringClass" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'declaringClass' field.
 @param value The value of 'declaringClass'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasDeclaringClass" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'declaringClass' field has been set.
 @return True if the 'declaringClass' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearDeclaringClass" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'declaringClass' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="getMethodName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'methodName' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setMethodName" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'methodName' field.
 @param value The value of 'methodName'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasMethodName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'methodName' field has been set.
 @return True if the 'methodName' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearMethodName" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'methodName' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.test.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for Method instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.test.avro.Method.Builder -->
  <!-- start class org.spf4j.test.avro.SampleNode -->
  <class name="SampleNode" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="SampleNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="SampleNode" type="java.lang.Integer, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param count The new value for count
 @param subNodes The new value for subNodes]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getCount" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'count' field.
 @return The value of the 'count' field.]]>
      </doc>
    </method>
    <method name="setCount"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'count' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getSubNodes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subNodes' field.
 @return The value of the 'subNodes' field.]]>
      </doc>
    </method>
    <method name="setSubNodes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'subNodes' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new SampleNode RecordBuilder.
 @return A new SampleNode RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test.avro.SampleNode.Builder"/>
      <doc>
      <![CDATA[Creates a new SampleNode RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new SampleNode RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test.avro.SampleNode"/>
      <doc>
      <![CDATA[Creates a new SampleNode RecordBuilder by copying an existing SampleNode instance.
 @param other The existing instance to copy.
 @return A new SampleNode RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="count" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="subNodes" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.test.avro.SampleNode -->
  <!-- start class org.spf4j.test.avro.SampleNode.Builder -->
  <class name="SampleNode.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getCount" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'count' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setCount" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'count' field.
 @param value The value of 'count'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasCount" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'count' field has been set.
 @return True if the 'count' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearCount" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'count' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="getSubNodes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'subNodes' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setSubNodes" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'subNodes' field.
 @param value The value of 'subNodes'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasSubNodes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'subNodes' field has been set.
 @return True if the 'subNodes' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearSubNodes" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'subNodes' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.test.avro.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for SampleNode instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.test.avro.SampleNode.Builder -->
  <!-- start class org.spf4j.test.avro.SamplePair -->
  <class name="SamplePair" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="SamplePair"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="SamplePair" type="org.spf4j.test.avro.Method, org.spf4j.test.avro.SampleNode"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param method The new value for method
 @param node The new value for node]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getMethod" return="org.spf4j.test.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'method' field.
 @return The value of the 'method' field.]]>
      </doc>
    </method>
    <method name="setMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test.avro.Method"/>
      <doc>
      <![CDATA[Sets the value of the 'method' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getNode" return="org.spf4j.test.avro.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'node' field.
 @return The value of the 'node' field.]]>
      </doc>
    </method>
    <method name="setNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test.avro.SampleNode"/>
      <doc>
      <![CDATA[Sets the value of the 'node' field.
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new SamplePair RecordBuilder.
 @return A new SamplePair RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test.avro.SamplePair.Builder"/>
      <doc>
      <![CDATA[Creates a new SamplePair RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new SamplePair RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.test.avro.SamplePair"/>
      <doc>
      <![CDATA[Creates a new SamplePair RecordBuilder by copying an existing SamplePair instance.
 @param other The existing instance to copy.
 @return A new SamplePair RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="method" type="org.spf4j.test.avro.Method"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="node" type="org.spf4j.test.avro.SampleNode"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.test.avro.SamplePair -->
  <!-- start class org.spf4j.test.avro.SamplePair.Builder -->
  <class name="SamplePair.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getMethod" return="org.spf4j.test.avro.Method"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'method' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setMethod" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test.avro.Method"/>
      <doc>
      <![CDATA[Sets the value of the 'method' field.
 @param value The value of 'method'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasMethod" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'method' field has been set.
 @return True if the 'method' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="getMethodBuilder" return="org.spf4j.test.avro.Method.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Builder instance for the 'method' field and creates one if it doesn't exist yet.
 @return This builder.]]>
      </doc>
    </method>
    <method name="setMethodBuilder" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test.avro.Method.Builder"/>
      <doc>
      <![CDATA[Sets the Builder instance for the 'method' field
 @param value The builder instance that must be set.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasMethodBuilder" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'method' field has an active Builder instance
 @return True if the 'method' field has an active Builder instance]]>
      </doc>
    </method>
    <method name="clearMethod" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'method' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="getNode" return="org.spf4j.test.avro.SampleNode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'node' field.
 @return The value.]]>
      </doc>
    </method>
    <method name="setNode" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test.avro.SampleNode"/>
      <doc>
      <![CDATA[Sets the value of the 'node' field.
 @param value The value of 'node'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasNode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'node' field has been set.
 @return True if the 'node' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="getNodeBuilder" return="org.spf4j.test.avro.SampleNode.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Builder instance for the 'node' field and creates one if it doesn't exist yet.
 @return This builder.]]>
      </doc>
    </method>
    <method name="setNodeBuilder" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.test.avro.SampleNode.Builder"/>
      <doc>
      <![CDATA[Sets the Builder instance for the 'node' field
 @param value The builder instance that must be set.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasNodeBuilder" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'node' field has an active Builder instance
 @return True if the 'node' field has an active Builder instance]]>
      </doc>
    </method>
    <method name="clearNode" return="org.spf4j.test.avro.SamplePair.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'node' field.
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.test.avro.SamplePair"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for SamplePair instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.test.avro.SamplePair.Builder -->
</package>
<package name="org.spf4j.recyclable">
  <!-- start interface org.spf4j.recyclable.Disposable -->
  <interface name="Disposable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="dispose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="tryDispose" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeoutMillis" type="long"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.Disposable -->
  <!-- start interface org.spf4j.recyclable.Lease -->
  <interface name="Lease"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
    <implements name="java.lang.AutoCloseable"/>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.Lease -->
  <!-- start interface org.spf4j.recyclable.LeaseSupplier -->
  <interface name="LeaseSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.function.Supplier"/>
  </interface>
  <!-- end interface org.spf4j.recyclable.LeaseSupplier -->
  <!-- start interface org.spf4j.recyclable.ObjectBorower -->
  <interface name="ObjectBorower"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Scanable"/>
    <method name="tryRequestReturnObject" return="org.spf4j.base.Either"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Non Blocking method.

 @return null if request was not made, the object if available, or REQUEST_MADE if request could be made to return
 Object.]]>
      </doc>
    </method>
    <method name="tryReturnObjectIfNotInUse" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Non Blocking method.

 @return null or the object if available.
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="tryReturnObjectsIfNotInUse" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Return all objects that are not currently in use.]]>
      </doc>
    </method>
    <method name="tryReturnObjectsIfNotNeededAnymore" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[This method is a cleanup method. The purpose is to recover all borrowed objects before once this borrower will
 never use them anymore...

 @return all objects borrowed]]>
      </doc>
    </method>
    <method name="nevermind" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Notify borower that object has been received back from another borrower.
 return true is indeed object was from here, false otherwise.
 @param object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.ObjectBorower -->
  <!-- start class org.spf4j.recyclable.ObjectBorower.Action -->
  <class name="ObjectBorower.Action" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.recyclable.ObjectBorower.Action[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.recyclable.ObjectBorower.Action"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="REQUEST_MADE" type="org.spf4j.recyclable.ObjectBorower.Action"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NONE" type="org.spf4j.recyclable.ObjectBorower.Action"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectBorower.Action -->
  <!-- start class org.spf4j.recyclable.ObjectBorrowException -->
  <class name="ObjectBorrowException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectBorrowException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectBorrowException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectBorrowException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectBorrowException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectBorrowException -->
  <!-- start class org.spf4j.recyclable.ObjectCreationException -->
  <class name="ObjectCreationException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectCreationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectCreationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectCreationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectCreationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectCreationException -->
  <!-- start class org.spf4j.recyclable.ObjectDisposeException -->
  <class name="ObjectDisposeException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectDisposeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectDisposeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectDisposeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectDisposeException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectDisposeException -->
  <!-- start class org.spf4j.recyclable.ObjectReturnException -->
  <class name="ObjectReturnException" extends="org.spf4j.recyclable.SupplierException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ObjectReturnException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectReturnException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectReturnException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectReturnException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.ObjectReturnException -->
  <!-- start class org.spf4j.recyclable.RecyclerFactory -->
  <class name="RecyclerFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="toLeaseSupplier" return="org.spf4j.recyclable.LeaseSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rs" type="org.spf4j.recyclable.RecyclingSupplier"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.RecyclerFactory -->
  <!-- start interface org.spf4j.recyclable.RecyclingSupplier -->
  <interface name="RecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Disposable"/>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <exception name="ObjectBorrowException" type="org.spf4j.recyclable.ObjectBorrowException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[block until a object is available and return it.

 @return - a object instance returned by this supplier.
 @throws ObjectCreationException - cannot create an object.
 @throws ObjectBorrowException - cannot borrow an object.
 @throws InterruptedException - interrupted.
 @throws TimeoutException - timed out while getting object.]]>
      </doc>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
      <doc>
      <![CDATA[return a object previously borrowed from the pool,
 together with a optional exception in case one was encountered
 while using the object. passing an exception will cause the object
 to be validated and potentially retired from the pool.

 @param object - object to recycle.
 @param e - exception encountered while handling the object. this is useful for the recycle to validate/retire
 object]]>
      </doc>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[recycle object.
 @param object - object to recycle.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Object pool interface.

 My goal is to create a simpler and better object pool interface and implementation.


 @author zoly
 @param <T> - type of recycled objects]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.RecyclingSupplier -->
  <!-- start interface org.spf4j.recyclable.RecyclingSupplier.Factory -->
  <interface name="RecyclingSupplier.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <doc>
      <![CDATA[create the object.

 @return - the created object.
 @throws ObjectCreationException - cannot create object.]]>
      </doc>
    </method>
    <method name="dispose"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <exception name="ObjectDisposeException" type="org.spf4j.recyclable.ObjectDisposeException"/>
      <doc>
      <![CDATA[Dispose the object.

 @param object - object to dispose.
 @throws ObjectDisposeException - cannot dispose object.]]>
      </doc>
    </method>
    <method name="validate" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="e" type="java.lang.Exception"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Validate the object, return true if valid,
 false of throw an Exception with validation detail otherwise.
 in case of throwing an exception the object is considered invalid.
 @param object - object to validate.
 @param e - exception previously encountered while handling the object.
 @return  - true is object is still valid, false otherwise.
 @throws java.lang.Exception - something happened during validation.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.recyclable.RecyclingSupplier.Factory -->
  <!-- start interface org.spf4j.recyclable.Scanable -->
  <interface name="Scanable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scan" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.recyclable.Scanable.ScanHandler"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Scan through  objects and call handler...
 if handler throws exception scan is not aborted.
 scan is aborted only if handler returns false.
 @param handler - the handler to handle the scanned objects.
 @return - false if scanning is stopped by the handler, true otherwise.
 @throws Exception - whatever exception is thrown during scanning.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly
 @param <T> - type of the objects to scan.]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.Scanable -->
  <!-- start interface org.spf4j.recyclable.Scanable.ScanHandler -->
  <interface name="Scanable.ScanHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[method to handle object
 @param object - the scanned object.
 @return true if scan operation is to continue, false otherwise.
 @throws java.lang.Exception - whatever exception this handler needs to throw.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.spf4j.recyclable.Scanable.ScanHandler -->
  <!-- start interface org.spf4j.recyclable.SizedLeaseSupplier -->
  <interface name="SizedLeaseSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="lease" return="org.spf4j.recyclable.Lease"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.SizedLeaseSupplier -->
  <!-- start interface org.spf4j.recyclable.SizedRecyclingSupplier -->
  <interface name="SizedRecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.SizedRecyclingSupplier -->
  <!-- start interface org.spf4j.recyclable.SizedRecyclingSupplier.Factory -->
  <interface name="SizedRecyclingSupplier.Factory"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
    </method>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.recyclable.SizedRecyclingSupplier.Factory -->
  <!-- start interface org.spf4j.recyclable.SmartRecyclingSupplier -->
  <interface name="SmartRecyclingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.recyclable.Disposable"/>
    <implements name="org.spf4j.recyclable.Scanable"/>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <exception name="ObjectCreationException" type="org.spf4j.recyclable.ObjectCreationException"/>
      <doc>
      <![CDATA[Borrow object from pool.
 @param borower
 @return
 @throws InterruptedException
 @throws TimeoutException
 @throws ObjectCreationException]]>
      </doc>
    </method>
    <method name="recycle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <param name="borower" type="org.spf4j.recyclable.ObjectBorower"/>
      <doc>
      <![CDATA[Return object to pool.
 @param object
 @param borower]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.SmartRecyclingSupplier -->
  <!-- start class org.spf4j.recyclable.SupplierException -->
  <class name="SupplierException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SupplierException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SupplierException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SupplierException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SupplierException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.recyclable.SupplierException -->
  <!-- start class org.spf4j.recyclable.Template -->
  <class name="Template" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Template" type="org.spf4j.recyclable.RecyclingSupplier, int, int, int, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doOnSupplied"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="doOnSupplied"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="handler" type="org.spf4j.base.Handler"/>
      <param name="pool" type="org.spf4j.recyclable.RecyclingSupplier"/>
      <param name="nrImmediateRetries" type="int"/>
      <param name="retryWaitMillis" type="int"/>
      <param name="timeoutMillis" type="int"/>
      <param name="exClass" type="java.lang.Class"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.recyclable.Template -->
  <!-- start interface org.spf4j.recyclable.UsageProvider -->
  <interface name="UsageProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUsage" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.recyclable.UsageProvider -->
</package>
<package name="org.spf4j.tsdb2.avro">
  <!-- start class org.spf4j.tsdb2.avro.ColumnDef -->
  <class name="ColumnDef" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="ColumnDef"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="ColumnDef" type="java.lang.String, org.spf4j.tsdb2.avro.Type, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param name column name
 @param type column value type
 @param unitOfMeasurement unit of measurement for the data
 @param description Column description]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.
 @return column name]]>
      </doc>
    </method>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field.
 column name
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getType" return="org.spf4j.tsdb2.avro.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'type' field.
 @return column value type]]>
      </doc>
    </method>
    <method name="setType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.tsdb2.avro.Type"/>
      <doc>
      <![CDATA[Sets the value of the 'type' field.
 column value type
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'unitOfMeasurement' field.
 @return unit of measurement for the data]]>
      </doc>
    </method>
    <method name="setUnitOfMeasurement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'unitOfMeasurement' field.
 unit of measurement for the data
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'description' field.
 @return Column description]]>
      </doc>
    </method>
    <method name="setDescription"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'description' field.
 Column description
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new ColumnDef RecordBuilder.
 @return A new ColumnDef RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.ColumnDef.Builder"/>
      <doc>
      <![CDATA[Creates a new ColumnDef RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new ColumnDef RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.ColumnDef"/>
      <doc>
      <![CDATA[Creates a new ColumnDef RecordBuilder by copying an existing ColumnDef instance.
 @param other The existing instance to copy.
 @return A new ColumnDef RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[column name]]>
      </doc>
    </field>
    <field name="type" type="org.spf4j.tsdb2.avro.Type"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[column value type]]>
      </doc>
    </field>
    <field name="unitOfMeasurement" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[unit of measurement for the data]]>
      </doc>
    </field>
    <field name="description" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Column description]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.ColumnDef -->
  <!-- start class org.spf4j.tsdb2.avro.ColumnDef.Builder -->
  <class name="ColumnDef.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.
 column name
 @return The value.]]>
      </doc>
    </method>
    <method name="setName" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field.
 column name
 @param value The value of 'name'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'name' field has been set.
 column name
 @return True if the 'name' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearName" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'name' field.
 column name
 @return This builder.]]>
      </doc>
    </method>
    <method name="getType" return="org.spf4j.tsdb2.avro.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'type' field.
 column value type
 @return The value.]]>
      </doc>
    </method>
    <method name="setType" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.spf4j.tsdb2.avro.Type"/>
      <doc>
      <![CDATA[Sets the value of the 'type' field.
 column value type
 @param value The value of 'type'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'type' field has been set.
 column value type
 @return True if the 'type' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearType" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'type' field.
 column value type
 @return This builder.]]>
      </doc>
    </method>
    <method name="getUnitOfMeasurement" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'unitOfMeasurement' field.
 unit of measurement for the data
 @return The value.]]>
      </doc>
    </method>
    <method name="setUnitOfMeasurement" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'unitOfMeasurement' field.
 unit of measurement for the data
 @param value The value of 'unitOfMeasurement'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasUnitOfMeasurement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'unitOfMeasurement' field has been set.
 unit of measurement for the data
 @return True if the 'unitOfMeasurement' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearUnitOfMeasurement" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'unitOfMeasurement' field.
 unit of measurement for the data
 @return This builder.]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'description' field.
 Column description
 @return The value.]]>
      </doc>
    </method>
    <method name="setDescription" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'description' field.
 Column description
 @param value The value of 'description'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasDescription" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'description' field has been set.
 Column description
 @return True if the 'description' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearDescription" return="org.spf4j.tsdb2.avro.ColumnDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'description' field.
 Column description
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.tsdb2.avro.ColumnDef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for ColumnDef instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.ColumnDef.Builder -->
  <!-- start class org.spf4j.tsdb2.avro.DataBlock -->
  <class name="DataBlock" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="DataBlock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="DataBlock" type="java.lang.Long, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param baseTimestamp the UTC timestamp that all timestamps in this block are relative to
 @param values rows]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getBaseTimestamp" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'baseTimestamp' field.
 @return the UTC timestamp that all timestamps in this block are relative to]]>
      </doc>
    </method>
    <method name="setBaseTimestamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Long"/>
      <doc>
      <![CDATA[Sets the value of the 'baseTimestamp' field.
 the UTC timestamp that all timestamps in this block are relative to
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getValues" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'values' field.
 @return rows]]>
      </doc>
    </method>
    <method name="setValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'values' field.
 rows
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new DataBlock RecordBuilder.
 @return A new DataBlock RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.DataBlock.Builder"/>
      <doc>
      <![CDATA[Creates a new DataBlock RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new DataBlock RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.DataBlock"/>
      <doc>
      <![CDATA[Creates a new DataBlock RecordBuilder by copying an existing DataBlock instance.
 @param other The existing instance to copy.
 @return A new DataBlock RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="baseTimestamp" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the UTC timestamp that all timestamps in this block are relative to]]>
      </doc>
    </field>
    <field name="values" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[rows]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.DataBlock -->
  <!-- start class org.spf4j.tsdb2.avro.DataBlock.Builder -->
  <class name="DataBlock.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getBaseTimestamp" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'baseTimestamp' field.
 the UTC timestamp that all timestamps in this block are relative to
 @return The value.]]>
      </doc>
    </method>
    <method name="setBaseTimestamp" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'baseTimestamp' field.
 the UTC timestamp that all timestamps in this block are relative to
 @param value The value of 'baseTimestamp'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasBaseTimestamp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'baseTimestamp' field has been set.
 the UTC timestamp that all timestamps in this block are relative to
 @return True if the 'baseTimestamp' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearBaseTimestamp" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'baseTimestamp' field.
 the UTC timestamp that all timestamps in this block are relative to
 @return This builder.]]>
      </doc>
    </method>
    <method name="getValues" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'values' field.
 rows
 @return The value.]]>
      </doc>
    </method>
    <method name="setValues" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'values' field.
 rows
 @param value The value of 'values'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasValues" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'values' field has been set.
 rows
 @return True if the 'values' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearValues" return="org.spf4j.tsdb2.avro.DataBlock.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'values' field.
 rows
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.tsdb2.avro.DataBlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for DataBlock instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.DataBlock.Builder -->
  <!-- start class org.spf4j.tsdb2.avro.DataRow -->
  <class name="DataRow" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="DataRow"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="DataRow" type="java.lang.Integer, java.lang.Long, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param relTimeStamp row relative timestamp
 @param tableDefId the file pointer where the Table definition for the data is
 @param data the row data]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getRelTimeStamp" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'relTimeStamp' field.
 @return row relative timestamp]]>
      </doc>
    </method>
    <method name="setRelTimeStamp"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'relTimeStamp' field.
 row relative timestamp
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getTableDefId" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'tableDefId' field.
 @return the file pointer where the Table definition for the data is]]>
      </doc>
    </method>
    <method name="setTableDefId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Long"/>
      <doc>
      <![CDATA[Sets the value of the 'tableDefId' field.
 the file pointer where the Table definition for the data is
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getData" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'data' field.
 @return the row data]]>
      </doc>
    </method>
    <method name="setData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'data' field.
 the row data
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new DataRow RecordBuilder.
 @return A new DataRow RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.DataRow.Builder"/>
      <doc>
      <![CDATA[Creates a new DataRow RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new DataRow RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.DataRow"/>
      <doc>
      <![CDATA[Creates a new DataRow RecordBuilder by copying an existing DataRow instance.
 @param other The existing instance to copy.
 @return A new DataRow RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="relTimeStamp" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[row relative timestamp]]>
      </doc>
    </field>
    <field name="tableDefId" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the file pointer where the Table definition for the data is]]>
      </doc>
    </field>
    <field name="data" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the row data]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.DataRow -->
  <!-- start class org.spf4j.tsdb2.avro.DataRow.Builder -->
  <class name="DataRow.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getRelTimeStamp" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'relTimeStamp' field.
 row relative timestamp
 @return The value.]]>
      </doc>
    </method>
    <method name="setRelTimeStamp" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'relTimeStamp' field.
 row relative timestamp
 @param value The value of 'relTimeStamp'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasRelTimeStamp" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'relTimeStamp' field has been set.
 row relative timestamp
 @return True if the 'relTimeStamp' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearRelTimeStamp" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'relTimeStamp' field.
 row relative timestamp
 @return This builder.]]>
      </doc>
    </method>
    <method name="getTableDefId" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'tableDefId' field.
 the file pointer where the Table definition for the data is
 @return The value.]]>
      </doc>
    </method>
    <method name="setTableDefId" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'tableDefId' field.
 the file pointer where the Table definition for the data is
 @param value The value of 'tableDefId'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasTableDefId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'tableDefId' field has been set.
 the file pointer where the Table definition for the data is
 @return True if the 'tableDefId' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearTableDefId" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'tableDefId' field.
 the file pointer where the Table definition for the data is
 @return This builder.]]>
      </doc>
    </method>
    <method name="getData" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'data' field.
 the row data
 @return The value.]]>
      </doc>
    </method>
    <method name="setData" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'data' field.
 the row data
 @param value The value of 'data'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasData" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'data' field has been set.
 the row data
 @return True if the 'data' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearData" return="org.spf4j.tsdb2.avro.DataRow.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'data' field.
 the row data
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.tsdb2.avro.DataRow"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for DataRow instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.DataRow.Builder -->
  <!-- start class org.spf4j.tsdb2.avro.Header -->
  <class name="Header" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="Header"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="Header" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param contentSchema file content schema
 @param description file description]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getContentSchema" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'contentSchema' field.
 @return file content schema]]>
      </doc>
    </method>
    <method name="setContentSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'contentSchema' field.
 file content schema
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'description' field.
 @return file description]]>
      </doc>
    </method>
    <method name="setDescription"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'description' field.
 file description
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new Header RecordBuilder.
 @return A new Header RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.Header.Builder"/>
      <doc>
      <![CDATA[Creates a new Header RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new Header RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.Header"/>
      <doc>
      <![CDATA[Creates a new Header RecordBuilder by copying an existing Header instance.
 @param other The existing instance to copy.
 @return A new Header RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="contentSchema" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[file content schema]]>
      </doc>
    </field>
    <field name="description" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[file description]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.Header -->
  <!-- start class org.spf4j.tsdb2.avro.Header.Builder -->
  <class name="Header.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getContentSchema" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'contentSchema' field.
 file content schema
 @return The value.]]>
      </doc>
    </method>
    <method name="setContentSchema" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'contentSchema' field.
 file content schema
 @param value The value of 'contentSchema'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasContentSchema" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'contentSchema' field has been set.
 file content schema
 @return True if the 'contentSchema' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearContentSchema" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'contentSchema' field.
 file content schema
 @return This builder.]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'description' field.
 file description
 @return The value.]]>
      </doc>
    </method>
    <method name="setDescription" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'description' field.
 file description
 @param value The value of 'description'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasDescription" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'description' field has been set.
 file description
 @return True if the 'description' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearDescription" return="org.spf4j.tsdb2.avro.Header.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'description' field.
 file description
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.tsdb2.avro.Header"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for Header instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.Header.Builder -->
  <!-- start class org.spf4j.tsdb2.avro.TableDef -->
  <class name="TableDef" extends="org.apache.avro.specific.SpecificRecordBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.specific.SpecificRecord"/>
    <constructor name="TableDef"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.  Note that this does not initialize fields
 to their default values from the schema.  If that is desired then
 one should use <code>newBuilder()</code>.]]>
      </doc>
    </constructor>
    <constructor name="TableDef" type="java.lang.Long, java.lang.String, java.lang.String, java.util.List, java.lang.Integer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All-args constructor.
 @param id def id
 @param name table name
 @param description table description
 @param columns column definitions
 @param sampleTime the interval]]>
      </doc>
    </constructor>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field$" type="int"/>
      <param name="value$" type="java.lang.Object"/>
    </method>
    <method name="getId" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'id' field.
 @return def id]]>
      </doc>
    </method>
    <method name="setId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Long"/>
      <doc>
      <![CDATA[Sets the value of the 'id' field.
 def id
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.
 @return table name]]>
      </doc>
    </method>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field.
 table name
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'description' field.
 @return table description]]>
      </doc>
    </method>
    <method name="setDescription"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'description' field.
 table description
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getColumns" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'columns' field.
 @return column definitions]]>
      </doc>
    </method>
    <method name="setColumns"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'columns' field.
 column definitions
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="getSampleTime" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'sampleTime' field.
 @return the interval]]>
      </doc>
    </method>
    <method name="setSampleTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Sets the value of the 'sampleTime' field.
 the interval
 @param value the value to set.]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new TableDef RecordBuilder.
 @return A new TableDef RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.TableDef.Builder"/>
      <doc>
      <![CDATA[Creates a new TableDef RecordBuilder by copying an existing Builder.
 @param other The existing builder to copy.
 @return A new TableDef RecordBuilder]]>
      </doc>
    </method>
    <method name="newBuilder" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.spf4j.tsdb2.avro.TableDef"/>
      <doc>
      <![CDATA[Creates a new TableDef RecordBuilder by copying an existing TableDef instance.
 @param other The existing instance to copy.
 @return A new TableDef RecordBuilder]]>
      </doc>
    </method>
    <method name="writeExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.ObjectOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readExternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.ObjectInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="id" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[def id]]>
      </doc>
    </field>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[table name]]>
      </doc>
    </field>
    <field name="description" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[table description]]>
      </doc>
    </field>
    <field name="columns" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[column definitions]]>
      </doc>
    </field>
    <field name="sampleTime" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[the interval]]>
      </doc>
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.TableDef -->
  <!-- start class org.spf4j.tsdb2.avro.TableDef.Builder -->
  <class name="TableDef.Builder" extends="org.apache.avro.specific.SpecificRecordBuilderBase"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.avro.data.RecordBuilder"/>
    <method name="getId" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'id' field.
 def id
 @return The value.]]>
      </doc>
    </method>
    <method name="setId" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Sets the value of the 'id' field.
 def id
 @param value The value of 'id'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasId" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'id' field has been set.
 def id
 @return True if the 'id' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearId" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'id' field.
 def id
 @return This builder.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'name' field.
 table name
 @return The value.]]>
      </doc>
    </method>
    <method name="setName" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'name' field.
 table name
 @param value The value of 'name'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'name' field has been set.
 table name
 @return True if the 'name' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearName" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'name' field.
 table name
 @return This builder.]]>
      </doc>
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'description' field.
 table description
 @return The value.]]>
      </doc>
    </method>
    <method name="setDescription" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the value of the 'description' field.
 table description
 @param value The value of 'description'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasDescription" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'description' field has been set.
 table description
 @return True if the 'description' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearDescription" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'description' field.
 table description
 @return This builder.]]>
      </doc>
    </method>
    <method name="getColumns" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'columns' field.
 column definitions
 @return The value.]]>
      </doc>
    </method>
    <method name="setColumns" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.List"/>
      <doc>
      <![CDATA[Sets the value of the 'columns' field.
 column definitions
 @param value The value of 'columns'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasColumns" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'columns' field has been set.
 column definitions
 @return True if the 'columns' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearColumns" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'columns' field.
 column definitions
 @return This builder.]]>
      </doc>
    </method>
    <method name="getSampleTime" return="java.lang.Integer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the value of the 'sampleTime' field.
 the interval
 @return The value.]]>
      </doc>
    </method>
    <method name="setSampleTime" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Sets the value of the 'sampleTime' field.
 the interval
 @param value The value of 'sampleTime'.
 @return This builder.]]>
      </doc>
    </method>
    <method name="hasSampleTime" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks whether the 'sampleTime' field has been set.
 the interval
 @return True if the 'sampleTime' field has been set, false otherwise.]]>
      </doc>
    </method>
    <method name="clearSampleTime" return="org.spf4j.tsdb2.avro.TableDef.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears the value of the 'sampleTime' field.
 the interval
 @return This builder.]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.tsdb2.avro.TableDef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[RecordBuilder for TableDef instances.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.TableDef.Builder -->
  <!-- start interface org.spf4j.tsdb2.avro.Tsdb2 -->
  <interface name="Tsdb2"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="PROTOCOL" type="org.apache.avro.Protocol"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.tsdb2.avro.Tsdb2 -->
  <!-- start interface org.spf4j.tsdb2.avro.Tsdb2.Callback -->
  <interface name="Tsdb2.Callback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.tsdb2.avro.Tsdb2"/>
    <field name="PROTOCOL" type="org.apache.avro.Protocol"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.spf4j.tsdb2.avro.Tsdb2.Callback -->
  <!-- start class org.spf4j.tsdb2.avro.Type -->
  <class name="Type" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.tsdb2.avro.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.tsdb2.avro.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getClassSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="LONG" type="org.spf4j.tsdb2.avro.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE" type="org.spf4j.tsdb2.avro.Type"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SCHEMA$" type="org.apache.avro.Schema"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.tsdb2.avro.Type -->
</package>
<package name="org.spf4j.io.tcp.proxy">
  <!-- start class org.spf4j.io.tcp.proxy.ProxyBufferTransferHandler -->
  <class name="ProxyBufferTransferHandler" extends="org.spf4j.io.tcp.SelectorEventHandler"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProxyBufferTransferHandler" type="org.spf4j.io.tcp.proxy.TransferBuffer, org.spf4j.io.tcp.proxy.TransferBuffer, org.spf4j.io.tcp.proxy.SnifferFactory, java.nio.channels.SocketChannel, java.nio.channels.Selector, java.util.concurrent.ExecutorService, java.util.concurrent.BlockingQueue, org.spf4j.ds.UpdateablePriorityQueue.ElementRef"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialInterestRegistration" return="java.nio.channels.SelectionKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
    </method>
    <method name="canRunAsync" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="runAsync"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sKey" type="java.nio.channels.SelectionKey"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="skey" type="java.nio.channels.SelectionKey"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.ProxyBufferTransferHandler -->
  <!-- start class org.spf4j.io.tcp.proxy.ProxyClientHandler -->
  <class name="ProxyClientHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.io.tcp.ClientHandler"/>
    <constructor name="ProxyClientHandler" type="com.google.common.net.HostAndPort, org.spf4j.io.tcp.proxy.SnifferFactory, org.spf4j.io.tcp.proxy.SnifferFactory, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[TCP proxy client handler.
 @param fwdDestination - the destination all connections will be forwarded to.
 @param c2sSnifferFact - create sniffer to be invoked when data is received from client.
 @param s2cSnifferFact - create sniffer to be invoked when data is received from server.
 @param proxyBufferSize - the transmission buffer sizes.
 @param connectTimeoutMillis - The connection timeout.]]>
      </doc>
    </constructor>
    <method name="handle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverSelector" type="java.nio.channels.Selector"/>
      <param name="clientChannel" type="java.nio.channels.SocketChannel"/>
      <param name="exec" type="java.util.concurrent.ExecutorService"/>
      <param name="tasksToRunBySelector" type="java.util.concurrent.BlockingQueue"/>
      <param name="deadlineActions" type="org.spf4j.ds.UpdateablePriorityQueue"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.ProxyClientHandler -->
  <!-- start interface org.spf4j.io.tcp.proxy.Sniffer -->
  <interface name="Sniffer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="received" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="java.nio.ByteBuffer"/>
      <param name="nrBytes" type="int"/>
      <doc>
      <![CDATA[Invoked on data receive/transmission.
 @param data - the byte buffer containing the data.
 @param nrBytes - number of bytes in the buffer. The data in the buffer is from position-nrBytes to position.
 nrBytes will be -1 on EOF.
 @return new nrReadValue if we aim to mutate buffer, returning -1 will simulate a EOF.]]>
      </doc>
    </method>
    <method name="received" return="java.io.IOException"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ex" type="java.io.IOException"/>
      <doc>
      <![CDATA[Allows to intercept read errors and change/suppress them.
 @param ex
 @return A exception you want to propagate, or null in case we do not want to propagate exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.tcp.proxy.Sniffer -->
  <!-- start interface org.spf4j.io.tcp.proxy.SnifferFactory -->
  <interface name="SnifferFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.spf4j.io.tcp.proxy.Sniffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.SocketChannel"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.io.tcp.proxy.SnifferFactory -->
  <!-- start class org.spf4j.io.tcp.proxy.TransferBuffer -->
  <class name="TransferBuffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TransferBuffer" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.SocketChannel"/>
    </method>
    <method name="write" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.SocketChannel"/>
    </method>
    <method name="transfer" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.nio.channels.SocketChannel"/>
      <param name="out" type="java.nio.channels.SocketChannel"/>
      <param name="buffer" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setIsDataInBufferHook"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isDataInBufferHook" type="java.lang.Runnable"/>
    </method>
    <method name="setIsRoomInBufferHook"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isRoomInBufferHook" type="java.lang.Runnable"/>
    </method>
    <method name="setIncomingSniffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="incomingSniffer" type="org.spf4j.io.tcp.proxy.Sniffer"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.TransferBuffer -->
  <!-- start class org.spf4j.io.tcp.proxy.TransferBuffer.Operation -->
  <class name="TransferBuffer.Operation" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.io.tcp.proxy.TransferBuffer.Operation[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.io.tcp.proxy.TransferBuffer.Operation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="READ" type="org.spf4j.io.tcp.proxy.TransferBuffer.Operation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WRITE" type="org.spf4j.io.tcp.proxy.TransferBuffer.Operation"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.io.tcp.proxy.TransferBuffer.Operation -->
</package>
<package name="org.spf4j.perf.impl.ms.tsdb">
  <!-- start class org.spf4j.perf.impl.ms.tsdb.TSDBMeasurementStore -->
  <class name="TSDBMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="TSDBMeasurementStore" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTables" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTableAsCsv" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDBWriter" return="org.spf4j.tsdb2.TSDBWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.TSDBMeasurementStore -->
  <!-- start class org.spf4j.perf.impl.ms.tsdb.TSDBTxtMeasurementStore -->
  <class name="TSDBTxtMeasurementStore" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementStore"/>
    <constructor name="TSDBTxtMeasurementStore" type="java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="alocateMeasurements" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
    </method>
    <method name="saveMeasurements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[File based store implementation.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.impl.ms.tsdb.TSDBTxtMeasurementStore -->
</package>
<package name="org.spf4j.io.compress">
  <!-- start class org.spf4j.io.compress.Compress -->
  <class name="Compress" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="zip" return="java.nio.file.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileOrFolderToCompress" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Zip a file or folder.
 @param fileOrFolderToCompress file or folder to compress.
 @return the Path of the compressed file. It will created in the same folder as the input parent.
 @throws IOException]]>
      </doc>
    </method>
    <method name="zip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileOrFolderToCompress" type="java.nio.file.Path"/>
      <param name="destFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Zip a file or folder.
 @param fileOrFolderToCompress file or folder to compress.
 @param destFile the destination zip file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="copyFileAtomic"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.nio.file.Path"/>
      <param name="destinationFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy file atomic.
 file will be written to a tmp file in the destination folder, and atomically renamed (if file system supports)
 @param source
 @param destinationFile
 @throws IOException]]>
      </doc>
    </method>
    <method name="unzip" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unzip a zip archive to same folder.
 @param zipFile
 @return list of unzipped files.
 @throws IOException]]>
      </doc>
    </method>
    <method name="unzip" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zipFile" type="java.nio.file.Path"/>
      <param name="destinationDirectory" type="java.nio.file.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unzip a zip file to a destination folder.
 @param zipFile
 @param destinationDirectory
 @return the list of files that were extracted.
 @throws IOException in case extraction fails for whatever reason.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.io.compress.Compress -->
</package>
<package name="org.spf4j.text">
  <!-- start class org.spf4j.text.AttributedString -->
  <class name="AttributedString" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AttributedString" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the given text.
 @param text The text for this attributed string.
 @exception NullPointerException if <code>text</code> is null.]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.lang.String, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the given text and attributes.
 @param text The text for this attributed string.
 @param attributes The attributes that apply to the entire string.
 @exception NullPointerException if <code>text</code> or
            <code>attributes</code> is null.
 @exception IllegalArgumentException if the text has length 0
 and the attributes parameter is not an empty Map (attributes
 cannot be applied to a 0-length range).]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.text.AttributedCharacterIterator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the given attributed
 text represented by AttributedCharacterIterator.
 @param text The text for this attributed string.
 @exception NullPointerException if <code>text</code> is null.]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.text.AttributedCharacterIterator, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the subrange of
 the given attributed text represented by
 AttributedCharacterIterator. If the given range produces an
 empty text, all attributes will be discarded.  Note that any
 attributes wrapped by an Annotation object are discarded for a
 subrange of the original attribute range.

 @param text The text for this attributed string.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last character
 of the range.
 @exception NullPointerException if <code>text</code> is null.
 @exception IllegalArgumentException if the subrange given by
 beginIndex and endIndex is out of the text range.
 @see java.text.Annotation]]>
      </doc>
    </constructor>
    <constructor name="AttributedString" type="java.text.AttributedCharacterIterator, int, int, java.text.AttributedCharacterIterator.Attribute[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an AttributedString instance with the subrange of
 the given attributed text represented by
 AttributedCharacterIterator.  Only attributes that match the
 given attributes will be incorporated into the instance. If the
 given range produces an empty text, all attributes will be
 discarded. Note that any attributes wrapped by an Annotation
 object are discarded for a subrange of the original attribute
 range.

 @param text The text for this attributed string.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last character
 of the range.
 @param attributes Specifies attributes to be extracted
 from the text. If null is specified, all available attributes will
 be used.
 @exception NullPointerException if <code>text</code> is null.
 @exception IllegalArgumentException if the subrange given by
 beginIndex and endIndex is out of the text range.
 @see java.text.Annotation]]>
      </doc>
    </constructor>
    <method name="addAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.text.AttributedCharacterIterator.Attribute"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds an attribute to the entire string.
 @param attribute the attribute key
 @param value the value of the attribute; may be null
 @exception NullPointerException if <code>attribute</code> is null.
 @exception IllegalArgumentException if the AttributedString has length 0
 (attributes cannot be applied to a 0-length range).]]>
      </doc>
    </method>
    <method name="addAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="java.text.AttributedCharacterIterator.Attribute"/>
      <param name="value" type="java.lang.Object"/>
      <param name="beginIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Adds an attribute to a subrange of the string.
 @param attribute the attribute key
 @param value The value of the attribute. May be null.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last character of the range.
 @exception NullPointerException if <code>attribute</code> is null.
 @exception IllegalArgumentException if beginIndex is less then 0, endIndex is
 greater than the length of the string, or beginIndex and endIndex together don't
 define a non-empty subrange of the string.]]>
      </doc>
    </method>
    <method name="addAttributes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributes" type="java.util.Map"/>
      <param name="beginIndex" type="int"/>
      <param name="endIndex" type="int"/>
      <doc>
      <![CDATA[Adds a set of attributes to a subrange of the string.
 @param attributes The attributes to be added to the string.
 @param beginIndex Index of the first character of the range.
 @param endIndex Index of the character following the last
 character of the range.
 @exception NullPointerException if <code>attributes</code> is null.
 @exception IllegalArgumentException if beginIndex is less then
 0, endIndex is greater than the length of the string, or
 beginIndex and endIndex together don't define a non-empty
 subrange of the string and the attributes parameter is not an
 empty Map.]]>
      </doc>
    </method>
    <method name="getIterator" return="java.text.AttributedCharacterIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an AttributedCharacterIterator instance that provides access to the entire contents of
 this string.

 @return An iterator providing access to the text and its attributes.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An AttributedString holds text and related attribute information. It
 may be used as the actual data storage in some cases where a text
 reader wants to access attributed text through the AttributedCharacterIterator
 interface.

 <p>
 An attribute is a key/value pair, identified by the key.  No two
 attributes on a given character can have the same key.

 <p>The values for an attribute are immutable, or must not be mutated
 by clients or storage.  They are always passed by reference, and not
 cloned.

 @see AttributedCharacterIterator
 @see Annotation
 @since 1.2]]>
    </doc>
  </class>
  <!-- end class org.spf4j.text.AttributedString -->
  <!-- start class org.spf4j.text.MessageFormat -->
  <class name="MessageFormat" extends="java.text.Format"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="MessageFormat" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a FastMessageFormat for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
 specified pattern. The constructor first sets the locale, then parses the pattern and creates a list of subformats
 for the format elements contained in it. Patterns and their interpretation are specified in the
 <a href="#patterns">class description</a>.

 @param pattern the pattern for this message format
 @exception IllegalArgumentException if the pattern is invalid]]>
      </doc>
    </constructor>
    <constructor name="MessageFormat" type="java.lang.String, java.util.Locale"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a FastMessageFormat for the specified locale and pattern. The constructor first sets the locale, then
 parses the pattern and creates a list of sub-formats for the format elements contained in it. Patterns and their
 interpretation are specified in the
 <a href="#patterns">class description</a>.

 @param pattern the pattern for this message format
 @param locale the locale for this message format
 @exception IllegalArgumentException if the pattern is invalid
 @since 1.4]]>
      </doc>
    </constructor>
    <method name="setLocale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="locale" type="java.util.Locale"/>
      <doc>
      <![CDATA[Sets the locale to be used when creating or comparing subformats. This affects subsequent calls
 <ul>
 <li>to the {@link #applyPattern applyPattern} and {@link #toPattern toPattern} methods if format elements specify a
 format type and therefore have the subformats created in the <code>applyPattern</code> method, as well as
 <li>to the <code>format</code> and {@link #formatToCharacterIterator formatToCharacterIterator} methods if format
 elements do not specify a format type and therefore have the subformats created in the formatting methods.
 </ul>
 Subformats that have already been created are not affected.

 @param locale the locale to be used when creating or comparing subformats]]>
      </doc>
    </method>
    <method name="getLocale" return="java.util.Locale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the locale that's used when creating or comparing subformats.

 @return the locale used when creating or comparing subformats]]>
      </doc>
    </method>
    <method name="applyPattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the pattern used by this message format. The method parses the pattern and creates a list of subformats for
 the format elements contained in it. Patterns and their interpretation are specified in the
 <a href="#patterns">class description</a>.

 @param pattern the pattern for this message format
 @exception IllegalArgumentException if the pattern is invalid]]>
      </doc>
    </method>
    <method name="toPattern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a pattern representing the current state of the message format. The string is constructed from internal
 information and therefore does not necessarily equal the previously applied pattern.

 @return a pattern representing the current state of the message format]]>
      </doc>
    </method>
    <method name="setFormatsByArgumentIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newFormats" type="java.text.Format[]"/>
      <doc>
      <![CDATA[Sets the formats to use for the values passed into <code>format</code> methods or returned from <code>parse</code>
 methods. The indices of elements in <code>newFormats</code> correspond to the argument indices used in the
 previously set pattern string. The order of formats in <code>newFormats</code> thus corresponds to the order of
 elements in the <code>arguments</code> array passed to the <code>format</code> methods or the result array returned
 by the <code>parse</code> methods.
 <p>
 If an argument index is used for more than one format element in the pattern string, then the corresponding new
 format is used for all such format elements. If an argument index is not used for any format element in the pattern
 string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the
 formats for argument indices less than <code>newFormats.length</code> are replaced.

 @param newFormats the new formats to use
 @exception NullPointerException if <code>newFormats</code> is null
 @since 1.4]]>
      </doc>
    </method>
    <method name="setFormats"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newFormats" type="java.text.Format[]"/>
      <doc>
      <![CDATA[Sets the formats to use for the format elements in the previously set pattern string. The order of formats in
 <code>newFormats</code> corresponds to the order of format elements in the pattern string.
 <p>
 If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats
 are provided than needed, then only the first <code>newFormats.length</code> formats are replaced.
 <p>
 Since the order of format elements in a pattern string often changes during localization, it is generally better to
 use the {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex} method, which assumes an order of formats
 corresponding to the order of elements in the <code>arguments</code> array passed to the <code>format</code>
 methods or the result array returned by the <code>parse</code> methods.

 @param newFormats the new formats to use
 @exception NullPointerException if <code>newFormats</code> is null]]>
      </doc>
    </method>
    <method name="setFormatByArgumentIndex"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argumentIndex" type="int"/>
      <param name="newFormat" type="java.text.Format"/>
      <doc>
      <![CDATA[Sets the format to use for the format elements within the previously set pattern string that use the given argument
 index. The argument index is part of the format element definition and represents an index into the
 <code>arguments</code> array passed to the <code>format</code> methods or the result array returned by the
 <code>parse</code> methods.
 <p>
 If the argument index is used for more than one format element in the pattern string, then the new format is used
 for all such format elements. If the argument index is not used for any format element in the pattern string, then
 the new format is ignored.

 @param argumentIndex the argument index for which to use the new format
 @param newFormat the new format to use
 @since 1.4]]>
      </doc>
    </method>
    <method name="setFormat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="formatElementIndex" type="int"/>
      <param name="newFormat" type="java.text.Format"/>
      <doc>
      <![CDATA[Sets the format to use for the format element with the given format element index within the previously set pattern
 string. The format element index is the zero-based number of the format element counting from the start of the
 pattern string.
 <p>
 Since the order of format elements in a pattern string often changes during localization, it is generally better to
 use the {@link #setFormatByArgumentIndex setFormatByArgumentIndex} method, which accesses format elements based on
 the argument index they specify.

 @param formatElementIndex the index of a format element within the pattern
 @param newFormat the format to use for the specified format element
 @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or larger than the number of
 format elements in the pattern string]]>
      </doc>
    </method>
    <method name="getFormats" return="java.text.Format[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the formats used for the format elements in the previously set pattern string. The order of formats in the
 returned array corresponds to the order of format elements in the pattern string.
 <p>
 Since the order of format elements in a pattern string often changes during localization, it's generally better to
 use the {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex} method, which assumes an order of formats
 corresponding to the order of elements in the <code>arguments</code> array passed to the <code>format</code>
 methods or the result array returned by the <code>parse</code> methods.

 @return the formats used for the format elements in the pattern]]>
      </doc>
    </method>
    <method name="format" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object[]"/>
      <param name="result" type="java.lang.CharSequence"/>
      <param name="pos" type="java.text.FieldPosition"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Formats an array of objects and appends the <code>MessageFormat</code>'s pattern, with format elements replaced by
 the formatted objects, to the provided <code>StringBuffer</code>.
 <p>
 The text substituted for the individual format elements is derived from the current subformat of the format element
 and the <code>arguments</code> element at the format element's argument index as indicated by the first matching
 line of the following table. An argument is <i>unavailable</i> if <code>arguments</code> is <code>null</code> or
 has fewer than argumentIndex+1 elements.

 <table border=1 summary="Examples of subformat,argument,and formatted text">
 <tr>
 <th>Subformat
 <th>Argument
 <th>Formatted Text
 <tr>
 <td><i>any</i>
 <td><i>unavailable</i>
 <td><code>"{" + argumentIndex + "}"</code>
 <tr>
 <td><i>any</i>
 <td><code>null</code>
 <td><code>"null"</code>
 <tr>
 <td><code>instanceof ChoiceFormat</code>
 <td><i>any</i>
 <td><code>subformat.format(argument).indexOf('{') &gt;= 0 ?<br>
 (new MessageFormat(subformat.format(argument), getLocale())).format(argument) : subformat.format(argument)</code>
 <tr>
 <td><code>!= null</code>
 <td><i>any</i>
 <td><code>subformat.format(argument)</code>
 <tr>
 <td><code>null</code>
 <td><code>instanceof Number</code>
 <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>
 <tr>
 <td><code>null</code>
 <td><code>instanceof Date</code>
 <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)</code>
 <tr>
 <td><code>null</code>
 <td><code>instanceof String</code>
 <td><code>argument</code>
 <tr>
 <td><code>null</code>
 <td><i>any</i>
 <td><code>argument.toString()</code>
 </table>
 <p>
 If <code>pos</code> is non-null, and refers to <code>Field.ARGUMENT</code>, the location of the first formatted
 string will be returned.

 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired. On output: the offsets of the alignment field.
 @return the string buffer passed in as {@code result}, with formatted text appended
 @exception IllegalArgumentException if an argument in the <code>arguments</code> array is not of the type expected
 by the format element(s) that use it.]]>
      </doc>
    </method>
    <method name="format" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object[]"/>
      <param name="result" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="format" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pattern" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Creates a MessageFormat with the given pattern and uses it to format the given arguments. This is equivalent to
 <blockquote>
 <code>(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments,
 new StringBuffer(), null).toString()</code>
 </blockquote>

 @param pattern the pattern string
 @param arguments object(s) to format
 @return the formatted string
 @exception IllegalArgumentException if the pattern is invalid, or if an argument in the <code>arguments</code>
 array is not of the type expected by the format element(s) that use it.]]>
      </doc>
    </method>
    <method name="format" return="java.lang.CharSequence"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object"/>
      <param name="result" type="java.lang.CharSequence"/>
      <param name="pos" type="java.text.FieldPosition"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Formats an array of objects and appends the <code>MessageFormat</code>'s pattern, with format elements replaced by
 the formatted objects, to the provided <code>StringBuffer</code>. This is equivalent to
 <blockquote>
 <code>{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[])
 arguments, result, pos)</code>
 </blockquote>

 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired. On output: the offsets of the alignment field.
 @exception IllegalArgumentException if an argument in the <code>arguments</code> array is not of the type expected
 by the format element(s) that use it.]]>
      </doc>
    </method>
    <method name="formatToCharacterIterator" return="java.text.AttributedCharacterIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="arguments" type="java.lang.Object"/>
      <doc>
      <![CDATA[Formats an array of objects and inserts them into the <code>MessageFormat</code>'s pattern, producing an
 <code>AttributedCharacterIterator</code>. You can use the returned <code>AttributedCharacterIterator</code> to
 build the resulting String, as well as to determine information about the resulting String.
 <p>
 The text of the returned <code>AttributedCharacterIterator</code> is the same that would be returned by
 <blockquote>
 <code>{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new
 StringBuffer(), null).toString()</code>
 </blockquote>
 <p>
 In addition, the <code>AttributedCharacterIterator</code> contains at least attributes indicating where text was
 generated from an argument in the <code>arguments</code> array. The keys of these attributes are of type
 <code>MessageFormat.Field</code>, their values are <code>Integer</code> objects indicating the index in the
 <code>arguments</code> array of the argument from which the text was generated.
 <p>
 The attributes/value from the underlying <code>Format</code> instances that <code>MessageFormat</code> uses will
 also be placed in the resulting <code>AttributedCharacterIterator</code>. This allows you to not only find where an
 argument is placed in the resulting String, but also which fields it contains in turn.

 @param arguments an array of objects to be formatted and substituted.
 @return AttributedCharacterIterator describing the formatted value.
 @exception NullPointerException if <code>arguments</code> is null.
 @exception IllegalArgumentException if an argument in the <code>arguments</code> array is not of the type expected
 by the format element(s) that use it.
 @since 1.4]]>
      </doc>
    </method>
    <method name="parse" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <param name="pos" type="java.text.ParsePosition"/>
      <doc>
      <![CDATA[Parses the string.

 <p>
 Caveats: The parse may fail in a number of circumstances. For example:
 <ul>
 <li>If one of the arguments does not occur in the pattern.
 <li>If the format of an argument loses information, such as with a choice format where a large number formats to
 "many".
 <li>Does not yet handle recursion (where the substituted strings contain {n} references.)
 <li>Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the
 pattern "{1},{2}" is used with the string arguments {"a,b", "c"}, it will format as "a,b,c". When the result is
 parsed, it will return {"a", "b,c"}.
 <li>If a single argument is parsed more than once in the string, then the later parse wins.
 </ul>
 When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The
 returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if
 the parsing string "AAA {0} BBB" is comparing against the pattern "AAD {0} BBB", the error index is 0. When an
 error occurs, the call to this method will return null. If the source is null, return an empty array. (zoltan:
 yuck)


 @param source the string to parse
 @param pos the parse position
 @return an array of parsed objects]]>
      </doc>
    </method>
    <method name="parse" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <exception name="ParseException" type="java.text.ParseException"/>
      <doc>
      <![CDATA[Parses text from the beginning of the given string to produce an object array. The method may not use the entire
 text of the given string.
 <p>
 See the {@link #parse(String, ParsePosition)} method for more information on message parsing.

 @param source A <code>String</code> whose beginning should be parsed.
 @return An <code>Object</code> array parsed from the string.
 @exception ParseException if the beginning of the specified string cannot be parsed.]]>
      </doc>
    </method>
    <method name="parseObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.String"/>
      <param name="pos" type="java.text.ParsePosition"/>
      <doc>
      <![CDATA[Parses text from a string to produce an object array.
 <p>
 The method attempts to parse text starting at the index given by <code>pos</code>. If parsing succeeds, then the
 index of <code>pos</code> is updated to the index after the last character used (parsing does not necessarily use
 all characters up to the end of the string), and the parsed object array is returned. The updated <code>pos</code>
 can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of
 <code>pos</code> is not changed, the error index of <code>pos</code> is set to the index of the character where the
 error occurred, and null is returned.
 <p>
 See the {@link #parse(String, ParsePosition)} method for more information on message parsing.

 @param source A <code>String</code>, part of which should be parsed.
 @param pos A <code>ParsePosition</code> object with index and error index information as described above.
 @return An <code>Object</code> array parsed from the string. In case of error, returns null.
 @exception NullPointerException if <code>pos</code> is null.]]>
      </doc>
    </method>
    <method name="clone" return="org.spf4j.text.MessageFormat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates and returns a copy of this object.

 @return a clone of this instance.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Equality comparison between two message format objects]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generates a hash code for the message format object.]]>
      </doc>
    </method>
    <method name="format" return="java.lang.StringBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="toAppendTo" type="java.lang.StringBuffer"/>
      <param name="pos" type="java.text.FieldPosition"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Performance mutation of the JDK message formatter.
 Lots things of things have been done:
 1) reduced the amount of garbage generated during formatting.
 2) made some method invocations static.
 3) made this more flexible and usable against StringBuilder not only StringBuffer...
 4) thrown exceptions provide more detail on what went wrong.
 5) cleaned up lots of static analisys reported issues.

 <code>MessageFormat</code> provides a means to produce concatenated messages in a language-neutral way. Use this to
 construct messages displayed for end users.

 this implementation is based on java.text.MessageFormat with the goal to be a faster and more flexible implementation

 <p>
 <code>MessageFormat</code> takes a set of objects, formats them, then inserts the formatted strings into the pattern
 at the appropriate places.

 <p>
 <strong>Note:</strong>
 <code>MessageFormat</code> differs from the other <code>Format</code> classes in that you create a
 <code>MessageFormat</code> object with one of its constructors (not with a <code>getInstance</code> style factory
 method). The factory methods aren't necessary because <code>MessageFormat</code> itself doesn't implement locale
 specific behavior. Any locale specific behavior is defined by the pattern that you provide as well as the sub-formats
 used for inserted arguments.

 <h3><a name="patterns">Patterns and Their Interpretation</a></h3>

 <code>MessageFormat</code> uses patterns of the following form:
 <blockquote><pre>
 <i>MessageFormatPattern:</i>
         <i>String</i>
         <i>MessageFormatPattern</i> <i>FormatElement</i> <i>String</i>

 <i>FormatElement:</i>
         { <i>ArgumentIndex</i> }
         { <i>ArgumentIndex</i> , <i>FormatType</i> }
         { <i>ArgumentIndex</i> , <i>FormatType</i> , <i>FormatStyle</i> }

 <i>FormatType: one of </i>
         number date time choice

 <i>FormatStyle:</i>
         short
         medium
         long
         full
         integer
         currency
         percent
         <i>SubformatPattern</i>
 </pre></blockquote>

 <p>
 Within a <i>String</i>, a pair of single quotes can be used to quote any arbitrary characters except single quotes.
 For example, pattern string <code>"'{0}'"</code> represents string <code>"{0}"</code>, not a <i>FormatElement</i>. A
 single quote itself must be represented by doubled single quotes {@code ''} throughout a
 <i>String</i>. For example, pattern string <code>"'{''}'"</code> is interpreted as a sequence of <code>'{</code>
 (start of quoting and a left curly brace), <code>''</code> (a single quote), and <code>}'</code> (a right curly brace
 and end of quoting),
 <em>not</em> <code>'{'</code> and <code>'}'</code> (quoted left and right curly braces): representing string
 <code>"{'}"</code>,
 <em>not</em> <code>"{}"</code>.

 <p>
 A <i>SubformatPattern</i> is interpreted by its corresponding sub-format, and sub-format-dependent pattern rules
 apply. For example, pattern string <code>"{1,number,<u>$'#',##</u>}"</code> (<i>SubformatPattern</i> with underline)
 will produce a number format with the pound-sign quoted, with a result such as: {@code
 "$#31,45"}. Refer to each {@code Format} subclass documentation for details.

 <p>
 Any unmatched quote is treated as closed at the end of the given pattern. For example, pattern string {@code "'{0}"}
 is treated as pattern {@code "'{0}'"}.

 <p>
 Any curly braces within an unquoted pattern must be balanced. For example, <code>"ab {0} de"</code> and
 <code>"ab '}' de"</code> are valid patterns, but <code>"ab {0'}' de"</code>, <code>"ab } de"</code> and
 <code>"''{''"</code> are not.

 <dl><dt><b>Warning:</b><dd>The rules for using quotes within message format patterns unfortunately have shown to be
 somewhat confusing. In particular, it isn't always obvious to localizers whether single quotes need to be doubled or
 not. Make sure to inform localizers about the rules, and tell them (for example, by using comments in resource bundle
 source files) which strings will be processed by {@code MessageFormat}. Note that localizers may need to use single
 quotes in translated strings where the original version doesn't have them.
 </dl>
 <p>
 The <i>ArgumentIndex</i> value is a non-negative integer written using the digits {@code '0'} through {@code '9'},
 and represents an index into the {@code arguments} array passed to the {@code format} methods or the result array
 returned by the {@code parse} methods.
 <p>
 The <i>FormatType</i> and <i>FormatStyle</i> values are used to create a {@code Format} instance for the format
 element. The following table shows how the values map to {@code Format} instances. Combinations not shown in the
 table are illegal. A <i>SubformatPattern</i> must be a valid pattern string for the {@code Format} subclass used.

 <table border=1 summary="Shows how FormatType and FormatStyle values map to Format instances">
 <tr>
 <th id="ft" class="TableHeadingColor">FormatType
 <th id="fs" class="TableHeadingColor">FormatStyle
 <th id="sc" class="TableHeadingColor">Subformat Created
 <tr>
 <td headers="ft"><i>(none)</i>
 <td headers="fs"><i>(none)</i>
 <td headers="sc"><code>null</code>
 <tr>
 <td headers="ft" rowspan=5><code>number</code>
 <td headers="fs"><i>(none)</i>
 <td headers="sc">{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><code>integer</code>
 <td headers="sc">{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><code>currency</code>
 <td headers="sc">{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><code>percent</code>
 <td headers="sc">{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
 <tr>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new}
 {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
 <tr>
 <td headers="ft" rowspan=6><code>date</code>
 <td headers="fs"><i>(none)</i>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>short</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>medium</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>long</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>full</code>
 <td headers="sc">{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 <tr>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new}
 {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 <tr>
 <td headers="ft" rowspan=6><code>time</code>
 <td headers="fs"><i>(none)</i>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>short</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>medium</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>long</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 <tr>
 <td headers="fs"><code>full</code>
 <td headers="sc">{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 <tr>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new}
 {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 <tr>
 <td headers="ft"><code>choice</code>
 <td headers="fs"><i>SubformatPattern</i>
 <td headers="sc">{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 </table>

 <h4>Usage Information</h4>

 <p>
 Here are some examples of usage. In real internationalized programs, the message format pattern and other static
 strings will, of course, be obtained from resource bundles. Other parameters will be dynamically determined at
 runtime.
 <p>
 The first example uses the static method <code>MessageFormat.format</code>, which internally creates a
 <code>MessageFormat</code> for one-time use:
 <blockquote><pre>
 int planet = 7;
 String event = "a disturbance in the Force";

 String result = MessageFormat.format(
     "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
     planet, new Date(), event);
 </pre></blockquote>
 The output is:
 <blockquote><pre>
 At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 </pre></blockquote>

 <p>
 The following example creates a <code>MessageFormat</code> instance that can be used repeatedly:
 <blockquote><pre>
 int fileCount = 1273;
 String diskName = "MyDisk";
 Object[] testArgs = {new Long(fileCount), diskName};

 MessageFormat form = new MessageFormat(
     "The disk \"{1}\" contains {0} file(s).");

 System.out.println(form.format(testArgs));
 </pre></blockquote>
 The output with different values for <code>fileCount</code>:
 <blockquote><pre>
 The disk "MyDisk" contains 0 file(s).
 The disk "MyDisk" contains 1 file(s).
 The disk "MyDisk" contains 1,273 file(s).
 </pre></blockquote>

 <p>
 For more sophisticated patterns, you can use a <code>ChoiceFormat</code> to produce correct forms for singular and
 plural:
 <blockquote><pre>
 MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
 double[] filelimits = {0,1,2};
 String[] filepart = {"no files","one file","{0,number} files"};
 ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 form.setFormatByArgumentIndex(0, fileform);

 int fileCount = 1273;
 String diskName = "MyDisk";
 Object[] testArgs = {new Long(fileCount), diskName};

 System.out.println(form.format(testArgs));
 </pre></blockquote>
 The output with different values for <code>fileCount</code>:
 <blockquote><pre>
 The disk "MyDisk" contains no files.
 The disk "MyDisk" contains one file.
 The disk "MyDisk" contains 1,273 files.
 </pre></blockquote>

 <p>
 You can create the <code>ChoiceFormat</code> programmatically, as in the above example, or by using a pattern. See
 {@link ChoiceFormat} for more information.
 <blockquote><pre>{@code
 form.applyPattern(
    "There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.");
 }</pre></blockquote>

 <p>
 <strong>Note:</strong> As we see above, the string produced by a <code>ChoiceFormat</code> in
 <code>MessageFormat</code> is treated as special; occurrences of '{' are used to indicate subformats, and cause
 recursion. If you create both a <code>MessageFormat</code> and <code>ChoiceFormat</code> programmatically (instead of
 using the string patterns), then be careful not to produce a format that recurses on itself, which will cause an
 infinite loop.
 <p>
 When a single argument is parsed more than once in the string, the last match will be the final result of the
 parsing. For example,
 <blockquote><pre>
 MessageFormat mf = new MessageFormat("{0,number,#.##}, {0,number,#.#}");
 Object[] objs = {new Double(3.1415)};
 String result = mf.format( objs );
 // result now equals "3.14, 3.1"
 objs = null;
 objs = mf.parse(result, new ParsePosition(0));
 // objs now equals {new Double(3.1)}
 </pre></blockquote>

 <p>
 Likewise, parsing with a {@code MessageFormat} object using patterns containing multiple occurrences of the same
 argument would return the last match. For example,
 <blockquote><pre>
 MessageFormat mf = new MessageFormat("{0}, {0}, {0}");
 String forParsing = "x, y, z";
 Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 // result now equals {new String("z")}
 </pre></blockquote>

 <h4><a name="synchronization">Synchronization</a></h4>

 <p>
 Message formats are not synchronized. It is recommended to create separate format instances for each thread. If
 multiple threads access a format concurrently, it must be synchronized externally.

 @see java.util.Locale
 @see Format
 @see NumberFormat
 @see DecimalFormat
 @see DecimalFormatSymbols
 @see ChoiceFormat
 @see DateFormat
 @see SimpleDateFormat

 @author Mark Davis]]>
    </doc>
  </class>
  <!-- end class org.spf4j.text.MessageFormat -->
</package>
<package name="org.spf4j.jmx.mappers">
  <!-- start class org.spf4j.jmx.mappers.DefaultMXBeanMappingFactoryOpenTypeMapper -->
  <class name="DefaultMXBeanMappingFactoryOpenTypeMapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMappingSupplier"/>
    <constructor name="DefaultMXBeanMappingFactoryOpenTypeMapper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="register" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class"/>
      <param name="mapperSuplier" type="org.spf4j.jmx.JMXBeanMappingSupplier"/>
    </method>
    <method name="get" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
      <doc>
      <![CDATA[returns MXBeanMapping or null if type is not mappable to a OpenType.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[OpenType conversion utility. right now can deal with JDK + avro stuff, will eventually become extensible with custom
 type handling.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.DefaultMXBeanMappingFactoryOpenTypeMapper -->
  <!-- start class org.spf4j.jmx.mappers.MapEntryOpenTypeMapping -->
  <class name="MapEntryOpenTypeMapping" extends="com.sun.jmx.mbeanserver.MXBeanMapping"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMapping"/>
    <constructor name="MapEntryOpenTypeMapping" type="java.lang.reflect.ParameterizedType, org.spf4j.jmx.JMXBeanMappingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </constructor>
    <method name="fromOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openValue" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="toOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaValue" type="java.lang.Object"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="getMappedType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.MapEntryOpenTypeMapping -->
  <!-- start class org.spf4j.jmx.mappers.MXBeanMappings -->
  <class name="MXBeanMappings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="com.sun.jmx.mbeanserver.MXBeanMapping"/>
    </method>
    <method name="convert" return="com.sun.jmx.mbeanserver.MXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="org.spf4j.jmx.JMXBeanMapping"/>
    </method>
    <method name="makeOpenClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaType" type="java.lang.reflect.Type"/>
      <param name="openType" type="javax.management.openmbean.OpenType"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.MXBeanMappings -->
  <!-- start class org.spf4j.jmx.mappers.SpecificRecordOpenTypeMapping -->
  <class name="SpecificRecordOpenTypeMapping" extends="com.sun.jmx.mbeanserver.MXBeanMapping"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMapping"/>
    <constructor name="SpecificRecordOpenTypeMapping" type="java.lang.Class, org.spf4j.jmx.JMXBeanMappingSupplier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </constructor>
    <method name="fromOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openValue" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="getGenericType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
    </method>
    <method name="toOpenValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaValue" type="java.lang.Object"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="getMappedType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.SpecificRecordOpenTypeMapping -->
  <!-- start class org.spf4j.jmx.mappers.Spf4jOpenTypeMapper -->
  <class name="Spf4jOpenTypeMapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.JMXBeanMappingSupplier"/>
    <constructor name="Spf4jOpenTypeMapper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </method>
    <method name="getCache" return="org.spf4j.reflect.CachingTypeMapSupplierWrapper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.mappers.Spf4jOpenTypeMapper -->
</package>
<package name="org.spf4j.jmx">
  <!-- start class org.spf4j.jmx.Client -->
  <class name="Client" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceUrl" type="java.lang.String"/>
      <param name="domain" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attribName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InstanceNotFoundException" type="javax.management.InstanceNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <doc>
      <![CDATA[get a an attribute from a JMX mbean.

 @param serviceUrl in the form of: "service:jmx:rmi:///jndi/rmi://:9999/jmxrmi"
 @param domain - mbean domain name.
 @param mbeanName - mbean name.
 @param attribName - attribute name.
 @return - the attribute value.
 @throws java.io.IOException - IO issue communicating with mbean.
 @throws javax.management.InstanceNotFoundException - mbean not found.
 @throws javax.management.MBeanException - exception while getting the attribute.
 @throws javax.management.AttributeNotFoundException - attribute not found.
 @throws javax.management.ReflectionException - mbean reflection exception.]]>
      </doc>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceUrl" type="java.lang.String"/>
      <param name="domain" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attribName" type="java.lang.String"/>
      <param name="attribValue" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InstanceNotFoundException" type="javax.management.InstanceNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
      <exception name="InvalidAttributeValueException" type="javax.management.InvalidAttributeValueException"/>
    </method>
    <method name="callOperation" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceUrl" type="java.lang.String"/>
      <param name="domain" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="operationName" type="java.lang.String"/>
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InstanceNotFoundException" type="javax.management.InstanceNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
    </method>
    <doc>
    <![CDATA[Simple Jmx Client utilities.

 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.Client -->
  <!-- start class org.spf4j.jmx.DynamicMBeanBuilder -->
  <class name="DynamicMBeanBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicMBeanBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newBuilder" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withOperation" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operation" type="org.spf4j.jmx.ExportedOperation"/>
    </method>
    <method name="withAttribute" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="org.spf4j.jmx.ExportedValue"/>
    </method>
    <method name="withAttributes" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vals" type="org.spf4j.jmx.ExportedValue[]"/>
    </method>
    <method name="withAttributes" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapAttributes" type="java.util.Map"/>
    </method>
    <method name="withJmxExportObject" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[add all exported (with @JmxExport) attributes and operations of the object.
 @param object
 @return]]>
      </doc>
    </method>
    <method name="withJmxExportObjects" return="org.spf4j.jmx.DynamicMBeanBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[add all exported (with @JmxExport) attributes and operations of the objects.
 @param objects
 @return]]>
      </doc>
    </method>
    <method name="build" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[Build the dynamic mbean.
 @param packageName
 @param mbeanName
 @return dynamic mbean or null if no exportable attributes or operations are present.]]>
      </doc>
    </method>
    <method name="extend" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toExtend" type="org.spf4j.jmx.ExportedValuesMBean"/>
      <doc>
      <![CDATA[Create a dynamic bean with extends the toExtend mbean with the attributes and operations from thsi builder.
 @param toExtend
 @return]]>
      </doc>
    </method>
    <method name="extend" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[extend existing Mbean registered with provided packageName and mbeanName
 @param packageName
 @param mbeanName
 @return null is nothing was registered.]]>
      </doc>
    </method>
    <method name="replace" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[Replace mbean registered with packageName and mbeanName with a mbean constructed by this builder.
 @param packageName
 @param mbeanName
 @return null if nothing has been done.]]>
      </doc>
    </method>
    <method name="register" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <doc>
      <![CDATA[register a mbean.
 @param packageName
 @param mbeanName
 @return null if nothing is done, and a dinamic bean instance that was registered otherwise.
 @throws InstanceAlreadyExistsException is a instance already exists.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A JMX managed bean Builder.

 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.DynamicMBeanBuilder -->
  <!-- start interface org.spf4j.jmx.ExportedOperation -->
  <interface name="ExportedOperation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="getParameterInfos" return="javax.management.MBeanParameterInfo[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnType" return="java.lang.Class"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnOpenType" return="javax.management.openmbean.OpenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="org.spf4j.jmx.ExportedOperation"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.ExportedOperation -->
  <!-- start interface org.spf4j.jmx.ExportedValue -->
  <interface name="ExportedValue"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="InvalidAttributeValueException" type="javax.management.InvalidAttributeValueException"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="isWriteable" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueType" return="java.lang.reflect.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueOpenType" return="javax.management.openmbean.OpenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.spf4j.jmx.ExportedValue -->
  <!-- start class org.spf4j.jmx.GenericExportedOperation -->
  <class name="GenericExportedOperation" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.ExportedOperation"/>
    <constructor name="GenericExportedOperation" type="java.lang.String, java.lang.String, org.spf4j.base.Invocation, java.lang.reflect.Type[], java.lang.reflect.Type, java.lang.String[], java.lang.String[], boolean[], boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parameters" type="java.lang.Object[]"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="getParameterInfos" return="javax.management.MBeanParameterInfo[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReturnOpenType" return="javax.management.openmbean.OpenType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.GenericExportedOperation -->
  <!-- start class org.spf4j.jmx.GenericExportedValue -->
  <class name="GenericExportedValue" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.jmx.ExportedValue"/>
    <constructor name="GenericExportedValue" type="java.lang.String, java.lang.String, java.util.function.Supplier, java.util.function.Consumer, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </constructor>
    <constructor name="GenericExportedValue" type="java.lang.String, java.lang.String, java.util.function.Supplier, java.util.function.Consumer, javax.management.openmbean.CompositeType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <method name="isWriteable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValueOpenType" return="javax.management.openmbean.OpenType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.GenericExportedValue -->
  <!-- start class org.spf4j.jmx.GlobalMXBeanMapperSupplier -->
  <class name="GlobalMXBeanMapperSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.spf4j.jmx.JMXBeanMappingSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="register" return="org.spf4j.jmx.JMXBeanMappingSupplier"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newMapper" type="org.spf4j.jmx.JMXBeanMappingSupplier"/>
    </method>
    <method name="getOpenTypeMapping" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </method>
    <method name="getOpenType" return="javax.management.openmbean.OpenType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.GlobalMXBeanMapperSupplier -->
  <!-- start interface org.spf4j.jmx.JMXBeanMapping -->
  <interface name="JMXBeanMapping"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromOpenValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="openValue" type="java.lang.Object"/>
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
      <doc>
      <![CDATA[convert from open value.
 @param openValue
 @return]]>
      </doc>
    </method>
    <method name="toOpenValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="javaValue" type="java.lang.Object"/>
      <exception name="OpenDataException" type="javax.management.openmbean.OpenDataException"/>
      <doc>
      <![CDATA[convert to open value.
 @param javaValue
 @return]]>
      </doc>
    </method>
    <method name="getJavaType" return="java.lang.reflect.Type"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 The Java type the open type mapping is mapped to</p>

 @return the Java type that the open type mapping is mapped to.]]>
      </doc>
    </method>
    <method name="getMappedType" return="java.lang.Class"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Jet the mapped java type.
 @return]]>
      </doc>
    </method>
    <method name="getOpenType" return="javax.management.openmbean.OpenType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 The Open Type.</p>

 @return the Open Type.]]>
      </doc>
    </method>
    <method name="isSimpleType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A type where the open type class and the java class are the same.
 @return]]>
      </doc>
    </method>
    <field name="NOMAPPING" type="org.spf4j.jmx.JMXBeanMapping"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.JMXBeanMapping -->
  <!-- start interface org.spf4j.jmx.JMXBeanMappingSupplier -->
  <interface name="JMXBeanMappingSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <method name="get" return="org.spf4j.jmx.JMXBeanMapping"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="NotSerializableException" type="java.io.NotSerializableException"/>
      <doc>
      <![CDATA[Get a opentype mapping if available.
 @param type the java typ eto lookup open type mapping
 @return the open type mapping (to/from converter) if available.
 @throws NotSerializableException will be thrown if type is a non serializable class (not interface).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.JMXBeanMappingSupplier -->
  <!-- start interface org.spf4j.jmx.JmxExport -->
  <interface name="JmxExport"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return - the name of the operation or attribute or parameter.]]>
      </doc>
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return - the description of the operation attribute or parameter.]]>
      </doc>
    </method>
    <method name="mapOpenType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map to openType the types associated to the exported entity. (or not)
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Annotation to mark setters and getters of attributes to export via JMX,
 Any other methods that do not respect get/set/is bean naming conventions will be exported as JMX operation.
 Any method parameters annotated with JMXExport allows you to provide names and descriptions to your
 operation parameters.
 Names are inferred from the method names, but can be customized further with JmxExport.value.

 Open type mapping is configurable by registering a new mapper with: GlobalMXBeanMapperSupplier.register
 or modifying the current ones (if supported). The default implementation, Spf4jOpenTypeMapper supports this.
 attribute description can be added to the annotation.

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.jmx.JmxExport -->
  <!-- start class org.spf4j.jmx.Registry -->
  <class name="Registry" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="registerMBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
      <param name="mbean" type="java.lang.Object"/>
      <doc>
      <![CDATA[Register MBean, will replace any existing bean.
 @param objectName
 @param mbean
 @return]]>
      </doc>
    </method>
    <method name="registerIfNotExistsMBean"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
      <param name="mbean" type="java.lang.Object"/>
    </method>
    <method name="getRegistered" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
    </method>
    <method name="getRegistered" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="registerMBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Class"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
    </method>
    <method name="unregister" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Class"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="objects" type="java.lang.Object[]"/>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use DynamicMBeanBuilder instead.">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attributes" type="java.util.Properties"/>
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@deprecated use DynamicMBeanBuilder instead.]]>
      </doc>
    </method>
    <method name="export" return="org.spf4j.jmx.ExportedValuesMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use BynamicMBeanBuilder instead.">
      <param name="packageName" type="java.lang.String"/>
      <param name="mbeanName" type="java.lang.String"/>
      <param name="attributes" type="java.util.Map"/>
      <param name="objects" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@deprecated use BynamicMBeanBuilder instead.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class that allows to easily exportAgg via JMX java beans.

 attributes can be exported as simply as:

       @JmxExport
       public String [][] getMatrix() {
           return matrix.clone();
       }

 for a writable attribute you will need to annotate the setter as well.

 Operations are as simple as:

       @JmxExport(description = "test operation")
       public String doStuff(@JmxExport(value = "what", description = "some param") final String what,
               final String where) {
           return "Doing " + what + " " + where;
       }

 A object annotated as above can be exported via JMX as simple as Registry.export(object).

 The registry utility also allows you to export the content of a Map as JMX attributes:

 Registry.export("package", "beanName", map);

 OpenType conversions are made for all type where this is doable.
 Avro SpecificRecord's are converted to CompositeData Open type.
 OpenType conversions can be enabled/disabled with JmcExport annotation.


 @author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.jmx.Registry -->
</package>
<package name="org.spf4j.ds">
  <!-- start interface org.spf4j.ds.Graph -->
  <interface name="Graph"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEdges" return="org.spf4j.ds.VertexEdges"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertice" type="java.lang.Object"/>
    </method>
    <method name="getVertices" return="org.spf4j.base.Pair"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="java.lang.Object"/>
    </method>
    <method name="getEdge" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.Object"/>
      <param name="to" type="java.lang.Object"/>
    </method>
    <method name="getVertices" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertice" type="java.lang.Object"/>
    </method>
    <method name="contains" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertice" type="java.lang.Object"/>
    </method>
    <method name="copy" return="org.spf4j.ds.Graph"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[a graph interface.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.ds.Graph -->
  <!-- start class org.spf4j.ds.Graphs -->
  <class name="Graphs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="clone" return="com.google.common.graph.MutableGraph"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="com.google.common.graph.MutableGraph"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.Graphs -->
  <!-- start class org.spf4j.ds.HashMapGraph -->
  <class name="HashMapGraph" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.ds.Graph"/>
    <constructor name="HashMapGraph"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertex" type="java.lang.Object"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="java.lang.Object"/>
      <param name="fromVertex" type="java.lang.Object"/>
      <param name="toVertex" type="java.lang.Object"/>
    </method>
    <method name="getVertices" return="org.spf4j.base.Pair"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="edge" type="java.lang.Object"/>
    </method>
    <method name="getEdges" return="org.spf4j.ds.VertexEdges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertice" type="java.lang.Object"/>
    </method>
    <method name="getVertices" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertice" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="org.spf4j.ds.Graph"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertice" type="java.lang.Object"/>
    </method>
    <method name="getEdge" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="from" type="java.lang.Object"/>
      <param name="to" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.HashMapGraph -->
  <!-- start class org.spf4j.ds.IdentityHashSet -->
  <class name="IdentityHashSet" extends="gnu.trove.set.hash.THashSet"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="IdentityHashSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IdentityHashSet" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IdentityHashSet" type="int, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IdentityHashSet" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notnull" type="java.lang.Object"/>
      <param name="two" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class org.spf4j.ds.IdentityHashSet -->
  <!-- start class org.spf4j.ds.LinkedHashMapEx -->
  <class name="LinkedHashMapEx" extends="java.util.LinkedHashMap"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.ds.LinkedMap"/>
    <constructor name="LinkedHashMapEx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="int, float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashMapEx" type="int, float, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLastEntry" return="java.util.Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastEntry" return="java.util.Map.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Linked hashmap that allows access to the Last Entry efficiently.
 @author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.LinkedHashMapEx -->
  <!-- start class org.spf4j.ds.LinkedHashSetEx -->
  <class name="LinkedHashSetEx" extends="java.util.AbstractSet"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.ds.LinkedSet"/>
    <constructor name="LinkedHashSetEx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LinkedHashSetEx" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLastValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.LinkedHashSetEx -->
  <!-- start interface org.spf4j.ds.LinkedMap -->
  <interface name="LinkedMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map"/>
    <method name="getLastEntry" return="java.util.Map.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastEntry" return="java.util.Map.Entry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.ds.LinkedMap -->
  <!-- start interface org.spf4j.ds.LinkedSet -->
  <interface name="LinkedSet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Set"/>
    <method name="getLastValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLastValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.ds.LinkedSet -->
  <!-- start class org.spf4j.ds.RTree -->
  <class name="RTree" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="RTree" type="int, int, int, org.spf4j.ds.RTree.SeedPicker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new RTree.

 @param maxEntries maximum number of entries per node
 @param minEntries minimum number of entries per node (except for the root node)
 @param numDims the number of dimensions of the RTree.]]>
      </doc>
    </constructor>
    <constructor name="RTree" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RTree"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new RTree using default parameters: maximum 50 entries per node minimum 2 entries per node 2 dimensions]]>
      </doc>
    </constructor>
    <constructor name="RTree" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMaxEntries" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the maximum number of entries per node]]>
      </doc>
    </method>
    <method name="getMinEntries" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the minimum number of entries per node for all nodes except the root.]]>
      </doc>
    </method>
    <method name="getNumDims" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the number of dimensions of the tree]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the number of items in this tree.]]>
      </doc>
    </method>
    <method name="search" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="dimensions" type="float[]"/>
      <doc>
      <![CDATA[Searches the RTree for objects overlapping with the given rectangle.

 @param coords the corner of the rectangle that is the lower bound of every dimension (eg. the top-left corner)
 @param dimensions the dimensions of the rectangle.
 @return a list of objects whose rectangles overlap with the given rectangle.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="dimensions" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Deletes the entry associated with the given rectangle from the RTree

 @param coords the corner of the rectangle that is the lower bound in every dimension
 @param dimensions the dimensions of the rectangle
 @param entry the entry to delete
 @return true iff the entry was deleted from the RTree.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Empties the RTree]]>
      </doc>
    </method>
    <method name="insert"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="dimensions" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the given entry into the RTree, associated with the given rectangle.

 @param coords the corner of the rectangle that is the lower bound in every dimension
 @param dimensions the dimensions of the rectangle
 @param entry the entry to insert]]>
      </doc>
    </method>
    <method name="insert"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coords" type="float[]"/>
      <param name="entry" type="java.lang.Object"/>
      <doc>
      <![CDATA[Convenience method for inserting a point

 @param coords
 @param entry]]>
      </doc>
    </method>
    <method name="visualize" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of an arbitrary-dimension RTree. Based on R-Trees: A Dynamic Index Structure for Spatial Searching
 (Antonn Guttmann, 1984)

 This class is not thread-safe. Z TODO: I have cleaned up a bit this class, but there is a lot more to do here this
 class implementation is not clean in several places. (see findbugs supressions)

 @param <T> the type of entry to store in this RTree.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.RTree -->
  <!-- start class org.spf4j.ds.RTree.SeedPicker -->
  <class name="RTree.SeedPicker" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.spf4j.ds.RTree.SeedPicker[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.spf4j.ds.RTree.SeedPicker"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="LINEAR" type="org.spf4j.ds.RTree.SeedPicker"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="QUADRATIC" type="org.spf4j.ds.RTree.SeedPicker"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.spf4j.ds.RTree.SeedPicker -->
  <!-- start class org.spf4j.ds.Traversals -->
  <class name="Traversals" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="traverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="org.spf4j.ds.Graph"/>
      <param name="startNode" type="java.lang.Object"/>
      <param name="handler" type="org.spf4j.ds.Traversals.TraversalCallback"/>
      <param name="isBreadth" type="boolean"/>
    </method>
    <method name="customTraverse"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="graph" type="org.spf4j.ds.Graph"/>
      <param name="startNode" type="java.lang.Object"/>
      <param name="handler" type="org.spf4j.ds.Traversals.TraversalCallback"/>
      <doc>
      <![CDATA[Custom graph traversal, starting from a particular node and following its outgoing links
 with the child nodes being traversed in the order of least incoming links.
 will need to properly document and test this...

 @param <V>
 @param <E>
 @param graph
 @param startNode
 @param handler]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.Traversals -->
  <!-- start interface org.spf4j.ds.Traversals.TraversalCallback -->
  <interface name="Traversals.TraversalCallback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="vertex" type="java.lang.Object"/>
      <param name="edges" type="java.util.Map"/>
    </method>
  </interface>
  <!-- end interface org.spf4j.ds.Traversals.TraversalCallback -->
  <!-- start class org.spf4j.ds.Traversals.VertexHolder -->
  <class name="Traversals.VertexHolder" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="VertexHolder" type="java.lang.Object, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.spf4j.ds.Traversals.VertexHolder"/>
    </method>
    <method name="getVertex" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class org.spf4j.ds.Traversals.VertexHolder -->
  <!-- start class org.spf4j.ds.UpdateablePriorityQueue -->
  <class name="UpdateablePriorityQueue" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="UpdateablePriorityQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UpdateablePriorityQueue" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UpdateablePriorityQueue" type="int, java.util.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add" return="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
    </method>
    <method name="peek" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peekEntry" return="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qe" type="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object[]"/>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="comparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="heapify"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A priority queue which allows efficient element update.
 Element update can be either a replacement or element mutation.
 Implementation is based on jdk priority queue.
 @author zoly
 @param <E> - the type of the elements in the queue.]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.UpdateablePriorityQueue -->
  <!-- start class org.spf4j.ds.UpdateablePriorityQueue.ElementRef -->
  <class name="UpdateablePriorityQueue.ElementRef" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="org.spf4j.ds.UpdateablePriorityQueue.ElementRef"/>
    </method>
    <method name="getElem" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setElem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elem" type="java.lang.Object"/>
    </method>
    <method name="elementMutated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.spf4j.ds.UpdateablePriorityQueue.ElementRef -->
  <!-- start class org.spf4j.ds.VertexEdges -->
  <class name="VertexEdges" extends="org.spf4j.base.Pair"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="VertexEdges"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIncomming" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getOutgoing" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="org.spf4j.ds.VertexEdges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.VertexEdges -->
  <!-- start class org.spf4j.ds.ZArrayDequeue -->
  <class name="ZArrayDequeue" extends="java.util.AbstractCollection"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Deque"/>
    <implements name="java.lang.Cloneable"/>
    <implements name="java.io.Serializable"/>
    <constructor name="ZArrayDequeue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an empty array deque with an initial capacity sufficient to hold 16 elements.]]>
      </doc>
    </constructor>
    <constructor name="ZArrayDequeue" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an empty array deque with an initial capacity sufficient to hold the specified number of elements.

 @param numElements lower bound on initial capacity of the deque]]>
      </doc>
    </constructor>
    <constructor name="ZArrayDequeue" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a deque containing the elements of the specified collection, in the order they are returned by the
 collection's iterator. (The first element returned by the collection's iterator becomes the first element, or
 <i>front</i> of the deque.)

 @param c the collection whose elements are to be placed into the deque
 @throws NullPointerException if the specified collection is null]]>
      </doc>
    </constructor>
    <method name="addFirst"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the specified element at the front of this deque.

 @param e the element to add
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="addLast"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the specified element at the end of this deque.

 <p>
 This method is equivalent to {@link #add}.

 @param e the element to add
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="addLastAndGetPtr" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
    </method>
    <method name="offerFirst" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the specified element at the front of this deque.

 @param e the element to add
 @return <tt>true</tt> (as specified by {@link Deque#offerFirst})
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="offerLast" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the specified element at the end of this deque.

 @param e the element to add
 @return <tt>true</tt> (as specified by {@link Deque#offerLast})
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="removeFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="removeLast" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="pollFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pollLast" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="getLast" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="peekFirst" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="peekLast" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="removeFirstOccurrence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the first occurrence of the specified element in this deque (when traversing the deque from head to tail).
 If the deque does not contain the element, it is unchanged. More formally, removes the first element <tt>e</tt>
 such that
 <tt>o.equals(e)</tt> (if such an element exists). Returns <tt>true</tt> if this deque contained the specified
 element (or equivalently, if this deque changed as a result of the call).

 @param o element to be removed from this deque, if present
 @return <tt>true</tt> if the deque contained the specified element]]>
      </doc>
    </method>
    <method name="removeLastOccurrence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes the last occurrence of the specified element in this deque (when traversing the deque from head to tail).
 If the deque does not contain the element, it is unchanged. More formally, removes the last element <tt>e</tt> such
 that
 <tt>o.equals(e)</tt> (if such an element exists). Returns <tt>true</tt> if this deque contained the specified
 element (or equivalently, if this deque changed as a result of the call).

 @param o element to be removed from this deque, if present
 @return <tt>true</tt> if the deque contained the specified element]]>
      </doc>
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the specified element at the end of this deque.

 <p>
 This method is equivalent to {@link #addLast}.

 @param e the element to add
 @return <tt>true</tt> (as specified by {@link Collection#add})
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="offer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Inserts the specified element at the end of this deque.

 <p>
 This method is equivalent to {@link #offerLast}.

 @param e the element to add
 @return <tt>true</tt> (as specified by {@link Queue#offer})
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="remove" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves and removes the head of the queue represented by this deque.

 This method differs from {@link #poll poll} only in that it throws an exception if this deque is empty.

 <p>
 This method is equivalent to {@link #removeFirst}.

 @return the head of the queue represented by this deque
 @throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="poll" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this
 deque), or returns
 <tt>null</tt> if this deque is empty.

 <p>
 This method is equivalent to {@link #pollFirst}.

 @return the head of the queue represented by this deque, or
 <tt>null</tt> if this deque is empty]]>
      </doc>
    </method>
    <method name="element" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from
 {@link #peek peek} only in that it throws an exception if this deque is empty.

 <p>
 This method is equivalent to {@link #getFirst}.

 @return the head of the queue represented by this deque
 @throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="peek" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves, but does not remove, the head of the queue represented by this deque, or returns <tt>null</tt> if this
 deque is empty.

 <p>
 This method is equivalent to {@link #peekFirst}.

 @return the head of the queue represented by this deque, or
 <tt>null</tt> if this deque is empty]]>
      </doc>
    </method>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Object"/>
      <doc>
      <![CDATA[Pushes an element onto the stack represented by this deque. In other words, inserts the element at the front of
 this deque.

 <p>
 This method is equivalent to {@link #addFirst}.

 @param e the element to push
 @throws NullPointerException if the specified element is null]]>
      </doc>
    </method>
    <method name="pop" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Pops an element from the stack represented by this deque. In other words, removes and returns the first element of
 this deque.

 <p>
 This method is equivalent to {@link #removeFirst()}.

 @return the element at the front of this deque (which is the top of the stack represented by this deque)
 @throws NoSuchElementException {@inheritDoc}]]>
      </doc>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="elem" type="java.lang.Object"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of elements in this deque.

 @return the number of elements in this deque]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <tt>true</tt> if this deque contains no elements.

 @return <tt>true</tt> if this deque contains no elements]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an iterator over the elements in this deque. The elements will be ordered from first (head) to last (tail).
 This is the same order that elements would be dequeued (via successive calls to {@link #remove} or popped (via
 successive calls to {@link #pop}).

 @return an iterator over the elements in this deque]]>
      </doc>
    </method>
    <method name="descendingIterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns <tt>true</tt> if this deque contains the specified element. More formally, returns <tt>true</tt> if and
 only if this deque contains at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.

 @param o object to be checked for containment in this deque
 @return <tt>true</tt> if this deque contains the specified element]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes a single instance of the specified element from this deque. If the deque does not contain the element, it
 is unchanged. More formally, removes the first element <tt>e</tt> such that
 <tt>o.equals(e)</tt> (if such an element exists). Returns <tt>true</tt> if this deque contained the specified
 element (or equivalently, if this deque changed as a result of the call).

 <p>
 This method is equivalent to {@link #removeFirstOccurrence}.

 @param o element to be removed from this deque, if present
 @return <tt>true</tt> if this deque contained the specified element]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all of the elements from this deque. The deque will be empty after this call returns.]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array containing all of the elements in this deque in proper sequence (from first to last element).

 <p>
 The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this
 method must allocate a new array). The caller is thus free to modify the returned array.

 <p>
 This method acts as bridge between array-based and collection-based APIs.

 @return an array containing all of the elements in this deque]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pa" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Returns an array containing all of the elements in this deque in proper sequence (from first to last element); the
 runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is
 returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of
 this deque.

 <p>
 If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque),
 the element in the array immediately following the end of the deque is set to
 <tt>null</tt>.

 <p>
 Like the {@link #toArray()} method, this method acts as bridge between array-based and collection-based APIs.
 Further, this method allows precise control over the runtime type of the output array, and may, under certain
 circumstances, be used to save allocation costs.

 <p>
 Suppose <tt>x</tt> is a deque known to contain only strings. The following code can be used to dump the deque into
 a newly allocated array of <tt>String</tt>:

 <pre>
     String[] y = x.toArray(new String[0]);</pre>

 Note that <tt>toArray(new Object[0])</tt> is identical in function to
 <tt>toArray()</tt>.

 @param a the array into which the elements of the deque are to be stored, if it is big enough; otherwise, a new
 array of the same runtime type is allocated for this purpose
 @return an array containing all of the elements in this deque
 @throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of
 every element in this deque
 @throws NullPointerException if the specified array is null]]>
      </doc>
    </method>
    <method name="clone" return="org.spf4j.ds.ZArrayDequeue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of this deque.

 @return a copy of this deque]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Resizable-array implementation of the {@link Deque} interface. Array deques have no capacity restrictions; they grow
 as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not
 support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than
 {@link Stack} when used as a stack, and faster than {@link LinkedList} when used as a queue.

 <p>
 Most <tt>ArrayDeque</tt> operations run in amortized constant time. Exceptions include {@link #remove(Object) remove}, {@link
 #removeFirstOccurrence removeFirstOccurrence}, {@link #removeLastOccurrence
 removeLastOccurrence}, {@link #contains contains}, {@link #iterator
 iterator.remove()}, and the bulk operations, all of which run in linear time.

 <p>
 The iterators returned by this class's <tt>iterator</tt> method are
 <i>fail-fast</i>: If the deque is modified at any time after the iterator is created, in any way except through the
 iterator's own <tt>remove</tt>
 method, the iterator will generally throw a {@link
 ConcurrentModificationException}. Thus, in the face of concurrent modification, the iterator fails quickly and
 cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.

 <p>
 Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make
 any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw
 <tt>ConcurrentModificationException</tt> on a best-effort basis. Therefore, it would be wrong to write a program that
 depended on this exception for its correctness: <i>the fail-fast behavior of iterators should be used only to detect
 bugs.</i>

 <p>
 This class and its iterator implement all of the
 <em>optional</em> methods of the {@link Collection} and {@link
 Iterator} interfaces.

 <p>
 This class is a member of the
 <a href="{@docRoot}/../technotes/guides/collections/index.html">
 Java Collections Framework</a>.

 @author Josh Bloch and Doug Lea
 @since 1.6
 @param <E> the type of elements held in this collection]]>
    </doc>
  </class>
  <!-- end class org.spf4j.ds.ZArrayDequeue -->
</package>
<package name="org.spf4j.reflect">
  <!-- start interface org.spf4j.reflect.ByTypeSupplier -->
  <interface name="ByTypeSupplier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.reflect.ByTypeSupplier -->
  <!-- start class org.spf4j.reflect.CachingTypeMapSupplierWrapper -->
  <class name="CachingTypeMapSupplierWrapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <constructor name="CachingTypeMapSupplierWrapper" type="com.google.common.cache.CacheBuilder, org.spf4j.reflect.TypeMap, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CachingTypeMapSupplierWrapper" type="org.spf4j.reflect.TypeMap, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="putIfNotPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="appender" type="org.spf4j.reflect.ByTypeSupplier"/>
    </method>
    <method name="safePut"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="object" type="org.spf4j.reflect.ByTypeSupplier"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="clearCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.reflect.CachingTypeMapSupplierWrapper -->
  <!-- start class org.spf4j.reflect.CachingTypeMapWrapper -->
  <class name="CachingTypeMapWrapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.TypeMap"/>
    <constructor name="CachingTypeMapWrapper" type="com.google.common.cache.CacheBuilder, org.spf4j.reflect.TypeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CachingTypeMapWrapper" type="org.spf4j.reflect.TypeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAll" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <method name="putIfNotPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="appender" type="java.lang.Object"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="getExact" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <method name="replace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <param name="f" type="java.util.function.Function"/>
    </method>
    <method name="clearCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.reflect.CachingTypeMapWrapper -->
  <!-- start class org.spf4j.reflect.GraphTypeMap -->
  <class name="GraphTypeMap" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.TypeMap"/>
    <constructor name="GraphTypeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="GraphTypeMap" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAll" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <method name="putIfNotPresent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="appender" type="java.lang.Object"/>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExact" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
    </method>
    <doc>
    <![CDATA[@author Zoltan Farkas]]>
    </doc>
  </class>
  <!-- end class org.spf4j.reflect.GraphTypeMap -->
  <!-- start interface org.spf4j.reflect.TypeMap -->
  <interface name="TypeMap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.reflect.ByTypeSupplier"/>
    <method name="getAll" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Get all Objects associated to all unrelated compatible types.

 for example we habe Object O of type T a subtype of T1 and T2.
 if this typemap contains Objects mapped to T1 and T2, those 2 objects
 will be returned if T1 and T2 are not related (subtypes of each other)
 if T1 extends T2 the obeject mapped to the most specific type is returned.

 @param t
 @return]]>
      </doc>
    </method>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[get the object associated to a compatible type, only if there is only one.
 @param t
 @return]]>
      </doc>
    </method>
    <method name="getExact" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Get the the Object associated to type.
 @param t
 @return]]>
      </doc>
    </method>
    <method name="putIfNotPresent" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Associate object to type if no existing association present.
 @param type
 @param object
 @return]]>
      </doc>
    </method>
    <method name="safePut" return="org.spf4j.reflect.TypeMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[Associate object with type. if there is an existing association a exception will be thrown.
 @param type
 @param object]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[remove type association.
 @param type
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Type to Object map.
 association is not 1 - 1. if we have  type1 -> object that if type2 is subtype of type1, also type2 -> object
 this is useful for resolving: ITC_INHERITANCE_TYPE_CHECKING

 @author Zoltan Farkas]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.reflect.TypeMap -->
</package>
<package name="org.spf4j.perf">
  <!-- start interface org.spf4j.perf.MeasurementAccumulator -->
  <interface name="MeasurementAccumulator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.spf4j.perf.MeasurementRecorder"/>
    <method name="get" return="long[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getThenReset" return="long[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return null when no measurements have been made.]]>
      </doc>
    </method>
    <method name="aggregate" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mSource" type="org.spf4j.perf.MeasurementAccumulator"/>
    </method>
    <method name="createClone" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[reset this entity.

 @return a clone of the object prior to reset or null if no measurements have been made.]]>
      </doc>
    </method>
    <method name="createLike" return="org.spf4j.perf.MeasurementAccumulator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="java.lang.Object"/>
    </method>
    <method name="getInfo" return="org.spf4j.perf.MeasurementsInfo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCompositeData" return="javax.management.openmbean.CompositeDataSupport"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return null if no measurements have been made.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementAccumulator -->
  <!-- start interface org.spf4j.perf.MeasurementRecorder -->
  <interface name="MeasurementRecorder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="record"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long"/>
      <doc>
      <![CDATA[record a measurement for current time. System.currentTimeMillis().
 @param measurement the measurement value]]>
      </doc>
    </method>
    <method name="recordAt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long"/>
    </method>
    <doc>
    <![CDATA[Interface to record a measurement tuple (timestamp, long value)
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementRecorder -->
  <!-- start interface org.spf4j.perf.MeasurementRecorderSource -->
  <interface name="MeasurementRecorderSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="getRecorder" return="org.spf4j.perf.MeasurementRecorder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forWhat" type="java.lang.Object"/>
      <doc>
      <![CDATA[do not hold onto the returned recorder.
 the returned recorder should never cross Thread boundaries.
 @param forWhat - Object to get a recorder for.
 @return - measurement recorder.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for measurement recorders.
 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementRecorderSource -->
  <!-- start interface org.spf4j.perf.MeasurementsInfo -->
  <interface name="MeasurementsInfo"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMeasuredEntity" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementNames" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementUnits" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMeasurementName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getMeasurementUnit" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementNr" type="int"/>
    </method>
    <method name="getNumberOfMeasurements" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toCompositeType" return="javax.management.openmbean.CompositeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementsInfo -->
  <!-- start interface org.spf4j.perf.MeasurementsSource -->
  <interface name="MeasurementsSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEntitiesMeasurements" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntitiesMeasurementsAndReset" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementsSource -->
  <!-- start interface org.spf4j.perf.MeasurementStore -->
  <interface name="MeasurementStore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="alocateMeasurements" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurementInfo" type="org.spf4j.perf.MeasurementsInfo"/>
      <param name="sampleTimeMillis" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make any allocations necessary for the following measurements.

 @param measurementInfo - the information about the measurement(s)
 @param sampleTimeMillis - the expected sample time. (interval between the stored measurements).
 @return - the id of the measurementInfo table.
 @throws IOException - IO issues.]]>
      </doc>
    </method>
    <method name="saveMeasurements"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tableId" type="long"/>
      <param name="timeStampMillis" type="long"/>
      <param name="measurements" type="long[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Save measurements.

 @param tableId - the table ID to store measurements for.
 @param timeStampMillis - the timestamp of the measurement (millis since Jan 1 1970 UTC)
 @param measurements - the measurements to persist. (same order as declared)
 @throws IOException - IO issues.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[flush all data that might be buffered by this store.

 @throws IOException - IO issues.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A measurement store.

 @author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MeasurementStore -->
  <!-- start interface org.spf4j.perf.MultiMeasurementRecorder -->
  <interface name="MultiMeasurementRecorder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="record"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="measurement" type="long[]"/>
    </method>
    <method name="recordAt"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timestampMillis" type="long"/>
      <param name="measurement" type="long[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </interface>
  <!-- end interface org.spf4j.perf.MultiMeasurementRecorder -->
  <!-- start class org.spf4j.perf.PerformanceMonitor -->
  <class name="PerformanceMonitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="callAndMonitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="callAndMonitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="callAndMonitor" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mrs" type="org.spf4j.perf.MeasurementRecorderSource"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
    </method>
    <method name="performanceMonitoredCallable" return="java.util.concurrent.Callable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.spf4j.perf.MeasurementRecorder"/>
      <param name="warnMillis" type="long"/>
      <param name="errorMillis" type="long"/>
      <param name="callable" type="java.util.concurrent.Callable"/>
      <param name="isLogInfo" type="boolean"/>
      <param name="detail" type="java.lang.Object[]"/>
    </method>
    <doc>
    <![CDATA[@author zoly]]>
    </doc>
  </class>
  <!-- end class org.spf4j.perf.PerformanceMonitor -->
</package>

</api>
