<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SortV1.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data-rest</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data.rest</a> &gt; <span class="el_source">SortV1.java</span></div><h1>SortV1.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.molgenis.data.rest;

import org.apache.commons.lang3.StringUtils;

import java.io.Serializable;
import java.util.*;

/**
 * Copy of org.springframework.data.domain.Sort for backwards compatibility
 * &lt;p&gt;
 * Sort option for queries. You have to provide at least a list of properties to sort for that must not include
 * {@literal null} or empty strings. The direction defaults to {@link SortV1#DEFAULT_DIRECTION}.
 *
 * @author Oliver Gierke
 * @deprecated use {@link org.molgenis.data.Sort} instead.
 */
public class SortV1 implements Iterable&lt;SortV1.OrderV1&gt;, Serializable
{

	private static final long serialVersionUID = 5737186511678863905L;
<span class="nc" id="L36">	public static final DirectionV1 DEFAULT_DIRECTION = DirectionV1.ASC;</span>

	private final List&lt;OrderV1&gt; orders;

	/**
	 * Creates a new {@link SortV1} instance using the given {@link OrderV1}s.
	 *
	 * @param orders must not be {@literal null}.
	 */
	public SortV1(OrderV1... orders)
	{
<span class="nc" id="L47">		this(Arrays.asList(orders));</span>
<span class="nc" id="L48">	}</span>

	/**
	 * Creates a new {@link SortV1} instance.
	 *
	 * @param orders must not be {@literal null} or contain {@literal null}.
	 */
	public SortV1(List&lt;OrderV1&gt; orders)
<span class="nc" id="L56">	{</span>

<span class="nc bnc" id="L58" title="All 4 branches missed.">		if (null == orders || orders.isEmpty())</span>
		{
<span class="nc" id="L60">			throw new IllegalArgumentException(&quot;You have to provide at least one sort property to sort by!&quot;);</span>
		}

<span class="nc" id="L63">		this.orders = orders;</span>
<span class="nc" id="L64">	}</span>

	/**
	 * Creates a new {@link SortV1} instance. Order defaults to {@link DirectionV1#ASC}.
	 *
	 * @param properties must not be {@literal null} or contain {@literal null} or empty strings
	 */
	public SortV1(String... properties)
	{
<span class="nc" id="L73">		this(DEFAULT_DIRECTION, properties);</span>
<span class="nc" id="L74">	}</span>

	/**
	 * Creates a new {@link SortV1} instance.
	 *
	 * @param direction  defaults to {@link SortV1#DEFAULT_DIRECTION} (for {@literal null} cases, too)
	 * @param properties must not be {@literal null} or contain {@literal null} or empty strings
	 */
	public SortV1(DirectionV1 direction, String... properties)
	{
<span class="nc bnc" id="L84" title="All 2 branches missed.">		this(direction, properties == null ? new ArrayList&lt;&gt;() : Arrays.asList(properties));</span>
<span class="nc" id="L85">	}</span>

	/**
	 * Creates a new {@link SortV1} instance.
	 */
	public SortV1(DirectionV1 direction, List&lt;String&gt; properties)
<span class="nc" id="L91">	{</span>

<span class="nc bnc" id="L93" title="All 4 branches missed.">		if (properties == null || properties.isEmpty())</span>
		{
<span class="nc" id="L95">			throw new IllegalArgumentException(&quot;You have to provide at least one property to sort by!&quot;);</span>
		}

<span class="nc" id="L98">		this.orders = new ArrayList&lt;&gt;(properties.size());</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">		for (String property : properties)</span>
		{
<span class="nc" id="L102">			this.orders.add(new OrderV1(direction, property));</span>
<span class="nc" id="L103">		}</span>
<span class="nc" id="L104">	}</span>

	/**
	 * Returns a new {@link SortV1} consisting of the {@link OrderV1}s of the current {@link SortV1} combined with the
	 * given ones.
	 *
	 * @param sort can be {@literal null}.
	 */
	public SortV1 and(SortV1 sort)
	{

<span class="nc bnc" id="L115" title="All 2 branches missed.">		if (sort == null)</span>
		{
<span class="nc" id="L117">			return this;</span>
		}

<span class="nc" id="L120">		ArrayList&lt;OrderV1&gt; these = new ArrayList&lt;&gt;(this.orders);</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">		for (OrderV1 order : sort)</span>
		{
<span class="nc" id="L124">			these.add(order);</span>
<span class="nc" id="L125">		}</span>

<span class="nc" id="L127">		return new SortV1(these);</span>
	}

	/**
	 * Returns the order registered for the given property.
	 */
	public OrderV1 getOrderFor(String property)
	{

<span class="nc bnc" id="L136" title="All 2 branches missed.">		for (OrderV1 order : this)</span>
		{
<span class="nc bnc" id="L138" title="All 2 branches missed.">			if (order.getProperty().equals(property))</span>
			{
<span class="nc" id="L140">				return order;</span>
			}
<span class="nc" id="L142">		}</span>

<span class="nc" id="L144">		return null;</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Iterable#iterator()
	 */
	public Iterator&lt;OrderV1&gt; iterator()
	{
<span class="nc" id="L154">		return this.orders.iterator();</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj)
	{

<span class="nc bnc" id="L166" title="All 2 branches missed.">		if (this == obj)</span>
		{
<span class="nc" id="L168">			return true;</span>
		}

<span class="nc bnc" id="L171" title="All 2 branches missed.">		if (!(obj instanceof SortV1))</span>
		{
<span class="nc" id="L173">			return false;</span>
		}

<span class="nc" id="L176">		SortV1 that = (SortV1) obj;</span>

<span class="nc" id="L178">		return this.orders.equals(that.orders);</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode()
	{

<span class="nc" id="L190">		int result = 17;</span>
<span class="nc" id="L191">		result = 31 * result + orders.hashCode();</span>
<span class="nc" id="L192">		return result;</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
<span class="nc" id="L203">		return StringUtils.join(orders, ',');</span>
	}

	/**
	 * Enumeration for sort directions.
	 *
	 * @author Oliver Gierke
	 */
<span class="fc" id="L211">	public enum DirectionV1</span>
	{

<span class="fc" id="L214">		ASC, DESC;</span>

		/**
		 * Returns the {@link DirectionV1} enum for the given {@link String} value.
		 */
		public static DirectionV1 fromString(String value)
		{

			try
			{
<span class="nc" id="L224">				return DirectionV1.valueOf(value.toUpperCase(Locale.US));</span>
			}
<span class="nc" id="L226">			catch (Exception e)</span>
			{
<span class="nc" id="L228">				throw new IllegalArgumentException(String.format(</span>
						&quot;Invalid value '%s' for orders given! Has to be either 'desc' or 'asc' (case insensitive).&quot;,
						value), e);
			}
		}
	}

	/**
	 * PropertyPath implements the pairing of an {@link DirectionV1} and a property. It is used to provide input for
	 * {@link SortV1}
	 *
	 * @author Oliver Gierke
	 */
	public static class OrderV1 implements Serializable
	{

		private static final long serialVersionUID = 1522511010900108987L;

		private final DirectionV1 direction;
		private final String property;

		/**
		 * Creates a new {@link OrderV1} instance. if order is {@literal null} then order defaults to
		 * {@link SortV1#DEFAULT_DIRECTION}
		 *
		 * @param direction can be {@literal null}, will default to {@link SortV1#DEFAULT_DIRECTION}
		 * @param property  must not be {@literal null} or empty.
		 */
		public OrderV1(DirectionV1 direction, String property)
<span class="nc" id="L257">		{</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">			if (!StringUtils.isNotEmpty(property))</span>
			{
<span class="nc" id="L261">				throw new IllegalArgumentException(&quot;Property must not null or empty!&quot;);</span>
			}

<span class="nc bnc" id="L264" title="All 2 branches missed.">			this.direction = direction == null ? DEFAULT_DIRECTION : direction;</span>
<span class="nc" id="L265">			this.property = property;</span>
<span class="nc" id="L266">		}</span>

		/**
		 * Creates a new {@link OrderV1} instance. Takes a single property. Direction defaults to
		 * {@link SortV1#DEFAULT_DIRECTION}.
		 *
		 * @param property must not be {@literal null} or empty.
		 */
		public OrderV1(String property)
		{
<span class="nc" id="L276">			this(DEFAULT_DIRECTION, property);</span>
<span class="nc" id="L277">		}</span>

		/**
		 * @deprecated use {@link SortV1#SortV1(DirectionV1, List)} instead.
		 */
		@Deprecated
		public static List&lt;OrderV1&gt; create(DirectionV1 direction, Iterable&lt;String&gt; properties)
		{

<span class="nc" id="L286">			List&lt;OrderV1&gt; orders = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">			for (String property : properties)</span>
			{
<span class="nc" id="L289">				orders.add(new OrderV1(direction, property));</span>
<span class="nc" id="L290">			}</span>
<span class="nc" id="L291">			return orders;</span>
		}

		/**
		 * Returns the order the property shall be sorted for.
		 */
		public DirectionV1 getDirection()
		{
<span class="nc" id="L299">			return direction;</span>
		}

		/**
		 * Returns the property to order for.
		 */
		public String getProperty()
		{
<span class="nc" id="L307">			return property;</span>
		}

		/**
		 * Returns whether sorting for this property shall be ascending.
		 */
		public boolean isAscending()
		{
<span class="nc" id="L315">			return this.direction.equals(DirectionV1.ASC);</span>
		}

		/**
		 * Returns a new {@link OrderV1} with the given {@link OrderV1}.
		 */
		public OrderV1 with(DirectionV1 order)
		{
<span class="nc" id="L323">			return new OrderV1(order, this.property);</span>
		}

		/**
		 * Returns a new {@link SortV1} instance for the given properties.
		 */
		public SortV1 withProperties(String... properties)
		{
<span class="nc" id="L331">			return new SortV1(this.direction, properties);</span>
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#hashCode()
		 */
		@Override
		public int hashCode()
		{

<span class="nc" id="L343">			int result = 17;</span>

<span class="nc" id="L345">			result = 31 * result + direction.hashCode();</span>
<span class="nc" id="L346">			result = 31 * result + property.hashCode();</span>

<span class="nc" id="L348">			return result;</span>
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		@Override
		public boolean equals(Object obj)
		{

<span class="nc bnc" id="L360" title="All 2 branches missed.">			if (this == obj)</span>
			{
<span class="nc" id="L362">				return true;</span>
			}

<span class="nc bnc" id="L365" title="All 2 branches missed.">			if (!(obj instanceof OrderV1))</span>
			{
<span class="nc" id="L367">				return false;</span>
			}

<span class="nc" id="L370">			OrderV1 that = (OrderV1) obj;</span>

<span class="nc bnc" id="L372" title="All 4 branches missed.">			return this.direction.equals(that.direction) &amp;&amp; this.property.equals(that.property);</span>
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString()
		{
<span class="nc" id="L383">			return String.format(&quot;%s: %s&quot;, property, direction);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>