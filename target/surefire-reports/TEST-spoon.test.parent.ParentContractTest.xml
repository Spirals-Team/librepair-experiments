<?xml version="1.0" encoding="UTF-8"?>
<testsuite xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://maven.apache.org/surefire/maven-surefire-plugin/xsd/surefire-test-report.xsd" name="spoon.test.parent.ParentContractTest" time="0.729" tests="67" errors="0" skipped="0" failures="0">
  <properties>
    <property name="awt.toolkit" value="sun.awt.X11.XToolkit"/>
    <property name="file.encoding.pkg" value="sun.io"/>
    <property name="java.specification.version" value="1.8"/>
    <property name="sun.cpu.isalist" value=""/>
    <property name="sun.jnu.encoding" value="UTF-8"/>
    <property name="java.class.path" value="/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/maven/surefire/surefire-booter/2.20.1/surefire-booter-2.20.1.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/maven/surefire/surefire-api/2.20.1/surefire-api-2.20.1.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/maven/surefire/surefire-logger-api/2.20.1/surefire-logger-api-2.20.1.jar:/root/workspace/INRIA/spoon/383858391/target/test-classes:/root/workspace/INRIA/spoon/383858391/target/classes:/root/./workspace/INRIA/spoon/383858391/.m2/org/eclipse/tycho/org.eclipse.jdt.core/3.13.50.v20171007-0855/org.eclipse.jdt.core-3.13.50.v20171007-0855.jar:/root/./workspace/INRIA/spoon/383858391/.m2/junit/junit/4.12/junit-4.12.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/github/stefanbirkner/system-rules/1.9.0/system-rules-1.9.0.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/mockito/mockito-all/2.0.2-beta/mockito-all-2.0.2-beta.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/martiansoftware/jsap/2.1/jsap-2.1.jar:/root/./workspace/INRIA/spoon/383858391/.m2/log4j/log4j/1.2.17/log4j-1.2.17.jar:/root/./workspace/INRIA/spoon/383858391/.m2/commons-io/commons-io/2.5/commons-io-2.5.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/maven/maven-model/3.3.9/maven-model-3.3.9.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/codehaus/plexus/plexus-utils/3.0.22/plexus-utils-3.0.22.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/fasterxml/jackson/core/jackson-databind/2.9.2/jackson-databind-2.9.2.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/fasterxml/jackson/core/jackson-annotations/2.9.0/jackson-annotations-2.9.0.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/fasterxml/jackson/core/jackson-core/2.9.2/jackson-core-2.9.2.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/maven/surefire/surefire-junit4/2.20.1/surefire-junit4-2.20.1.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/jacoco/org.jacoco.agent/0.7.9/org.jacoco.agent-0.7.9-runtime.jar"/>
    <property name="java.vm.vendor" value="Oracle Corporation"/>
    <property name="skip.bower" value="true"/>
    <property name="sun.arch.data.model" value="64"/>
    <property name="java.vendor.url" value="http://java.oracle.com/"/>
    <property name="user.timezone" value=""/>
    <property name="java.vm.specification.version" value="1.8"/>
    <property name="os.name" value="Linux"/>
    <property name="rat.skip" value="true"/>
    <property name="gpg.skip" value="true"/>
    <property name="sun.java.launcher" value="SUN_STANDARD"/>
    <property name="sun.boot.library.path" value="/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64"/>
    <property name="skip.gulp" value="true"/>
    <property name="sun.java.command" value="org.apache.maven.surefire.booter.ForkedBooter /root/workspace/INRIA/spoon/383858391/target/surefire 2018-05-25T21-55-32_990-jvmRun1 surefire8082270228800823985tmp surefire_0450296059333244061tmp"/>
    <property name="dependency-check.skip" value="true"/>
    <property name="surefire.test.class.path" value="/root/workspace/INRIA/spoon/383858391/target/test-classes:/root/workspace/INRIA/spoon/383858391/target/classes:/root/./workspace/INRIA/spoon/383858391/.m2/org/eclipse/tycho/org.eclipse.jdt.core/3.13.50.v20171007-0855/org.eclipse.jdt.core-3.13.50.v20171007-0855.jar:/root/./workspace/INRIA/spoon/383858391/.m2/junit/junit/4.12/junit-4.12.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/github/stefanbirkner/system-rules/1.9.0/system-rules-1.9.0.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/mockito/mockito-all/2.0.2-beta/mockito-all-2.0.2-beta.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/martiansoftware/jsap/2.1/jsap-2.1.jar:/root/./workspace/INRIA/spoon/383858391/.m2/log4j/log4j/1.2.17/log4j-1.2.17.jar:/root/./workspace/INRIA/spoon/383858391/.m2/commons-io/commons-io/2.5/commons-io-2.5.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/maven/maven-model/3.3.9/maven-model-3.3.9.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/codehaus/plexus/plexus-utils/3.0.22/plexus-utils-3.0.22.jar:/root/./workspace/INRIA/spoon/383858391/.m2/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/fasterxml/jackson/core/jackson-databind/2.9.2/jackson-databind-2.9.2.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/fasterxml/jackson/core/jackson-annotations/2.9.0/jackson-annotations-2.9.0.jar:/root/./workspace/INRIA/spoon/383858391/.m2/com/fasterxml/jackson/core/jackson-core/2.9.2/jackson-core-2.9.2.jar:"/>
    <property name="sun.cpu.endian" value="little"/>
    <property name="user.home" value="/root"/>
    <property name="user.language" value="en"/>
    <property name="java.specification.vendor" value="Oracle Corporation"/>
    <property name="java.home" value="/usr/lib/jvm/java-8-openjdk-amd64/jre"/>
    <property name="basedir" value="/root/workspace/INRIA/spoon/383858391"/>
    <property name="file.separator" value="/"/>
    <property name="checkstyle.skip" value="true"/>
    <property name="line.separator" value="&#10;"/>
    <property name="skip.npm" value="true"/>
    <property name="java.vm.specification.vendor" value="Oracle Corporation"/>
    <property name="java.specification.name" value="Java Platform API Specification"/>
    <property name="java.awt.graphicsenv" value="sun.awt.X11GraphicsEnvironment"/>
    <property name="skipITs" value="true"/>
    <property name="cobertura.skip" value="true"/>
    <property name="sun.boot.class.path" value="/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-8-openjdk-amd64/jre/classes"/>
    <property name="sun.management.compiler" value="HotSpot 64-Bit Tiered Compilers"/>
    <property name="java.runtime.version" value="1.8.0_121-8u121-b13-1~bpo8+1-b13"/>
    <property name="user.name" value="root"/>
    <property name="findbugs.skip" value="true"/>
    <property name="path.separator" value=":"/>
    <property name="os.version" value="3.10.0-862.2.3.el7.x86_64"/>
    <property name="java.endorsed.dirs" value="/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/endorsed"/>
    <property name="java.runtime.name" value="OpenJDK Runtime Environment"/>
    <property name="file.encoding" value="UTF-8"/>
    <property name="java.vm.name" value="OpenJDK 64-Bit Server VM"/>
    <property name="localRepository" value="/root/./workspace/INRIA/spoon/383858391/.m2"/>
    <property name="java.vendor.url.bug" value="http://bugreport.sun.com/bugreport/"/>
    <property name="java.io.tmpdir" value="/tmp"/>
    <property name="java.version" value="1.8.0_121"/>
    <property name="user.dir" value="/root/workspace/INRIA/spoon/383858391"/>
    <property name="os.arch" value="amd64"/>
    <property name="license.skip" value="true"/>
    <property name="java.vm.specification.name" value="Java Virtual Machine Specification"/>
    <property name="java.awt.printerjob" value="sun.print.PSPrinterJob"/>
    <property name="sun.os.patch.level" value="unknown"/>
    <property name="java.library.path" value="/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib"/>
    <property name="java.vm.info" value="mixed mode"/>
    <property name="java.vendor" value="Oracle Corporation"/>
    <property name="java.vm.version" value="25.121-b13"/>
    <property name="java.ext.dirs" value="/usr/lib/jvm/java-8-openjdk-amd64/jre/lib/ext:/usr/java/packages/lib/ext"/>
    <property name="sun.io.unicode.encoding" value="UnicodeLittle"/>
    <property name="maven.repo.local" value="/root/./workspace/INRIA/spoon/383858391/.m2"/>
    <property name="enforcer.skip" value="true"/>
    <property name="java.class.version" value="52.0"/>
  </properties>
  <testcase name="testContract[public interface CtAnnotationFieldAccess&lt;T&gt; extends spoon.reflect.code.CtTargetedExpression&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; , spoon.reflect.code.CtVariableRead&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VARIABLE)&#10;    spoon.reflect.reference.CtFieldReference&lt;T&gt; getVariable();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtAnnotationFieldAccess&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.129"/>
  <testcase name="testContract[public interface CtArrayRead&lt;T&gt; extends spoon.reflect.code.CtArrayAccess&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtArrayRead&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.006"/>
  <testcase name="testContract[public interface CtArrayWrite&lt;T&gt; extends spoon.reflect.code.CtArrayAccess&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtArrayWrite&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.007"/>
  <testcase name="testContract[public interface CtAssert&lt;T&gt; extends spoon.reflect.code.CtStatement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONDITION)&#10;    spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; getAssertExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONDITION)&#10;    &lt;A extends spoon.reflect.code.CtAssert&lt;T&gt;&gt; A setAssertExpression(spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; asserted);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;A extends spoon.reflect.code.CtAssert&lt;T&gt;&gt; A setExpression(spoon.reflect.code.CtExpression&lt;T&gt; expression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtAssert&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.003"/>
  <testcase name="testContract[public interface CtAssignment&lt;T, A extends T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; , spoon.reflect.code.CtRHSReceiver&lt;A&gt; , spoon.reflect.code.CtStatement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.ASSIGNED)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getAssigned();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ASSIGNED)&#10;    &lt;C extends spoon.reflect.code.CtAssignment&lt;T, A&gt;&gt; C setAssigned(spoon.reflect.code.CtExpression&lt;T&gt; assigned);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtAssignment&lt;T, A&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.006"/>
  <testcase name="testContract[public interface CtBinaryOperator&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.LEFT_OPERAND)&#10;    spoon.reflect.code.CtExpression&lt;?&gt; getLeftHandOperand();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.RIGHT_OPERAND)&#10;    spoon.reflect.code.CtExpression&lt;?&gt; getRightHandOperand();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.LEFT_OPERAND)&#10;    &lt;C extends spoon.reflect.code.CtBinaryOperator&lt;T&gt;&gt; C setLeftHandOperand(spoon.reflect.code.CtExpression&lt;?&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.RIGHT_OPERAND)&#10;    &lt;C extends spoon.reflect.code.CtBinaryOperator&lt;T&gt;&gt; C setRightHandOperand(spoon.reflect.code.CtExpression&lt;?&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPERATOR_KIND)&#10;    &lt;C extends spoon.reflect.code.CtBinaryOperator&lt;T&gt;&gt; C setKind(spoon.reflect.code.BinaryOperatorKind kind);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.OPERATOR_KIND)&#10;    spoon.reflect.code.BinaryOperatorKind getKind();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtBinaryOperator&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.007"/>
  <testcase name="testContract[public interface CtBlock&lt;R&gt; extends spoon.reflect.code.CtStatement , spoon.reflect.code.CtStatementList , spoon.template.TemplateParameter&lt;R&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtBlock&lt;R&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtBreak extends spoon.reflect.code.CtLabelledFlowBreak {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtBreak clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtCase&lt;S&gt; extends spoon.reflect.code.CtStatement , spoon.reflect.code.CtStatementList {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;S&gt; getCaseExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtCase&lt;S&gt;&gt; T setCaseExpression(spoon.reflect.code.CtExpression&lt;S&gt; caseExpression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtCase&lt;S&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.006"/>
  <testcase name="testContract[public interface CtCatch extends spoon.reflect.code.CtBodyHolder , spoon.reflect.code.CtCodeElement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.PARAMETER)&#10;    spoon.reflect.code.CtCatchVariable&lt;? extends java.lang.Throwable&gt; getParameter();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.PARAMETER)&#10;    &lt;T extends spoon.reflect.code.CtCatch&gt; T setParameter(spoon.reflect.code.CtCatchVariable&lt;? extends java.lang.Throwable&gt; parameter);&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.BODY)&#10;    spoon.reflect.code.CtBlock&lt;?&gt; getBody();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtCatch clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtCatchVariable&lt;T&gt; extends spoon.reflect.code.CtCodeElement , spoon.reflect.declaration.CtMultiTypedElement , spoon.reflect.declaration.CtVariable&lt;T&gt; {&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtCatchVariableReference&lt;T&gt; getReference();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtCatchVariable&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtVariable&lt;T&gt;&gt; C setDefaultExpression(spoon.reflect.code.CtExpression&lt;T&gt; assignedExpression);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtTypeReference&lt;T&gt; getType();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.013"/>
  <testcase name="testContract[public interface CtCodeSnippetExpression&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; , spoon.reflect.declaration.CtCodeSnippet {&#10;    &lt;E extends spoon.reflect.code.CtExpression&lt;T&gt;&gt; E compile() throws spoon.support.compiler.SnippetCompilationError;&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtCodeSnippetExpression&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.006"/>
  <testcase name="testContract[public interface CtCodeSnippetStatement extends spoon.reflect.code.CtStatement , spoon.reflect.declaration.CtCodeSnippet {&#10;    &lt;S extends spoon.reflect.code.CtStatement&gt; S compile() throws spoon.support.compiler.SnippetCompilationError;&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtCodeSnippetStatement clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtComment extends spoon.reflect.code.CtStatement {&#10;    enum CommentType {&#10;        FILE, JAVADOC, INLINE, BLOCK;}&#10;&#10;    java.lang.String LINE_SEPARATOR = &quot;\n&quot;;&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.COMMENT_CONTENT)&#10;    java.lang.String getContent();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_CONTENT)&#10;    &lt;E extends spoon.reflect.code.CtComment&gt; E setContent(java.lang.String content);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.COMMENT_TYPE)&#10;    spoon.reflect.code.CtComment.CommentType getCommentType();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_TYPE)&#10;    &lt;E extends spoon.reflect.code.CtComment&gt; E setCommentType(spoon.reflect.code.CtComment.CommentType commentType);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtComment clone();&#10;&#10;    spoon.reflect.code.CtJavaDoc asJavaDoc();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtConditional&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.ELSE)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getElseExpression();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.THEN)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getThenExpression();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONDITION)&#10;    spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; getCondition();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ELSE)&#10;    &lt;C extends spoon.reflect.code.CtConditional&lt;T&gt;&gt; C setElseExpression(spoon.reflect.code.CtExpression&lt;T&gt; elseExpression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.THEN)&#10;    &lt;C extends spoon.reflect.code.CtConditional&lt;T&gt;&gt; C setThenExpression(spoon.reflect.code.CtExpression&lt;T&gt; thenExpression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONDITION)&#10;    &lt;C extends spoon.reflect.code.CtConditional&lt;T&gt;&gt; C setCondition(spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; condition);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtConditional&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.006"/>
  <testcase name="testContract[public interface CtConstructorCall&lt;T&gt; extends spoon.reflect.code.CtAbstractInvocation&lt;T&gt; , spoon.reflect.code.CtStatement , spoon.reflect.code.CtTargetedExpression&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; , spoon.reflect.reference.CtActualTypeContainer {&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    java.util.List&lt;spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; getActualTypeArguments();&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    &lt;T extends spoon.reflect.reference.CtActualTypeContainer&gt; T setActualTypeArguments(java.util.List&lt;? extends spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; actualTypeArguments);&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    &lt;T extends spoon.reflect.reference.CtActualTypeContainer&gt; T addActualTypeArgument(spoon.reflect.reference.CtTypeReference&lt;?&gt; actualTypeArgument);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtConstructorCall&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.TYPE)&#10;    spoon.reflect.reference.CtTypeReference&lt;T&gt; getType();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.011"/>
  <testcase name="testContract[public interface CtContinue extends spoon.reflect.code.CtLabelledFlowBreak {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtContinue clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtDo extends spoon.reflect.code.CtLoop {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; getLoopingExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtDo&gt; T setLoopingExpression(spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; expression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtDo clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtExecutableReferenceExpression&lt;T, E extends spoon.reflect.code.CtExpression&lt;?&gt;&gt; extends spoon.reflect.code.CtTargetedExpression&lt;T, E&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXECUTABLE_REF)&#10;    spoon.reflect.reference.CtExecutableReference&lt;T&gt; getExecutable();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXECUTABLE_REF)&#10;    &lt;C extends spoon.reflect.code.CtExecutableReferenceExpression&lt;T, E&gt;&gt; C setExecutable(spoon.reflect.reference.CtExecutableReference&lt;T&gt; executable);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtExecutableReferenceExpression&lt;T, E&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.008"/>
  <testcase name="testContract[public interface CtFieldRead&lt;T&gt; extends spoon.reflect.code.CtFieldAccess&lt;T&gt; , spoon.reflect.code.CtVariableRead&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtFieldRead&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.016"/>
  <testcase name="testContract[public interface CtFieldWrite&lt;T&gt; extends spoon.reflect.code.CtFieldAccess&lt;T&gt; , spoon.reflect.code.CtVariableWrite&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtFieldWrite&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.014"/>
  <testcase name="testContract[public interface CtFor extends spoon.reflect.code.CtLoop {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; getExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtFor&gt; T setExpression(spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.FOR_INIT)&#10;    java.util.List&lt;spoon.reflect.code.CtStatement&gt; getForInit();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOR_INIT)&#10;    &lt;T extends spoon.reflect.code.CtFor&gt; T addForInit(spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOR_INIT)&#10;    &lt;T extends spoon.reflect.code.CtFor&gt; T setForInit(java.util.List&lt;spoon.reflect.code.CtStatement&gt; forInit);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOR_INIT)&#10;    boolean removeForInit(spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.FOR_UPDATE)&#10;    java.util.List&lt;spoon.reflect.code.CtStatement&gt; getForUpdate();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOR_UPDATE)&#10;    &lt;T extends spoon.reflect.code.CtFor&gt; T addForUpdate(spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOR_UPDATE)&#10;    &lt;T extends spoon.reflect.code.CtFor&gt; T setForUpdate(java.util.List&lt;spoon.reflect.code.CtStatement&gt; forUpdate);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOR_UPDATE)&#10;    boolean removeForUpdate(spoon.reflect.code.CtStatement statement);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtFor clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.006"/>
  <testcase name="testContract[public interface CtForEach extends spoon.reflect.code.CtLoop {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;?&gt; getExpression();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.FOREACH_VARIABLE)&#10;    spoon.reflect.code.CtLocalVariable&lt;?&gt; getVariable();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtForEach&gt; T setExpression(spoon.reflect.code.CtExpression&lt;?&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FOREACH_VARIABLE)&#10;    &lt;T extends spoon.reflect.code.CtForEach&gt; T setVariable(spoon.reflect.code.CtLocalVariable&lt;?&gt; variable);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtForEach clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtIf extends spoon.reflect.code.CtStatement , spoon.template.TemplateParameter&lt;java.lang.Void&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONDITION)&#10;    spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; getCondition();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.ELSE)&#10;    &lt;S extends spoon.reflect.code.CtStatement&gt; S getElseStatement();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.THEN)&#10;    &lt;S extends spoon.reflect.code.CtStatement&gt; S getThenStatement();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONDITION)&#10;    &lt;T extends spoon.reflect.code.CtIf&gt; T setCondition(spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ELSE)&#10;    &lt;T extends spoon.reflect.code.CtIf&gt; T setElseStatement(spoon.reflect.code.CtStatement elseStatement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.THEN)&#10;    &lt;T extends spoon.reflect.code.CtIf&gt; T setThenStatement(spoon.reflect.code.CtStatement thenStatement);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtIf clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.003"/>
  <testcase name="testContract[public interface CtInvocation&lt;T&gt; extends spoon.reflect.code.CtAbstractInvocation&lt;T&gt; , spoon.reflect.code.CtStatement , spoon.reflect.code.CtTargetedExpression&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; , spoon.reflect.reference.CtActualTypeContainer {&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    java.util.List&lt;spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; getActualTypeArguments();&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    &lt;T extends spoon.reflect.reference.CtActualTypeContainer&gt; T setActualTypeArguments(java.util.List&lt;? extends spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; actualTypeArguments);&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    &lt;T extends spoon.reflect.reference.CtActualTypeContainer&gt; T addActualTypeArgument(spoon.reflect.reference.CtTypeReference&lt;?&gt; actualTypeArgument);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.TYPE)&#10;    spoon.reflect.reference.CtTypeReference&lt;T&gt; getType();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtInvocation&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.011"/>
  <testcase name="testContract[public interface CtJavaDoc extends spoon.reflect.code.CtComment {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.COMMENT_TAG)&#10;    java.util.List&lt;spoon.reflect.code.CtJavaDocTag&gt; getTags();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_TAG)&#10;    &lt;E extends spoon.reflect.code.CtJavaDoc&gt; E setTags(java.util.List&lt;spoon.reflect.code.CtJavaDocTag&gt; tags);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_TAG)&#10;    &lt;E extends spoon.reflect.code.CtJavaDoc&gt; E addTag(spoon.reflect.code.CtJavaDocTag tag);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_TAG)&#10;    &lt;E extends spoon.reflect.code.CtJavaDoc&gt; E addTag(int index, spoon.reflect.code.CtJavaDocTag tag);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_TAG)&#10;    &lt;E extends spoon.reflect.code.CtJavaDoc&gt; E removeTag(int index);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_TAG)&#10;    &lt;E extends spoon.reflect.code.CtJavaDoc&gt; E removeTag(spoon.reflect.code.CtJavaDocTag tag);&#10;&#10;    @spoon.support.DerivedProperty&#10;    java.lang.String getShortDescription();&#10;&#10;    @spoon.support.DerivedProperty&#10;    java.lang.String getLongDescription();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtJavaDoc clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtJavaDocTag extends spoon.reflect.declaration.CtElement {&#10;    java.lang.String JAVADOC_TAG_PREFIX = &quot;@&quot;;&#10;&#10;    enum TagType {&#10;        AUTHOR, DEPRECATED, EXCEPTION, PARAM, RETURN, SEE, SERIAL, SERIAL_DATA, SERIAL_FIELD, SINCE, THROWS, VERSION, UNKNOWN;&#10;        public boolean hasParam() {&#10;            return ((this) == (spoon.reflect.code.CtJavaDocTag.TagType.PARAM)) || ((this) == (spoon.reflect.code.CtJavaDocTag.TagType.THROWS));&#10;        }&#10;&#10;        public static spoon.reflect.code.CtJavaDocTag.TagType tagFromName(java.lang.String tagName) {&#10;            for (spoon.reflect.code.CtJavaDocTag.TagType t : spoon.reflect.code.CtJavaDocTag.TagType.values()) {&#10;                if (t.name().toLowerCase().equals(tagName.toLowerCase())) {&#10;                    return t;&#10;                }&#10;            }&#10;            return spoon.reflect.code.CtJavaDocTag.TagType.UNKNOWN;&#10;        }&#10;&#10;        @java.lang.Override&#10;        public java.lang.String toString() {&#10;            return (spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX) + (name().toLowerCase());&#10;        }&#10;    }&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.DOCUMENTATION_TYPE)&#10;    spoon.reflect.code.CtJavaDocTag.TagType getType();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.DOCUMENTATION_TYPE)&#10;    &lt;E extends spoon.reflect.code.CtJavaDocTag&gt; E setType(java.lang.String type);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.DOCUMENTATION_TYPE)&#10;    &lt;E extends spoon.reflect.code.CtJavaDocTag&gt; E setType(spoon.reflect.code.CtJavaDocTag.TagType type);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.COMMENT_CONTENT)&#10;    java.lang.String getContent();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.COMMENT_CONTENT)&#10;    &lt;E extends spoon.reflect.code.CtJavaDocTag&gt; E setContent(java.lang.String content);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.JAVADOC_TAG_VALUE)&#10;    java.lang.String getParam();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.JAVADOC_TAG_VALUE)&#10;    &lt;E extends spoon.reflect.code.CtJavaDocTag&gt; E setParam(java.lang.String param);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtJavaDocTag clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtLambda&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; , spoon.reflect.declaration.CtExecutable&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getExpression();&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;R&gt; spoon.reflect.declaration.CtMethod&lt;R&gt; getOverriddenMethod();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;C extends spoon.reflect.code.CtLambda&lt;T&gt;&gt; C setExpression(spoon.reflect.code.CtExpression&lt;T&gt; expression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtLambda&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T1 extends spoon.reflect.declaration.CtExecutable&lt;T&gt;&gt; T1 setThrownTypes(java.util.Set&lt;spoon.reflect.reference.CtTypeReference&lt;? extends java.lang.Throwable&gt;&gt; thrownTypes);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.018"/>
  <testcase name="testContract[public interface CtLiteral&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    T getValue();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;C extends spoon.reflect.code.CtLiteral&lt;T&gt;&gt; C setValue(T value);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtLiteral&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.007"/>
  <testcase name="testContract[public interface CtLocalVariable&lt;T&gt; extends spoon.reflect.code.CtRHSReceiver&lt;T&gt; , spoon.reflect.code.CtStatement , spoon.reflect.declaration.CtVariable&lt;T&gt; {&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtLocalVariableReference&lt;T&gt; getReference();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getAssignment();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtLocalVariable&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.01"/>
  <testcase name="testContract[public interface CtNewArray&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.DIMENSION)&#10;    java.util.List&lt;spoon.reflect.code.CtExpression&lt;java.lang.Integer&gt;&gt; getDimensionExpressions();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.DIMENSION)&#10;    &lt;C extends spoon.reflect.code.CtNewArray&lt;T&gt;&gt; C setDimensionExpressions(java.util.List&lt;spoon.reflect.code.CtExpression&lt;java.lang.Integer&gt;&gt; dimensions);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.DIMENSION)&#10;    &lt;C extends spoon.reflect.code.CtNewArray&lt;T&gt;&gt; C addDimensionExpression(spoon.reflect.code.CtExpression&lt;java.lang.Integer&gt; dimension);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.DIMENSION)&#10;    boolean removeDimensionExpression(spoon.reflect.code.CtExpression&lt;java.lang.Integer&gt; dimension);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    java.util.List&lt;spoon.reflect.code.CtExpression&lt;?&gt;&gt; getElements();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;C extends spoon.reflect.code.CtNewArray&lt;T&gt;&gt; C setElements(java.util.List&lt;spoon.reflect.code.CtExpression&lt;?&gt;&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;C extends spoon.reflect.code.CtNewArray&lt;T&gt;&gt; C addElement(spoon.reflect.code.CtExpression&lt;?&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    boolean removeElement(spoon.reflect.code.CtExpression&lt;?&gt; expression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtNewArray&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.008"/>
  <testcase name="testContract[public interface CtNewClass&lt;T&gt; extends spoon.reflect.code.CtConstructorCall&lt;T&gt; {&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    java.util.List&lt;spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; getActualTypeArguments();&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    &lt;T extends spoon.reflect.reference.CtActualTypeContainer&gt; T setActualTypeArguments(java.util.List&lt;? extends spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; actualTypeArguments);&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TYPE_ARGUMENT)&#10;    &lt;T extends spoon.reflect.reference.CtActualTypeContainer&gt; T addActualTypeArgument(spoon.reflect.reference.CtTypeReference&lt;?&gt; actualTypeArgument);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.NESTED_TYPE)&#10;    spoon.reflect.declaration.CtClass&lt;?&gt; getAnonymousClass();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.NESTED_TYPE)&#10;    &lt;N extends spoon.reflect.code.CtNewClass&gt; N setAnonymousClass(spoon.reflect.declaration.CtClass&lt;?&gt; anonymousClass);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtNewClass&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.015"/>
  <testcase name="testContract[public interface CtOperatorAssignment&lt;T, A extends T&gt; extends spoon.reflect.code.CtAssignment&lt;T, A&gt; {&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPERATOR_KIND)&#10;    &lt;C extends spoon.reflect.code.CtOperatorAssignment&lt;T, A&gt;&gt; C setKind(spoon.reflect.code.BinaryOperatorKind kind);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.OPERATOR_KIND)&#10;    spoon.reflect.code.BinaryOperatorKind getKind();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtOperatorAssignment&lt;T, A&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.009"/>
  <testcase name="testContract[public interface CtReturn&lt;R&gt; extends spoon.reflect.code.CtCFlowBreak , spoon.template.TemplateParameter&lt;java.lang.Void&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;R&gt; getReturnedExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtReturn&lt;R&gt;&gt; T setReturnedExpression(spoon.reflect.code.CtExpression&lt;R&gt; returnedExpression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtReturn&lt;R&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtStatementList extends java.lang.Iterable&lt;spoon.reflect.code.CtStatement&gt; , spoon.reflect.code.CtCodeElement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    java.util.List&lt;spoon.reflect.code.CtStatement&gt; getStatements();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T setStatements(java.util.List&lt;spoon.reflect.code.CtStatement&gt; statements);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T addStatement(spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T addStatement(int index, spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertBegin(spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertBegin(spoon.reflect.code.CtStatementList statements);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertEnd(spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertEnd(spoon.reflect.code.CtStatementList statements);&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertBefore(spoon.reflect.visitor.Filter&lt;? extends spoon.reflect.code.CtStatement&gt; insertionPoints, spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertBefore(spoon.reflect.visitor.Filter&lt;? extends spoon.reflect.code.CtStatement&gt; insertionPoints, spoon.reflect.code.CtStatementList statements);&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertAfter(spoon.reflect.visitor.Filter&lt;? extends spoon.reflect.code.CtStatement&gt; insertionPoints, spoon.reflect.code.CtStatement statement);&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.code.CtStatementList&gt; T insertAfter(spoon.reflect.visitor.Filter&lt;? extends spoon.reflect.code.CtStatement&gt; insertionPoints, spoon.reflect.code.CtStatementList statements);&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.code.CtStatement&gt; T getStatement(int i);&#10;&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.code.CtStatement&gt; T getLastStatement();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.STATEMENT)&#10;    void removeStatement(spoon.reflect.code.CtStatement statement);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtStatementList clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtSuperAccess&lt;T&gt; extends spoon.reflect.code.CtTargetedExpression&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; , spoon.reflect.code.CtVariableRead&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtSuperAccess&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtTypeReference&lt;T&gt; getType();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.013"/>
  <testcase name="testContract[public interface CtSwitch&lt;S&gt; extends spoon.reflect.code.CtStatement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;S&gt; getSelector();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtSwitch&lt;S&gt;&gt; T setSelector(spoon.reflect.code.CtExpression&lt;S&gt; selector);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CASE)&#10;    java.util.List&lt;spoon.reflect.code.CtCase&lt;? super S&gt;&gt; getCases();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CASE)&#10;    &lt;T extends spoon.reflect.code.CtSwitch&lt;S&gt;&gt; T setCases(java.util.List&lt;spoon.reflect.code.CtCase&lt;? super S&gt;&gt; cases);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CASE)&#10;    &lt;T extends spoon.reflect.code.CtSwitch&lt;S&gt;&gt; T addCase(spoon.reflect.code.CtCase&lt;? super S&gt; c);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CASE)&#10;    boolean removeCase(spoon.reflect.code.CtCase&lt;? super S&gt; c);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtSwitch&lt;S&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtSynchronized extends spoon.reflect.code.CtStatement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;?&gt; getExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtSynchronized&gt; T setExpression(spoon.reflect.code.CtExpression&lt;?&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.BODY)&#10;    spoon.reflect.code.CtBlock&lt;?&gt; getBlock();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.BODY)&#10;    &lt;T extends spoon.reflect.code.CtSynchronized&gt; T setBlock(spoon.reflect.code.CtBlock&lt;?&gt; block);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtSynchronized clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.003"/>
  <testcase name="testContract[public interface CtThisAccess&lt;T&gt; extends spoon.reflect.code.CtTargetedExpression&lt;T, spoon.reflect.code.CtExpression&lt;?&gt;&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtThisAccess&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.007"/>
  <testcase name="testContract[public interface CtThrow extends spoon.reflect.code.CtCFlowBreak , spoon.template.TemplateParameter&lt;java.lang.Void&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;? extends java.lang.Throwable&gt; getThrownExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtThrow&gt; T setThrownExpression(spoon.reflect.code.CtExpression&lt;? extends java.lang.Throwable&gt; thrownExpression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtThrow clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.003"/>
  <testcase name="testContract[public interface CtTry extends spoon.reflect.code.CtBodyHolder , spoon.reflect.code.CtStatement , spoon.template.TemplateParameter&lt;java.lang.Void&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CATCH)&#10;    java.util.List&lt;spoon.reflect.code.CtCatch&gt; getCatchers();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CATCH)&#10;    &lt;T extends spoon.reflect.code.CtTry&gt; T setCatchers(java.util.List&lt;spoon.reflect.code.CtCatch&gt; catchers);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CATCH)&#10;    &lt;T extends spoon.reflect.code.CtTry&gt; T addCatcher(spoon.reflect.code.CtCatch catcher);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CATCH)&#10;    boolean removeCatcher(spoon.reflect.code.CtCatch catcher);&#10;&#10;    @java.lang.Override&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.BODY)&#10;    spoon.reflect.code.CtBlock&lt;?&gt; getBody();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.FINALIZER)&#10;    spoon.reflect.code.CtBlock&lt;?&gt; getFinalizer();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.FINALIZER)&#10;    &lt;T extends spoon.reflect.code.CtTry&gt; T setFinalizer(spoon.reflect.code.CtBlock&lt;?&gt; finalizer);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtTry clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtTryWithResource extends spoon.reflect.code.CtTry {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.TRY_RESOURCE)&#10;    java.util.List&lt;spoon.reflect.code.CtLocalVariable&lt;?&gt;&gt; getResources();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TRY_RESOURCE)&#10;    &lt;T extends spoon.reflect.code.CtTryWithResource&gt; T setResources(java.util.List&lt;spoon.reflect.code.CtLocalVariable&lt;?&gt;&gt; resources);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TRY_RESOURCE)&#10;    &lt;T extends spoon.reflect.code.CtTryWithResource&gt; T addResource(spoon.reflect.code.CtLocalVariable&lt;?&gt; resource);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.TRY_RESOURCE)&#10;    boolean removeResource(spoon.reflect.code.CtLocalVariable&lt;?&gt; resource);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtTryWithResource clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.009"/>
  <testcase name="testContract[public interface CtTypeAccess&lt;A&gt; extends spoon.reflect.code.CtExpression&lt;java.lang.Void&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.ACCESSED_TYPE)&#10;    spoon.reflect.reference.CtTypeReference&lt;A&gt; getAccessedType();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ACCESSED_TYPE)&#10;    &lt;C extends spoon.reflect.code.CtTypeAccess&lt;A&gt;&gt; C setAccessedType(spoon.reflect.reference.CtTypeReference&lt;A&gt; accessedType);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtTypeReference&lt;java.lang.Void&gt; getType();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtTypedElement&gt; C setType(spoon.reflect.reference.CtTypeReference&lt;java.lang.Void&gt; type);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtTypeAccess&lt;A&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.008"/>
  <testcase name="testContract[public interface CtUnaryOperator&lt;T&gt; extends spoon.reflect.code.CtExpression&lt;T&gt; , spoon.reflect.code.CtStatement {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getOperand();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;C extends spoon.reflect.code.CtUnaryOperator&gt; C setOperand(spoon.reflect.code.CtExpression&lt;T&gt; expression);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPERATOR_KIND)&#10;    &lt;C extends spoon.reflect.code.CtUnaryOperator&gt; C setKind(spoon.reflect.code.UnaryOperatorKind kind);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.OPERATOR_KIND)&#10;    spoon.reflect.code.UnaryOperatorKind getKind();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtUnaryOperator&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.01"/>
  <testcase name="testContract[public interface CtVariableRead&lt;T&gt; extends spoon.reflect.code.CtVariableAccess&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtVariableRead&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.009"/>
  <testcase name="testContract[public interface CtVariableWrite&lt;T&gt; extends spoon.reflect.code.CtVariableAccess&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtVariableWrite&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.009"/>
  <testcase name="testContract[public interface CtWhile extends spoon.reflect.code.CtLoop {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; getLoopingExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPRESSION)&#10;    &lt;T extends spoon.reflect.code.CtWhile&gt; T setLoopingExpression(spoon.reflect.code.CtExpression&lt;java.lang.Boolean&gt; expression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.code.CtWhile clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtAnnotation&lt;A extends java.lang.annotation.Annotation&gt; extends spoon.reflect.code.CtExpression&lt;A&gt; , spoon.reflect.declaration.CtShadowable {&#10;    @spoon.support.DerivedProperty&#10;    A getActualAnnotation();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.ANNOTATION_TYPE)&#10;    spoon.reflect.reference.CtTypeReference&lt;A&gt; getAnnotationType();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.code.CtExpression&gt; T getValue(java.lang.String key);&#10;&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.code.CtExpression&gt; T getWrappedValue(java.lang.String key);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    java.util.Map&lt;java.lang.String, spoon.reflect.code.CtExpression&gt; getValues();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ANNOTATION_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T setAnnotationType(spoon.reflect.reference.CtTypeReference&lt;? extends java.lang.annotation.Annotation&gt; type);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T setElementValues(java.util.Map&lt;java.lang.String, java.lang.Object&gt; values);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T setValues(java.util.Map&lt;java.lang.String, spoon.reflect.code.CtExpression&gt; values);&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtElement getAnnotatedElement();&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtAnnotatedElementType getAnnotatedElementType();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T addValue(java.lang.String elementName, java.lang.Object value);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T addValue(java.lang.String elementName, spoon.reflect.code.CtLiteral&lt;?&gt; value);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T addValue(java.lang.String elementName, spoon.reflect.code.CtNewArray&lt;? extends spoon.reflect.code.CtExpression&gt; value);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T addValue(java.lang.String elementName, spoon.reflect.code.CtFieldAccess&lt;?&gt; value);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;T extends spoon.reflect.declaration.CtAnnotation&lt;A&gt;&gt; T addValue(java.lang.String elementName, spoon.reflect.declaration.CtAnnotation&lt;?&gt; value);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtAnnotation&lt;A&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.code.CtExpression&lt;A&gt;&gt; C setTypeCasts(java.util.List&lt;spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; types);&#10;&#10;    static spoon.reflect.declaration.CtAnnotatedElementType getAnnotatedElementTypeForCtElement(spoon.reflect.declaration.CtElement element) {&#10;        if (element == null) {&#10;            return null;&#10;        }&#10;        if (element instanceof spoon.reflect.declaration.CtMethod) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.METHOD;&#10;        }&#10;        if ((element instanceof spoon.reflect.declaration.CtAnnotation) || (element instanceof spoon.reflect.declaration.CtAnnotationType)) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.ANNOTATION_TYPE;&#10;        }&#10;        if (element instanceof spoon.reflect.declaration.CtType) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.TYPE;&#10;        }&#10;        if (element instanceof spoon.reflect.declaration.CtField) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.FIELD;&#10;        }&#10;        if (element instanceof spoon.reflect.declaration.CtConstructor) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.CONSTRUCTOR;&#10;        }&#10;        if (element instanceof spoon.reflect.declaration.CtParameter) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.PARAMETER;&#10;        }&#10;        if (element instanceof spoon.reflect.code.CtLocalVariable) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.LOCAL_VARIABLE;&#10;        }&#10;        if (element instanceof spoon.reflect.declaration.CtPackage) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.PACKAGE;&#10;        }&#10;        if (element instanceof spoon.reflect.reference.CtTypeParameterReference) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.TYPE_PARAMETER;&#10;        }&#10;        if (element instanceof spoon.reflect.reference.CtTypeReference) {&#10;            return spoon.reflect.declaration.CtAnnotatedElementType.TYPE_USE;&#10;        }&#10;        return null;&#10;    }&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.012"/>
  <testcase name="testContract[public interface CtAnnotationMethod&lt;T&gt; extends spoon.reflect.declaration.CtMethod&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.DEFAULT_EXPRESSION)&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getDefaultExpression();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.DEFAULT_EXPRESSION)&#10;    &lt;C extends spoon.reflect.declaration.CtAnnotationMethod&lt;T&gt;&gt; C setDefaultExpression(spoon.reflect.code.CtExpression&lt;T&gt; assignedExpression);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtAnnotationMethod&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T1 extends spoon.reflect.code.CtBodyHolder&gt; T1 setBody(spoon.reflect.code.CtStatement body);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T1 extends spoon.reflect.declaration.CtExecutable&lt;T&gt;&gt; T1 setThrownTypes(java.util.Set&lt;spoon.reflect.reference.CtTypeReference&lt;? extends java.lang.Throwable&gt;&gt; thrownTypes);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T extends spoon.reflect.declaration.CtFormalTypeDeclarer&gt; T setFormalCtTypeParameters(java.util.List&lt;spoon.reflect.declaration.CtTypeParameter&gt; formalTypeParameters);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T1 extends spoon.reflect.declaration.CtExecutable&lt;T&gt;&gt; T1 setParameters(java.util.List&lt;spoon.reflect.declaration.CtParameter&lt;?&gt;&gt; parameters);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.019"/>
  <testcase name="testContract[public interface CtAnnotationType&lt;T extends java.lang.annotation.Annotation&gt; extends spoon.reflect.declaration.CtType&lt;T&gt; {&#10;    @spoon.support.DerivedProperty&#10;    java.util.Set&lt;spoon.reflect.declaration.CtAnnotationMethod&lt;?&gt;&gt; getAnnotationMethods();&#10;&#10;    @java.lang.Override&#10;    &lt;M, C extends spoon.reflect.declaration.CtType&lt;T&gt;&gt; C addMethod(spoon.reflect.declaration.CtMethod&lt;M&gt; method);&#10;&#10;    @java.lang.Override&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;T&gt;&gt; C setMethods(java.util.Set&lt;spoon.reflect.declaration.CtMethod&lt;?&gt;&gt; methods);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtAnnotationType&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T extends spoon.reflect.declaration.CtFormalTypeDeclarer&gt; T setFormalCtTypeParameters(java.util.List&lt;spoon.reflect.declaration.CtTypeParameter&gt; formalTypeParameters);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;T&gt;&gt; C setSuperInterfaces(java.util.Set&lt;spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; interfaces);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;T&gt;&gt; C setSuperclass(spoon.reflect.reference.CtTypeReference&lt;?&gt; superClass);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.018"/>
  <testcase name="testContract[public interface CtAnonymousExecutable extends spoon.reflect.declaration.CtExecutable&lt;java.lang.Void&gt; , spoon.reflect.declaration.CtTypeMember {&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtAnonymousExecutable clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T extends spoon.reflect.declaration.CtExecutable&lt;java.lang.Void&gt;&gt; T setThrownTypes(java.util.Set&lt;spoon.reflect.reference.CtTypeReference&lt;? extends java.lang.Throwable&gt;&gt; thrownTypes);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T extends spoon.reflect.declaration.CtExecutable&lt;java.lang.Void&gt;&gt; T setParameters(java.util.List&lt;spoon.reflect.declaration.CtParameter&lt;?&gt;&gt; parameters);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtTypedElement&gt; C setType(spoon.reflect.reference.CtTypeReference&lt;java.lang.Void&gt; type);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.013"/>
  <testcase name="testContract[public interface CtClass&lt;T extends java.lang.Object&gt; extends spoon.reflect.code.CtStatement , spoon.reflect.declaration.CtType&lt;T&gt; {&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)&#10;    java.util.List&lt;spoon.reflect.declaration.CtAnonymousExecutable&gt; getAnonymousExecutables();&#10;&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONSTRUCTOR)&#10;    spoon.reflect.declaration.CtConstructor&lt;T&gt; getConstructor(spoon.reflect.reference.CtTypeReference&lt;?&gt;... parameterTypes);&#10;&#10;    @spoon.support.DerivedProperty&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONSTRUCTOR)&#10;    java.util.Set&lt;spoon.reflect.declaration.CtConstructor&lt;T&gt;&gt; getConstructors();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)&#10;    &lt;C extends spoon.reflect.declaration.CtClass&lt;T&gt;&gt; C setAnonymousExecutables(java.util.List&lt;spoon.reflect.declaration.CtAnonymousExecutable&gt; e);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)&#10;    &lt;C extends spoon.reflect.declaration.CtClass&lt;T&gt;&gt; C addAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable e);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE)&#10;    boolean removeAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable e);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONSTRUCTOR)&#10;    &lt;C extends spoon.reflect.declaration.CtClass&lt;T&gt;&gt; C setConstructors(java.util.Set&lt;spoon.reflect.declaration.CtConstructor&lt;T&gt;&gt; constructors);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONSTRUCTOR)&#10;    &lt;C extends spoon.reflect.declaration.CtClass&lt;T&gt;&gt; C addConstructor(spoon.reflect.declaration.CtConstructor&lt;T&gt; constructor);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONSTRUCTOR)&#10;    void removeConstructor(spoon.reflect.declaration.CtConstructor&lt;T&gt; constructor);&#10;&#10;    boolean isAnonymous();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtClass&lt;T&gt; clone();&#10;&#10;    T newInstance();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.022"/>
  <testcase name="testContract[public interface CtConstructor&lt;T&gt; extends spoon.reflect.declaration.CtExecutable&lt;T&gt; , spoon.reflect.declaration.CtFormalTypeDeclarer , spoon.reflect.declaration.CtShadowable , spoon.reflect.declaration.CtTypeMember {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.NAME)&#10;    java.lang.String getSimpleName();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtConstructor&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtTypedElement&gt; C setType(spoon.reflect.reference.CtTypeReference&lt;T&gt; type);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.017"/>
  <testcase name="testContract[public interface CtEnum&lt;T extends java.lang.Enum&lt;?&gt;&gt; extends spoon.reflect.declaration.CtClass&lt;T&gt; {&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;C extends spoon.reflect.declaration.CtEnum&lt;T&gt;&gt; C addEnumValue(spoon.reflect.declaration.CtEnumValue&lt;?&gt; enumValue);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    boolean removeEnumValue(spoon.reflect.declaration.CtEnumValue&lt;?&gt; enumValue);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    spoon.reflect.declaration.CtEnumValue&lt;?&gt; getEnumValue(java.lang.String name);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    java.util.List&lt;spoon.reflect.declaration.CtEnumValue&lt;?&gt;&gt; getEnumValues();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.VALUE)&#10;    &lt;C extends spoon.reflect.declaration.CtEnum&lt;T&gt;&gt; C setEnumValues(java.util.List&lt;spoon.reflect.declaration.CtEnumValue&lt;?&gt;&gt; enumValues);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtEnum&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T extends spoon.reflect.declaration.CtFormalTypeDeclarer&gt; T setFormalCtTypeParameters(java.util.List&lt;spoon.reflect.declaration.CtTypeParameter&gt; formalTypeParameters);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;T&gt;&gt; C setSuperclass(spoon.reflect.reference.CtTypeReference&lt;?&gt; superClass);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.024"/>
  <testcase name="testContract[public interface CtEnumValue&lt;T&gt; extends spoon.reflect.declaration.CtField&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtEnumValue clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.011"/>
  <testcase name="testContract[public interface CtField&lt;T&gt; extends spoon.reflect.code.CtRHSReceiver&lt;T&gt; , spoon.reflect.declaration.CtShadowable , spoon.reflect.declaration.CtTypeMember , spoon.reflect.declaration.CtVariable&lt;T&gt; {&#10;    java.lang.String FIELD_SEPARATOR = &quot;#&quot;;&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtFieldReference&lt;T&gt; getReference();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.code.CtExpression&lt;T&gt; getAssignment();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtField&lt;T&gt; clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.009"/>
  <testcase name="testContract[public interface CtImport extends spoon.reflect.declaration.CtElement {&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtImportKind getImportKind();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.IMPORT_REFERENCE)&#10;    spoon.reflect.reference.CtReference getReference();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.IMPORT_REFERENCE)&#10;    &lt;T extends spoon.reflect.declaration.CtImport&gt; T setReference(spoon.reflect.reference.CtReference reference);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtImport clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.003"/>
  <testcase name="testContract[public interface CtInterface&lt;T&gt; extends spoon.reflect.declaration.CtType&lt;T&gt; {&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtInterface&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;T&gt;&gt; C setSuperclass(spoon.reflect.reference.CtTypeReference&lt;?&gt; superClass);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.016"/>
  <testcase name="testContract[public interface CtMethod&lt;T&gt; extends spoon.reflect.declaration.CtExecutable&lt;T&gt; , spoon.reflect.declaration.CtFormalTypeDeclarer , spoon.reflect.declaration.CtShadowable , spoon.reflect.declaration.CtTypeMember {&#10;    boolean isOverriding(spoon.reflect.declaration.CtMethod&lt;?&gt; superMethod);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.IS_DEFAULT)&#10;    boolean isDefaultMethod();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.IS_DEFAULT)&#10;    &lt;C extends spoon.reflect.declaration.CtMethod&lt;T&gt;&gt; C setDefaultMethod(boolean defaultMethod);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtMethod&lt;T&gt; clone();&#10;&#10;    java.util.Collection&lt;spoon.reflect.declaration.CtMethod&lt;?&gt;&gt; getTopDefinitions();&#10;&#10;    spoon.reflect.declaration.CtMethod&lt;?&gt; copyMethod();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.015"/>
  <testcase name="testContract[public interface CtModule extends spoon.reflect.declaration.CtNamedElement {&#10;    java.lang.String TOP_LEVEL_MODULE_NAME = &quot;unnamed module&quot;;&#10;&#10;    @spoon.support.DerivedProperty&#10;    boolean isUnnamedModule();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.MODIFIER)&#10;    boolean isOpenModule();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODIFIER)&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setIsOpenModule(boolean openModule);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_DIRECTIVE)&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setModuleDirectives(java.util.List&lt;spoon.reflect.declaration.CtModuleDirective&gt; moduleDirectives);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_DIRECTIVE)&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addModuleDirective(spoon.reflect.declaration.CtModuleDirective moduleDirective);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_DIRECTIVE)&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addModuleDirectiveAt(int position, spoon.reflect.declaration.CtModuleDirective moduleDirective);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.MODULE_DIRECTIVE)&#10;    java.util.List&lt;spoon.reflect.declaration.CtModuleDirective&gt; getModuleDirectives();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_DIRECTIVE)&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T removeModuleDirective(spoon.reflect.declaration.CtModuleDirective moduleDirective);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    @spoon.support.DerivedProperty&#10;    java.util.List&lt;spoon.reflect.declaration.CtUsedService&gt; getUsedServices();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setUsedServices(java.util.List&lt;spoon.reflect.declaration.CtUsedService&gt; usedServices);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addUsedService(spoon.reflect.declaration.CtUsedService usedService);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T removeUsedService(spoon.reflect.declaration.CtUsedService usedService);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.EXPORTED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    java.util.List&lt;spoon.reflect.declaration.CtPackageExport&gt; getExportedPackages();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPORTED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setExportedPackages(java.util.List&lt;spoon.reflect.declaration.CtPackageExport&gt; exportedPackages);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPORTED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addExportedPackage(spoon.reflect.declaration.CtPackageExport exportedPackage);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.EXPORTED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T removeExportedPackage(spoon.reflect.declaration.CtPackageExport exportedPackage);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.OPENED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    java.util.List&lt;spoon.reflect.declaration.CtPackageExport&gt; getOpenedPackages();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPENED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setOpenedPackages(java.util.List&lt;spoon.reflect.declaration.CtPackageExport&gt; openedPackages);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPENED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addOpenedPackage(spoon.reflect.declaration.CtPackageExport openedPackage);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPENED_PACKAGE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T removeOpenedPackage(spoon.reflect.declaration.CtPackageExport openedPackage);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.REQUIRED_MODULE)&#10;    @spoon.support.DerivedProperty&#10;    java.util.List&lt;spoon.reflect.declaration.CtModuleRequirement&gt; getRequiredModules();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.REQUIRED_MODULE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setRequiredModules(java.util.List&lt;spoon.reflect.declaration.CtModuleRequirement&gt; requiredModules);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.REQUIRED_MODULE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addRequiredModule(spoon.reflect.declaration.CtModuleRequirement requiredModule);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.REQUIRED_MODULE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T removeRequiredModule(spoon.reflect.declaration.CtModuleRequirement requiredModule);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.PROVIDED_SERVICE)&#10;    @spoon.support.DerivedProperty&#10;    java.util.List&lt;spoon.reflect.declaration.CtProvidedService&gt; getProvidedServices();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.PROVIDED_SERVICE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setProvidedServices(java.util.List&lt;spoon.reflect.declaration.CtProvidedService&gt; providedServices);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.PROVIDED_SERVICE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T addProvidedService(spoon.reflect.declaration.CtProvidedService providedService);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.PROVIDED_SERVICE)&#10;    @spoon.support.DerivedProperty&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T removeProvidedService(spoon.reflect.declaration.CtProvidedService providedService);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    spoon.reflect.declaration.CtPackage getRootPackage();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    &lt;T extends spoon.reflect.declaration.CtModule&gt; T setRootPackage(spoon.reflect.declaration.CtPackage rootPackage);&#10;&#10;    @spoon.support.DerivedProperty&#10;    @java.lang.Override&#10;    spoon.reflect.reference.CtModuleReference getReference();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtModule clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.008"/>
  <testcase name="testContract[public interface CtModuleRequirement extends spoon.reflect.declaration.CtModuleDirective {&#10;    enum RequiresModifier {&#10;        STATIC, TRANSITIVE;}&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.MODIFIER)&#10;    java.util.Set&lt;spoon.reflect.declaration.CtModuleRequirement.RequiresModifier&gt; getRequiresModifiers();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODIFIER)&#10;    &lt;T extends spoon.reflect.declaration.CtModuleRequirement&gt; T setRequiresModifiers(java.util.Set&lt;spoon.reflect.declaration.CtModuleRequirement.RequiresModifier&gt; requiresModifiers);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.MODULE_REF)&#10;    spoon.reflect.reference.CtModuleReference getModuleReference();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_REF)&#10;    &lt;T extends spoon.reflect.declaration.CtModuleRequirement&gt; T setModuleReference(spoon.reflect.reference.CtModuleReference moduleReference);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtModuleRequirement clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.003"/>
  <testcase name="testContract[public interface CtPackage extends spoon.reflect.declaration.CtNamedElement , spoon.reflect.declaration.CtShadowable {&#10;    java.lang.String PACKAGE_SEPARATOR = &quot;.&quot;;&#10;&#10;    char PACKAGE_SEPARATOR_CHAR = &apos;.&apos;;&#10;&#10;    java.lang.String TOP_LEVEL_PACKAGE_NAME = &quot;unnamed package&quot;;&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtModule getDeclaringModule();&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtPackage getDeclaringPackage();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    spoon.reflect.declaration.CtPackage getPackage(java.lang.String name);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    java.util.Set&lt;spoon.reflect.declaration.CtPackage&gt; getPackages();&#10;&#10;    java.lang.String getQualifiedName();&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtPackageReference getReference();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONTAINED_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtType&lt;?&gt;&gt; T getType(java.lang.String simpleName);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.CONTAINED_TYPE)&#10;    java.util.Set&lt;spoon.reflect.declaration.CtType&lt;?&gt;&gt; getTypes();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONTAINED_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtPackage&gt; T addType(spoon.reflect.declaration.CtType&lt;?&gt; type);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONTAINED_TYPE)&#10;    void removeType(spoon.reflect.declaration.CtType&lt;?&gt; type);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    &lt;T extends spoon.reflect.declaration.CtPackage&gt; T setPackages(java.util.Set&lt;spoon.reflect.declaration.CtPackage&gt; pack);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    &lt;T extends spoon.reflect.declaration.CtPackage&gt; T addPackage(spoon.reflect.declaration.CtPackage pack);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SUB_PACKAGE)&#10;    boolean removePackage(spoon.reflect.declaration.CtPackage pack);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.CONTAINED_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtPackage&gt; T setTypes(java.util.Set&lt;spoon.reflect.declaration.CtType&lt;?&gt;&gt; types);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtPackage clone();&#10;&#10;    boolean isUnnamedPackage();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtPackageExport extends spoon.reflect.declaration.CtModuleDirective {&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.OPENED_PACKAGE)&#10;    &lt;T extends spoon.reflect.declaration.CtPackageExport&gt; T setOpenedPackage(boolean openedPackage);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.OPENED_PACKAGE)&#10;    boolean isOpenedPackage();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.PACKAGE_REF)&#10;    spoon.reflect.reference.CtPackageReference getPackageReference();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.PACKAGE_REF)&#10;    &lt;T extends spoon.reflect.declaration.CtPackageExport&gt; T setPackageReference(spoon.reflect.reference.CtPackageReference packageReference);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.MODULE_REF)&#10;    java.util.List&lt;spoon.reflect.reference.CtModuleReference&gt; getTargetExport();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_REF)&#10;    &lt;T extends spoon.reflect.declaration.CtPackageExport&gt; T setTargetExport(java.util.List&lt;spoon.reflect.reference.CtModuleReference&gt; targetExport);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.MODULE_REF)&#10;    &lt;T extends spoon.reflect.declaration.CtPackageExport&gt; T addTargetExport(spoon.reflect.reference.CtModuleReference targetExport);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtPackageExport clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.005"/>
  <testcase name="testContract[public interface CtParameter&lt;T&gt; extends spoon.reflect.declaration.CtShadowable , spoon.reflect.declaration.CtVariable&lt;T&gt; {&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtExecutable&lt;?&gt; getParent();&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.IS_VARARGS)&#10;    boolean isVarArgs();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.IS_VARARGS)&#10;    &lt;C extends spoon.reflect.declaration.CtParameter&lt;T&gt;&gt; C setVarArgs(boolean varArgs);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtParameterReference&lt;T&gt; getReference();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtParameter&lt;T&gt; clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtVariable&lt;T&gt;&gt; C setDefaultExpression(spoon.reflect.code.CtExpression&lt;T&gt; assignedExpression);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.007"/>
  <testcase name="testContract[public interface CtProvidedService extends spoon.reflect.declaration.CtModuleDirective {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    spoon.reflect.reference.CtTypeReference getServiceType();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtProvidedService&gt; T setServiceType(spoon.reflect.reference.CtTypeReference providingType);&#10;&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.IMPLEMENTATION_TYPE)&#10;    java.util.List&lt;spoon.reflect.reference.CtTypeReference&gt; getImplementationTypes();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.IMPLEMENTATION_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtProvidedService&gt; T setImplementationTypes(java.util.List&lt;spoon.reflect.reference.CtTypeReference&gt; usedTypes);&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.IMPLEMENTATION_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtProvidedService&gt; T addImplementationType(spoon.reflect.reference.CtTypeReference usedType);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtProvidedService clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
  <testcase name="testContract[public interface CtTypeParameter extends spoon.reflect.declaration.CtType&lt;java.lang.Object&gt; {&#10;    @java.lang.Override&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.reference.CtTypeParameterReference getReference();&#10;&#10;    @spoon.support.DerivedProperty&#10;    spoon.reflect.declaration.CtFormalTypeDeclarer getTypeParameterDeclarer();&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtTypeParameter clone();&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;T extends spoon.reflect.declaration.CtFormalTypeDeclarer&gt; T setFormalCtTypeParameters(java.util.List&lt;spoon.reflect.declaration.CtTypeParameter&gt; formalTypeParameters);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;java.lang.Object&gt;&gt; C setSuperInterfaces(java.util.Set&lt;spoon.reflect.reference.CtTypeReference&lt;?&gt;&gt; interfaces);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;java.lang.Object&gt;&gt; C setTypeMembers(java.util.List&lt;spoon.reflect.declaration.CtTypeMember&gt; members);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;java.lang.Object&gt;&gt; C setFields(java.util.List&lt;spoon.reflect.declaration.CtField&lt;?&gt;&gt; fields);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;java.lang.Object&gt;&gt; C setMethods(java.util.Set&lt;spoon.reflect.declaration.CtMethod&lt;?&gt;&gt; methods);&#10;&#10;    @java.lang.Override&#10;    @spoon.support.UnsettableProperty&#10;    &lt;C extends spoon.reflect.declaration.CtType&lt;java.lang.Object&gt;&gt; C setNestedTypes(java.util.Set&lt;spoon.reflect.declaration.CtType&lt;?&gt;&gt; nestedTypes);&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.017"/>
  <testcase name="testContract[public interface CtUsedService extends spoon.reflect.declaration.CtModuleDirective {&#10;    @spoon.reflect.annotations.PropertyGetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    spoon.reflect.reference.CtTypeReference getServiceType();&#10;&#10;    @spoon.reflect.annotations.PropertySetter(role = spoon.reflect.path.CtRole.SERVICE_TYPE)&#10;    &lt;T extends spoon.reflect.declaration.CtUsedService&gt; T setServiceType(spoon.reflect.reference.CtTypeReference providingType);&#10;&#10;    @java.lang.Override&#10;    spoon.reflect.declaration.CtUsedService clone();&#10;}]" classname="spoon.test.parent.ParentContractTest" time="0.004"/>
</testsuite>