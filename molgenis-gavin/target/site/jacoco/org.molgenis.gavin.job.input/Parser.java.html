<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gavin</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.gavin.job.input</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">package org.molgenis.gavin.job.input;

import com.google.common.collect.EnumMultiset;
import com.google.common.collect.Multiset;
import org.molgenis.gavin.job.input.model.CaddVariant;
import org.molgenis.gavin.job.input.model.LineType;
import org.molgenis.gavin.job.input.model.Variant;
import org.molgenis.gavin.job.input.model.VcfVariant;
import org.slf4j.Logger;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import static java.lang.String.format;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.apache.commons.lang3.StringUtils.isEmpty;
import static org.molgenis.gavin.job.input.Files.getLines;
import static org.molgenis.gavin.job.input.model.LineType.*;
import static org.slf4j.LoggerFactory.getLogger;

/**
 * Parses input lines.
 * Two formats are supported, the output from the online CADD webtool and a VCF of which only the first five columns are read.
 */
@Component
<span class="fc" id="L32">public class Parser</span>
{
<span class="fc" id="L34">	private static final Logger LOG = getLogger(Parser.class);</span>

	private static final int CHROM_INDEX = 0;
	private static final int POS_INDEX = 1;
	private static final int CADD_REF_INDEX = 2;
	private static final int CADD_ALT_INDEX = 3;
	private static final int CADD_RAW_SCORE_INDEX = 4;
	private static final int CADD_PHRED_SCORE = 5;
	private static final int VCF_ID_INDEX = 2;
	private static final int VCF_REF_INDEX = 3;
	private static final int VCF_ALT_INDEX = 4;
	private static final int CADD_NR_OF_COLS = 6;
	private static final int VCF_NR_OF_COLUMNS = 5;
	public static final int MAX_LINES = 100000;

<span class="fc" id="L49">	private static Pattern CHROM_PATTERN = Pattern.compile(</span>
			&quot;([Cc][Hh][Rr])?(?&lt;chrom&gt;([1-9])|(1[0-9])|(2[0-2])|[xX]|[yY])&quot;);
<span class="fc" id="L51">	private static Pattern REF_PATTERN = Pattern.compile(&quot;[ACTG]+&quot;);</span>
<span class="fc" id="L52">	private static Pattern ALT_PATTERN = Pattern.compile(&quot;[ACTG]+|\\.&quot;);</span>

	/**
	 * Transforms gavin input file.
	 *
	 * @param inputFile the file to transform
	 * @param output    the file to output parsed variants to
	 * @param error     the file to output error lines to
	 * @return Multiset counting the {@link LineType}s of the input file's lines
	 * @throws IOException if the file interaction fails
	 */
	public Multiset&lt;LineType&gt; tryTransform(File inputFile, File output, File error) throws IOException
	{
<span class="nc" id="L65">		LOG.debug(&quot;Parsing {}...&quot;, inputFile.getAbsolutePath());</span>
<span class="nc" id="L66">		try (Stream&lt;String&gt; lines = getLines(inputFile.toPath(), UTF_8);</span>
<span class="nc" id="L67">				LineSink outputSink = new LineSink(output);</span>
<span class="nc" id="L68">				LineSink errorSink = new LineSink(error))</span>
		{
<span class="nc" id="L70">			Multiset&lt;LineType&gt; lineTypes = transformLines(lines, outputSink, errorSink);</span>
<span class="nc" id="L71">			LOG.info(&quot;Parsed {}. LineTypes: {}&quot;, inputFile.getAbsolutePath(), lineTypes);</span>
<span class="nc" id="L72">			return lineTypes;</span>
		}
	}

	/**
	 * Transforms a stream of lines and sends them to the error sink
	 *
	 * @param lines      the Stream of lines to transform
	 * @param outputSink {@link LineSink} to write transformed lines to
	 * @param errorSink  {@link LineSink} to write unparseable lines to
	 * @return Multiset counting the {@link LineType}s found in the stream
	 */
	Multiset&lt;LineType&gt; transformLines(Stream&lt;String&gt; lines, LineSink outputSink, LineSink errorSink)
	{
<span class="fc" id="L86">		Multiset&lt;LineType&gt; lineTypes = EnumMultiset.create(LineType.class);</span>
<span class="fc" id="L87">		writeVcfHeader(outputSink);</span>
<span class="fc" id="L88">		lines.map(line -&gt; transformLine(line, lineTypes.size(), countValidLines(lineTypes), outputSink, errorSink))</span>
<span class="fc" id="L89">			 .forEach(lineTypes::add);</span>
<span class="fc" id="L90">		return lineTypes;</span>
	}

	private int countValidLines(Multiset&lt;LineType&gt; lineTypes)
	{
<span class="fc" id="L95">		return lineTypes.count(VCF) + lineTypes.count(CADD);</span>
	}

	private void writeVcfHeader(LineSink outputSink)
	{
<span class="fc" id="L100">		outputSink.accept(&quot;##fileformat=VCFv4.0&quot;);</span>
<span class="fc" id="L101">		outputSink.accept(&quot;##INFO=&lt;ID=CADD,Number=.,Type=String,Description=\&quot;Raw CADD score\&quot;&gt;&quot;);</span>
<span class="fc" id="L102">		outputSink.accept(&quot;##INFO=&lt;ID=CADD_SCALED,Number=.,Type=String,Description=\&quot;Scaled CADD score\&quot;&gt;&quot;);</span>
<span class="fc" id="L103">		outputSink.accept(&quot;#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO&quot;);</span>
<span class="fc" id="L104">	}</span>

	/**
	 * Transforms a single line.
	 *
	 * @param line          the line to parse
	 * @param numValidLines the number of valid lines already parsed
	 * @param outputSink    {@link LineSink} to write parsed variants to
	 * @param errorSink     {@link LineSink} to write lines to that we cannot parse
	 * @return LineType of the parsed line
	 */
	public LineType transformLine(String line, int numLines, int numValidLines, LineSink outputSink, LineSink errorSink)
	{
<span class="fc bfc" id="L117" title="All 2 branches covered.">		if (numValidLines &gt;= MAX_LINES)</span>
		{
<span class="fc" id="L119">			return SKIPPED;</span>
		}
<span class="fc bfc" id="L121" title="All 2 branches covered.">		if (isComment(line))</span>
		{
<span class="fc" id="L123">			return COMMENT;</span>
		}
<span class="fc" id="L125">		Variant variant = tryParseVariant(line);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">		if (variant == null)</span>
		{
<span class="nc" id="L128">			errorSink.accept(format(&quot;Line %d:\t%s&quot;, numLines + 1, line));</span>
<span class="nc" id="L129">			return ERROR;</span>
		}
<span class="fc bfc" id="L131" title="All 2 branches covered.">		if (variant.getLineType() == INDEL_NOCADD)</span>
		{
			// Don't process indels without cadd annotation
<span class="fc" id="L134">			errorSink.accept(format(&quot;Line %d:\t%s&quot;, numLines + 1, line));</span>
		}
		else
		{
<span class="fc" id="L138">			outputSink.accept(variant.toString());</span>
		}
<span class="fc" id="L140">		return variant.getLineType();</span>
	}

	/**
	 * Determines if a line is a comment line. Comment lines start with &quot;#&quot;.
	 *
	 * @param line the line that may be a comment line
	 * @return true if the line is a comment line
	 */
	public boolean isComment(String line)
	{
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">		return line != null &amp;&amp; line.startsWith(&quot;#&quot;);</span>
	}

	/**
	 * Parses a line into a {@link Variant}. It may be one of two formats, CADD output or five VCF columns.
	 *
	 * @param line the line to parse
	 * @return parsed Variant, or null if the line could not be parsed
	 */
	public Variant tryParseVariant(String line)
	{
		try
		{
<span class="fc" id="L164">			return parseVariant(line);</span>
		}
<span class="nc" id="L166">		catch (Exception ex)</span>
		{
<span class="nc" id="L168">			LOG.debug(&quot;Error parsing line {}&quot;, line, ex);</span>
<span class="nc" id="L169">			return null;</span>
		}
	}

	private Variant parseVariant(String line)
	{
<span class="fc" id="L175">		String[] columns = line.split(&quot;\t&quot;);</span>
<span class="fc" id="L176">		Variant caddVariant = parseCaddLine(columns);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">		return caddVariant != null ? caddVariant : parseVcfLine(columns);</span>
	}

	/**
	 * Determines if any of the values are null
	 *
	 * @param values the values that may be null
	 * @return true if any of the values was null
	 */
	private boolean anyNull(Object... values)
	{
<span class="fc" id="L188">		return Arrays.stream(values).anyMatch(Objects::isNull);</span>
	}

	/**
	 * Attempts to parse a line as a CADD output record.
	 *
	 * @param columns the columns of the line
	 * @return parsed {@link CaddVariant}, or null if parsing failed
	 */
	private CaddVariant parseCaddLine(String[] columns)
	{
<span class="fc bfc" id="L199" title="All 2 branches covered.">		if (columns.length != CADD_NR_OF_COLS)</span>
		{
<span class="fc" id="L201">			return null;</span>
		}
<span class="fc" id="L203">		String chrom = parseChrom(columns[CHROM_INDEX].trim());</span>
<span class="fc" id="L204">		Long pos = parsePos(columns[POS_INDEX].trim());</span>

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">		if (anyNull(chrom, pos))</span>
		{
<span class="nc" id="L208">			return null;</span>
		}
		try
		{
<span class="fc" id="L212">			String ref = parseRef(columns[CADD_REF_INDEX].trim());</span>
<span class="fc" id="L213">			String alt = parseAlt(columns[CADD_ALT_INDEX].trim());</span>
<span class="fc" id="L214">			Double rawScore = parseDouble(columns[CADD_RAW_SCORE_INDEX].trim());</span>
<span class="fc" id="L215">			Double phred = parseDouble(columns[CADD_PHRED_SCORE].trim());</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">			if (anyNull(ref, alt))</span>
			{
<span class="nc" id="L218">				return null;</span>
			}
<span class="fc" id="L220">			return CaddVariant.create(chrom, pos, ref, alt, rawScore, phred);</span>
		}
<span class="fc" id="L222">		catch (NumberFormatException e)</span>
		{
<span class="fc" id="L224">			return null;</span>
		}
	}

	/**
	 * Attempts to parse a line as a VCF record.
	 *
	 * @param columns the columns of the line
	 * @return parsed {@link VcfVariant}
	 */
	private VcfVariant parseVcfLine(String[] columns)
	{
<span class="fc bfc" id="L236" title="All 2 branches covered.">		if (columns.length &lt; VCF_NR_OF_COLUMNS)</span>
		{
<span class="fc" id="L238">			return null;</span>
		}
<span class="fc" id="L240">		String chrom = parseChrom(columns[CHROM_INDEX].trim());</span>
<span class="fc" id="L241">		Long pos = parsePos(columns[POS_INDEX].trim());</span>
<span class="fc" id="L242">		String id = columns[VCF_ID_INDEX].trim();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		if (isEmpty(id))</span>
		{
<span class="fc" id="L245">			id = &quot;.&quot;;</span>
		}
<span class="fc" id="L247">		String ref = parseRef(columns[VCF_REF_INDEX].trim());</span>
<span class="fc" id="L248">		String alt = parseAlt(columns[VCF_ALT_INDEX].trim());</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">		if (anyNull(chrom, pos, ref, alt))</span>
		{
<span class="fc" id="L252">			return null;</span>
		}
<span class="fc" id="L254">		return VcfVariant.create(chrom, pos, id, ref, alt);</span>
	}

	private Double parseDouble(String doubleString)
	{
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">		return isEmpty(doubleString) ? null : Double.parseDouble(doubleString);</span>
	}

	String parseChrom(String chrom)
	{
<span class="fc" id="L264">		Matcher m = CHROM_PATTERN.matcher(chrom);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">		return !m.matches() ? null : m.group(&quot;chrom&quot;).toUpperCase();</span>
	}

	private Long parsePos(String pos)
	{
		try
		{
<span class="fc" id="L272">			return Long.parseLong(pos);</span>
		}
<span class="nc" id="L274">		catch (NumberFormatException ex)</span>
		{
<span class="nc" id="L276">			return null;</span>
		}
	}

	private String parseRef(String value)
	{
<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (!REF_PATTERN.matcher(value).matches())</span>
		{
<span class="fc" id="L284">			return null;</span>
		}
<span class="fc" id="L286">		return value;</span>
	}

	private String parseAlt(String value)
	{
<span class="fc bfc" id="L291" title="All 2 branches covered.">		if (!ALT_PATTERN.matcher(value).matches())</span>
		{
<span class="fc" id="L293">			return null;</span>
		}
<span class="fc" id="L295">		return value;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>