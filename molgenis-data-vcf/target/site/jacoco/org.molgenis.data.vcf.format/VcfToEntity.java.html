<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VcfToEntity.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data-vcf</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data.vcf.format</a> &gt; <span class="el_source">VcfToEntity.java</span></div><h1>VcfToEntity.java</h1><pre class="source lang-java linenums">package org.molgenis.data.vcf.format;

import com.google.common.collect.Lists;
import org.apache.commons.lang3.StringUtils;
import org.molgenis.data.Entity;
import org.molgenis.data.MolgenisDataException;
import org.molgenis.data.meta.AttributeType;
import org.molgenis.data.meta.model.Attribute;
import org.molgenis.data.meta.model.AttributeFactory;
import org.molgenis.data.meta.model.EntityType;
import org.molgenis.data.meta.model.EntityTypeFactory;
import org.molgenis.data.support.DynamicEntity;
import org.molgenis.data.validation.meta.NameValidator;
import org.molgenis.data.vcf.VcfRepository;
import org.molgenis.data.vcf.model.VcfAttributes;
import org.molgenis.data.vcf.utils.VcfUtils;
import org.molgenis.genotype.Allele;
import org.molgenis.genotype.GenotypeDataException;
import org.molgenis.util.UnexpectedEnumException;
import org.molgenis.vcf.VcfInfo;
import org.molgenis.vcf.VcfRecord;
import org.molgenis.vcf.VcfSample;
import org.molgenis.vcf.meta.VcfMeta;
import org.molgenis.vcf.meta.VcfMetaFormat;
import org.molgenis.vcf.meta.VcfMetaInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.*;

import static com.google.common.collect.Iterables.size;
import static com.google.common.collect.Maps.newHashMapWithExpectedSize;
import static java.lang.String.format;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toSet;
import static java.util.stream.StreamSupport.stream;
import static org.molgenis.data.meta.AttributeType.*;
import static org.molgenis.data.meta.model.EntityType.AttributeRole.*;
import static org.molgenis.data.util.EntityUtils.getTypedValue;
import static org.molgenis.data.vcf.VcfRepository.NAME;
import static org.molgenis.data.vcf.VcfRepository.ORIGINAL_NAME;
import static org.molgenis.data.vcf.model.VcfAttributes.*;

public class VcfToEntity
{
<span class="fc" id="L48">	private static final Logger LOG = LoggerFactory.getLogger(VcfToEntity.class);</span>
<span class="fc" id="L49">	private static final String[] EMPTY_FORMAT = { &quot;.&quot; };</span>

	private final VcfMeta vcfMeta;
	private final VcfAttributes vcfAttributes;
	private final EntityTypeFactory entityTypeFactory;
	private final AttributeFactory attrMetaFactory;
	private final EntityType sampleEntityType;
	private final EntityType entityType;

	/**
	 * Performance: VCF record info column keys of for info columns of type 'Flag'
	 */
	private final Set&lt;String&gt; vcfInfoFlagFieldKeys;

	/**
	 * Performance: VCF record info column ID to attribute name map
	 */
	private final Map&lt;String, String&gt; infoFieldKeyToAttrNameMap;

	public VcfToEntity(String entityTypeId, VcfMeta vcfMeta, VcfAttributes vcfAttributes,
			EntityTypeFactory entityTypeFactory, AttributeFactory attrMetaFactory)
<span class="fc" id="L70">	{</span>
<span class="fc" id="L71">		requireNonNull(entityTypeId);</span>
<span class="fc" id="L72">		this.vcfMeta = requireNonNull(vcfMeta);</span>
<span class="fc" id="L73">		requireNonNull(vcfMeta.getFormatMeta());</span>
<span class="fc" id="L74">		this.vcfAttributes = requireNonNull(vcfAttributes);</span>
<span class="fc" id="L75">		this.entityTypeFactory = requireNonNull(entityTypeFactory);</span>
<span class="fc" id="L76">		this.attrMetaFactory = requireNonNull(attrMetaFactory);</span>

<span class="fc" id="L78">		this.vcfInfoFlagFieldKeys = determineVcfInfoFlagFields(vcfMeta);</span>
<span class="fc" id="L79">		this.infoFieldKeyToAttrNameMap = createInfoFieldKeyToAttrNameMap(vcfMeta, entityTypeId);</span>

<span class="fc" id="L81">		this.sampleEntityType = createSampleEntityType(entityTypeId, vcfMeta.getFormatMeta());</span>
<span class="fc" id="L82">		this.entityType = createEntityType(entityTypeId, vcfMeta);</span>
<span class="fc" id="L83">	}</span>

	private EntityType createEntityType(String entityTypeId, VcfMeta vcfMeta)
	{
<span class="fc" id="L87">		Attribute idAttribute = attrMetaFactory.create().setName(INTERNAL_ID).setDataType(STRING);</span>
<span class="fc" id="L88">		idAttribute.setVisible(false);</span>

<span class="fc" id="L90">		EntityType entityType = entityTypeFactory.create(entityTypeId);</span>
<span class="fc" id="L91">		entityType.setLabel(entityTypeId);</span>
<span class="fc" id="L92">		entityType.addAttribute(vcfAttributes.getChromAttribute());</span>
<span class="fc" id="L93">		entityType.addAttribute(vcfAttributes.getAltAttribute());</span>
<span class="fc" id="L94">		entityType.addAttribute(vcfAttributes.getPosAttribute());</span>
<span class="fc" id="L95">		entityType.addAttribute(vcfAttributes.getRefAttribute());</span>
<span class="fc" id="L96">		entityType.addAttribute(vcfAttributes.getFilterAttribute());</span>
<span class="fc" id="L97">		entityType.addAttribute(vcfAttributes.getQualAttribute());</span>
<span class="fc" id="L98">		entityType.addAttribute(vcfAttributes.getIdAttribute());</span>
<span class="fc" id="L99">		entityType.addAttribute(idAttribute, ROLE_ID);</span>

<span class="fc" id="L101">		Attribute infoMetaData = attrMetaFactory.create().setName(INFO).setDataType(COMPOUND).setNillable(true);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">		for (VcfMetaInfo info : vcfMeta.getInfoMeta())</span>
		{
<span class="fc" id="L104">			String attrName = toAttributeName(info.getId());</span>
<span class="fc" id="L105">			AttributeType attrType = vcfReaderFormatToMolgenisType(info);</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">			String attrDescription = StringUtils.isBlank(</span>
<span class="fc" id="L107">					info.getDescription()) ? VcfRepository.DEFAULT_ATTRIBUTE_DESCRIPTION : info.getDescription();</span>

<span class="fc" id="L109">			Attribute attribute = attrMetaFactory.create()</span>
<span class="fc" id="L110">												 .setName(attrName)</span>
<span class="fc" id="L111">												 .setDataType(attrType)</span>
<span class="fc" id="L112">												 .setDescription(attrDescription)</span>
<span class="fc" id="L113">												 .setAggregatable(true)</span>
<span class="fc" id="L114">												 .setParent(infoMetaData);</span>

<span class="fc" id="L116">			entityType.addAttribute(attribute);</span>
<span class="fc" id="L117">		}</span>
<span class="fc" id="L118">		entityType.addAttribute(infoMetaData);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		if (sampleEntityType != null)</span>
		{
<span class="fc" id="L121">			Attribute samplesAttributeMeta = attrMetaFactory.create()</span>
<span class="fc" id="L122">															.setName(SAMPLES)</span>
<span class="fc" id="L123">															.setDataType(MREF)</span>
<span class="fc" id="L124">															.setRefEntity(sampleEntityType)</span>
<span class="fc" id="L125">															.setLabel(&quot;SAMPLES&quot;);</span>
<span class="fc" id="L126">			entityType.addAttribute(samplesAttributeMeta);</span>
		}
<span class="fc" id="L128">		return entityType;</span>
	}

	private EntityType createSampleEntityType(String entityTypeId, Iterable&lt;VcfMetaFormat&gt; formatMetaData)
	{
<span class="fc" id="L133">		EntityType result = null;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">		if (formatMetaData.iterator().hasNext())</span>
		{
<span class="fc" id="L136">			String sampleEntityTypeId = entityTypeId + &quot;Sample&quot;;</span>
<span class="fc" id="L137">			result = entityTypeFactory.create(sampleEntityTypeId);</span>
<span class="fc" id="L138">			result.setLabel(sampleEntityTypeId);</span>
<span class="fc" id="L139">			Attribute idAttr = attrMetaFactory.create().setName(ID).setAggregatable(true).setVisible(false);</span>
<span class="fc" id="L140">			Attribute nameAttr = attrMetaFactory.create()</span>
<span class="fc" id="L141">												.setName(NAME)</span>
<span class="fc" id="L142">												.setDataType(TEXT)</span>
<span class="fc" id="L143">												.setAggregatable(true)</span>
<span class="fc" id="L144">												.setNillable(false);</span>
<span class="fc" id="L145">			Attribute originalNameAttr = attrMetaFactory.create().setName(ORIGINAL_NAME).setDataType(TEXT);</span>

<span class="fc" id="L147">			result.addAttribute(idAttr, ROLE_ID);</span>
<span class="fc" id="L148">			result.addAttribute(nameAttr, ROLE_LABEL, ROLE_LOOKUP);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">			for (VcfMetaFormat meta : formatMetaData)</span>
			{
<span class="fc" id="L151">				String name = meta.getId();</span>
<span class="pc bpc" id="L152" title="2 of 4 branches missed.">				if (NameValidator.KEYWORDS.contains(name) || NameValidator.KEYWORDS.contains(name.toUpperCase()))</span>
				{
<span class="nc" id="L154">					name = name + &quot;_&quot;;</span>
				}
<span class="fc" id="L156">				Attribute attr = attrMetaFactory.create()</span>
<span class="fc" id="L157">												.setName(name.replaceAll(&quot;[-.*$&amp;%^()#!@?_]&quot;, &quot;&quot;))</span>
<span class="fc" id="L158">												.setDataType(vcfFieldTypeToMolgenisFieldType(meta))</span>
<span class="fc" id="L159">												.setAggregatable(true)</span>
<span class="fc" id="L160">												.setLabel(meta.getId());</span>

<span class="fc" id="L162">				result.addAttribute(attr);</span>
<span class="fc" id="L163">			}</span>

<span class="fc" id="L165">			result.addAttribute(originalNameAttr);</span>
		}
<span class="fc" id="L167">		return result;</span>
	}

	private static AttributeType vcfReaderFormatToMolgenisType(VcfMetaInfo vcfMetaInfo)
	{
<span class="fc" id="L172">		String number = vcfMetaInfo.getNumber();</span>
		boolean isListValue;
		try
		{
<span class="pc bpc" id="L176" title="2 of 8 branches missed.">			isListValue = number.equals(&quot;A&quot;) || number.equals(&quot;R&quot;) || number.equals(&quot;G&quot;) || number.equals(&quot;.&quot;)</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">					|| Integer.parseInt(number) &gt; 1;</span>
		}
<span class="nc" id="L179">		catch (NumberFormatException ex)</span>
		{
<span class="nc" id="L181">			throw new GenotypeDataException(&quot;Error parsing length of vcf info field. &quot; + number</span>
					+ &quot; is not a valid int or expected preset (A, R, G, .)&quot;, ex);
<span class="fc" id="L183">		}</span>
<span class="pc bpc" id="L184" title="1 of 6 branches missed.">		switch (vcfMetaInfo.getType())</span>
		{
			case CHARACTER:
<span class="fc bfc" id="L187" title="All 2 branches covered.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="fc" id="L190">					return STRING;</span>
				}
<span class="fc" id="L192">				return STRING;</span>
			case FLAG:
<span class="fc" id="L194">				return BOOL;</span>
			case FLOAT:
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="fc" id="L199">					return STRING;</span>
				}
<span class="nc" id="L201">				return DECIMAL;</span>
			case INTEGER:
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="nc" id="L206">					return STRING;</span>
				}
<span class="fc" id="L208">				return INT;</span>
			case STRING:
<span class="fc bfc" id="L210" title="All 2 branches covered.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="fc" id="L213">					return TEXT;</span>
				}
<span class="fc" id="L215">				return TEXT;</span>
			default:
<span class="nc" id="L217">				throw new UnexpectedEnumException(vcfMetaInfo.getType());</span>
		}
	}

	private static AttributeType vcfFieldTypeToMolgenisFieldType(VcfMetaFormat format)
	{
<span class="fc" id="L223">		String number = format.getNumber();</span>
		boolean isListValue;
		try
		{
<span class="pc bpc" id="L227" title="3 of 8 branches missed.">			isListValue = number.equals(&quot;A&quot;) || number.equals(&quot;R&quot;) || number.equals(&quot;G&quot;) || number.equals(&quot;.&quot;)</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">					|| Integer.parseInt(number) &gt; 1;</span>
		}
<span class="nc" id="L230">		catch (NumberFormatException ex)</span>
		{
<span class="nc" id="L232">			throw new GenotypeDataException(&quot;Error parsing length of vcf info field. &quot; + number</span>
					+ &quot; is not a valid int or expected preset (A, R, G, .)&quot;, ex);
<span class="fc" id="L234">		}</span>
<span class="pc bpc" id="L235" title="2 of 5 branches missed.">		switch (format.getType())</span>
		{
			case CHARACTER:
<span class="nc bnc" id="L238" title="All 2 branches missed.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="nc" id="L241">					return STRING;</span>
				}
<span class="nc" id="L243">				return STRING;</span>
			case FLOAT:
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="fc" id="L248">					return STRING;</span>
				}
<span class="nc" id="L250">				return DECIMAL;</span>
			case INTEGER:
<span class="fc bfc" id="L252" title="All 2 branches covered.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="fc" id="L255">					return STRING;</span>
				}
<span class="fc" id="L257">				return INT;</span>
			case STRING:
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">				if (isListValue)</span>
				{
					// TODO support list of primitives datatype
<span class="nc" id="L262">					return STRING;</span>
				}
<span class="fc" id="L264">				return STRING;</span>
			default:
<span class="nc" id="L266">				throw new UnexpectedEnumException(format.getType());</span>
		}
	}

	public Entity toEntity(String[] tokens)
	{
<span class="nc" id="L272">		return toEntity(new VcfRecord(vcfMeta, tokens));</span>
	}

	public Entity toEntity(VcfRecord vcfRecord)
	{
<span class="fc" id="L277">		Entity entity = new DynamicEntity(entityType);</span>
<span class="fc" id="L278">		entity.set(CHROM, vcfRecord.getChromosome());</span>
<span class="fc" id="L279">		entity.set(ALT, StringUtils.join(Lists.transform(vcfRecord.getAlternateAlleles(), Allele::toString), ','));</span>
<span class="fc" id="L280">		entity.set(POS, vcfRecord.getPosition());</span>
<span class="fc" id="L281">		entity.set(REF, vcfRecord.getReferenceAllele().toString());</span>
<span class="fc" id="L282">		entity.set(FILTER, vcfRecord.getFilterStatus());</span>
<span class="fc" id="L283">		entity.set(QUAL, vcfRecord.getQuality());</span>
<span class="fc" id="L284">		entity.set(ID, StringUtils.join(vcfRecord.getIdentifiers(), ','));</span>

<span class="fc" id="L286">		String id = VcfUtils.createId(entity);</span>
<span class="fc" id="L287">		entity.set(INTERNAL_ID, id);</span>

<span class="fc" id="L289">		writeInfoFieldsToEntity(vcfRecord, entity);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">		if (sampleEntityType != null)</span>
		{
<span class="fc" id="L292">			List&lt;Entity&gt; samples = createSampleEntities(vcfRecord, entity.get(POS) + &quot;_&quot; + entity.get(ALT), id);</span>
<span class="fc" id="L293">			entity.set(SAMPLES, samples);</span>
		}
<span class="fc" id="L295">		return entity;</span>
	}

	private List&lt;Entity&gt; createSampleEntities(VcfRecord vcfRecord, String entityPosAlt, String entityId)
	{
<span class="fc" id="L300">		List&lt;Entity&gt; samples = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L301">		Iterator&lt;VcfSample&gt; sampleIterator = vcfRecord.getSamples().iterator();</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">		if (vcfRecord.getNrSamples() &gt; 0)</span>
		{
<span class="fc" id="L304">			Iterator&lt;String&gt; sampleNameIterator = vcfMeta.getSampleNames().iterator();</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			for (int j = 0; sampleIterator.hasNext(); ++j)</span>
			{
<span class="fc" id="L307">				String[] format = vcfRecord.getFormat();</span>
<span class="fc" id="L308">				VcfSample sample = sampleIterator.next();</span>
<span class="fc" id="L309">				Entity sampleEntity = new DynamicEntity(sampleEntityType);</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">				for (int i = 0; i &lt; format.length; i = i + 1)</span>
				{
<span class="fc" id="L312">					String strValue = sample.getData(i);</span>
<span class="fc" id="L313">					Object value = null;</span>
<span class="fc" id="L314">					EntityType sampleEntityType = sampleEntity.getEntityType();</span>
<span class="fc" id="L315">					Attribute attr = sampleEntityType.getAttribute(format[i]);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">					if (attr != null)</span>
					{
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">						if (strValue != null)</span>
						{
<span class="fc" id="L320">							value = getTypedValue(strValue, attr);</span>
						}
					}
					else
					{
<span class="nc bnc" id="L325" title="All 2 branches missed.">						if (Arrays.equals(EMPTY_FORMAT, format))</span>
						{
<span class="nc" id="L327">							LOG.debug(&quot;Found a dot as format, assuming no samples present&quot;);</span>
						}
						else
						{
<span class="nc" id="L331">							throw new MolgenisDataException(&quot;Sample entity contains an attribute [&quot; + format[i]</span>
									+ &quot;] which is not specified in vcf headers&quot;);
						}
					}
<span class="fc" id="L335">					sampleEntity.set(format[i], value);</span>
				}
<span class="fc" id="L337">				sampleEntity.set(ID, entityId + j);</span>

				// FIXME remove entity ID from Sample label after #1400 is fixed, see also:
				// jquery.molgenis.table.js line 152
<span class="fc" id="L341">				String original_name = sampleNameIterator.next();</span>
<span class="fc" id="L342">				sampleEntity.set(NAME, entityPosAlt + &quot;_&quot; + original_name);</span>
<span class="fc" id="L343">				sampleEntity.set(ORIGINAL_NAME, original_name);</span>
<span class="fc" id="L344">				samples.add(sampleEntity);</span>
			}
		}
<span class="fc" id="L347">		return samples;</span>
	}

	private void writeInfoFieldsToEntity(VcfRecord vcfRecord, Entity entity)
	{
		// Set default values for VCF info fields of type 'flag' to false. Note that VcfInfo of a VcfRecord do not
		// have to contain all flag fields.
<span class="fc bfc" id="L354" title="All 2 branches covered.">		for (String vcfInfoFlagFieldKey : vcfInfoFlagFieldKeys)</span>
		{
<span class="fc" id="L356">			entity.set(toAttributeName(vcfInfoFlagFieldKey), false);</span>
<span class="fc" id="L357">		}</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">		for (VcfInfo vcfInfo : vcfRecord.getInformation())</span>
		{
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">			if (vcfInfo.getKey().equals(&quot;.&quot;)) // value not available</span>
			{
<span class="nc" id="L363">				continue;</span>
			}

			Object val;
<span class="fc bfc" id="L367" title="All 2 branches covered.">			if (vcfInfoFlagFieldKeys.contains(vcfInfo.getKey()))</span>
			{
<span class="fc" id="L369">				val = true;</span>
			}
			else
			{
<span class="fc" id="L373">				Object vcfInfoVal = vcfInfo.getVal();</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">				if (vcfInfoVal == null)</span>
				{
<span class="nc" id="L376">					val = null;</span>
				}
<span class="fc bfc" id="L378" title="All 2 branches covered.">				else if (vcfInfoVal instanceof List&lt;?&gt;)</span>
				{
<span class="fc" id="L380">					List&lt;?&gt; vcfInfoValTokens = (List&lt;?&gt;) vcfInfoVal;</span>
					// TODO Use list data type once available (see http://www.molgenis.org/ticket/2681)
<span class="fc" id="L382">					val = vcfInfoValTokens.stream()</span>
<span class="fc" id="L383">										  .map(vcfInfoValToken -&gt;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">												  vcfInfoValToken != null ? vcfInfoValToken.toString() : &quot;.&quot;)</span>
<span class="fc" id="L385">										  .collect(joining(&quot;,&quot;));</span>
<span class="fc" id="L386">				}</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">				else if (vcfInfoVal instanceof Float)</span>
				{
<span class="nc bnc" id="L389" title="All 2 branches missed.">					if (Float.isNaN((Float) vcfInfoVal))</span>
					{
<span class="nc" id="L391">						val = null;</span>
					}
					else
					{
<span class="nc" id="L395">						val = new BigDecimal(</span>
<span class="nc" id="L396">								String.valueOf(vcfInfoVal)).doubleValue(); // TODO why not Double.valueOf(string)?</span>
					}
				}
<span class="fc bfc" id="L399" title="All 2 branches covered.">				else if (vcfInfoVal instanceof Character)</span>
				{
<span class="fc" id="L401">					val = vcfInfoVal.toString();</span>
				}
				else
				{
<span class="fc" id="L405">					val = vcfInfoVal; // VCF value type matches type expected for this MOLGENIS attribute type</span>
				}
			}

<span class="fc" id="L409">			entity.set(toAttributeName(vcfInfo.getKey()), val);</span>
<span class="fc" id="L410">		}</span>
<span class="fc" id="L411">	}</span>

	public EntityType getEntityType()
	{
<span class="fc" id="L415">		return entityType;</span>
	}

	/**
	 * Returns the corresponding attribute name for a VCF info field key
	 *
	 * @param vcfInfoFieldKey VCF info field key
	 * @return MOLGENIS attribute name
	 * @throws RuntimeException if no attribute could be found for a VCF info field key
	 */
	private String toAttributeName(String vcfInfoFieldKey)
	{
<span class="fc" id="L427">		String attrName = infoFieldKeyToAttrNameMap.get(vcfInfoFieldKey);</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">		if (attrName == null)</span>
		{
<span class="nc" id="L430">			throw new RuntimeException(format(&quot;Missing attribute for VCF info field [%s]&quot;, vcfInfoFieldKey));</span>
		}
<span class="fc" id="L432">		return attrName;</span>
	}

	/**
	 * Returns a set of all possible VCF info fields of type 'Flag'
	 *
	 * @param vcfMeta VCF metadata
	 * @return Set of VCF info fields of type 'Flag'
	 */
	private static Set&lt;String&gt; determineVcfInfoFlagFields(VcfMeta vcfMeta)
	{
<span class="fc" id="L443">		return stream(vcfMeta.getInfoMeta().spliterator(), false).filter(</span>
<span class="fc" id="L444">				vcfInfoMeta -&gt; vcfInfoMeta.getType().equals(VcfMetaInfo.Type.FLAG))</span>
<span class="fc" id="L445">																 .map(VcfMetaInfo::getId)</span>
<span class="fc" id="L446">																 .collect(toSet());</span>
	}

	/**
	 * Returns a mapping of VCF info field keys to MOLGENIS attribute names
	 *
	 * @param vcfMeta      VCF metadata
	 * @param entityTypeId entity name (that could be used to create a MOLGENIS attribute name)
	 * @return map of VCF info field keys to MOLGENIS attribute names
	 */
	private static Map&lt;String, String&gt; createInfoFieldKeyToAttrNameMap(VcfMeta vcfMeta, String entityTypeId)
	{
<span class="fc" id="L458">		Map&lt;String, String&gt; infoFieldIdToAttrNameMap = newHashMapWithExpectedSize(size(vcfMeta.getInfoMeta()));</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">		for (VcfMetaInfo info : vcfMeta.getInfoMeta())</span>
		{
			// according to the VCF standard it is allowed to have info columns with names that equal default VCF cols.
			// rename these info columns in the meta data to prevent collisions.
<span class="fc" id="L463">			String postFix = &quot;&quot;;</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">			switch (info.getId())</span>
			{
				case INTERNAL_ID:
				case CHROM:
				case ALT:
				case POS:
				case REF:
				case FILTER:
				case QUAL:
				case ID:
<span class="nc" id="L474">					postFix = '_' + entityTypeId;</span>
<span class="nc" id="L475">					break;</span>
				default:
					break;
			}

<span class="fc" id="L480">			String name = info.getId();</span>
<span class="pc bpc" id="L481" title="2 of 4 branches missed.">			if (NameValidator.KEYWORDS.contains(name) || NameValidator.KEYWORDS.contains(name.toUpperCase()))</span>
			{
<span class="nc" id="L483">				name = name + '_';</span>
			}
<span class="fc" id="L485">			infoFieldIdToAttrNameMap.put(info.getId(), name + postFix);</span>
<span class="fc" id="L486">		}</span>
<span class="fc" id="L487">		return infoFieldIdToAttrNameMap;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>