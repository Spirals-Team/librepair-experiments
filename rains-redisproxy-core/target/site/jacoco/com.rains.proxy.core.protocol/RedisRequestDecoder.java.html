<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedisRequestDecoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">redis-proxy-core</a> &gt; <a href="index.source.html" class="el_package">com.rains.proxy.core.protocol</a> &gt; <span class="el_source">RedisRequestDecoder.java</span></div><h1>RedisRequestDecoder.java</h1><pre class="source lang-java linenums">package com.rains.proxy.core.protocol;

import com.rains.proxy.core.command.impl.RedisCommand;
import com.rains.proxy.core.constants.RedisConstants;
import com.rains.proxy.core.enums.RequestState;
import com.rains.proxy.core.exception.RedisRequestException;
import com.rains.proxy.core.protocol.request.decoder.IRedisRequestDecoder;
import com.rains.proxy.core.protocol.request.decoder.RedisRequestDecoderFactory;
import com.rains.proxy.core.utils.ProtoUtils;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ReplayingDecoder;
import io.netty.util.CharsetUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

/**
 * @author dourx
 * @version V1.0
 * @Description: TODO
 * @date 2018年 05 月  29日  14:01
 */
public  class RedisRequestDecoder extends ReplayingDecoder&lt;RequestState&gt; {
<span class="fc" id="L27">    private static final Logger logger = LoggerFactory.getLogger(RedisRequestDecoder.class);</span>

    private RedisCommand requestCommand;

    public RedisRequestDecoder() {
<span class="fc" id="L32">        super(RequestState.READ_SKIP);</span>
<span class="fc" id="L33">    }</span>

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer,
                          List&lt;Object&gt; out) throws Exception {


<span class="pc bpc" id="L40" title="4 of 6 branches missed.">        switch (state()) {</span>
            case READ_SKIP: {
                try {
<span class="fc" id="L43">                    skipChar(buffer);</span>
<span class="fc" id="L44">                    checkpoint(RequestState.READ_INIT);</span>
                } finally {
<span class="pc" id="L46">                    checkpoint();</span>
<span class="fc" id="L47">                }</span>
            }
            case READ_INIT: {
<span class="fc" id="L50">                requestCommand = new RedisCommand();</span>
<span class="fc" id="L51">                char ch = (char) buffer.readByte();</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">                if (ch == RedisConstants.ASTERISK_BYTE) {//redis 新协议开头</span>
<span class="fc" id="L53">                    requestCommand.setInline(false);</span>
                    //读取参数数量(新协议)
<span class="fc" id="L55">                    checkpoint(RequestState.READ_ARG_COUNT);</span>
                } else {
<span class="fc" id="L57">                    buffer.resetReaderIndex();</span>
<span class="fc" id="L58">                    requestCommand.setInline(true);</span>
                    //读取参数
<span class="fc" id="L60">                    checkpoint(RequestState.READ_ARG);</span>

                }

            }
            case READ_ARG_COUNT: {
<span class="pc bpc" id="L66" title="1 of 4 branches missed.">                if (requestCommand != null &amp;&amp; !requestCommand.isInline()) {</span>
<span class="fc" id="L67">                    requestCommand.setArgCount(ProtoUtils.readInt(buffer));</span>
                }
<span class="fc" id="L69">                checkpoint(RequestState.READ_ARG);</span>
            }
            case READ_ARG: {
<span class="fc" id="L72">                IRedisRequestDecoder decoder =RedisRequestDecoderFactory.getInstance(requestCommand.isInline());</span>
<span class="fc" id="L73">                RequestState state=   decoder.readArg(buffer,requestCommand);</span>

<span class="fc" id="L75">                checkpoint(state);</span>
            }
            case READ_END: {
<span class="fc" id="L78">                RedisCommand command = this.requestCommand;</span>
<span class="fc" id="L79">                this.requestCommand = null;</span>
<span class="fc" id="L80">                checkpoint(RequestState.READ_INIT);</span>
<span class="fc" id="L81">                out.add(command);</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                if(logger.isDebugEnabled()){</span>
<span class="fc" id="L83">                    logger.debug(&quot;request解码前协议文本内容:{}&quot;,buffer.slice(0,buffer.readerIndex()).toString(CharsetUtil.UTF_8).replaceAll(&quot;\r\n&quot;,&quot;\\\\r\\\\n&quot;));</span>
                }
<span class="fc" id="L85">                return;</span>
            }
            default:
<span class="nc" id="L88">                throw new Error(&quot;can't reach here!&quot;);</span>
        }
    }

    private int readInt(ByteBuf buffer) throws Exception {
<span class="nc" id="L93">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L94">        char ch = (char) buffer.readByte();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        while (ch != RedisConstants.CR_BYTE) {</span>
<span class="nc" id="L96">            sb.append(ch);</span>
<span class="nc" id="L97">            ch = (char) buffer.readByte();//\r读取</span>
        }
<span class="nc" id="L99">        buffer.readByte();//\n读取</span>
        try {
<span class="nc" id="L101">            int result = 1;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (!sb.toString().toLowerCase().equals(RedisConstants.PING)) {</span>
<span class="nc" id="L103">                result = Integer.parseInt(sb.toString());</span>
            }
<span class="nc" id="L105">            return result;</span>
<span class="nc" id="L106">        } catch (Exception e) {//网络闭包引起</span>

<span class="nc" id="L108">            throw new Exception(&quot;readInt Unexpected character,result:&quot; + sb.toString() + &quot;,ch:&quot; + String.valueOf(ch));</span>
        }
    }



    private void skipChar(ByteBuf buffer) {
        for (; ; ) {
<span class="fc" id="L116">            char ch = (char) buffer.readByte();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (ch != RedisConstants.SPACE_BYTE) {</span>
<span class="fc" id="L118">                buffer.readerIndex(buffer.readerIndex() - 1);</span>
<span class="fc" id="L119">                break;</span>
            }
<span class="fc" id="L121">        }</span>
<span class="fc" id="L122">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>