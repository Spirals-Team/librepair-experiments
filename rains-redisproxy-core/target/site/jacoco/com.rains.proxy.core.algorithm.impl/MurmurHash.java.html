<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MurmurHash.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">redis-proxy-core</a> &gt; <a href="index.source.html" class="el_package">com.rains.proxy.core.algorithm.impl</a> &gt; <span class="el_source">MurmurHash.java</span></div><h1>MurmurHash.java</h1><pre class="source lang-java linenums">/**
 * 
 */
package com.rains.proxy.core.algorithm.impl;

import com.rains.proxy.core.algorithm.Hashing;
import com.rains.proxy.core.algorithm.impl.support.SafeEncoder;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * murmhash算法
 * @author liubing
 *
 */
<span class="fc" id="L17">public class MurmurHash implements Hashing {</span>

	/**
     * Hashes bytes in an array.
     * 
     * @param data
     *            The bytes to hash.
     * @param seed
     *            The seed for the hash.
     * @return The 32 bit hash of the bytes in question.
     */
    public static int hash(byte[] data, int seed) {
<span class="nc" id="L29">        return hash(ByteBuffer.wrap(data), seed);</span>
    }

    /**
     * Hashes bytes in part of an array.
     * 
     * @param data
     *            The data to hash.
     * @param offset
     *            Where to start munging.
     * @param length
     *            How many bytes to process.
     * @param seed
     *            The seed to start with.
     * @return The 32-bit hash of the data in question.
     */
    public static int hash(byte[] data, int offset, int length, int seed) {
<span class="nc" id="L46">        return hash(ByteBuffer.wrap(data, offset, length), seed);</span>
    }

    /**
     * Hashes the bytes in a buffer from the current position to the limit.
     * 
     * @param buf
     *            The bytes to hash.
     * @param seed
     *            The seed for the hash.
     * @return The 32 bit murmur hash of the bytes in the buffer.
     */
    public static int hash(ByteBuffer buf, int seed) {
        // save byte order for later restoration
<span class="nc" id="L60">        ByteOrder byteOrder = buf.order();</span>
<span class="nc" id="L61">        buf.order(ByteOrder.LITTLE_ENDIAN);</span>

<span class="nc" id="L63">        int m = 0x5bd1e995;</span>
<span class="nc" id="L64">        int r = 24;</span>

<span class="nc" id="L66">        int h = seed ^ buf.remaining();</span>

        int k;
<span class="nc bnc" id="L69" title="All 2 branches missed.">        while (buf.remaining() &gt;= 4) {</span>
<span class="nc" id="L70">            k = buf.getInt();</span>

<span class="nc" id="L72">            k *= m;</span>
<span class="nc" id="L73">            k ^= k &gt;&gt;&gt; r;</span>
<span class="nc" id="L74">            k *= m;</span>

<span class="nc" id="L76">            h *= m;</span>
<span class="nc" id="L77">            h ^= k;</span>
        }

<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (buf.remaining() &gt; 0) {</span>
<span class="nc" id="L81">            ByteBuffer finish = ByteBuffer.allocate(4).order(</span>
                    ByteOrder.LITTLE_ENDIAN);
            // for big-endian version, use this first:
            // finish.position(4-buf.remaining());
<span class="nc" id="L85">            finish.put(buf).rewind();</span>
<span class="nc" id="L86">            h ^= finish.getInt();</span>
<span class="nc" id="L87">            h *= m;</span>
        }

<span class="nc" id="L90">        h ^= h &gt;&gt;&gt; 13;</span>
<span class="nc" id="L91">        h *= m;</span>
<span class="nc" id="L92">        h ^= h &gt;&gt;&gt; 15;</span>

<span class="nc" id="L94">        buf.order(byteOrder);</span>
<span class="nc" id="L95">        return h;</span>
    }

    public static long hash64A(byte[] data, int seed) {
<span class="fc" id="L99">        return hash64A(ByteBuffer.wrap(data), seed);</span>
    }

    public static long hash64A(byte[] data, int offset, int length, int seed) {
<span class="nc" id="L103">        return hash64A(ByteBuffer.wrap(data, offset, length), seed);</span>
    }

    public static long hash64A(ByteBuffer buf, int seed) {
<span class="fc" id="L107">        ByteOrder byteOrder = buf.order();</span>
<span class="fc" id="L108">        buf.order(ByteOrder.LITTLE_ENDIAN);</span>

<span class="fc" id="L110">        long m = 0xc6a4a7935bd1e995L;</span>
<span class="fc" id="L111">        int r = 47;</span>

<span class="fc" id="L113">        long h = seed ^ (buf.remaining() * m);</span>

        long k;
<span class="fc bfc" id="L116" title="All 2 branches covered.">        while (buf.remaining() &gt;= 8) {</span>
<span class="fc" id="L117">            k = buf.getLong();</span>

<span class="fc" id="L119">            k *= m;</span>
<span class="fc" id="L120">            k ^= k &gt;&gt;&gt; r;</span>
<span class="fc" id="L121">            k *= m;</span>

<span class="fc" id="L123">            h ^= k;</span>
<span class="fc" id="L124">            h *= m;</span>
        }

<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (buf.remaining() &gt; 0) {</span>
<span class="fc" id="L128">            ByteBuffer finish = ByteBuffer.allocate(8).order(</span>
                    ByteOrder.LITTLE_ENDIAN);
            // for big-endian version, do this first:
            // finish.position(8-buf.remaining());
<span class="fc" id="L132">            finish.put(buf).rewind();</span>
<span class="fc" id="L133">            h ^= finish.getLong();</span>
<span class="fc" id="L134">            h *= m;</span>
        }

<span class="fc" id="L137">        h ^= h &gt;&gt;&gt; r;</span>
<span class="fc" id="L138">        h *= m;</span>

<span class="fc" id="L140">        long sign = h &gt;&gt; 63;</span>


<span class="fc" id="L143">        buf.order(byteOrder);</span>
<span class="fc" id="L144">        return (h + sign) ^ sign;</span>
    }

    public long hash(byte[] key) {
<span class="fc" id="L148">        return hash64A(key, 0x1234ABCD);</span>
    }

    public long hash(String key) {
<span class="fc" id="L152">		return hash(SafeEncoder.encode(key));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>