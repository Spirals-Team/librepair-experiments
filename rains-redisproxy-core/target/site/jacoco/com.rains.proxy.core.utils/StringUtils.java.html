<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">redis-proxy-core</a> &gt; <a href="index.source.html" class="el_package">com.rains.proxy.core.utils</a> &gt; <span class="el_source">StringUtils.java</span></div><h1>StringUtils.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.rains.proxy.core.utils;



import com.rains.proxy.core.constants.RedisConstants;
import io.netty.util.CharsetUtil;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.*;
import java.util.regex.Pattern;

/**
 * @author dourx
 * @version V1.0
 * @Description: TODO
 * @date 2018/5/30  9:38
 */
<span class="nc" id="L36">public final class StringUtils {</span>

    // Empty checks
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Checks if a String is empty (&quot;&quot;) or null.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isEmpty(null)      = true
     * StringUtils.isEmpty(&quot;&quot;)        = true
     * StringUtils.isEmpty(&quot; &quot;)       = false
     * StringUtils.isEmpty(&quot;bob&quot;)     = false
     * StringUtils.isEmpty(&quot;  bob  &quot;) = false
     * &lt;/pre&gt;
     */
    public static boolean isEmpty(final String s) {
<span class="nc bnc" id="L54" title="All 4 branches missed.">        return s == null || s.length() == 0;</span>
    }

    /**
     * &lt;p&gt;
     * Checks if a String is not empty (&quot;&quot;) and not null.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNotEmpty(null)      = false
     * StringUtils.isNotEmpty(&quot;&quot;)        = false
     * StringUtils.isNotEmpty(&quot; &quot;)       = true
     * StringUtils.isNotEmpty(&quot;bob&quot;)     = true
     * StringUtils.isNotEmpty(&quot;  bob  &quot;) = true
     * &lt;/pre&gt;
     */
    public static boolean isNotEmpty(final String s) {
<span class="nc bnc" id="L71" title="All 4 branches missed.">        return s != null &amp;&amp; s.length() &gt; 0;</span>
    }

    /**
     * &lt;p&gt;
     * Checks if a String is whitespace, empty (&quot;&quot;) or null.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isBlank(null)      = true
     * StringUtils.isBlank(&quot;&quot;)        = true
     * StringUtils.isBlank(&quot; &quot;)       = true
     * StringUtils.isBlank(&quot;bob&quot;)     = false
     * StringUtils.isBlank(&quot;  bob  &quot;) = false
     * &lt;/pre&gt;
     */
    public static boolean isBlank(final String s) {
        int len;
<span class="pc bpc" id="L89" title="2 of 4 branches missed.">        if (s == null || (len = s.length()) == 0) {</span>
<span class="nc" id="L90">            return true;</span>
        }
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            if (Character.isWhitespace(s.charAt(i)) == false) {</span>
<span class="fc" id="L94">                return false;</span>
            }
        }
<span class="nc" id="L97">        return true;</span>
    }

    /**
     * &lt;p&gt;
     * Checks if a String is not empty (&quot;&quot;), not null and not whitespace
     * only.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNotBlank(null)      = false
     * StringUtils.isNotBlank(&quot;&quot;)        = false
     * StringUtils.isNotBlank(&quot; &quot;)       = false
     * StringUtils.isNotBlank(&quot;bob&quot;)     = true
     * StringUtils.isNotBlank(&quot;  bob  &quot;) = true
     * &lt;/pre&gt;
     */
    public static boolean isNotBlank(final String s) {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        return !isBlank(s);</span>
    }

    public static byte[] getBytes(String s, String charsetName) {
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L120">            return null;</span>
        }
        try {
<span class="nc" id="L123">            return s.getBytes(charsetName);</span>
<span class="nc" id="L124">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L125">            throw new RuntimeException(e);</span>
        }
    }

    public static byte[] getUtf8Bytes(String s) {
<span class="nc" id="L130">        return s.getBytes(CharsetUtil.UTF_8);</span>
    }

    // Trim
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Removes control characters (char &amp;lt;= 32) from both ends of this String,
     * handling {@code null} by returning {@code null}.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The String is trimmed using {@link String#trim()}. Trim removes start and
     * end characters &amp;lt;= 32.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trim(null)          = null
     * StringUtils.trim(&quot;&quot;)            = &quot;&quot;
     * StringUtils.trim(&quot;     &quot;)       = &quot;&quot;
     * StringUtils.trim(&quot;abc&quot;)         = &quot;abc&quot;
     * StringUtils.trim(&quot;    abc    &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String trim(final String s) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        return s == null ? null : s.trim();</span>
    }

    /**
     * &lt;p&gt;
     * Removes control characters (char &amp;lt;= 32) from both ends of this String
     * returning {@code null} if the String is empty (&quot;&quot;) after the trim or if
     * it is {@code null}.
     *
     * &lt;p&gt;
     * The String is trimmed using {@link String#trim()}. Trim removes start and
     * end characters &amp;lt;= 32.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trimToNull(null)          = null
     * StringUtils.trimToNull(&quot;&quot;)            = null
     * StringUtils.trimToNull(&quot;     &quot;)       = null
     * StringUtils.trimToNull(&quot;abc&quot;)         = &quot;abc&quot;
     * StringUtils.trimToNull(&quot;    abc    &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String trimToNull(final String s) {
<span class="nc" id="L178">        final String ts = trim(s);</span>
<span class="nc bnc" id="L179" title="All 4 branches missed.">        return ts == null || ts.length() == 0 ? null : ts;</span>
    }

    /**
     * &lt;p&gt;
     * Removes control characters (char &amp;lt;= 32) from both ends of this String
     * returning an empty String (&quot;&quot;) if the String is empty (&quot;&quot;) after the trim
     * or if it is {@code null}.
     *
     * &lt;p&gt;
     * The String is trimmed using {@link String#trim()}. Trim removes start and
     * end characters &amp;lt;= 32.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trimToEmpty(null)          = &quot;&quot;
     * StringUtils.trimToEmpty(&quot;&quot;)            = &quot;&quot;
     * StringUtils.trimToEmpty(&quot;     &quot;)       = &quot;&quot;
     * StringUtils.trimToEmpty(&quot;abc&quot;)         = &quot;abc&quot;
     * StringUtils.trimToEmpty(&quot;    abc    &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String trimToEmpty(final String s) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        return s == null ? &quot;&quot; : s.trim();</span>
    }

    public static String[] trim(String[] ss) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (ss != null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            for (int i = 0; i &lt; ss.length; i++) {</span>
<span class="nc" id="L208">                String string = ss[i];</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (string != null) {</span>
<span class="nc" id="L210">                    ss[i] = string.trim();</span>
                }
            }
        }
<span class="nc" id="L214">        return ss;</span>
    }

    // Defaults
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Returns either the passed in String, or if the String is {@code null},
     * the value of {@code defaultStr}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultIfNull(null, &quot;NULL&quot;)  = &quot;NULL&quot;
     * StringUtils.defaultIfNull(&quot;&quot;, &quot;NULL&quot;)    = &quot;&quot;
     * StringUtils.defaultIfNull(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
     * &lt;/pre&gt;
     */
    public static String defaultIfNull(final String s, final String defaultStr) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        return s == null ? defaultStr : s;</span>
    }

    /**
     * &lt;p&gt;
     * Returns either the passed in String, or if the String is
     * empty or {@code null}, the value of {@code defaultStr}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultIfEmpty(null, &quot;NULL&quot;)  = &quot;NULL&quot;
     * StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
     * StringUtils.defaultIfEmpty(&quot; &quot;, &quot;NULL&quot;)   = &quot; &quot;
     * StringUtils.defaultIfEmpty(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
     * StringUtils.defaultIfEmpty(&quot;&quot;, null)      = null
     * &lt;/pre&gt;
     */
    public static String defaultIfEmpty(final String s, final String defaultStr) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        return isEmpty(s) ? defaultStr : s;</span>
    }

    /**
     * &lt;p&gt;
     * Returns either the passed in String, or if the String is
     * whitespace, empty (&quot;&quot;) or {@code null}, the value of {@code defaultStr}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultIfBlank(null, &quot;NULL&quot;)  = &quot;NULL&quot;
     * StringUtils.defaultIfBlank(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
     * StringUtils.defaultIfBlank(&quot; &quot;, &quot;NULL&quot;)   = &quot;NULL&quot;
     * StringUtils.defaultIfBlank(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
     * StringUtils.defaultIfBlank(&quot;&quot;, null)      = null
     * &lt;/pre&gt;
     */
    public static String defaultIfBlank(final String s, final String defaultStr) {
<span class="nc bnc" id="L268" title="All 2 branches missed.">        return isBlank(s) ? defaultStr : s;</span>
    }

    // Equals
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Compares two CharSequences, returning {@code true} if they represent
     * equal sequences of characters.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code null}s are handled without exceptions. Two {@code null} references
     * are considered to be equal. The comparison is case sensitive.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.equals(null, null)   = true
     * StringUtils.equals(null, &quot;abc&quot;)  = false
     * StringUtils.equals(&quot;abc&quot;, null)  = false
     * StringUtils.equals(&quot;abc&quot;, &quot;abc&quot;) = true
     * StringUtils.equals(&quot;abc&quot;, &quot;ABC&quot;) = false
     * &lt;/pre&gt;
     */
    public static boolean equals(final String s1, final String s2) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (s1 == s2) {</span>
<span class="nc" id="L294">            return true;</span>
        }
<span class="nc bnc" id="L296" title="All 4 branches missed.">        if (s1 == null || s2 == null) {</span>
<span class="nc" id="L297">            return false;</span>
        }
<span class="nc" id="L299">        return s1.equals(s2);</span>
    }

    /**
     * &lt;p&gt;
     * Compares two CharSequences, returning {@code true} if they represent
     * equal sequences of characters, ignoring case.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code null}s are handled without exceptions. Two {@code null} references
     * are considered equal. Comparison is case insensitive.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.equalsIgnoreCase(null, null)   = true
     * StringUtils.equalsIgnoreCase(null, &quot;abc&quot;)  = false
     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, null)  = false
     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;abc&quot;) = true
     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;) = true
     * &lt;/pre&gt;
     */
    public static boolean equalsIgnoreCase(final String s1, final String s2) {
<span class="nc bnc" id="L322" title="All 4 branches missed.">        if (s1 == null || s2 == null) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            return s1 == s2;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        } else if (s1 == s2) {</span>
<span class="nc" id="L325">            return true;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        } else if (s1.length() != s2.length()) {</span>
<span class="nc" id="L327">            return false;</span>
        } else {
<span class="nc" id="L329">            return s1.equals(s2);</span>
        }
    }

    // startsWith
    // -----------------------------------------------------------------------

    /**
     * &lt;p&gt;
     * Check if a String starts with a specified prefix.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code null}s are handled without exceptions. Two {@code null} references
     * are considered to be equal. The comparison is case sensitive.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWith(null, null)      = true
     * StringUtils.startsWith(null, &quot;abc&quot;)     = false
     * StringUtils.startsWith(&quot;abcdef&quot;, null)  = false
     * StringUtils.startsWith(&quot;abcdef&quot;, &quot;abc&quot;) = true
     * StringUtils.startsWith(&quot;ABCDEF&quot;, &quot;abc&quot;) = false
     * &lt;/pre&gt;
     *
     * @see String#startsWith(String)
     * @param s
     *            the String to check, may be null
     * @param prefix
     *            the prefix to find, may be null
     * @return {@code true} if the String starts with the prefix, case
     *         sensitive, or both {@code null}
     */
    public static boolean startsWith(final String s, final String prefix) {
<span class="nc" id="L363">        return startsWith(s, prefix, false);</span>
    }

    /**
     * &lt;p&gt;
     * Case insensitive check if a String starts with a specified prefix.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code null}s are handled without exceptions. Two {@code null} references
     * are considered to be equal. The comparison is case insensitive.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWithIgnoreCase(null, null)      = true
     * StringUtils.startsWithIgnoreCase(null, &quot;abc&quot;)     = false
     * StringUtils.startsWithIgnoreCase(&quot;abcdef&quot;, null)  = false
     * StringUtils.startsWithIgnoreCase(&quot;abcdef&quot;, &quot;abc&quot;) = true
     * StringUtils.startsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;abc&quot;) = true
     * &lt;/pre&gt;
     *
     * @see String#startsWith(String)
     */
    public static boolean startsWithIgnoreCase(final String s, final String prefix) {
<span class="nc" id="L387">        return startsWith(s, prefix, true);</span>
    }

    /**
     * &lt;p&gt;
     * Check if a String starts with a specified prefix (optionally case
     * insensitive).
     * &lt;/p&gt;
     *
     * @see String#startsWith(String)
     */
    private static boolean startsWith(final String s, final String prefix, final boolean ignoreCase) {
<span class="nc bnc" id="L399" title="All 4 branches missed.">        if (s == null || prefix == null) {</span>
<span class="nc bnc" id="L400" title="All 4 branches missed.">            return s == null &amp;&amp; prefix == null;</span>
        }
<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (prefix.length() &gt; s.length()) {</span>
<span class="nc" id="L403">            return false;</span>
        }
<span class="nc" id="L405">        return s.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());</span>
    }

    public static int startsWithOne(String s, String... dest) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">        for (int i = 0; i &lt; dest.length; i++) {</span>
<span class="nc" id="L410">            String m = dest[i];</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (m != null) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (s.startsWith(m)) return i;</span>
            }
        }
<span class="nc" id="L415">        return -1;</span>
    }

    public static int startsWithOneIgnoreCase(String s, String... dest) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (int i = 0; i &lt; dest.length; i++) {</span>
<span class="nc" id="L420">            String m = dest[i];</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (m != null) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                if (startsWithIgnoreCase(s, m)) return i;</span>
            }
        }
<span class="nc" id="L425">        return -1;</span>
    }

    public static boolean startsWithChar(final String s, final char c) {
<span class="nc bnc" id="L429" title="All 4 branches missed.">        if (s == null || s.length() == 0) {</span>
<span class="nc" id="L430">            return false;</span>
        }
<span class="nc bnc" id="L432" title="All 2 branches missed.">        return s.charAt(0) == c;</span>
    }

    // endsWith
    // -----------------------------------------------------------------------

    /**
     * &lt;p&gt;
     * Check if a String ends with a specified suffix.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code null}s are handled without exceptions. Two {@code null} references
     * are considered to be equal. The comparison is case sensitive.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWith(null, null)      = true
     * StringUtils.endsWith(null, &quot;def&quot;)     = false
     * StringUtils.endsWith(&quot;abcdef&quot;, null)  = false
     * StringUtils.endsWith(&quot;abcdef&quot;, &quot;def&quot;) = true
     * StringUtils.endsWith(&quot;ABCDEF&quot;, &quot;def&quot;) = false
     * StringUtils.endsWith(&quot;ABCDEF&quot;, &quot;cde&quot;) = false
     * &lt;/pre&gt;
     *
     * @see String#endsWith(String)
     */
    public static boolean endsWith(final String s, final String suffix) {
<span class="nc" id="L460">        return endsWith(s, suffix, false);</span>
    }

    /**
     * &lt;p&gt;
     * Case insensitive check if a String ends with a specified suffix.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * {@code null}s are handled without exceptions. Two {@code null} references
     * are considered to be equal. The comparison is case insensitive.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWithIgnoreCase(null, null)      = true
     * StringUtils.endsWithIgnoreCase(null, &quot;def&quot;)     = false
     * StringUtils.endsWithIgnoreCase(&quot;abcdef&quot;, null)  = false
     * StringUtils.endsWithIgnoreCase(&quot;abcdef&quot;, &quot;def&quot;) = true
     * StringUtils.endsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;def&quot;) = true
     * StringUtils.endsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;cde&quot;) = false
     * &lt;/pre&gt;
     *
     * @see String#endsWith(String)
     */
    public static boolean endsWithIgnoreCase(final String s, final String suffix) {
<span class="nc" id="L485">        return endsWith(s, suffix, true);</span>
    }

    /**
     * &lt;p&gt;
     * Check if a String ends with a specified suffix (optionally case
     * insensitive).
     * &lt;/p&gt;
     *
     * @see String#endsWith(String)
     */
    private static boolean endsWith(final String s, final String suffix, final boolean ignoreCase) {
<span class="nc bnc" id="L497" title="All 4 branches missed.">        if (s == null || suffix == null) {</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">            return s == null &amp;&amp; suffix == null;</span>
        }
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (suffix.length() &gt; s.length()) {</span>
<span class="nc" id="L501">            return false;</span>
        }
<span class="nc" id="L503">        final int strOffset = s.length() - suffix.length();</span>
<span class="nc" id="L504">        return s.toString().regionMatches(ignoreCase, strOffset, suffix.toString(), 0, suffix.length());</span>
    }

    public static int endsWithOne(String src, String... dest) {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        for (int i = 0; i &lt; dest.length; i++) {</span>
<span class="nc" id="L509">            String m = dest[i];</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (m != null) {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (src.endsWith(m)) return i;</span>
            }
        }
<span class="nc" id="L514">        return -1;</span>
    }

    public static int endsWithOneIgnoreCase(String s, String... dest) {
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (int i = 0; i &lt; dest.length; i++) {</span>
<span class="nc" id="L519">            String m = dest[i];</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (m != null) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (endsWithIgnoreCase(s, m)) return i;</span>
            }
        }
<span class="nc" id="L524">        return -1;</span>
    }

    public static boolean endsWithChar(final String s, final char c) {
<span class="nc bnc" id="L528" title="All 4 branches missed.">        if (s == null || s.length() == 0) {</span>
<span class="nc" id="L529">            return false;</span>
        }
<span class="nc bnc" id="L531" title="All 2 branches missed.">        return s.charAt(s.length() - 1) == c;</span>
    }

    // ---------------------------------------------------------------- indexof and ignore cases

    /**
     * Finds first occurrence of a substring in the given source but within limited range [start, end).
     * It is fastest possible code, but still original &lt;code&gt;String.indexOf(String, int)&lt;/code&gt;
     * is much faster (since it uses char[] value directly) and should be used when no range is needed.
     *
     * @param s                source string for examination
     * @param substr                substring to find
     * @param startIndex        starting index
     * @param endIndex                ending index
     * @return index of founded substring or -1 if substring not found
     */
    public static int indexOf(String s, String substr, int startIndex, int endIndex) {
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (startIndex &lt; 0) {</span>
<span class="nc" id="L549">            startIndex = 0;</span>
        }
<span class="nc" id="L551">        int srclen = s.length();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (endIndex &gt; srclen) {</span>
<span class="nc" id="L553">            endIndex = srclen;</span>
        }
<span class="nc" id="L555">        int sublen = substr.length();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (sublen == 0) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            return startIndex &gt; srclen ? srclen : startIndex;</span>
        }

<span class="nc" id="L560">        int total = endIndex - sublen + 1;</span>
<span class="nc" id="L561">        char c = substr.charAt(0);</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">        mainloop: for (int i = startIndex; i &lt; total; i++) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (s.charAt(i) != c) {</span>
<span class="nc" id="L564">                continue;</span>
            }
<span class="nc" id="L566">            int j = 1;</span>
<span class="nc" id="L567">            int k = i + 1;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            while (j &lt; sublen) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                if (substr.charAt(j) != s.charAt(k)) {</span>
<span class="nc" id="L570">                    continue mainloop;</span>
                }
<span class="nc" id="L572">                j++;</span>
<span class="nc" id="L573">                k++;</span>
            }
<span class="nc" id="L575">            return i;</span>
        }
<span class="nc" id="L577">        return -1;</span>
    }

    /**
     * Finds the first occurrence of a character in the given source but within limited range (start, end].
     */
    public static int indexOf(String s, char c, int startIndex, int endIndex) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (startIndex &lt; 0) {</span>
<span class="nc" id="L585">            startIndex = 0;</span>
        }
<span class="nc" id="L587">        int srclen = s.length();</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (endIndex &gt; srclen) {</span>
<span class="nc" id="L589">            endIndex = srclen;</span>
        }
<span class="nc bnc" id="L591" title="All 2 branches missed.">        for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (s.charAt(i) == c) {</span>
<span class="nc" id="L593">                return i;</span>
            }
        }
<span class="nc" id="L596">        return -1;</span>
    }

    /**
     * Finds the first occurrence of a character in the given source but within limited range (start, end].
     */
    public static int indexOfIgnoreCase(String s, char c, int startIndex, int endIndex) {
<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (startIndex &lt; 0) {</span>
<span class="nc" id="L604">            startIndex = 0;</span>
        }
<span class="nc" id="L606">        int srclen = s.length();</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (endIndex &gt; srclen) {</span>
<span class="nc" id="L608">            endIndex = srclen;</span>
        }
<span class="nc" id="L610">        c = Character.toLowerCase(c);</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">        for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (Character.toLowerCase(s.charAt(i)) == c) {</span>
<span class="nc" id="L613">                return i;</span>
            }
        }
<span class="nc" id="L616">        return -1;</span>
    }

    /**
     * Finds first index of a substring in the given source string with ignored case.
     *
     * @param s    source string for examination
     * @param substr   substring to find
     *
     * @return index of founded substring or -1 if substring is not found
     * @see #indexOfIgnoreCase(String, String, int)
     */
    public static int indexOfIgnoreCase(String s, String substr) {
<span class="nc" id="L629">        return indexOfIgnoreCase(s, substr, 0, s.length());</span>
    }

    /**
     * Finds first index of a substring in the given source string with ignored
     * case. This seems to be the fastest way doing this, with common string
     * length and content (of course, with no use of Boyer-Mayer type of
     * algorithms). Other implementations are slower: getting char array first,
     * lower casing the source string, using String.regionMatch etc.
     *
     * @param s        source string for examination
     * @param substr       substring to find
     * @param startIndex starting index from where search begins
     *
     * @return index of founded substring or -1 if substring is not found
     */
    public static int indexOfIgnoreCase(String s, String substr, int startIndex) {
<span class="nc" id="L646">        return indexOfIgnoreCase(s, substr, startIndex, s.length());</span>
    }

    /**
     * Finds first index of a substring in the given source string and range with
     * ignored case.
     *
     * @param s                source string for examination
     * @param substr                substring to find
     * @param startIndex        starting index from where search begins
     * @param endIndex                endint index
     * @return index of founded substring or -1 if substring is not found
     * @see #indexOfIgnoreCase(String, String, int)
     */
    public static int indexOfIgnoreCase(String s, String substr, int startIndex, int endIndex) {
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (startIndex &lt; 0) {</span>
<span class="nc" id="L662">            startIndex = 0;</span>
        }
<span class="nc" id="L664">        int srclen = s.length();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (endIndex &gt; srclen) {</span>
<span class="nc" id="L666">            endIndex = srclen;</span>
        }

<span class="nc" id="L669">        int sublen = substr.length();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (sublen == 0) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">            return startIndex &gt; srclen ? srclen : startIndex;</span>
        }
<span class="nc" id="L673">        substr = substr.toLowerCase();</span>
<span class="nc" id="L674">        int total = endIndex - sublen + 1;</span>
<span class="nc" id="L675">        char c = substr.charAt(0);</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">        mainloop: for (int i = startIndex; i &lt; total; i++) {</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">            if (Character.toLowerCase(s.charAt(i)) != c) {</span>
<span class="nc" id="L678">                continue;</span>
            }
<span class="nc" id="L680">            int j = 1;</span>
<span class="nc" id="L681">            int k = i + 1;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            while (j &lt; sublen) {</span>
<span class="nc" id="L683">                char source = Character.toLowerCase(s.charAt(k));</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (substr.charAt(j) != source) {</span>
<span class="nc" id="L685">                    continue mainloop;</span>
                }
<span class="nc" id="L687">                j++;</span>
<span class="nc" id="L688">                k++;</span>
<span class="nc" id="L689">            }</span>
<span class="nc" id="L690">            return i;</span>
        }
<span class="nc" id="L692">        return -1;</span>
    }

    /**
     * Finds the very first index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt; if
     * noting found.
     *
     * @param s      source string
     * @param arr    string array
     */
    public static int[] indexOf(String s, String arr[]) {
<span class="nc" id="L705">        return indexOf(s, arr, 0);</span>
    }

    /**
     * Finds the very first index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param arr    string array
     * @param start  starting position
     */
    public static int[] indexOf(String s, String arr[], int start) {
<span class="nc" id="L719">        int arrLen = arr.length;</span>
<span class="nc" id="L720">        int index = Integer.MAX_VALUE;</span>
<span class="nc" id="L721">        int last = -1;</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (int j = 0; j &lt; arrLen; j++) {</span>
<span class="nc" id="L723">            int i = s.indexOf(arr[j], start);</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                if (i &lt; index) {</span>
<span class="nc" id="L726">                    index = i;</span>
<span class="nc" id="L727">                    last = j;</span>
                }
            }
        }
<span class="nc bnc" id="L731" title="All 2 branches missed.">        return last == -1 ? null : new int[] { last, index };</span>
    }

    /**
     * Finds the very first index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt; if
     * noting found.
     *
     * @param s      source string
     * @param c      char array
     */
    public static int[] indexOf(String s, char c[]) {
<span class="nc" id="L744">        return indexOf(s, c, 0);</span>
    }

    /**
     * Finds the very first index of a char from the specified array. It
     * returns an int[2] where int[0] represents the char index and int[1]
     * represents position where char was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param c      char array
     * @param start  starting position
     */
    public static int[] indexOf(String s, char c[], int start) {
<span class="nc" id="L758">        int arrLen = c.length;</span>
<span class="nc" id="L759">        int index = Integer.MAX_VALUE;</span>
<span class="nc" id="L760">        int last = -1;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        for (int j = 0; j &lt; arrLen; j++) {</span>
<span class="nc" id="L762">            int i = s.indexOf(c[j], start);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                if (i &lt; index) {</span>
<span class="nc" id="L765">                    index = i;</span>
<span class="nc" id="L766">                    last = j;</span>
                }
            }
        }
<span class="nc bnc" id="L770" title="All 2 branches missed.">        return last == -1 ? null : new int[] { last, index };</span>
    }

    /**
     * Finds the very first index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param arr    string array
     */
    public static int[] indexOfIgnoreCase(String s, String arr[]) {
<span class="nc" id="L783">        return indexOfIgnoreCase(s, arr, 0);</span>
    }

    /**
     * Finds the very first index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param arr    string array
     * @param start  starting position
     */
    public static int[] indexOfIgnoreCase(String s, String arr[], int start) {
<span class="nc" id="L797">        int arrLen = arr.length;</span>
<span class="nc" id="L798">        int index = Integer.MAX_VALUE;</span>
<span class="nc" id="L799">        int last = -1;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        for (int j = 0; j &lt; arrLen; j++) {</span>
<span class="nc" id="L801">            int i = indexOfIgnoreCase(s, arr[j], start);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">                if (i &lt; index) {</span>
<span class="nc" id="L804">                    index = i;</span>
<span class="nc" id="L805">                    last = j;</span>
                }
            }
        }
<span class="nc bnc" id="L809" title="All 2 branches missed.">        return last == -1 ? null : new int[] { last, index };</span>
    }

    /**
     * Finds last index of a substring in the given source string with ignored
     * case.
     *
     * @param s      source string
     * @param substr   substring to find
     *
     * @return last index of founded substring or -1 if substring is not found
     * @see #indexOfIgnoreCase(String, String, int)
     * @see #lastIndexOfIgnoreCase(String, String, int)
     */
    public static int lastIndexOfIgnoreCase(String s, String substr) {
<span class="nc" id="L824">        return lastIndexOfIgnoreCase(s, substr, s.length(), 0);</span>
    }

    /**
     * Finds last index of a substring in the given source string with ignored
     * case.
     *
     * @param s        source string for examination
     * @param substr       substring to find
     * @param startIndex starting index from where search begins
     *
     * @return last index of founded substring or -1 if substring is not found
     * @see #indexOfIgnoreCase(String, String, int)
     */
    public static int lastIndexOfIgnoreCase(String s, String substr, int startIndex) {
<span class="nc" id="L839">        return lastIndexOfIgnoreCase(s, substr, startIndex, 0);</span>
    }

    /**
     * Finds last index of a substring in the given source string with ignored
     * case in specified range.
     *
     * @param s                source to examine
     * @param sub                substring to find
     * @param startIndex        starting index
     * @param endIndex                end index
     * @return last index of founded substring or -1 if substring is not found
     */
    public static int lastIndexOfIgnoreCase(String s, String sub, int startIndex, int endIndex) {
<span class="nc" id="L853">        int sublen = sub.length();</span>
<span class="nc" id="L854">        int srclen = s.length();</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (sublen == 0) {</span>
<span class="nc bnc" id="L856" title="All 4 branches missed.">            return startIndex &gt; srclen ? srclen : (startIndex &lt; -1 ? -1 : startIndex);</span>
        }
<span class="nc" id="L858">        sub = sub.toLowerCase();</span>
<span class="nc" id="L859">        int total = srclen - sublen;</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (total &lt; 0) {</span>
<span class="nc" id="L861">            return -1;</span>
        }
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (startIndex &gt;= total) {</span>
<span class="nc" id="L864">            startIndex = total;</span>
        }
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (endIndex &lt; 0) {</span>
<span class="nc" id="L867">            endIndex = 0;</span>
        }
<span class="nc" id="L869">        char c = sub.charAt(0);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">        mainloop: for (int i = startIndex; i &gt;= endIndex; i--) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            if (Character.toLowerCase(s.charAt(i)) != c) {</span>
<span class="nc" id="L872">                continue;</span>
            }
<span class="nc" id="L874">            int j = 1;</span>
<span class="nc" id="L875">            int k = i + 1;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">            while (j &lt; sublen) {</span>
<span class="nc" id="L877">                char source = Character.toLowerCase(s.charAt(k));</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">                if (sub.charAt(j) != source) {</span>
<span class="nc" id="L879">                    continue mainloop;</span>
                }
<span class="nc" id="L881">                j++;</span>
<span class="nc" id="L882">                k++;</span>
<span class="nc" id="L883">            }</span>
<span class="nc" id="L884">            return i;</span>
        }
<span class="nc" id="L886">        return -1;</span>
    }

    /**
     * Finds last index of a substring in the given source string in specified range [end, start]
     * See {@link #indexOf(String, String, int, int)}  for details about the speed.
     *
     * @param s                source to examine
     * @param sub                substring to find
     * @param startIndex        starting index
     * @param endIndex                end index
     * @return last index of founded substring or -1 if substring is not found
     */
    public static int lastIndexOf(String s, String sub, int startIndex, int endIndex) {
<span class="nc" id="L900">        int sublen = sub.length();</span>
<span class="nc" id="L901">        int srclen = s.length();</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (sublen == 0) {</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">            return startIndex &gt; srclen ? srclen : (startIndex &lt; -1 ? -1 : startIndex);</span>
        }
<span class="nc" id="L905">        int total = srclen - sublen;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (total &lt; 0) {</span>
<span class="nc" id="L907">            return -1;</span>
        }
<span class="nc bnc" id="L909" title="All 2 branches missed.">        if (startIndex &gt;= total) {</span>
<span class="nc" id="L910">            startIndex = total;</span>
        }
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (endIndex &lt; 0) {</span>
<span class="nc" id="L913">            endIndex = 0;</span>
        }
<span class="nc" id="L915">        char c = sub.charAt(0);</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        mainloop: for (int i = startIndex; i &gt;= endIndex; i--) {</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">            if (s.charAt(i) != c) {</span>
<span class="nc" id="L918">                continue;</span>
            }
<span class="nc" id="L920">            int j = 1;</span>
<span class="nc" id="L921">            int k = i + 1;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">            while (j &lt; sublen) {</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                if (sub.charAt(j) != s.charAt(k)) {</span>
<span class="nc" id="L924">                    continue mainloop;</span>
                }
<span class="nc" id="L926">                j++;</span>
<span class="nc" id="L927">                k++;</span>
            }
<span class="nc" id="L929">            return i;</span>
        }
<span class="nc" id="L931">        return -1;</span>
    }

    /**
     * Finds last index of a character in the given source string in specified range [end, start]
     */
    public static int lastIndexOf(String s, char c, int startIndex, int endIndex) {
<span class="nc" id="L938">        int total = s.length() - 1;</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (total &lt; 0) {</span>
<span class="nc" id="L940">            return -1;</span>
        }
<span class="nc bnc" id="L942" title="All 2 branches missed.">        if (startIndex &gt;= total) {</span>
<span class="nc" id="L943">            startIndex = total;</span>
        }
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (endIndex &lt; 0) {</span>
<span class="nc" id="L946">            endIndex = 0;</span>
        }
<span class="nc bnc" id="L948" title="All 2 branches missed.">        for (int i = startIndex; i &gt;= endIndex; i--) {</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">            if (s.charAt(i) == c) {</span>
<span class="nc" id="L950">                return i;</span>
            }
        }
<span class="nc" id="L953">        return -1;</span>
    }

    /**
     * Finds last index of a character in the given source string in specified range [end, start]
     */
    public static int lastIndexOfIgnoreCase(String s, char c, int startIndex, int endIndex) {
<span class="nc" id="L960">        int total = s.length() - 1;</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        if (total &lt; 0) {</span>
<span class="nc" id="L962">            return -1;</span>
        }
<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (startIndex &gt;= total) {</span>
<span class="nc" id="L965">            startIndex = total;</span>
        }
<span class="nc bnc" id="L967" title="All 2 branches missed.">        if (endIndex &lt; 0) {</span>
<span class="nc" id="L968">            endIndex = 0;</span>
        }
<span class="nc" id="L970">        c = Character.toLowerCase(c);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        for (int i = startIndex; i &gt;= endIndex; i--) {</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">            if (Character.toLowerCase(s.charAt(i)) == c) {</span>
<span class="nc" id="L973">                return i;</span>
            }
        }
<span class="nc" id="L976">        return -1;</span>
    }

    /**
     * Finds the very last index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param arr    string array
     */
    public static int[] lastIndexOf(String s, String arr[]) {
<span class="nc" id="L989">        return lastIndexOf(s, arr, s.length());</span>
    }

    /**
     * Finds the very last index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s         source string
     * @param arr       string array
     * @param fromIndex starting position
     */
    public static int[] lastIndexOf(String s, String arr[], int fromIndex) {
<span class="nc" id="L1003">        int arrLen = arr.length;</span>
<span class="nc" id="L1004">        int index = -1;</span>
<span class="nc" id="L1005">        int last = -1;</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        for (int j = 0; j &lt; arrLen; j++) {</span>
<span class="nc" id="L1007">            int i = s.lastIndexOf(arr[j], fromIndex);</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (i &gt; index) {</span>
<span class="nc" id="L1010">                    index = i;</span>
<span class="nc" id="L1011">                    last = j;</span>
                }
            }
        }
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        return last == -1 ? null : new int[] { last, index };</span>
    }

    /**
     * Finds the very last index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param c      char array
     */
    public static int[] lastIndexOf(String s, char c[]) {
<span class="nc" id="L1028">        return lastIndexOf(s, c, s.length());</span>
    }

    /**
     * Finds the very last index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s         source string
     * @param c         char array
     * @param fromIndex starting position
     */
    public static int[] lastIndexOf(String s, char c[], int fromIndex) {
<span class="nc" id="L1042">        int arrLen = c.length;</span>
<span class="nc" id="L1043">        int index = -1;</span>
<span class="nc" id="L1044">        int last = -1;</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        for (int j = 0; j &lt; arrLen; j++) {</span>
<span class="nc" id="L1046">            int i = s.lastIndexOf(c[j], fromIndex);</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                if (i &gt; index) {</span>
<span class="nc" id="L1049">                    index = i;</span>
<span class="nc" id="L1050">                    last = j;</span>
                }
            }
        }
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        return last == -1 ? null : new int[] { last, index };</span>
    }

    /**
     * Finds the very last index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s      source string
     * @param arr    string array
     *
     * @return int[2]
     */
    public static int[] lastIndexOfIgnoreCase(String s, String arr[]) {
<span class="nc" id="L1069">        return lastIndexOfIgnoreCase(s, arr, s.length());</span>
    }

    /**
     * Finds the very last index of a substring from the specified array. It
     * returns an int[2] where int[0] represents the substring index and int[1]
     * represents position where substring was found. Returns &lt;code&gt;null&lt;/code&gt;
     * if noting found.
     *
     * @param s         source string
     * @param arr       string array
     * @param fromIndex starting position
     */
    public static int[] lastIndexOfIgnoreCase(String s, String arr[], int fromIndex) {
<span class="nc" id="L1083">        int arrLen = arr.length;</span>
<span class="nc" id="L1084">        int index = -1;</span>
<span class="nc" id="L1085">        int last = -1;</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        for (int j = 0; j &lt; arrLen; j++) {</span>
<span class="nc" id="L1087">            int i = lastIndexOfIgnoreCase(s, arr[j], fromIndex);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                if (i &gt; index) {</span>
<span class="nc" id="L1090">                    index = i;</span>
<span class="nc" id="L1091">                    last = j;</span>
                }
            }
        }
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        return last == -1 ? null : new int[] { last, index };</span>
    }

    // Substring
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Gets a substring from the specified String avoiding exceptions.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A negative start position can be used to start {@code n} characters from
     * the end of the String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} String will return {@code null}. An empty (&quot;&quot;) String will
     * return &quot;&quot;.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substring(null, *)   = null
     * StringUtils.substring(&quot;&quot;, *)     = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, 0)  = &quot;abc&quot;
     * StringUtils.substring(&quot;abc&quot;, 2)  = &quot;c&quot;
     * StringUtils.substring(&quot;abc&quot;, 4)  = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, -2) = &quot;bc&quot;
     * StringUtils.substring(&quot;abc&quot;, -4) = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String substring(final String s, int start) {
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1127">            return null;</span>
        }

        // handle negatives, which means last n characters
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L1132">            start = s.length() + start; // remember start is negative</span>
        }

<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L1136">            start = 0;</span>
        }
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (start &gt; s.length()) {</span>
<span class="nc" id="L1139">            return &quot;&quot;;</span>
        }

<span class="nc" id="L1142">        return s.substring(start);</span>
    }

    /**
     * &lt;p&gt;
     * Gets a substring from the specified String avoiding exceptions.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A negative start position can be used to start/end {@code n} characters
     * from the end of the String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The returned substring starts with the character in the {@code start}
     * position and ends before the {@code end} position. All position counting
     * is zero-based -- i.e., to start at the beginning of the string use
     * {@code start = 0}. Negative start and end positions can be used to
     * specify offsets relative to the end of the String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If {@code start} is not strictly to the left of {@code end}, &quot;&quot; is
     * returned.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substring(null, *, *)    = null
     * StringUtils.substring(&quot;&quot;, * ,  *)    = &quot;&quot;;
     * StringUtils.substring(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;
     * StringUtils.substring(&quot;abc&quot;, 2, 0)   = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, 2, 4)   = &quot;c&quot;
     * StringUtils.substring(&quot;abc&quot;, 4, 6)   = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, 2, 2)   = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, -2, -1) = &quot;b&quot;
     * StringUtils.substring(&quot;abc&quot;, -4, 2)  = &quot;ab&quot;
     * &lt;/pre&gt;
     */
    public static String substring(final String s, int start, int end) {
<span class="nc bnc" id="L1181" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1182">            return null;</span>
        }

        // handle negatives
<span class="nc bnc" id="L1186" title="All 2 branches missed.">        if (end &lt; 0) {</span>
<span class="nc" id="L1187">            end = s.length() + end; // remember end is negative</span>
        }
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L1190">            start = s.length() + start; // remember start is negative</span>
        }

        // check length next
<span class="nc bnc" id="L1194" title="All 2 branches missed.">        if (end &gt; s.length()) {</span>
<span class="nc" id="L1195">            end = s.length();</span>
        }

        // if start is greater than end, return &quot;&quot;
<span class="nc bnc" id="L1199" title="All 2 branches missed.">        if (start &gt; end) {</span>
<span class="nc" id="L1200">            return &quot;&quot;;</span>
        }

<span class="nc bnc" id="L1203" title="All 2 branches missed.">        if (start &lt; 0) {</span>
<span class="nc" id="L1204">            start = 0;</span>
        }
<span class="nc bnc" id="L1206" title="All 2 branches missed.">        if (end &lt; 0) {</span>
<span class="nc" id="L1207">            end = 0;</span>
        }

<span class="nc" id="L1210">        return s.substring(start, end);</span>
    }

    // SubStringAfter/SubStringBefore
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Gets the substring before the first occurrence of a separator. The
     * separator is not returned.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} string input will return {@code null}. An empty (&quot;&quot;)
     * string input will return the empty string. A {@code null} separator will
     * return the input string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If nothing is found, the string input is returned.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBefore(null, *)      = null
     * StringUtils.substringBefore(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;a&quot;)   = &quot;&quot;
     * StringUtils.substringBefore(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;d&quot;)   = &quot;abc&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;&quot;)    = &quot;&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, null)  = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String substringBefore(final String s, final String separator) {
<span class="nc bnc" id="L1243" title="All 4 branches missed.">        if (isEmpty(s) || separator == null) {</span>
<span class="nc" id="L1244">            return s;</span>
        }
<span class="nc bnc" id="L1246" title="All 2 branches missed.">        if (separator.isEmpty()) {</span>
<span class="nc" id="L1247">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1249">        final int pos = s.indexOf(separator);</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L1251">            return s;</span>
        }
<span class="nc" id="L1253">        return s.substring(0, pos);</span>
    }

    /**
     * &lt;p&gt;
     * Gets the substring after the first occurrence of a separator. The
     * separator is not returned.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} string input will return {@code null}. An empty (&quot;&quot;)
     * string input will return the empty string. A {@code null} separator will
     * return the empty string if the input string is not {@code null}.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If nothing is found, the empty string is returned.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringAfter(null, *)      = null
     * StringUtils.substringAfter(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringAfter(*, null)      = &quot;&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
     * StringUtils.substringAfter(&quot;abcba&quot;, &quot;b&quot;) = &quot;cba&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;d&quot;)   = &quot;&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String substringAfter(final String s, final String separator) {
<span class="nc bnc" id="L1284" title="All 2 branches missed.">        if (isEmpty(s)) {</span>
<span class="nc" id="L1285">            return s;</span>
        }
<span class="nc bnc" id="L1287" title="All 2 branches missed.">        if (separator == null) {</span>
<span class="nc" id="L1288">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1290">        final int pos = s.indexOf(separator);</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L1292">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1294">        return s.substring(pos + separator.length());</span>
    }

    /**
     * &lt;p&gt;
     * Gets the substring before the last occurrence of a separator. The
     * separator is not returned.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} string input will return {@code null}. An empty (&quot;&quot;)
     * string input will return the empty string. An empty or {@code null}
     * separator will return the input string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If nothing is found, the string input is returned.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBeforeLast(null, *)      = null
     * StringUtils.substringBeforeLast(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringBeforeLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;abc&quot;
     * StringUtils.substringBeforeLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;z&quot;)     = &quot;a&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, null)    = &quot;a&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;&quot;)      = &quot;a&quot;
     * &lt;/pre&gt;
     */
    public static String substringBeforeLast(final String s, final String separator) {
<span class="nc bnc" id="L1325" title="All 4 branches missed.">        if (isEmpty(s) || isEmpty(separator)) {</span>
<span class="nc" id="L1326">            return s;</span>
        }
<span class="nc" id="L1328">        final int pos = s.lastIndexOf(separator);</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L1330">            return s;</span>
        }
<span class="nc" id="L1332">        return s.substring(0, pos);</span>
    }

    /**
     * &lt;p&gt;
     * Gets the substring after the last occurrence of a separator. The
     * separator is not returned.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} string input will return {@code null}. An empty (&quot;&quot;)
     * string input will return the empty string. An empty or {@code null}
     * separator will return the empty string if the input string is not
     * {@code null}.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If nothing is found, the empty string is returned.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringAfterLast(null, *)      = null
     * StringUtils.substringAfterLast(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringAfterLast(*, &quot;&quot;)        = &quot;&quot;
     * StringUtils.substringAfterLast(*, null)      = &quot;&quot;
     * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
     * StringUtils.substringAfterLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
     * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
     * StringUtils.substringAfterLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
     * StringUtils.substringAfterLast(&quot;a&quot;, &quot;z&quot;)     = &quot;&quot;
     * &lt;/pre&gt;
     */
    public static String substringAfterLast(final String s, final String separator) {
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (isEmpty(s)) {</span>
<span class="nc" id="L1366">            return s;</span>
        }
<span class="nc bnc" id="L1368" title="All 2 branches missed.">        if (isEmpty(separator)) {</span>
<span class="nc" id="L1369">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1371">        final int pos = s.lastIndexOf(separator);</span>
<span class="nc bnc" id="L1372" title="All 4 branches missed.">        if (pos &lt; 0 || pos == s.length() - separator.length()) {</span>
<span class="nc" id="L1373">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1375">        return s.substring(pos + separator.length());</span>
    }

    // Substring between
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Gets the String that is nested in between two instances of the same
     * String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} input String returns {@code null}. A {@code null} tag
     * returns {@code null}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBetween(null, *)            = null
     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;)             = &quot;&quot;
     * StringUtils.substringBetween(&quot;&quot;, &quot;tag&quot;)          = null
     * StringUtils.substringBetween(&quot;tagabctag&quot;, null)  = null
     * StringUtils.substringBetween(&quot;tagabctag&quot;, &quot;&quot;)    = &quot;&quot;
     * StringUtils.substringBetween(&quot;tagabctag&quot;, &quot;tag&quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String substringBetween(final String s, final String tag) {
<span class="nc" id="L1401">        return substringBetween(s, tag, tag);</span>
    }

    /**
     * &lt;p&gt;
     * Gets the String that is nested in between two Strings. Only the first
     * match is returned.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} input String returns {@code null}. A {@code null}
     * open/close returns {@code null} (no match). An empty (&quot;&quot;) open and close
     * returns an empty string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBetween(&quot;wx[b]yz&quot;, &quot;[&quot;, &quot;]&quot;) = &quot;b&quot;
     * StringUtils.substringBetween(null, *, *)          = null
     * StringUtils.substringBetween(*, null, *)          = null
     * StringUtils.substringBetween(*, *, null)          = null
     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;&quot;)          = &quot;&quot;
     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;]&quot;)         = null
     * StringUtils.substringBetween(&quot;&quot;, &quot;[&quot;, &quot;]&quot;)        = null
     * StringUtils.substringBetween(&quot;yabcz&quot;, &quot;&quot;, &quot;&quot;)     = &quot;&quot;
     * StringUtils.substringBetween(&quot;yabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
     * StringUtils.substringBetween(&quot;yabczyabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String substringBetween(final String s, final String open, final String close) {
<span class="nc bnc" id="L1430" title="All 6 branches missed.">        if (s == null || open == null || close == null) {</span>
<span class="nc" id="L1431">            return null;</span>
        }
<span class="nc" id="L1433">        final int start = s.indexOf(open);</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">        if (start &gt;= 0) {</span>
<span class="nc" id="L1435">            final int end = s.indexOf(close, start + open.length());</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">            if (end &gt;= 0) {</span>
<span class="nc" id="L1437">                return s.substring(start + open.length(), end);</span>
            }
        }
<span class="nc" id="L1440">        return null;</span>
    }

    // Left/Right/Mid
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Gets the leftmost {@code len} characters of a String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If {@code len} characters are not available, or the String is
     * {@code null}, the String will be returned without an exception. An empty
     * String is returned if len is negative.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.left(null, *)    = null
     * StringUtils.left(*, -ve)     = &quot;&quot;
     * StringUtils.left(&quot;&quot;, *)      = &quot;&quot;
     * StringUtils.left(&quot;abc&quot;, 0)   = &quot;&quot;
     * StringUtils.left(&quot;abc&quot;, 2)   = &quot;ab&quot;
     * StringUtils.left(&quot;abc&quot;, 4)   = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String left(final String s, final int len) {
<span class="nc bnc" id="L1466" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1467">            return null;</span>
        }
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L1470">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L1472" title="All 2 branches missed.">        if (s.length() &lt;= len) {</span>
<span class="nc" id="L1473">            return s;</span>
        }
<span class="nc" id="L1475">        return s.substring(0, len);</span>
    }

    /**
     * &lt;p&gt;
     * Gets the rightmost {@code len} characters of a String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If {@code len} characters are not available, or the String is
     * {@code null}, the String will be returned without an an exception. An
     * empty String is returned if len is negative.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.right(null, *)    = null
     * StringUtils.right(*, -ve)     = &quot;&quot;
     * StringUtils.right(&quot;&quot;, *)      = &quot;&quot;
     * StringUtils.right(&quot;abc&quot;, 0)   = &quot;&quot;
     * StringUtils.right(&quot;abc&quot;, 2)   = &quot;bc&quot;
     * StringUtils.right(&quot;abc&quot;, 4)   = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String right(final String s, final int len) {
<span class="nc bnc" id="L1499" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1500">            return null;</span>
        }
<span class="nc bnc" id="L1502" title="All 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L1503">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L1505" title="All 2 branches missed.">        if (s.length() &lt;= len) {</span>
<span class="nc" id="L1506">            return s;</span>
        }
<span class="nc" id="L1508">        return s.substring(s.length() - len);</span>
    }

    /**
     * &lt;p&gt;
     * Gets {@code len} characters from the middle of a String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If {@code len} characters are not available, the remainder of the String
     * will be returned without an exception. If the String is {@code null},
     * {@code null} will be returned. An empty String is returned if len is
     * negative or exceeds the length of {@code str}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.mid(null, *, *)    = null
     * StringUtils.mid(*, *, -ve)     = &quot;&quot;
     * StringUtils.mid(&quot;&quot;, 0, *)      = &quot;&quot;
     * StringUtils.mid(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;
     * StringUtils.mid(&quot;abc&quot;, 0, 4)   = &quot;abc&quot;
     * StringUtils.mid(&quot;abc&quot;, 2, 4)   = &quot;c&quot;
     * StringUtils.mid(&quot;abc&quot;, 4, 2)   = &quot;&quot;
     * StringUtils.mid(&quot;abc&quot;, -2, 2)  = &quot;ab&quot;
     * &lt;/pre&gt;
     */
    public static String mid(final String s, int pos, final int len) {
<span class="nc bnc" id="L1535" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1536">            return null;</span>
        }
<span class="nc bnc" id="L1538" title="All 4 branches missed.">        if (len &lt; 0 || pos &gt; s.length()) {</span>
<span class="nc" id="L1539">            return &quot;&quot;;</span>
        }
<span class="nc bnc" id="L1541" title="All 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L1542">            pos = 0;</span>
        }
<span class="nc bnc" id="L1544" title="All 2 branches missed.">        if (s.length() &lt;= pos + len) {</span>
<span class="nc" id="L1545">            return s.substring(pos);</span>
        }
<span class="nc" id="L1547">        return s.substring(pos, pos + len);</span>
    }

    // Padding
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Repeat a String {@code repeat} times to form a new String.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, 2) = null
     * StringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;
     * StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;
     * StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;
     * StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;
     * &lt;/pre&gt;
     */
    public static String repeat(final String s, final int repeat) {
<span class="nc bnc" id="L1567" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1568">            return null;</span>
        }
<span class="nc bnc" id="L1570" title="All 2 branches missed.">        if (repeat &lt;= 0) {</span>
<span class="nc" id="L1571">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1573">        final int inputLength = s.length();</span>
<span class="nc bnc" id="L1574" title="All 4 branches missed.">        if (repeat == 1 || inputLength == 0) {</span>
<span class="nc" id="L1575">            return s;</span>
        }

<span class="nc" id="L1578">        final int outputLength = inputLength * repeat;</span>
<span class="nc bnc" id="L1579" title="All 3 branches missed.">        switch (inputLength) {</span>
        case 1:
<span class="nc" id="L1581">            return repeat(s.charAt(0), repeat);</span>
        case 2:
<span class="nc" id="L1583">            final char ch0 = s.charAt(0);</span>
<span class="nc" id="L1584">            final char ch1 = s.charAt(1);</span>
<span class="nc" id="L1585">            final char[] output2 = new char[outputLength];</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">            for (int i = repeat * 2 - 2; i &gt;= 0; i--, i--) {</span>
<span class="nc" id="L1587">                output2[i] = ch0;</span>
<span class="nc" id="L1588">                output2[i + 1] = ch1;</span>
            }
<span class="nc" id="L1590">            return new String(output2);</span>
        default:
<span class="nc" id="L1592">            final StringBuilder buf = new StringBuilder(outputLength);</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">            for (int i = 0; i &lt; repeat; i++) {</span>
<span class="nc" id="L1594">                buf.append(s);</span>
            }
<span class="nc" id="L1596">            return buf.toString();</span>
        }
    }

    /**
     * &lt;p&gt;
     * Repeat a String {@code repeat} times to form a new String, with a String
     * separator injected each time.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, null, 2) = null
     * StringUtils.repeat(null, &quot;x&quot;, 2)  = null
     * StringUtils.repeat(&quot;&quot;, null, 0)   = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, &quot;&quot;, 2)     = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, &quot;x&quot;, 3)    = &quot;xxx&quot;
     * StringUtils.repeat(&quot;?&quot;, &quot;, &quot;, 3)  = &quot;?, ?, ?&quot;
     * &lt;/pre&gt;
     */
    public static String repeat(final String s, final String separator, final int repeat) {
<span class="nc bnc" id="L1616" title="All 4 branches missed.">        if (s == null || separator == null) {</span>
<span class="nc" id="L1617">            return repeat(s, repeat);</span>
        }
        // given that repeat(String, int) is quite optimized, better to rely on
        // it than try and splice this into it
<span class="nc" id="L1621">        final String result = repeat(s + separator, repeat);</span>
<span class="nc" id="L1622">        return removeEnd(result, separator);</span>
    }

    /**
     * &lt;p&gt;
     * Returns padding using the specified delimiter repeated to a given length.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat('e', 0)  = &quot;&quot;
     * StringUtils.repeat('e', 3)  = &quot;eee&quot;
     * StringUtils.repeat('e', -2) = &quot;&quot;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * Note: this method doesn't not support padding with &lt;a
     * href=&quot;http://www.unicode.org/glossary/#supplementary_character&quot;&gt;Unicode
     * Supplementary Characters&lt;/a&gt; as they require a pair of {@code char}s to
     * be represented. If you are needing to support full I18N of your
     * applications consider using {@link #repeat(String, int)} instead.
     * &lt;/p&gt;
     * @see #repeat(String, int)
     */
    public static String repeat(final char ch, final int repeat) {
<span class="nc" id="L1646">        final char[] buf = new char[repeat];</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">        for (int i = repeat - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1648">            buf[i] = ch;</span>
        }
<span class="nc" id="L1650">        return new String(buf);</span>
    }

    public static String leftPad(String str, int size) {
<span class="nc" id="L1654">        return leftPad(str, size, ' ');</span>
    }

    public static String leftPad(String str, int size, char padChar) {
<span class="nc bnc" id="L1658" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1659">            return null;</span>
        }
<span class="nc" id="L1661">        int pads = size - str.length();</span>
<span class="nc bnc" id="L1662" title="All 2 branches missed.">        if (pads &lt;= 0) {</span>
<span class="nc" id="L1663">            return str;</span>
        }
<span class="nc bnc" id="L1665" title="All 2 branches missed.">        if (pads &gt; 8192) {</span>
<span class="nc" id="L1666">            return leftPad(str, size, String.valueOf(padChar));</span>
        }
<span class="nc" id="L1668">        return repeat(padChar, pads).concat(str);</span>
    }

    public static String leftPad(String str, int size, String padStr) {
<span class="nc bnc" id="L1672" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1673">            return null;</span>
        }
<span class="nc bnc" id="L1675" title="All 2 branches missed.">        if (isEmpty(padStr)) {</span>
<span class="nc" id="L1676">            padStr = &quot; &quot;;</span>
        }
<span class="nc" id="L1678">        int padLen = padStr.length();</span>
<span class="nc" id="L1679">        int strLen = str.length();</span>
<span class="nc" id="L1680">        int pads = size - strLen;</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        if (pads &lt;= 0) {</span>
<span class="nc" id="L1682">            return str;</span>
        }
<span class="nc bnc" id="L1684" title="All 4 branches missed.">        if ((padLen == 1) &amp;&amp; (pads &lt;= 8192)) {</span>
<span class="nc" id="L1685">            return leftPad(str, size, padStr.charAt(0));</span>
        }
<span class="nc bnc" id="L1687" title="All 2 branches missed.">        if (pads == padLen) {</span>
<span class="nc" id="L1688">            return padStr.concat(str);</span>
        }
<span class="nc bnc" id="L1690" title="All 2 branches missed.">        if (pads &lt; padLen) {</span>
<span class="nc" id="L1691">            return padStr.substring(0, pads).concat(str);</span>
        }
<span class="nc" id="L1693">        char[] padding = new char[pads];</span>
<span class="nc" id="L1694">        char[] padChars = padStr.toCharArray();</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">        for (int i = 0; i &lt; pads; i++) {</span>
<span class="nc" id="L1696">            padding[i] = padChars[(i % padLen)];</span>
        }
<span class="nc" id="L1698">        return new String(padding).concat(str);</span>
    }

    public static String rightPad(String str, int size) {
<span class="nc" id="L1702">        return rightPad(str, size, ' ');</span>
    }

    public static String rightPad(String str, int size, char padChar) {
<span class="nc bnc" id="L1706" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1707">            return null;</span>
        }
<span class="nc" id="L1709">        int pads = size - str.length();</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">        if (pads &lt;= 0) {</span>
<span class="nc" id="L1711">            return str;</span>
        }
<span class="nc bnc" id="L1713" title="All 2 branches missed.">        if (pads &gt; 8192) {</span>
<span class="nc" id="L1714">            return rightPad(str, size, String.valueOf(padChar));</span>
        }
<span class="nc" id="L1716">        return str.concat(repeat(padChar, pads));</span>
    }

    public static String rightPad(String str, int size, String padStr) {
<span class="nc bnc" id="L1720" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L1721">            return null;</span>
        }
<span class="nc bnc" id="L1723" title="All 2 branches missed.">        if (isEmpty(padStr)) {</span>
<span class="nc" id="L1724">            padStr = &quot; &quot;;</span>
        }
<span class="nc" id="L1726">        int padLen = padStr.length();</span>
<span class="nc" id="L1727">        int strLen = str.length();</span>
<span class="nc" id="L1728">        int pads = size - strLen;</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">        if (pads &lt;= 0) {</span>
<span class="nc" id="L1730">            return str;</span>
        }
<span class="nc bnc" id="L1732" title="All 4 branches missed.">        if ((padLen == 1) &amp;&amp; (pads &lt;= 8192)) {</span>
<span class="nc" id="L1733">            return rightPad(str, size, padStr.charAt(0));</span>
        }
<span class="nc bnc" id="L1735" title="All 2 branches missed.">        if (pads == padLen) {</span>
<span class="nc" id="L1736">            return str.concat(padStr);</span>
        }
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        if (pads &lt; padLen) {</span>
<span class="nc" id="L1739">            return str.concat(padStr.substring(0, pads));</span>
        }
<span class="nc" id="L1741">        char[] padding = new char[pads];</span>
<span class="nc" id="L1742">        char[] padChars = padStr.toCharArray();</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">        for (int i = 0; i &lt; pads; i++) {</span>
<span class="nc" id="L1744">            padding[i] = padChars[(i % padLen)];</span>
        }
<span class="nc" id="L1746">        return str.concat(new String(padding));</span>
    }

    public static String center(String str, int size) {
<span class="nc" id="L1750">        return center(str, size, ' ');</span>
    }

    public static String center(String str, int size, char padChar) {
<span class="nc bnc" id="L1754" title="All 4 branches missed.">        if ((str == null) || (size &lt;= 0)) {</span>
<span class="nc" id="L1755">            return str;</span>
        }
<span class="nc" id="L1757">        int strLen = str.length();</span>
<span class="nc" id="L1758">        int pads = size - strLen;</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">        if (pads &lt;= 0) {</span>
<span class="nc" id="L1760">            return str;</span>
        }
<span class="nc" id="L1762">        str = leftPad(str, strLen + pads / 2, padChar);</span>
<span class="nc" id="L1763">        str = rightPad(str, size, padChar);</span>
<span class="nc" id="L1764">        return str;</span>
    }

    public static String reverse(String s) {
<span class="nc" id="L1768">        StringBuilder result = new StringBuilder(s.length());</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        for (int i = s.length() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1770">            result.append(s.charAt(i));</span>
        }
<span class="nc" id="L1772">        return result.toString();</span>
    }

    // Delete
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Deletes all whitespaces from a String as defined by
     * {@link Character#isWhitespace(char)}.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.deleteWhitespace(null)         = null
     * StringUtils.deleteWhitespace(&quot;&quot;)           = &quot;&quot;
     * StringUtils.deleteWhitespace(&quot;abc&quot;)        = &quot;abc&quot;
     * StringUtils.deleteWhitespace(&quot;   ab  c  &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param s
     *            the String to delete whitespace from, may be null
     * @return the String without whitespaces, {@code null} if null String input
     */
    public static String deleteWhitespace(final String s) {
<span class="nc bnc" id="L1795" title="All 2 branches missed.">        if (isEmpty(s)) {</span>
<span class="nc" id="L1796">            return s;</span>
        }
<span class="nc" id="L1798">        final int sz = s.length();</span>
<span class="nc" id="L1799">        final char[] chs = new char[sz];</span>
<span class="nc" id="L1800">        int count = 0;</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">            if (!Character.isWhitespace(s.charAt(i))) {</span>
<span class="nc" id="L1803">                chs[count++] = s.charAt(i);</span>
            }
        }
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        if (count == sz) {</span>
<span class="nc" id="L1807">            return s;</span>
        }
<span class="nc" id="L1809">        return new String(chs, 0, count);</span>
    }

    // Remove
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Removes a substring only if it is at the beginning of a source string,
     * otherwise returns the source string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} source string will return {@code null}. An empty (&quot;&quot;)
     * source string will return the empty string. A {@code null} search string
     * will return the source string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeStart(null, *)      = null
     * StringUtils.removeStart(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeStart(*, null)      = *
     * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;
     * StringUtils.removeStart(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;
     * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeStart(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String removeStart(final String s, final String remove) {
<span class="nc bnc" id="L1837" title="All 4 branches missed.">        if (isEmpty(s) || isEmpty(remove)) {</span>
<span class="nc" id="L1838">            return s;</span>
        }
<span class="nc bnc" id="L1840" title="All 2 branches missed.">        if (s.startsWith(remove)) {</span>
<span class="nc" id="L1841">            return s.substring(remove.length());</span>
        }
<span class="nc" id="L1843">        return s;</span>
    }

    /**
     * &lt;p&gt;
     * Case insensitive removal of a substring if it is at the beginning of a
     * source string, otherwise returns the source string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} source string will return {@code null}. An empty (&quot;&quot;)
     * source string will return the empty string. A {@code null} search string
     * will return the source string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeStartIgnoreCase(null, *)      = null
     * StringUtils.removeStartIgnoreCase(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeStartIgnoreCase(*, null)      = *
     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;WWW.&quot;)   = &quot;domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String removeStartIgnoreCase(final String s, final String remove) {
<span class="nc bnc" id="L1870" title="All 4 branches missed.">        if (isEmpty(s) || isEmpty(remove)) {</span>
<span class="nc" id="L1871">            return s;</span>
        }
<span class="nc bnc" id="L1873" title="All 2 branches missed.">        if (startsWithIgnoreCase(s, remove)) {</span>
<span class="nc" id="L1874">            return s.substring(remove.length());</span>
        }
<span class="nc" id="L1876">        return s;</span>
    }

    /**
     * &lt;p&gt;
     * Removes a substring only if it is at the end of a source string,
     * otherwise returns the source string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} source string will return {@code null}. An empty (&quot;&quot;)
     * source string will return the empty string. A {@code null} search string
     * will return the source string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEnd(null, *)      = null
     * StringUtils.removeEnd(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeEnd(*, null)      = *
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     */
    public static String removeEnd(final String s, final String remove) {
<span class="nc bnc" id="L1902" title="All 4 branches missed.">        if (isEmpty(s) || isEmpty(remove)) {</span>
<span class="nc" id="L1903">            return s;</span>
        }
<span class="nc bnc" id="L1905" title="All 2 branches missed.">        if (s.endsWith(remove)) {</span>
<span class="nc" id="L1906">            return s.substring(0, s.length() - remove.length());</span>
        }
<span class="nc" id="L1908">        return s;</span>
    }

    /**
     * &lt;p&gt;
     * Case insensitive removal of a substring if it is at the end of a source
     * string, otherwise returns the source string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} source string will return {@code null}. An empty (&quot;&quot;)
     * source string will return the empty string. A {@code null} search string
     * will return the source string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEndIgnoreCase(null, *)      = null
     * StringUtils.removeEndIgnoreCase(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeEndIgnoreCase(*, null)      = *
     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com&quot;
     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeEndIgnoreCase(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * StringUtils.removeEndIgnoreCase(&quot;www.domain.com&quot;, &quot;.COM&quot;) = &quot;www.domain&quot;)
     * StringUtils.removeEndIgnoreCase(&quot;www.domain.COM&quot;, &quot;.com&quot;) = &quot;www.domain&quot;)
     * &lt;/pre&gt;
     */
    public static String removeEndIgnoreCase(final String s, final String remove) {
<span class="nc bnc" id="L1936" title="All 4 branches missed.">        if (isEmpty(s) || isEmpty(remove)) {</span>
<span class="nc" id="L1937">            return s;</span>
        }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">        if (endsWithIgnoreCase(s, remove)) {</span>
<span class="nc" id="L1940">            return s.substring(0, s.length() - remove.length());</span>
        }
<span class="nc" id="L1942">        return s;</span>
    }

    /**
     * &lt;p&gt;
     * Removes all occurrences of a substring from within the source string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} source string will return {@code null}. An empty (&quot;&quot;)
     * source string will return the empty string. A {@code null} remove string
     * will return the source string. An empty (&quot;&quot;) remove string will return
     * the source string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.remove(null, *)        = null
     * StringUtils.remove(&quot;&quot;, *)          = &quot;&quot;
     * StringUtils.remove(*, null)        = *
     * StringUtils.remove(*, &quot;&quot;)          = *
     * StringUtils.remove(&quot;queued&quot;, &quot;ue&quot;) = &quot;qd&quot;
     * StringUtils.remove(&quot;queued&quot;, &quot;zz&quot;) = &quot;queued&quot;
     * &lt;/pre&gt;
     */
    public static String remove(final String s, final String remove) {
<span class="nc bnc" id="L1967" title="All 4 branches missed.">        if (isEmpty(s) || isEmpty(remove)) {</span>
<span class="nc" id="L1968">            return s;</span>
        }
<span class="nc" id="L1970">        return replace(s, remove, &quot;&quot;, -1);</span>
    }

    /**
     * &lt;p&gt;
     * Removes all occurrences of a character from within the source string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} source string will return {@code null}. An empty (&quot;&quot;)
     * source string will return the empty string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.remove(null, *)       = null
     * StringUtils.remove(&quot;&quot;, *)         = &quot;&quot;
     * StringUtils.remove(&quot;queued&quot;, 'u') = &quot;qeed&quot;
     * StringUtils.remove(&quot;queued&quot;, 'z') = &quot;queued&quot;
     * &lt;/pre&gt;
     */
    public static String remove(final String s, final char remove) {
<span class="nc bnc" id="L1991" title="All 4 branches missed.">        if (isEmpty(s) || s.indexOf(remove) &lt; 0) {</span>
<span class="nc" id="L1992">            return s;</span>
        }
<span class="nc" id="L1994">        final char[] chars = s.toCharArray();</span>
<span class="nc" id="L1995">        int pos = 0;</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">            if (chars[i] != remove) {</span>
<span class="nc" id="L1998">                chars[pos++] = chars[i];</span>
            }
        }
<span class="nc" id="L2001">        return new String(chars, 0, pos);</span>
    }

    /**
     * Removes all characters contained in provided string.
     *
     * @param s    source string
     * @param chars  string containing characters to remove
     */
    public static String removeChars(String s, String chars) {
<span class="nc" id="L2011">        int i = s.length();</span>
<span class="nc" id="L2012">        StringBuilder sb = new StringBuilder(i);</span>
<span class="nc bnc" id="L2013" title="All 2 branches missed.">        for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L2014">            char c = s.charAt(j);</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">            if (chars.indexOf(c) == -1) {</span>
<span class="nc" id="L2016">                sb.append(c);</span>
            }
        }
<span class="nc" id="L2019">        return sb.toString();</span>
    }

    /**
     * Removes set of characters from string.
     *
     * @param s    string
     * @param chars  characters to remove
     */
    public static String removeChars(String s, char... chars) {
<span class="nc" id="L2029">        int i = s.length();</span>
<span class="nc" id="L2030">        StringBuilder sb = new StringBuilder(i);</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">        mainloop: for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L2032">            char c = s.charAt(j);</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">            for (char aChar : chars) {</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                if (c == aChar) {</span>
<span class="nc" id="L2035">                    continue mainloop;</span>
                }
            }
<span class="nc" id="L2038">            sb.append(c);</span>
        }
<span class="nc" id="L2040">        return sb.toString();</span>
    }

    public static String prefix(String s, String prefix) {
<span class="nc bnc" id="L2044" title="All 2 branches missed.">        if (!s.startsWith(prefix)) {</span>
<span class="nc" id="L2045">            s = prefix + s;</span>
        }
<span class="nc" id="L2047">        return s;</span>
    }

    public static String suffix(String s, String suffix) {
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        if (!s.endsWith(suffix)) {</span>
<span class="nc" id="L2052">            s = s + suffix;</span>
        }
<span class="nc" id="L2054">        return s;</span>
    }

    // Replacing
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Replaces a String with another String inside a larger String, once.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceOnce(null, *, *)        = null
     * StringUtils.replaceOnce(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replaceOnce(&quot;any&quot;, null, *)    = &quot;any&quot;
     * StringUtils.replaceOnce(&quot;any&quot;, *, null)    = &quot;any&quot;
     * StringUtils.replaceOnce(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;ba&quot;
     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zba&quot;
     * &lt;/pre&gt;
     *
     * @see #replace(String text, String searchString, String replacement, int
     *      max)
     */
    public static String replaceOnce(final String text, final String searchString, final String replacement) {
<span class="nc" id="L2083">        return replace(text, searchString, replacement, 1);</span>
    }

    /**
     * Replaces each substring of the source String that matches the given
     * regular expression with the given replacement using the
     * {@link Pattern#DOTALL} option. DOTALL is also know as single-line mode in
     * Perl. This call is also equivalent to:
     * &lt;ul&gt;
     * &lt;li&gt;{@code source.replaceAll(&amp;quot;(?s)&amp;quot; + regex, replacement)}&lt;/li&gt;
     * &lt;li&gt;
     * {@code Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement)}
     * &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @see String#replaceAll(String, String)
     * @see Pattern#DOTALL
     */
    public static String replacePattern(final String source, final String regex, final String replacement) {
<span class="nc" id="L2102">        return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of a String within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *)        = null
     * StringUtils.replace(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replace(&quot;any&quot;, null, *)    = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, null)    = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;b&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zbz&quot;
     * &lt;/pre&gt;
     */
    public static String replace(final String text, final String searchString, final String replacement) {
<span class="nc" id="L2126">        return replace(text, searchString, replacement, -1);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces a String with another String inside a larger String, for the
     * first {@code max} values of the search String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *, *)         = null
     * StringUtils.replace(&quot;&quot;, *, *, *)           = &quot;&quot;
     * StringUtils.replace(&quot;any&quot;, null, *, *)     = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, null, *)     = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *, *)       = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, *, 0)        = &quot;any&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, null, -1) = &quot;abaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;&quot;, -1)   = &quot;b&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 0)   = &quot;abaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 1)   = &quot;zbaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 2)   = &quot;zbza&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, -1)  = &quot;zbzz&quot;
     * &lt;/pre&gt;
     */
    public static String replace(final String text, final String searchString, final String replacement, int max) {
<span class="nc bnc" id="L2155" title="All 8 branches missed.">        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {</span>
<span class="nc" id="L2156">            return text;</span>
        }
<span class="nc" id="L2158">        int start = 0;</span>
<span class="nc" id="L2159">        int end = text.indexOf(searchString, start);</span>
<span class="nc bnc" id="L2160" title="All 2 branches missed.">        if (end &lt; 0) {</span>
<span class="nc" id="L2161">            return text;</span>
        }
<span class="nc" id="L2163">        final int replLength = searchString.length();</span>
<span class="nc" id="L2164">        int increase = replacement.length() - replLength;</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">        increase = increase &lt; 0 ? 0 : increase;</span>
<span class="nc bnc" id="L2166" title="All 4 branches missed.">        increase *= max &lt; 0 ? 16 : max &gt; 64 ? 64 : max;</span>
<span class="nc" id="L2167">        final StringBuilder buf = new StringBuilder(text.length() + increase);</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">        while (end &gt;= 0) {</span>
<span class="nc" id="L2169">            buf.append(text.substring(start, end)).append(replacement);</span>
<span class="nc" id="L2170">            start = end + replLength;</span>
<span class="nc bnc" id="L2171" title="All 2 branches missed.">            if (--max == 0) {</span>
<span class="nc" id="L2172">                break;</span>
            }
<span class="nc" id="L2174">            end = text.indexOf(searchString, start);</span>
        }
<span class="nc" id="L2176">        buf.append(text.substring(start));</span>
<span class="nc" id="L2177">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op, or if any
     * &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
     * ignored. This will not repeat. For repeating replaces, call the
     * overloaded method.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *)        = null
     *  StringUtils.replaceEach(&quot;&quot;, *, *)          = &quot;&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, null) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0]) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null)  = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;})  = &quot;b&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;})  = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;})  = &quot;wcte&quot;
     *  (example of how it does not repeat)
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;})  = &quot;dcte&quot;
     * &lt;/pre&gt;
     */
    public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {
<span class="nc" id="L2207">        return replaceEach(text, searchList, replacementList, false, 0);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op, or if any
     * &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
     * ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *, *) = null
     *  StringUtils.replaceEach(&quot;&quot;, *, *, *) = &quot;&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0], *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;}, *) = &quot;b&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;}, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;}, *) = &quot;wcte&quot;
     *  (example of how it repeats)
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, false) = &quot;dcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, true) = &quot;tcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, true) = IllegalStateException
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, false) = &quot;dcabe&quot;
     * &lt;/pre&gt;
     */
    public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {
        // timeToLive should be 0 if not used or nothing to replace, else it's
        // the length of the replace array
<span class="nc bnc" id="L2241" title="All 2 branches missed.">        final int timeToLive = searchList == null ? 0 : searchList.length;</span>
<span class="nc" id="L2242">        return replaceEach(text, searchList, replacementList, true, timeToLive);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} reference passed to this method is a no-op, or if any
     * &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
     * ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *, *) = null
     *  StringUtils.replaceEach(&quot;&quot;, *, *, *) = &quot;&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0], *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;}, *) = &quot;b&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;}, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;}, *) = &quot;wcte&quot;
     *  (example of how it repeats)
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, false) = &quot;dcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, true) = &quot;tcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, *) = IllegalStateException
     * &lt;/pre&gt;
     */
    private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
<span class="nc bnc" id="L2273" title="All 12 branches missed.">        if (text == null || text.isEmpty() || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {</span>
<span class="nc" id="L2274">            return text;</span>
        }

        // if recursing, this shouldn't be less than 0
<span class="nc bnc" id="L2278" title="All 2 branches missed.">        if (timeToLive &lt; 0) {</span>
<span class="nc" id="L2279">            throw new IllegalStateException(&quot;Aborting to protect against StackOverflowError - &quot; + &quot;output of one loop is the input of another&quot;);</span>
        }

<span class="nc" id="L2282">        final int searchLength = searchList.length;</span>
<span class="nc" id="L2283">        final int replacementLength = replacementList.length;</span>

        // make sure lengths are ok, these need to be equal
<span class="nc bnc" id="L2286" title="All 2 branches missed.">        if (searchLength != replacementLength) {</span>
<span class="nc" id="L2287">            throw new IllegalArgumentException(&quot;Search and Replace array lengths don't match: &quot; + searchLength + &quot; vs &quot; + replacementLength);</span>
        }

        // keep track of which still have matches
<span class="nc" id="L2291">        final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];</span>

        // index on index that the match was found
<span class="nc" id="L2294">        int textIndex = -1;</span>
<span class="nc" id="L2295">        int replaceIndex = -1;</span>
<span class="nc" id="L2296">        int tempIndex = -1;</span>

        // index of replace array that will replace the search string found
        // NOTE: logic duplicated below START
<span class="nc bnc" id="L2300" title="All 2 branches missed.">        for (int i = 0; i &lt; searchLength; i++) {</span>
<span class="nc bnc" id="L2301" title="All 8 branches missed.">            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {</span>
<span class="nc" id="L2302">                continue;</span>
            }
<span class="nc" id="L2304">            tempIndex = text.indexOf(searchList[i]);</span>

            // see if we need to keep searching for this
<span class="nc bnc" id="L2307" title="All 2 branches missed.">            if (tempIndex == -1) {</span>
<span class="nc" id="L2308">                noMoreMatchesForReplIndex[i] = true;</span>
            } else {
<span class="nc bnc" id="L2310" title="All 4 branches missed.">                if (textIndex == -1 || tempIndex &lt; textIndex) {</span>
<span class="nc" id="L2311">                    textIndex = tempIndex;</span>
<span class="nc" id="L2312">                    replaceIndex = i;</span>
                }
            }
        }
        // NOTE: logic mostly below END

        // no search strings found, we are done
<span class="nc bnc" id="L2319" title="All 2 branches missed.">        if (textIndex == -1) {</span>
<span class="nc" id="L2320">            return text;</span>
        }

<span class="nc" id="L2323">        int start = 0;</span>

        // get a good guess on the size of the result buffer so it doesn't have
        // to double if it goes over a bit
<span class="nc" id="L2327">        int increase = 0;</span>

        // count the replacement text elements that are larger than their
        // corresponding text being replaced
<span class="nc bnc" id="L2331" title="All 2 branches missed.">        for (int i = 0; i &lt; searchList.length; i++) {</span>
<span class="nc bnc" id="L2332" title="All 4 branches missed.">            if (searchList[i] == null || replacementList[i] == null) {</span>
<span class="nc" id="L2333">                continue;</span>
            }
<span class="nc" id="L2335">            final int greater = replacementList[i].length() - searchList[i].length();</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">            if (greater &gt; 0) {</span>
<span class="nc" id="L2337">                increase += 3 * greater; // assume 3 matches</span>
            }
        }
        // have upper-bound at 20% increase, then let Java take over
<span class="nc" id="L2341">        increase = Math.min(increase, text.length() / 5);</span>

<span class="nc" id="L2343">        final StringBuilder buf = new StringBuilder(text.length() + increase);</span>

<span class="nc bnc" id="L2345" title="All 2 branches missed.">        while (textIndex != -1) {</span>

<span class="nc bnc" id="L2347" title="All 2 branches missed.">            for (int i = start; i &lt; textIndex; i++) {</span>
<span class="nc" id="L2348">                buf.append(text.charAt(i));</span>
            }
<span class="nc" id="L2350">            buf.append(replacementList[replaceIndex]);</span>

<span class="nc" id="L2352">            start = textIndex + searchList[replaceIndex].length();</span>

<span class="nc" id="L2354">            textIndex = -1;</span>
<span class="nc" id="L2355">            replaceIndex = -1;</span>
<span class="nc" id="L2356">            tempIndex = -1;</span>
            // find the next earliest match
            // NOTE: logic mostly duplicated above START
<span class="nc bnc" id="L2359" title="All 2 branches missed.">            for (int i = 0; i &lt; searchLength; i++) {</span>
<span class="nc bnc" id="L2360" title="All 8 branches missed.">                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {</span>
<span class="nc" id="L2361">                    continue;</span>
                }
<span class="nc" id="L2363">                tempIndex = text.indexOf(searchList[i], start);</span>

                // see if we need to keep searching for this
<span class="nc bnc" id="L2366" title="All 2 branches missed.">                if (tempIndex == -1) {</span>
<span class="nc" id="L2367">                    noMoreMatchesForReplIndex[i] = true;</span>
                } else {
<span class="nc bnc" id="L2369" title="All 4 branches missed.">                    if (textIndex == -1 || tempIndex &lt; textIndex) {</span>
<span class="nc" id="L2370">                        textIndex = tempIndex;</span>
<span class="nc" id="L2371">                        replaceIndex = i;</span>
                    }
                }
            }
            // NOTE: logic duplicated above END

        }
<span class="nc" id="L2378">        final int textLength = text.length();</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">        for (int i = start; i &lt; textLength; i++) {</span>
<span class="nc" id="L2380">            buf.append(text.charAt(i));</span>
        }
<span class="nc" id="L2382">        final String result = buf.toString();</span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">        if (!repeat) {</span>
<span class="nc" id="L2384">            return result;</span>
        }

<span class="nc" id="L2387">        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);</span>
    }

    // Replace, character based
    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;
     * Replaces all occurrences of a character in a String with another. This is
     * a null-safe version of {@link String#replace(char, char)}.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} string input returns {@code null}. An empty (&quot;&quot;) string
     * input returns an empty string.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceChars(null, *, *)        = null
     * StringUtils.replaceChars(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, 'b', 'y') = &quot;aycya&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, 'z', 'y') = &quot;abcba&quot;
     * &lt;/pre&gt;
     */
    public static String replaceChars(final String str, final char searchChar, final char replaceChar) {
<span class="nc bnc" id="L2411" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L2412">            return null;</span>
        }
<span class="nc" id="L2414">        return str.replace(searchChar, replaceChar);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces multiple characters in a String in one go. This method can also
     * be used to delete characters.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * For example:&lt;br&gt;
     * &lt;code&gt;replaceChars(&amp;quot;hello&amp;quot;, &amp;quot;ho&amp;quot;, &amp;quot;jy&amp;quot;) = jelly&lt;/code&gt;
     * .
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * A {@code null} string input returns {@code null}. An empty (&quot;&quot;) string
     * input returns an empty string. A null or empty set of search characters
     * returns the input string.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The length of the search characters should normally equal the length of
     * the replace characters. If the search characters is longer, then the
     * extra search characters are deleted. If the search characters is shorter,
     * then the extra replace characters are ignored.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceChars(null, *, *)           = null
     * StringUtils.replaceChars(&quot;&quot;, *, *)             = &quot;&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, null, *)       = &quot;abc&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, &quot;&quot;, *)         = &quot;abc&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, &quot;b&quot;, null)     = &quot;ac&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, &quot;b&quot;, &quot;&quot;)       = &quot;ac&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;yz&quot;)  = &quot;ayzya&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;y&quot;)   = &quot;ayya&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;yzx&quot;) = &quot;ayzya&quot;
     * &lt;/pre&gt;
     */
    public static String replaceChars(final String str, final String searchChars, String replaceChars) {
<span class="nc bnc" id="L2455" title="All 4 branches missed.">        if (isEmpty(str) || isEmpty(searchChars)) {</span>
<span class="nc" id="L2456">            return str;</span>
        }
<span class="nc bnc" id="L2458" title="All 2 branches missed.">        if (replaceChars == null) {</span>
<span class="nc" id="L2459">            replaceChars = &quot;&quot;;</span>
        }
<span class="nc" id="L2461">        boolean modified = false;</span>
<span class="nc" id="L2462">        final int replaceCharsLength = replaceChars.length();</span>
<span class="nc" id="L2463">        final int strLength = str.length();</span>
<span class="nc" id="L2464">        final StringBuilder buf = new StringBuilder(strLength);</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">        for (int i = 0; i &lt; strLength; i++) {</span>
<span class="nc" id="L2466">            final char ch = str.charAt(i);</span>
<span class="nc" id="L2467">            final int index = searchChars.indexOf(ch);</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="nc" id="L2469">                modified = true;</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">                if (index &lt; replaceCharsLength) {</span>
<span class="nc" id="L2471">                    buf.append(replaceChars.charAt(index));</span>
                }
            } else {
<span class="nc" id="L2474">                buf.append(ch);</span>
            }
        }
<span class="nc bnc" id="L2477" title="All 2 branches missed.">        if (modified) {</span>
<span class="nc" id="L2478">            return buf.toString();</span>
        }
<span class="nc" id="L2480">        return str;</span>
    }

    public static String[] split(String str, String delimiter) {
<span class="nc bnc" id="L2484" title="All 2 branches missed.">        if (str == null) return null;</span>
<span class="nc" id="L2485">        List&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L2487">        int ipos = 0, lastpos = 0;</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">        while ((ipos = str.indexOf(delimiter, lastpos)) != -1) {</span>
<span class="nc" id="L2489">            results.add(str.substring(lastpos, ipos));</span>
<span class="nc" id="L2490">            lastpos = ipos + delimiter.length();</span>
        }
<span class="nc" id="L2492">        results.add(str.substring(lastpos));</span>
<span class="nc" id="L2493">        return results.toArray(new String[results.size()]);</span>
    }

    public static String[] split(String str, char delimiter) {
<span class="nc bnc" id="L2497" title="All 2 branches missed.">        if (str == null) return null;</span>
<span class="nc" id="L2498">        List&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L2500">        int ipos = 0, lastpos = 0;</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">        while ((ipos = str.indexOf(delimiter, lastpos)) != -1) {</span>
<span class="nc" id="L2502">            results.add(str.substring(lastpos, ipos));</span>
<span class="nc" id="L2503">            lastpos = ipos + 1;</span>
        }
<span class="nc" id="L2505">        results.add(str.substring(lastpos));</span>
<span class="nc" id="L2506">        return results.toArray(new String[results.size()]);</span>
    }

    public static String[] splitChars(String str, String delimiters) {
<span class="nc bnc" id="L2510" title="All 2 branches missed.">        if (str == null) return null;</span>
<span class="nc" id="L2511">        List&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L2513">        int lastpos = 0;</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">        for (int i = 0, len = str.length(); i &lt; len; i++) {</span>
<span class="nc" id="L2515">            char c = str.charAt(i);</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">            if (delimiters.indexOf(c) != -1) {</span>
<span class="nc" id="L2517">                results.add(str.substring(lastpos, i));</span>
<span class="nc" id="L2518">                lastpos = i + 1;</span>
            }
        }
<span class="nc" id="L2521">        results.add(str.substring(lastpos));</span>
<span class="nc" id="L2522">        return results.toArray(new String[results.size()]);</span>
    }

    public static String[] splitChars(String str, char... delimiters) {
<span class="nc bnc" id="L2526" title="All 2 branches missed.">        if (str == null) return null;</span>
<span class="nc" id="L2527">        List&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L2529">        int lastpos = 0;</span>
<span class="nc bnc" id="L2530" title="All 2 branches missed.">        for (int i = 0, len = str.length(); i &lt; len; i++) {</span>
<span class="nc" id="L2531">            char c = str.charAt(i);</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">            if (ArrayUtils.contains(delimiters, c)) {</span>
<span class="nc" id="L2533">                results.add(str.substring(lastpos, i));</span>
<span class="nc" id="L2534">                lastpos = i + 1;</span>
            }
        }
<span class="nc" id="L2537">        results.add(str.substring(lastpos));</span>
<span class="nc" id="L2538">        return results.toArray(new String[results.size()]);</span>
    }

    /**
     * 按逗号分隔，两边加引号的不分割（CSV 规则）.
     */
    public static String[] splitCSV(String str) {
<span class="nc bnc" id="L2545" title="All 2 branches missed.">        if (str == null) return null;</span>
<span class="nc" id="L2546">        String[] parts = StringUtils.split(str, ',');</span>

<span class="nc" id="L2548">        List&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L2549" title="All 2 branches missed.">        for (int i = 0; i &lt; parts.length; i++) {</span>
<span class="nc" id="L2550">            String s = parts[i].trim();</span>
<span class="nc bnc" id="L2551" title="All 2 branches missed.">            if (s.length() == 0) {</span>
<span class="nc" id="L2552">                results.add(s);</span>
            } else {
<span class="nc" id="L2554">                char c = s.charAt(0);</span>
<span class="nc bnc" id="L2555" title="All 6 branches missed.">                if (c == '&quot;' || c == '\'' || c == '`') {</span>
<span class="nc" id="L2556">                    StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2557">                    sb.append(s);</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">                    while (i + 1 &lt; parts.length) {</span>
<span class="nc bnc" id="L2559" title="All 6 branches missed.">                        if (sb.length() &gt; 1 &amp;&amp; s.length() &gt; 0 &amp;&amp; s.charAt(s.length() - 1) == c) {</span>
<span class="nc" id="L2560">                            break;</span>
                        }
<span class="nc" id="L2562">                        s = parts[++i];</span>
<span class="nc" id="L2563">                        sb.append(',').append(s);</span>
                    }
<span class="nc" id="L2565">                    s = sb.toString().trim();</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">                    if (s.charAt(s.length() - 1) == c) {</span>
<span class="nc" id="L2567">                        s = s.substring(1, s.length() - 1);</span>
                    }
<span class="nc" id="L2569">                    results.add(s);</span>
<span class="nc" id="L2570">                } else {</span>
<span class="nc" id="L2571">                    results.add(s);</span>
                }
            }
        }
<span class="nc" id="L2575">        return results.toArray(new String[results.size()]);</span>
    }

    public static String join(String... parts) {
<span class="nc" id="L2579">        StringBuilder sb = new StringBuilder(parts.length);</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">        for (String part : parts) {</span>
<span class="nc" id="L2581">            sb.append(part);</span>
        }
<span class="nc" id="L2583">        return sb.toString();</span>
    }

    public static String join(Iterable&lt;?&gt; elements, String separator) {
<span class="nc bnc" id="L2587" title="All 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L2588">            return &quot;&quot;;</span>
        }
<span class="nc" id="L2590">        return join(elements.iterator(), separator);</span>
    }

    public static String join(Iterator&lt;?&gt; elements, String separator) {
<span class="nc bnc" id="L2594" title="All 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L2595">            return &quot;&quot;;</span>
        }
<span class="nc" id="L2597">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2598" title="All 2 branches missed.">        while (elements.hasNext()) {</span>
<span class="nc" id="L2599">            Object o = elements.next();</span>
<span class="nc bnc" id="L2600" title="All 4 branches missed.">            if (sb.length() &gt; 0 &amp;&amp; separator != null) {</span>
<span class="nc" id="L2601">                sb.append(separator);</span>
            }
<span class="nc" id="L2603">            sb.append(o);</span>
<span class="nc" id="L2604">        }</span>
<span class="nc" id="L2605">        return sb.toString();</span>
    }

    public static String join(Object[] elements, String separator) {
<span class="nc bnc" id="L2609" title="All 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L2610">            return &quot;&quot;;</span>
        }
<span class="nc" id="L2612">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2613" title="All 2 branches missed.">        for (Object o : elements) {</span>
<span class="nc bnc" id="L2614" title="All 4 branches missed.">            if (sb.length() &gt; 0 &amp;&amp; separator != null) {</span>
<span class="nc" id="L2615">                sb.append(separator);</span>
            }
<span class="nc" id="L2617">            sb.append(o);</span>
        }
<span class="nc" id="L2619">        return sb.toString();</span>
    }

    public static int count(String source, String substr) {
<span class="nc" id="L2623">        return count(source, substr, 0);</span>
    }

    public static int count(String source, String substr, int start) {
<span class="nc bnc" id="L2627" title="All 4 branches missed.">        if (source == null || source.length() == 0) {</span>
<span class="nc" id="L2628">            return 0;</span>
        }

<span class="nc" id="L2631">        int count = 0;</span>
<span class="nc" id="L2632">        int j = start;</span>
<span class="nc" id="L2633">        int sublen = substr.length();</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">        if (sublen == 0) return 0;</span>
        while (true) {
<span class="nc" id="L2636">            int i = source.indexOf(substr, j);</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">            if (i == -1) {</span>
<span class="nc" id="L2638">                break;</span>
            }
<span class="nc" id="L2640">            count++;</span>
<span class="nc" id="L2641">            j = i + sublen;</span>
<span class="nc" id="L2642">        }</span>
<span class="nc" id="L2643">        return count;</span>
    }

    public static int count(String source, char c) {
<span class="nc" id="L2647">        return count(source, c, 0);</span>
    }

    public static int count(String source, char c, int start) {
<span class="nc bnc" id="L2651" title="All 4 branches missed.">        if (source == null || source.length() == 0) {</span>
<span class="nc" id="L2652">            return 0;</span>
        }

<span class="nc" id="L2655">        int count = 0;</span>
<span class="nc" id="L2656">        int j = start;</span>
        while (true) {
<span class="nc" id="L2658">            int i = source.indexOf(c, j);</span>
<span class="nc bnc" id="L2659" title="All 2 branches missed.">            if (i == -1) {</span>
<span class="nc" id="L2660">                break;</span>
            }
<span class="nc" id="L2662">            count++;</span>
<span class="nc" id="L2663">            j = i + 1;</span>
<span class="nc" id="L2664">        }</span>
<span class="nc" id="L2665">        return count;</span>
    }
    
    public static int parseInteger(String intStr) {
<span class="nc bnc" id="L2669" title="All 2 branches missed.">        if (intStr == null) {</span>
<span class="nc" id="L2670">            return RedisConstants.DEFAULT_INT_VALUE;</span>
        }
        try {
<span class="nc" id="L2673">            return Integer.parseInt(intStr);</span>
<span class="nc" id="L2674">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L2675">            return RedisConstants.DEFAULT_INT_VALUE;</span>
        }
    }

    public static String urlEncode(String value) {
<span class="nc bnc" id="L2680" title="All 2 branches missed.">        if (StringUtils.isEmpty(value)) {</span>
<span class="nc" id="L2681">            return &quot;&quot;;</span>
        }
        try {
<span class="nc" id="L2684">            return URLEncoder.encode(value, RedisConstants.DEFAULT_CHARACTER);</span>
<span class="nc" id="L2685">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L2686">            throw new RuntimeException(e.getMessage(), e);</span>
        }
    }

    public static String urlDecode(String value) {
<span class="nc bnc" id="L2691" title="All 2 branches missed.">        if (StringUtils.isBlank(value)) {</span>
<span class="nc" id="L2692">            return &quot;&quot;;</span>
        }
        try {
<span class="nc" id="L2695">            return URLDecoder.decode(value, RedisConstants.DEFAULT_CHARACTER);</span>
<span class="nc" id="L2696">        } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L2697">            throw new RuntimeException(e.getMessage(), e);</span>
        }
    }

    public static String toQueryString(Map&lt;String, String&gt; ps) {
<span class="nc" id="L2702">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L2703" title="All 4 branches missed.">        if (ps != null &amp;&amp; ps.size() &gt; 0) {</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">            for (Map.Entry&lt;String, String&gt; entry : new TreeMap&lt;String, String&gt;(ps).entrySet()) {</span>
<span class="nc" id="L2705">                String key = entry.getKey();</span>
<span class="nc" id="L2706">                String value = entry.getValue();</span>
<span class="nc bnc" id="L2707" title="All 8 branches missed.">                if (key != null &amp;&amp; key.length() &gt; 0 &amp;&amp; value != null &amp;&amp; value.length() &gt; 0) {</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">                    if (buf.length() &gt; 0) {</span>
<span class="nc" id="L2709">                        buf.append(&quot;&amp;&quot;);</span>
                    }
<span class="nc" id="L2711">                    buf.append(key);</span>
<span class="nc" id="L2712">                    buf.append(&quot;=&quot;);</span>
<span class="nc" id="L2713">                    buf.append(value);</span>
                }
<span class="nc" id="L2715">            }</span>
        }
<span class="nc" id="L2717">        return buf.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>