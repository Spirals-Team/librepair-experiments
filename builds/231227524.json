{
  "@type": "build",
  "@href": "/v3/build/231227524",
  "@representation": "standard",
  "@permissions": {
    "read": true,
    "cancel": false,
    "restart": false
  },
  "id": 231227524,
  "number": "3184",
  "state": "failed",
  "duration": 94,
  "event_type": "push",
  "previous_state": null,
  "pull_request_title": null,
  "pull_request_number": null,
  "started_at": "2017-05-11T16:28:34Z",
  "finished_at": "2017-05-11T16:30:08Z",
  "private": false,
  "repository": {
    "@type": "repository",
    "@href": "/v3/repo/78264",
    "@representation": "minimal",
    "id": 78264,
    "name": "retrofit",
    "slug": "square/retrofit"
  },
  "branch": {
    "@type": "branch",
    "@href": "/v3/repo/78264/branch/jw%2F2017-05-11%2Ferror-city",
    "@representation": "minimal",
    "name": "jw/2017-05-11/error-city"
  },
  "tag": null,
  "commit": {
    "@type": "commit",
    "@representation": "minimal",
    "id": 66923406,
    "sha": "623d7cd2ad7f1bf361bce14995fa5489fe1d815c",
    "ref": "refs/heads/jw/2017-05-11/error-city",
    "message": "Explicitly handle wrapped, re-thrown exceptions from onComplete, onError.\n\nBecause Exceptions.throwIfFatal treats these as fatal, prior to this they would bubble up to the caller. This is either the thread uncaught exception handler which is fine, but in the case of async sources it would go to the library code invoking the async callback (like OkHttp's Call) which might swallow them.",
    "compare_url": "https://github.com/square/retrofit/commit/623d7cd2ad7f",
    "committed_at": "2017-05-11T16:28:15Z"
  },
  "jobs": [
    {
      "@type": "job",
      "@href": "/v3/job/231227525",
      "@representation": "minimal",
      "id": 231227525
    }
  ],
  "stages": [

  ],
  "created_by": {
    "@type": "user",
    "@href": "/v3/user/16209",
    "@representation": "minimal",
    "id": 16209,
    "login": "JakeWharton"
  },
  "updated_at": "2019-04-10T09:26:59.501Z"
}