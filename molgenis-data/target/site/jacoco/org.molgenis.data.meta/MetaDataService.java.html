<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetaDataService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data.meta</a> &gt; <span class="el_source">MetaDataService.java</span></div><h1>MetaDataService.java</h1><pre class="source lang-java linenums">package org.molgenis.data.meta;

import org.molgenis.data.Entity;
import org.molgenis.data.Repository;
import org.molgenis.data.RepositoryCollection;
import org.molgenis.data.UnknownEntityTypeException;
import org.molgenis.data.meta.model.*;
import org.molgenis.data.meta.model.Package;

import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.stream.Stream;

import static org.molgenis.data.meta.model.AttributeMetadata.ATTRIBUTE_META_DATA;
import static org.molgenis.data.meta.model.EntityTypeMetadata.ENTITY_TYPE_META_DATA;
import static org.molgenis.data.meta.model.PackageMetadata.PACKAGE;
import static org.molgenis.data.meta.model.TagMetadata.TAG;

public interface MetaDataService extends Iterable&lt;RepositoryCollection&gt;
{
	/**
	 * Returns the repository for the given entity name.
	 *
	 * @return entity repository or null if no repository exists for the entity (e.g. the entity is abstract)
	 * @throws UnknownEntityTypeException if no entity with the given name exists
	 */
	Repository&lt;Entity&gt; getRepository(String entityTypeId);

	/**
	 * Returns the typed repository for the given entity name.
	 *
	 * @param entityClass entity class
	 * @param &lt;E&gt;         entity type
	 * @return typed entity repository or null if no repository exists for the entity (e.g. the entity is abstract)
	 * @throws UnknownEntityTypeException if no entity with the given name exists
	 */
	&lt;E extends Entity&gt; Repository&lt;E&gt; getRepository(String entityTypeId, Class&lt;E&gt; entityClass);

	/**
	 * Returns the repository for the given entity type
	 *
	 * @param entityType entity type
	 * @return entity repository or null if no repository exists for the entity (e.g. the entity is abstract)
	 */
	Repository&lt;Entity&gt; getRepository(EntityType entityType);

	/**
	 * Returns the typed repository for the given entity type
	 *
	 * @param entityType  entity type
	 * @param entityClass entity class
	 * @param &lt;E&gt;         entity type
	 * @return typed entity repository or null if no repository exists for the entity (e.g. the entity is abstract).
	 */
	&lt;E extends Entity&gt; Repository&lt;E&gt; getRepository(EntityType entityType, Class&lt;E&gt; entityClass);

	/**
	 * Returns whether a {@link Repository} exists for the given entity name. Always returns false for abstract entities.
	 *
	 * @return true if non-abstract entity type exists for the given entity name
	 */
	boolean hasRepository(String entityTypeId); // FIXME use entity type ids instead of entity type fqns

	/**
	 * Create a repository for the given entity type.
	 *
	 * @param entityType entity type
	 * @return repository
	 * @throws org.molgenis.data.MolgenisDataException if entity type is abstract
	 */
	Repository&lt;Entity&gt; createRepository(EntityType entityType);

	/**
	 * Create a typed repository for the given entity type.
	 *
	 * @param entityType  entity type
	 * @param entityClass entity class
	 * @param &lt;E&gt;         entity type
	 * @return typed repository
	 * @throws org.molgenis.data.MolgenisDataException if entity type is abstract
	 */
	&lt;E extends Entity&gt; Repository&lt;E&gt; createRepository(EntityType entityType, Class&lt;E&gt; entityClass);

	/**
	 * Get a backend by name or null if it does not exists
	 *
	 * @param backendName repository collection name
	 * @return repository collection, null if entity type is abstract
	 */
	RepositoryCollection getBackend(String backendName);

	/**
	 * Get the backend the EntityType belongs to
	 *
	 * @param entityType entity type
	 * @return repository collection, null if entity type is abstract
	 */
	RepositoryCollection getBackend(EntityType entityType);

	/**
	 * Has backend will check if the requested backend already exists and is registered.
	 *
	 * @param backendName backend name
	 * @return true if a repository collection with the given name exists
	 */
	boolean hasBackend(String backendName);

	/**
	 * Get the default backend
	 *
	 * @return the default repository collection
	 */
	RepositoryCollection getDefaultBackend();

	/**
	 * Get all packages
	 *
	 * @return List of Package
	 */
	List&lt;Package&gt; getPackages();

	/**
	 * Lists all root packages.
	 *
	 * @return Iterable of all root Packages
	 */
	Iterable&lt;Package&gt; getRootPackages();

	/**
	 * Retrieves a package with a given name.
	 *
	 * @param name the name of the Package to retrieve
	 * @return the Package, or null if the package does not exist.
	 */
	Package getPackage(String name); // FIXME use entity type ids instead of entity type fqns

	/**
	 * Adds a new Package
	 *
	 * @param pack package
	 */
	void addPackage(Package pack);

	/**
	 * Add or update packages
	 *
	 * @param packages packages
	 */
	void upsertPackages(Stream&lt;Package&gt; packages);

	/**
	 * Add or update tags
	 *
	 * @param tags tags
	 */
	void upsertTags(Collection&lt;Tag&gt; tags);

	/**
	 * Returns whether an entity type with the given id exists.
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if entity type exists for the given entity id
	 */
	boolean hasEntityType(String entityTypeId);

	/**
	 * Gets the entity type for a given entity.
	 *
	 * @param name the fullyQualifiedName of the entity
	 * @return EntityType of the entity, or null if the entity does not exist
	 */
	EntityType getEntityType(String name); // FIXME use entity type ids instead of entity type fqns

	/**
	 * Gets the entity type for a given entity.
	 *
	 * @param entityTypeId the id of the entity
	 * @return EntityType of the entity, or null if the entity does not exist
	 */
	EntityType getEntityTypeById(String entityTypeId); // FIXME remove

	/**
	 * Returns a stream of all {@link EntityType entity type}.
	 *
	 * @return all entity type
	 */
	Stream&lt;EntityType&gt; getEntityTypes();

	/**
	 * Returns a stream of all {@link Repository repositories}.
	 *
	 * @return all repositories
	 */
	Stream&lt;Repository&lt;Entity&gt;&gt; getRepositories();

	/**
	 * Add entity type and entity type attributes.
	 *
	 * @param entityType entity type
	 */
	void addEntityType(EntityType entityType);

	/**
	 * Updates a single existing entity type and entity type attributes.
	 *
	 * @param entityType entity type
	 * @throws UnknownEntityTypeException if entity type does not exist
	 */
	void updateEntityType(EntityType entityType);

	/**
	 * Add or update a collection of entity type and entity type attributes.
	 * Resolves the dependencies between them so that the entities and their metadata get added in proper order.
	 * &lt;p&gt;
	 * Adds ONE_TO_MANY attributes in a two-pass algorithm.
	 * &lt;ol&gt;
	 * &lt;li&gt;Add the Author {@link EntityType} without books attribute and the Book {@link EntityType} with its author
	 * attribute.&lt;/li&gt;
	 * &lt;li&gt;Update the Author EntityType adding the books attribute&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * @param entityTypes {@link EntityType}s to add
	 */
	void upsertEntityTypes(Collection&lt;EntityType&gt; entityTypes);

	/**
	 * Deletes an EntityType
	 */
	void deleteEntityType(String entityTypeId); // FIXME use entity type ids instead of entity type fqns

	/**
	 * Deletes a collection of entity type.
	 *
	 * @param entityTypes entity type collection
	 */
	void deleteEntityType(Collection&lt;EntityType&gt; entityTypes);

	/**
	 * Adds an Attribute to an EntityType
	 */
	void addAttribute(Attribute attribute);

	/**
	 * Adds attributes to an EntityType
	 *
	 * @param attrs Stream &lt;Attribute&gt;
	 */
	void addAttributes(String entityTypeId, Stream&lt;Attribute&gt; attrs);

	/**
	 * Deletes an Attribute from an Entity
	 */
	void deleteAttributeById(Object id);

	/**
	 * Check the integration of an entity type with existing entities Check only if the existing attributes are the
	 * same as the new attributes
	 *
	 * @param repositoryCollection the new entities
	 */
	LinkedHashMap&lt;String, Boolean&gt; determineImportableEntities(RepositoryCollection repositoryCollection);

	/**
	 * Returns whether the given {@link EntityType} defines a meta entity such as {@link EntityTypeMetadata} or
	 * {@link Attribute}.
	 *
	 * @param entityType the EntityType that is checked
	 */
	static boolean isMetaEntityType(EntityType entityType)
	{
<span class="fc bfc" id="L271" title="All 2 branches covered.">		switch (entityType.getId())</span>
		{
			case ENTITY_TYPE_META_DATA:
			case ATTRIBUTE_META_DATA:
			case TAG:
			case PACKAGE:
<span class="fc" id="L277">				return true;</span>
			default:
<span class="fc" id="L279">				return false;</span>
		}
	}

	/**
	 * Returns whether the given {@link EntityType} attributes are compatible with
	 * the attributes of an existing repository with the same name
	 */
	boolean isEntityTypeCompatible(EntityType entityTypeData);

	/**
	 * Returns all concrete {@link EntityType}s that directly or indirectly extend a given {@link EntityType}.
	 * If the {@link EntityType} is concrete, will return a Stream containing only the given {@link EntityType}.
	 *
	 * @param entityType the {@link EntityType} whose concrete child entity types will be returned
	 * @return Stream containing all concrete children
	 */
	Stream&lt;EntityType&gt; getConcreteChildren(EntityType entityType);

	/**
	 * Retrieves EntityType, bypassing the {@link org.molgenis.data.meta.system.SystemEntityTypeRegistry}
	 * This method is a workaround for those cases where {@link #getEntityType(String)} cannot be used
	 * due to https://github.com/molgenis/molgenis/issues/5783
	 *
	 * @param entityTypeId ID of the EntityType
	 * @return EntityType the retrieved EntityType
	 * @TODO Remove this method when the issue is fixed
	 */
	EntityType getEntityTypeBypassingRegistry(String entityTypeId);

	/**
	 * Returns all {@link Attribute} that refer to a given {@link EntityType} as a refEntity
	 *
	 * @param entityTypeId ID of the {@link EntityType} that the attribute refers to
	 * @return Stream of referring {@link Attribute}s
	 */
	Stream&lt;Attribute&gt; getReferringAttributes(String entityTypeId);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>