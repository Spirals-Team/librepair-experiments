<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BatchingIterable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data.util</a> &gt; <span class="el_source">BatchingIterable.java</span></div><h1>BatchingIterable.java</h1><pre class="source lang-java linenums">package org.molgenis.data.util;

import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Iterable that returns an iterator that retrieves a new batch of objects after a given batchSize
 *
 * @param &lt;T&gt;
 */
public abstract class BatchingIterable&lt;T&gt; implements Iterable&lt;T&gt;
{
	private final int batchSize;
	private final int offset;
	/**
	 * Limit &gt; 0: Number of elements to retrieve, Limit = 0: Limit undefined
	 */
	private final int limit;

	public BatchingIterable(int batchSize)
	{
<span class="nc" id="L23">		this(batchSize, 0, 0);</span>
<span class="nc" id="L24">	}</span>

	public BatchingIterable(int batchSize, int offset, int limit)
<span class="fc" id="L27">	{</span>
<span class="pc bpc" id="L28" title="1 of 2 branches missed.">		if (batchSize &lt;= 0) throw new IllegalArgumentException(&quot;BatchSize must be greated then 0&quot;);</span>
<span class="pc bpc" id="L29" title="1 of 2 branches missed.">		if (offset &lt; 0) throw new IllegalArgumentException(&quot;Offset must be larger than or equal to 0&quot;);</span>
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">		if (limit &lt; 0) throw new IllegalArgumentException(&quot;Limit must be larger than or equal to 0&quot;);</span>
<span class="fc" id="L31">		this.batchSize = batchSize;</span>
<span class="fc" id="L32">		this.offset = offset;</span>
<span class="fc" id="L33">		this.limit = limit;</span>
<span class="fc" id="L34">	}</span>

	@Override
	public Iterator&lt;T&gt; iterator()
	{
<span class="fc" id="L39">		return new Iterator&lt;T&gt;()</span>
<span class="fc" id="L40">		{</span>
			/**
			 * Element index
			 */
<span class="fc" id="L44">			private int index = offset;</span>
			/**
			 * Element iterator for the current batch
			 */
			private Iterator&lt;T&gt; it;

			@Override
			public boolean hasNext()
			{
				boolean hasNext;

				// lazy load first batch
<span class="fc bfc" id="L56" title="All 2 branches covered.">				if (it == null)</span>
				{
<span class="fc" id="L58">					it = nextBatch();</span>
<span class="fc" id="L59">					hasNext = it.hasNext();</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">					if (!hasNext)</span>
					{
<span class="fc" id="L62">						return false;</span>
					}
				}
				else
				{
<span class="fc" id="L67">					hasNext = it.hasNext();</span>
				}

<span class="fc bfc" id="L70" title="All 2 branches covered.">				if (!hasNext)</span>
				{
<span class="fc" id="L72">					it = nextBatch();</span>
<span class="fc" id="L73">					hasNext = it.hasNext();</span>
				}

<span class="fc" id="L76">				return hasNext;</span>
			}

			@Override
			public T next()
			{
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">				if (!hasNext())</span>
				{
<span class="nc" id="L84">					throw new NoSuchElementException();</span>
				}

<span class="fc" id="L87">				T element = it.next();</span>
<span class="fc" id="L88">				++index;</span>
<span class="fc" id="L89">				return element;</span>
			}

			@Override
			public void remove()
			{
<span class="nc" id="L95">				throw new UnsupportedOperationException();</span>
			}

			private Iterator&lt;T&gt; nextBatch()
			{
				// calculate batch size
				int nextBatchSize;

				// always retrieve first batch: index == offset
				// retrieve next batch if previous batch contained less items then batch size
<span class="fc bfc" id="L105" title="All 4 branches covered.">				if (index == offset || (index - offset) % batchSize == 0)</span>
				{
<span class="fc bfc" id="L107" title="All 2 branches covered.">					if (limit == 0)</span>
					{
<span class="fc" id="L109">						nextBatchSize = batchSize;</span>
					}
					else
					{
<span class="fc bfc" id="L113" title="All 2 branches covered.">						if (index == offset + limit)</span>
						{
<span class="fc" id="L115">							nextBatchSize = 0;</span>
						}
<span class="fc bfc" id="L117" title="All 2 branches covered.">						else if (index + batchSize &lt;= offset + limit)</span>
						{
<span class="fc" id="L119">							nextBatchSize = batchSize;</span>
						}
						else
						{
<span class="fc" id="L123">							nextBatchSize = offset + limit - index;</span>
						}
					}
				}
				else
				{
<span class="fc" id="L129">					nextBatchSize = 0;</span>
				}

<span class="fc bfc" id="L132" title="All 2 branches covered.">				if (nextBatchSize == 0)</span>
				{
<span class="fc" id="L134">					return Collections.emptyIterator();</span>
				}
				else
				{
<span class="fc" id="L138">					return getBatch(index, nextBatchSize).iterator();</span>
				}
			}
		};
	}

	/**
	 * Return new batch, should not return null but empty list if no more elements are available
	 *
	 * @param offset (startIndex)
	 */
	protected abstract Iterable&lt;T&gt; getBatch(int offset, int batchSize);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>