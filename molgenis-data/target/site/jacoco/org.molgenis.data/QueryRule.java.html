<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryRule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data</a> &gt; <span class="el_source">QueryRule.java</span></div><h1>QueryRule.java</h1><pre class="source lang-java linenums">package org.molgenis.data;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import static java.util.stream.Collectors.toList;
import static java.util.stream.StreamSupport.stream;

/**
 * With this class an equation model can be described for a database-field (eg a column).
 */
@XmlRootElement
public class QueryRule
{
	/**
	 * The operator being applied to the field and value
	 */
	@XmlElement
	protected Operator operator;

	/**
	 * The field-name (eq column-name) in the database
	 */
<span class="fc" id="L28">	@XmlElement</span>
	protected String field = null;

	/**
	 * The value to compare entries of the field in the database with
	 */
<span class="fc" id="L34">	@XmlElement</span>
	protected Object value = null;

	protected List&lt;QueryRule&gt; nestedRules;

	public QueryRule()
<span class="fc" id="L40">	{</span>

<span class="fc" id="L42">	}</span>

	public QueryRule(List&lt;QueryRule&gt; nestedRules)
<span class="fc" id="L45">	{</span>
<span class="fc" id="L46">		this.nestedRules = nestedRules;</span>
<span class="fc" id="L47">		operator = Operator.NESTED;</span>
<span class="fc" id="L48">	}</span>

	public QueryRule(QueryRule copy)
<span class="fc" id="L51">	{</span>
<span class="fc" id="L52">		operator = copy.operator;</span>
<span class="fc" id="L53">		field = copy.field;</span>
<span class="fc" id="L54">		value = copy.value;</span>
<span class="fc" id="L55">	}</span>

	/**
	 * Different types of rules that can be applied.
	 */
<span class="fc" id="L60">	public enum Operator</span>
	{
		/**
		 * 'field' like 'value', searches all fields if field is not defined
		 */
<span class="fc" id="L65">		SEARCH(&quot;search&quot;),</span>

		/**
		 * 'field' equal to 'value'
		 * &lt;p&gt;
		 * When 'field type' is 'Mref' its results are derived from the 'Contains' behavior. &lt;br&gt;
		 * Examples: &lt;br&gt;
		 * 1. ref1 OR ref2 can result in:
		 * &lt;ul&gt;
		 * &lt;li&gt;re1&lt;/li&gt;
		 * &lt;li&gt;ref1, ref2&lt;/li&gt;
		 * &lt;li&gt;ref1, ref2, ref3;&lt;/li&gt;
		 * &lt;li&gt;ref2&lt;/li&gt;
		 * &lt;li&gt;ref2, ref3&lt;/li&gt;
		 * &lt;/ul&gt;
		 * 2. ref1 AND ref2 can result in:
		 * &lt;ul&gt;
		 * &lt;li&gt;ref1, ref2&lt;/li&gt;
		 * &lt;li&gt;ref1, ref2, ref3&lt;/li&gt;
		 * &lt;/ul&gt;
		 */
<span class="fc" id="L86">		EQUALS(&quot;=&quot;),</span>

		/**
		 * 'field' in 'value' (value being a list).
		 */
<span class="fc" id="L91">		IN(&quot;IN&quot;),</span>

		/**
		 * 'field' less-than 'value'
		 */
<span class="fc" id="L96">		LESS(&quot;&lt;&quot;),</span>

		/**
		 * 'field' equal-or-less-than 'value'
		 */
<span class="fc" id="L101">		LESS_EQUAL(&quot;&lt;=&quot;),</span>

		/**
		 * 'field' greater-than 'value'
		 */
<span class="fc" id="L106">		GREATER(&quot;&gt;&quot;),</span>

		/**
		 * 'field' equal-or-greater-than 'value'
		 */
<span class="fc" id="L111">		GREATER_EQUAL(&quot;&gt;=&quot;),</span>

		/**
		 * 'field' equal-or-greater-than 'from value' and equal-or-less-than 'to value' (value being a list with 'from
		 * value' as first element and 'to value' as second element
		 */
<span class="fc" id="L117">		RANGE(&quot;RANGE&quot;),</span>

		/**
		 * 'field' like 'value' (works like equals with wildcard before and after value)
		 */
<span class="fc" id="L122">		LIKE(&quot;LIKE&quot;),</span>

		/**
		 * 'field' not-equal to 'value'
		 */
<span class="fc" id="L127">		NOT(&quot;!=&quot;),</span>

		/**
		 * AND operation
		 */
<span class="fc" id="L132">		AND(&quot;AND&quot;),</span>

		/**
		 * OR operation
		 */
<span class="fc" id="L137">		OR(&quot;OR&quot;),</span>

		/**
		 * indicates that 'value' is a nested array of QueryRule. The parameter 'field' is ommitted.
		 */
<span class="fc" id="L142">		NESTED(&quot;&quot;),</span>

		/**
		 * Boolean query
		 */
<span class="fc" id="L147">		SHOULD(&quot;SHOULD&quot;),</span>

		/**
		 * Disjunction max query
		 */
<span class="fc" id="L152">		DIS_MAX(&quot;DIS_MAX&quot;),</span>

		/**
		 * Fuzzy match operator
		 */
<span class="fc" id="L157">		FUZZY_MATCH(&quot;FUZZY_MATCH&quot;),</span>

		/**
		 * Fuzzy match operator
		 */
<span class="fc" id="L162">		FUZZY_MATCH_NGRAM(&quot;FUZZY_MATCH_NGRAM&quot;);</span>

		private String label;

		/**
		 * Translate String label of the operator to Operator.
		 *
		 * @param label of the operator
		 */
		Operator(String label)
<span class="fc" id="L172">		{</span>
<span class="fc" id="L173">			this.label = label;</span>
<span class="fc" id="L174">		}</span>

		/**
		 * Get the String label of the Operator.
		 */
		@Override
		public String toString()
		{
<span class="fc" id="L182">			return label;</span>
		}
	}

	// constructor

	/**
	 * Standard constructor.
	 * &lt;p&gt;
	 * With this constructor the field, operator and value are set in one go, so there is no need for additional
	 * statements.
	 *
	 * @param field    The field-name.
	 * @param operator The operator to use for comparing entries in the field with the value.
	 * @param value    The value.
	 */
	public QueryRule(String field, Operator operator, Object value)
<span class="fc" id="L199">	{</span>
<span class="pc bpc" id="L200" title="2 of 4 branches missed.">		if (operator == Operator.AND || operator == Operator.OR)</span>
		{
<span class="nc" id="L202">			throw new IllegalArgumentException(</span>
					&quot;QueryRule(): Operator.&quot; + operator + &quot; cannot be used with two arguments&quot;);
		}
<span class="fc" id="L205">		this.field = field;</span>
<span class="fc" id="L206">		this.operator = operator;</span>
<span class="fc" id="L207">		setValue(value);</span>
<span class="fc" id="L208">	}</span>

	/**
	 * Specific constructor for rules that do not apply to a field such as LIMIT and OFFSET.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public QueryRule(Operator operator, Object value)
<span class="fc" id="L215">	{</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">		if (operator == Operator.SEARCH)</span>
		{
<span class="nc" id="L218">			this.operator = operator;</span>
<span class="nc" id="L219">			setValue(value);</span>
		}
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		else if (Operator.NESTED.equals(operator))</span>
		{
<span class="fc" id="L223">			boolean okay = true;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">			if (value instanceof List)</span>
			{
<span class="fc bfc" id="L226" title="All 2 branches covered.">				for (Object o : (List&lt;?&gt;) value)</span>
				{
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">					if (!(o instanceof QueryRule)) okay = false;</span>
<span class="fc" id="L229">				}</span>
			}
			else
			{
<span class="nc" id="L233">				okay = false;</span>
			}
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">			if (!okay) throw new IllegalArgumentException(&quot;QueryRule(NESTED, value): value should be List&lt;QueryRule&gt;&quot;);</span>
<span class="fc" id="L236">			this.nestedRules = (List&lt;QueryRule&gt;) value;</span>
<span class="fc" id="L237">			this.operator = operator;</span>
<span class="fc" id="L238">		}</span>
		else
		{
<span class="nc" id="L241">			throw new IllegalArgumentException(</span>
					&quot;QueryRule(): Operator.&quot; + operator + &quot; cannot be used with one argument&quot;);
		}
<span class="fc" id="L244">	}</span>

	public QueryRule(Operator operator, QueryRule nestedRules)
<span class="fc" id="L247">	{</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">		if (operator == Operator.NOT)</span>
		{
<span class="fc" id="L250">			this.operator = operator;</span>
<span class="fc" id="L251">			this.nestedRules = Arrays.asList(nestedRules);</span>
		}
		else
		{
<span class="nc" id="L255">			throw new IllegalArgumentException(</span>
					&quot;QueryRule(): Operator.&quot; + operator + &quot; cannot be used with one argument&quot;);
		}
<span class="fc" id="L258">	}</span>

	/**
	 * Specific constructor for rules that don't have a value or field such as LAST
	 */
	public QueryRule(Operator operator)
<span class="fc" id="L264">	{</span>
<span class="pc bpc" id="L265" title="3 of 6 branches missed.">		if (operator == Operator.AND || operator == Operator.OR || operator == Operator.NOT)</span>
		{
<span class="fc" id="L267">			this.operator = operator;</span>
		}
		else
		{
<span class="nc" id="L271">			throw new IllegalArgumentException(</span>
					&quot;QueryRule(): Operator '&quot; + operator + &quot;' cannot be used without arguments&quot;);
		}
<span class="fc" id="L274">	}</span>

	public QueryRule(String field, Operator equals, String value)
	{
<span class="fc" id="L278">		this(field, equals, (Object) value);</span>
<span class="fc" id="L279">	}</span>

	/**
	 * Returns the field-name set for this rule.
	 *
	 * @return The field-name.
	 */
	public String getField()
	{
<span class="fc" id="L288">		return field;</span>
	}

	/**
	 * Sets a new field-name for this rule.
	 *
	 * @param field The new field-name.
	 */
	public void setField(String field)
	{
<span class="nc" id="L298">		this.field = field;</span>
<span class="nc" id="L299">	}</span>

	/**
	 * Returns the operator set for this rule.
	 *
	 * @return The operator.
	 */
	public Operator getOperator()
	{
<span class="fc" id="L308">		return operator;</span>
	}

	/**
	 * Sets a new operator for this rule.
	 *
	 * @param operator The new operator.
	 */
	public void setOperator(Operator operator)
	{
<span class="nc" id="L318">		this.operator = operator;</span>
<span class="nc" id="L319">	}</span>

	/**
	 * Returns the value set for this rule.
	 *
	 * @return The value.
	 */
	public Object getValue()
	{
<span class="fc" id="L328">		return value;</span>
	}

	/**
	 * Sets a new value for this rule.
	 *
	 * @param value The new value.
	 */
	public void setValue(Object value)
	{
<span class="fc bfc" id="L338" title="All 2 branches covered.">		if (value instanceof Iterable&lt;?&gt;)</span>
		{
<span class="fc" id="L340">			this.value = stream(((Iterable&lt;?&gt;) value).spliterator(), false).map(this::toValue).collect(toList());</span>
		}
		else
		{
<span class="fc" id="L344">			this.value = toValue(value);</span>
		}
<span class="fc" id="L346">	}</span>

	private Object toValue(Object value)
	{
<span class="fc bfc" id="L350" title="All 2 branches covered.">		if (value instanceof Entity)</span>
		{
<span class="fc" id="L352">			return ((Entity) value).getIdValue();</span>
		}
<span class="fc" id="L354">		return value;</span>
	}

	/**
	 * Convenience function to return value as nested rule array.
	 *
	 * @return Nested rule set
	 */
	public List&lt;QueryRule&gt; getNestedRules()
	{
<span class="fc bfc" id="L364" title="All 2 branches covered.">		if (nestedRules == null)</span>
		{
<span class="fc" id="L366">			return Collections.emptyList();</span>
		}

<span class="fc" id="L369">		return nestedRules;</span>
	}

	@Override
	public String toString()
	{
<span class="fc" id="L375">		StringBuilder strBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">		if (field != null)</span>
		{
<span class="fc" id="L378">			strBuilder.append('\'').append(field).append('\'');</span>
		}
<span class="pc bpc" id="L380" title="1 of 4 branches missed.">		if (operator != null &amp;&amp; operator != Operator.NESTED)</span>
		{
<span class="fc bfc" id="L382" title="All 2 branches covered.">			if (strBuilder.length() &gt; 0)</span>
			{
<span class="fc" id="L384">				strBuilder.append(' ');</span>
			}
<span class="fc" id="L386">			strBuilder.append(operator);</span>
		}
<span class="pc bpc" id="L388" title="3 of 12 branches missed.">		if (operator != Operator.AND &amp;&amp; operator != Operator.OR &amp;&amp; operator != Operator.NOT</span>
				&amp;&amp; operator != Operator.NESTED &amp;&amp; operator != Operator.DIS_MAX &amp;&amp; operator != Operator.SHOULD)
		{
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">			if (strBuilder.length() &gt; 0)</span>
			{
<span class="fc" id="L393">				strBuilder.append(' ');</span>
			}
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">			if (operator != Operator.IN)</span>
			{
<span class="fc" id="L397">				strBuilder.append('\'').append(value).append('\'');</span>
			}
			else
			{
<span class="nc" id="L401">				strBuilder.append(value);</span>
			}
		}
<span class="pc bpc" id="L404" title="1 of 4 branches missed.">		if (nestedRules != null &amp;&amp; !nestedRules.isEmpty())</span>
		{
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">			if (strBuilder.length() &gt; 0)</span>
			{
<span class="nc" id="L408">				strBuilder.append(' ');</span>
			}
<span class="fc" id="L410">			strBuilder.append('(');</span>

<span class="fc bfc" id="L412" title="All 2 branches covered.">			for (Iterator&lt;QueryRule&gt; it = nestedRules.iterator(); it.hasNext(); )</span>
			{
<span class="fc" id="L414">				strBuilder.append(it.next());</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">				if (it.hasNext())</span>
				{
<span class="fc" id="L417">					strBuilder.append(&quot;, &quot;);</span>
				}
			}
<span class="fc" id="L420">			strBuilder.append(')');</span>
		}
<span class="fc" id="L422">		return strBuilder.toString();</span>
	}

	public static QueryRule eq(String name, Object value)
	{
<span class="nc" id="L427">		return new QueryRule(name, Operator.EQUALS, value);</span>
	}

	@Override
	public int hashCode()
	{
<span class="nc bnc" id="L433" title="All 2 branches missed.">		int result = operator != null ? operator.hashCode() : 0;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">		result = 31 * result + (field != null ? field.hashCode() : 0);</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">		result = 31 * result + (value != null ? value.hashCode() : 0);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">		result = 31 * result + (nestedRules != null ? nestedRules.hashCode() : 0);</span>
<span class="nc" id="L437">		return result;</span>
	}

	@Override
	public boolean equals(Object o)
	{
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">		if (this == o) return true;</span>
<span class="pc bpc" id="L444" title="2 of 4 branches missed.">		if (o == null || getClass() != o.getClass()) return false;</span>

<span class="fc" id="L446">		QueryRule queryRule = (QueryRule) o;</span>

<span class="pc bpc" id="L448" title="1 of 6 branches missed.">		if (field != null ? !field.equals(queryRule.field) : queryRule.field != null) return false;</span>
<span class="pc bpc" id="L449" title="1 of 6 branches missed.">		if (nestedRules != null ? !nestedRules.equals(queryRule.nestedRules) : queryRule.nestedRules != null)</span>
<span class="fc" id="L450">			return false;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">		if (operator != queryRule.operator) return false;</span>
<span class="pc bpc" id="L452" title="1 of 6 branches missed.">		if (value != null ? !value.equals(queryRule.value) : queryRule.value != null) return false;</span>

<span class="fc" id="L454">		return true;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>