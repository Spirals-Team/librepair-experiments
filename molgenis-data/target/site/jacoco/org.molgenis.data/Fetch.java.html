<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Fetch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data</a> &gt; <span class="el_source">Fetch.java</span></div><h1>Fetch.java</h1><pre class="source lang-java linenums">package org.molgenis.data;

import org.molgenis.data.meta.model.Attribute;

import java.util.*;
import java.util.Map.Entry;

/**
 * {@link Fetch} that defines which entity attributes to retrieve. For attributes referring to entities a Fetch can be
 * supplied that defines which entity attributes to retrieve for the referred entity.
 * &lt;p&gt;
 * A null Fetch means that all attributes should be retrieved.
 */
public class Fetch implements Iterable&lt;Entry&lt;String, Fetch&gt;&gt;
{
	private final Map&lt;String, Fetch&gt; attrFetchMap;

	/**
	 * Creates an empty Fetch.
	 */
	public Fetch()
<span class="fc" id="L22">	{</span>
<span class="fc" id="L23">		this.attrFetchMap = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L24">	}</span>

	/**
	 * Updates this Fetch, adding a single field. If the field is a reference, the reference will be fetched with a null
	 * Fetch, which means that all attributes will be fetched.
	 *
	 * @param field the name of the field to fetch
	 * @return this Fetch, updated
	 */
	public Fetch field(String field)
	{
<span class="fc" id="L35">		return field(field, null);</span>
	}

	/**
	 * Updates this fetch, adding a single field. If the field is a reference, the reference will be fetched with the
	 * Fetch that is provided.
	 *
	 * @param field the name of the field to fetch
	 * @param fetch the fetch to use for this field, if the field is a reference
	 * @return this Fetch, updated
	 */
	public Fetch field(String field, Fetch fetch)
	{
<span class="fc" id="L48">		attrFetchMap.put(field, fetch);</span>
<span class="fc" id="L49">		return this;</span>
	}

	/**
	 * Retrieves the Fetch for a particular field
	 *
	 * @param field the field for which the Fetch is retrieved
	 * @return the Fetch for this field, or null if none was provided
	 */
	public Fetch getFetch(String field)
	{
<span class="fc" id="L60">		return attrFetchMap.get(field);</span>
	}

	/**
	 * Retrieves the Fetch for an attribute
	 */
	public Fetch getFetch(Attribute attr)
	{
<span class="nc" id="L68">		return getFetch(attr.getName());</span>
	}

	/**
	 * Indicates if a field is included in this Fetch.
	 *
	 * @param field the field that is queried
	 * @return true if the field is included in this Fetch, otherwise false
	 */
	public boolean hasField(String field)
	{
<span class="fc" id="L79">		return attrFetchMap.containsKey(field);</span>
	}

	/**
	 * Indicates if a field is included in this Fetch
	 *
	 * @param attr {@link Attribute} for the field
	 * @return true if the field is included in this Fetch, otherwise false
	 */
	public boolean hasField(Attribute attr)
	{
<span class="nc" id="L90">		return hasField(attr.getName());</span>
	}

	/**
	 * Retrieves the fields included in this Fetch
	 *
	 * @return {@link Set} containing the names of all fields included in this Fetch
	 */
	public Set&lt;String&gt; getFields()
	{
<span class="fc" id="L100">		return Collections.unmodifiableMap(attrFetchMap).keySet();</span>
	}

	/**
	 * Iterates over all fields in this fetch. The key is the field name, the value is the {@link Fetch} for that field,
	 * or null if no Fetch is provided for that field.
	 *
	 * @return {@link Iterator} over all {@link Entry}s in this fetch.
	 */
	@Override
	public Iterator&lt;Entry&lt;String, Fetch&gt;&gt; iterator()
	{
<span class="fc" id="L112">		return Collections.unmodifiableMap(attrFetchMap).entrySet().iterator();</span>
	}

	@Override
	public int hashCode()
	{
<span class="nc" id="L118">		final int prime = 31;</span>
<span class="nc" id="L119">		int result = 1;</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">		result = prime * result + ((attrFetchMap == null) ? 0 : attrFetchMap.hashCode());</span>
<span class="nc" id="L121">		return result;</span>
	}

	@Override
	public boolean equals(Object obj)
	{
<span class="fc bfc" id="L127" title="All 2 branches covered.">		if (this == obj) return true;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">		if (obj == null) return false;</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">		if (getClass() != obj.getClass()) return false;</span>
<span class="fc" id="L130">		Fetch other = (Fetch) obj;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if (attrFetchMap == null)</span>
		{
<span class="nc bnc" id="L133" title="All 2 branches missed.">			if (other.attrFetchMap != null) return false;</span>
		}
<span class="fc bfc" id="L135" title="All 2 branches covered.">		else if (!attrFetchMap.equals(other.attrFetchMap)) return false;</span>
<span class="fc" id="L136">		return true;</span>
	}

	@Override
	public String toString()
	{
<span class="nc" id="L142">		StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L143">		toStringRec(builder, this);</span>
<span class="nc" id="L144">		return builder.toString();</span>
	}

	private void toStringRec(StringBuilder builder, Fetch fetch)
	{
<span class="nc" id="L149">		builder.append('(');</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">		for (Iterator&lt;Map.Entry&lt;String, Fetch&gt;&gt; it = fetch.iterator(); it.hasNext(); )</span>
		{
<span class="nc" id="L152">			Entry&lt;String, Fetch&gt; entry = it.next();</span>
<span class="nc" id="L153">			builder.append(entry.getKey());</span>

<span class="nc" id="L155">			Fetch subFetch = entry.getValue();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">			if (subFetch != null)</span>
			{
<span class="nc" id="L158">				toStringRec(builder, subFetch);</span>
			}

<span class="nc bnc" id="L161" title="All 2 branches missed.">			if (it.hasNext())</span>
			{
<span class="nc" id="L163">				builder.append(',');</span>
			}
<span class="nc" id="L165">		}</span>
<span class="nc" id="L166">		builder.append(')');</span>
<span class="nc" id="L167">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>