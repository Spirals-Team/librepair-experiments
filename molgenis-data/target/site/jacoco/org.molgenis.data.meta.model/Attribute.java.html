<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Attribute.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">data</a> &gt; <a href="index.source.html" class="el_package">org.molgenis.data.meta.model</a> &gt; <span class="el_source">Attribute.java</span></div><h1>Attribute.java</h1><pre class="source lang-java linenums">package org.molgenis.data.meta.model;

import com.google.common.collect.Lists;
import org.molgenis.data.Entity;
import org.molgenis.data.Range;
import org.molgenis.data.Sort;
import org.molgenis.data.meta.AttributeType;
import org.molgenis.data.support.StaticEntity;
import org.molgenis.i18n.Labeled;

import javax.annotation.Nullable;
import java.util.List;

import static com.google.common.collect.Iterables.concat;
import static com.google.common.collect.Iterables.removeAll;
import static java.util.Arrays.asList;
import static java.util.Arrays.stream;
import static java.util.Collections.emptyList;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.StreamSupport.stream;
import static org.molgenis.data.meta.AttributeType.STRING;
import static org.molgenis.data.meta.model.AttributeMetadata.*;
import static org.molgenis.data.meta.model.EntityType.AttributeCopyMode.DEEP_COPY_ATTRS;
import static org.molgenis.data.support.AttributeUtils.getI18nAttributeName;
import static org.molgenis.data.support.EntityTypeUtils.isReferenceType;

/**
 * Attribute defines the properties of an entity. Synonyms: feature, column, data item.
 */
public class Attribute extends StaticEntity implements Labeled
{
	private transient AttributeType cachedDataType;

	public Attribute(Entity entity)
	{
<span class="fc" id="L39">		super(entity);</span>
<span class="fc" id="L40">	}</span>

	/**
	 * Creates a new attribute. Normally called by its {@link AttributeFactory entity factory}.
	 *
	 * @param entityType attribute meta data
	 */
	public Attribute(EntityType entityType)
	{
<span class="fc" id="L49">		super(entityType);</span>
<span class="fc" id="L50">		setDefaultValues();</span>
<span class="fc" id="L51">	}</span>

	/**
	 * Creates a new attribute with the given identifier. Normally called by its {@link AttributeFactory entity factory}.
	 *
	 * @param attrId     attribute identifier (not the attribute name)
	 * @param entityType attribute meta data
	 */
	public Attribute(String attrId, EntityType entityType)
	{
<span class="nc" id="L61">		super(entityType);</span>
<span class="nc" id="L62">		setDefaultValues();</span>
<span class="nc" id="L63">		setIdentifier(attrId);</span>
<span class="nc" id="L64">	}</span>

	/**
	 * Copy-factory (instead of copy-constructor to avoid accidental method overloading to
	 * {@link #Attribute(EntityType)}). Creates a copy of attribute with a shallow copy of referenced
	 * entity and tags.
	 *
	 * @param attrMeta     attribute
	 * @param attrCopyMode attribute copy mode that defines whether to deep-copy or shallow-copy attribute parts
	 * @param attrFactory  attribute factory used to create new attributes in deep-copy mode
	 * @return shallow or deep copy of attribute
	 */
	public static Attribute newInstance(Attribute attrMeta, AttributeCopyMode attrCopyMode,
			AttributeFactory attrFactory)
	{
<span class="fc" id="L79">		Attribute attrMetaCopy = attrFactory.create(); // create new attribute with unique identifier</span>
<span class="fc" id="L80">		attrMetaCopy.setName(attrMeta.getName());</span>
<span class="fc" id="L81">		attrMetaCopy.setEntity(attrMeta.getEntity());</span>
<span class="fc" id="L82">		attrMetaCopy.setSequenceNumber(attrMeta.getSequenceNumber());</span>
<span class="fc" id="L83">		attrMetaCopy.setDataType(attrMeta.getDataType());</span>
<span class="fc" id="L84">		attrMetaCopy.setIdAttribute(attrMeta.isIdAttribute());</span>
<span class="fc" id="L85">		attrMetaCopy.setLabelAttribute(attrMeta.isLabelAttribute());</span>
<span class="fc" id="L86">		attrMetaCopy.setLookupAttributeIndex(attrMeta.getLookupAttributeIndex());</span>
<span class="fc" id="L87">		attrMetaCopy.setRefEntity(attrMeta.getRefEntity()); // do not deep-copy</span>
<span class="fc" id="L88">		attrMetaCopy.setMappedBy(attrMeta.getMappedBy()); // do not deep-copy</span>
<span class="fc" id="L89">		attrMetaCopy.setOrderBy(attrMeta.getOrderBy());</span>
<span class="fc" id="L90">		attrMetaCopy.setExpression(attrMeta.getExpression());</span>
<span class="fc" id="L91">		attrMetaCopy.setNillable(attrMeta.isNillable());</span>
<span class="fc" id="L92">		attrMetaCopy.setAuto(attrMeta.isAuto());</span>
<span class="fc" id="L93">		attrMetaCopy.setVisible(attrMeta.isVisible());</span>
<span class="fc" id="L94">		attrMetaCopy.setLabel(attrMeta.getLabel());</span>
<span class="fc" id="L95">		attrMetaCopy.setDescription(attrMeta.getDescription());</span>
<span class="fc" id="L96">		attrMetaCopy.setAggregatable(attrMeta.isAggregatable());</span>
<span class="fc" id="L97">		attrMetaCopy.setEnumOptions(attrMeta.getEnumOptions());</span>
<span class="fc" id="L98">		attrMetaCopy.setRangeMin(attrMeta.getRangeMin());</span>
<span class="fc" id="L99">		attrMetaCopy.setRangeMax(attrMeta.getRangeMax());</span>
<span class="fc" id="L100">		attrMetaCopy.setReadOnly(attrMeta.isReadOnly());</span>
<span class="fc" id="L101">		attrMetaCopy.setUnique(attrMeta.isUnique());</span>
<span class="fc" id="L102">		Attribute parentAttr = attrMeta.getParent();</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">		if (attrCopyMode == DEEP_COPY_ATTRS)</span>
		{
<span class="nc bnc" id="L105" title="All 2 branches missed.">			attrMetaCopy.setParent(</span>
<span class="nc" id="L106">					parentAttr != null ? Attribute.newInstance(parentAttr, attrCopyMode, attrFactory) : null);</span>
		}
		else
		{
<span class="fc" id="L110">			attrMetaCopy.setParent(parentAttr);</span>
		}

<span class="fc" id="L113">		attrMetaCopy.setTags(Lists.newArrayList(attrMeta.getTags())); // do not deep-copy</span>
<span class="fc" id="L114">		attrMetaCopy.setNullableExpression(attrMeta.getNullableExpression());</span>
<span class="fc" id="L115">		attrMetaCopy.setValidationExpression(attrMeta.getValidationExpression());</span>
<span class="fc" id="L116">		attrMetaCopy.setVisibleExpression(attrMeta.getVisibleExpression());</span>
<span class="fc" id="L117">		attrMetaCopy.setDefaultValue(attrMeta.getDefaultValue());</span>
<span class="fc" id="L118">		return attrMetaCopy;</span>
	}

	public String getIdentifier()
	{
<span class="nc" id="L123">		return getString(ID);</span>
	}

	public Attribute setIdentifier(String identifier)
	{
<span class="fc" id="L128">		set(ID, identifier);</span>
<span class="fc" id="L129">		return this;</span>
	}

	/**
	 * Name of the attribute
	 *
	 * @return attribute name
	 */
	public String getName()
	{
<span class="fc" id="L139">		return getString(NAME);</span>
	}

	public Attribute setName(String name)
	{
<span class="fc" id="L144">		set(NAME, name);</span>
<span class="fc" id="L145">		return this;</span>
	}

	/**
	 * Attribute sequence number that determines attribute order within an entity
	 *
	 * @return attribute sequence number
	 */
	public Integer getSequenceNumber()
	{
<span class="fc" id="L155">		return getInt(SEQUENCE_NR);</span>
	}

	public Attribute setSequenceNumber(int seqNr)
	{
<span class="fc" id="L160">		set(SEQUENCE_NR, seqNr);</span>
<span class="fc" id="L161">		return this;</span>
	}

	public EntityType getEntity()
	{
<span class="nc" id="L166">		return getEntity(ENTITY, EntityType.class);</span>
	}

	public Attribute setEntity(EntityType entityMeta)
	{
<span class="fc" id="L171">		set(ENTITY, entityMeta);</span>
<span class="fc" id="L172">		return this;</span>
	}

	public boolean isIdAttribute()
	{
<span class="fc" id="L177">		Boolean isIdAttr = getBoolean(IS_ID_ATTRIBUTE);</span>
<span class="pc bpc" id="L178" title="1 of 4 branches missed.">		return isIdAttr != null &amp;&amp; isIdAttr;</span>
	}

	public Attribute setIdAttribute(Boolean isIdAttr)
	{
<span class="fc" id="L183">		set(IS_ID_ATTRIBUTE, isIdAttr);</span>
<span class="pc bpc" id="L184" title="1 of 4 branches missed.">		if (isIdAttr != null &amp;&amp; isIdAttr)</span>
		{
<span class="fc" id="L186">			setReadOnly(true);</span>
<span class="fc" id="L187">			setUnique(true);</span>
<span class="fc" id="L188">			setNillable(false);</span>
		}
<span class="fc" id="L190">		return this;</span>
	}

	public boolean isLabelAttribute()
	{
<span class="fc" id="L195">		Boolean isLabelAttr = getBoolean(IS_LABEL_ATTRIBUTE);</span>
<span class="fc bfc" id="L196" title="All 4 branches covered.">		return isLabelAttr != null &amp;&amp; isLabelAttr;</span>
	}

	public Attribute setLabelAttribute(Boolean isLabelAttr)
	{
<span class="fc" id="L201">		set(IS_LABEL_ATTRIBUTE, isLabelAttr);</span>
<span class="fc" id="L202">		return this;</span>
	}

	@Nullable
	public Integer getLookupAttributeIndex()
	{
<span class="fc" id="L208">		return getInt(LOOKUP_ATTRIBUTE_INDEX);</span>
	}

	public Attribute setLookupAttributeIndex(Integer lookupAttrIdx)
	{
<span class="fc" id="L213">		set(LOOKUP_ATTRIBUTE_INDEX, lookupAttrIdx);</span>
<span class="fc" id="L214">		return this;</span>
	}

	/**
	 * Label of the attribute in the default language if set else returns name
	 *
	 * @return attribute label
	 */
	@Nullable
	public String getLabel()
	{
<span class="nc" id="L225">		String label = getString(LABEL);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">		return label != null ? label : getName();</span>
	}

	/**
	 * Label of the attribute in the default language if set else returns name
	 *
	 * @return attribute label
	 */
	@Nullable
	public String getLabel(String languageCode)
	{
<span class="nc" id="L237">		String i18nString = getString(getI18nAttributeName(LABEL, languageCode));</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">		return i18nString != null ? i18nString : getLabel();</span>
	}

	public Attribute setLabel(String label)
	{
<span class="fc" id="L243">		set(LABEL, label);</span>
<span class="fc" id="L244">		return this;</span>
	}

	public Attribute setLabel(String languageCode, String label)
	{
<span class="nc" id="L249">		set(getI18nAttributeName(LABEL, languageCode), label);</span>
<span class="nc" id="L250">		return this;</span>
	}

	/**
	 * Description of the attribute
	 *
	 * @return attribute description or &lt;tt&gt;null&lt;/tt&gt;
	 */
	@Nullable
	public String getDescription()
	{
<span class="nc" id="L261">		return getString(DESCRIPTION);</span>
	}

	/**
	 * Description of the attribute in the requested languages
	 *
	 * @return attribute description or &lt;tt&gt;null&lt;/tt&gt;
	 */
	@Nullable
	public String getDescription(String languageCode)
	{
<span class="nc" id="L272">		String i18nDescription = getString(getI18nAttributeName(DESCRIPTION, languageCode));</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">		return i18nDescription != null ? i18nDescription : getDescription();</span>
	}

	public Attribute setDescription(String description)
	{
<span class="fc" id="L278">		set(DESCRIPTION, description);</span>
<span class="fc" id="L279">		return this;</span>
	}

	public Attribute setDescription(String languageCode, String description)
	{
<span class="nc" id="L284">		set(getI18nAttributeName(DESCRIPTION, languageCode), description);</span>
<span class="nc" id="L285">		return this;</span>
	}

	/**
	 * Data type of the attribute
	 *
	 * @return attribute data type
	 */
	public AttributeType getDataType()
	{
<span class="fc" id="L295">		return getCachedDataType();</span>
	}

	public Attribute setDataType(AttributeType dataType)
	{
<span class="fc" id="L300">		invalidateCachedDataType();</span>

<span class="fc" id="L302">		set(TYPE, AttributeType.getValueString(dataType));</span>
<span class="fc" id="L303">		return this;</span>
	}

	@Nullable
	public Boolean getCascadeDelete()
	{
<span class="nc" id="L309">		return getBoolean(IS_CASCADE_DELETE);</span>
	}

	public Attribute setCascadeDelete(Boolean isCascadeDelete)
	{
<span class="fc" id="L314">		set(IS_CASCADE_DELETE, isCascadeDelete);</span>
<span class="fc" id="L315">		return this;</span>
	}

	/**
	 * When getDataType=compound, get compound attribute parts
	 *
	 * @return Iterable of attributes or empty Iterable if no attribute parts exist
	 */
	public Iterable&lt;Attribute&gt; getChildren()
	{
<span class="nc" id="L325">		return getEntities(CHILDREN, Attribute.class);</span>
	}

	/**
	 * When getDataType=xref/mref, get other end of xref
	 *
	 * @return referenced entity
	 */
	@Nullable
	public EntityType getRefEntity()
	{
<span class="nc" id="L336">		return getEntity(REF_ENTITY_TYPE, EntityType.class);</span>
	}

	public Attribute setRefEntity(EntityType refEntity)
	{
<span class="fc" id="L341">		set(REF_ENTITY_TYPE, refEntity);</span>
<span class="fc" id="L342">		return this;</span>
	}

	@Nullable
	public Attribute getMappedBy()
	{
<span class="nc" id="L348">		return getEntity(MAPPED_BY, Attribute.class);</span>
	}

	public Attribute setMappedBy(Attribute mappedByAttr)
	{
<span class="fc" id="L353">		set(MAPPED_BY, mappedByAttr);</span>
<span class="fc" id="L354">		return this;</span>
	}

	/**
	 * Indicates if this attribute is the one-to-many back-reference of a bidirectionally navigable relationship.
	 */
	public boolean isMappedBy()
	{
<span class="nc bnc" id="L362" title="All 2 branches missed.">		return getMappedBy() != null;</span>
	}

	@Nullable
	public Sort getOrderBy()
	{
<span class="nc" id="L368">		String orderByStr = getString(ORDER_BY);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">		return orderByStr != null ? Sort.parse(orderByStr) : null;</span>
	}

	public Attribute setOrderBy(Sort sort)
	{
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">		String orderByStr = sort != null ? sort.toSortString() : null;</span>
<span class="fc" id="L375">		set(ORDER_BY, orderByStr);</span>
<span class="fc" id="L376">		return this;</span>
	}

	/**
	 * Expression used to compute this attribute.
	 *
	 * @return String representation of expression, in JSON format
	 */
	@Nullable
	public String getExpression()
	{
<span class="nc" id="L387">		return getString(EXPRESSION);</span>
	}

	public Attribute setExpression(String expression)
	{
<span class="nc" id="L392">		set(EXPRESSION, expression);</span>
<span class="nc" id="L393">		return this;</span>
	}

	/**
	 * Wheter attribute has an expression or not
	 *
	 * @return true if attribute has expression
	 */
	public boolean hasExpression()
	{
<span class="nc bnc" id="L403" title="All 2 branches missed.">		return getExpression() != null;</span>
	}

	/**
	 * Whether attribute has not null constraint
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if this attribute is nillable
	 */
	public boolean isNillable()
	{
<span class="fc" id="L413">		return requireNonNull(getBoolean(IS_NULLABLE));</span>
	}

	public Attribute setNillable(boolean nillable)
	{
<span class="fc" id="L418">		set(IS_NULLABLE, nillable);</span>
<span class="fc" id="L419">		return this;</span>
	}

	/**
	 * When true the attribute is automatically assigned a value when persisted (for example the current date)
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if this attribute is automatically assigned
	 */
	public boolean isAuto()
	{
<span class="fc" id="L429">		return requireNonNull(getBoolean(IS_AUTO));</span>
	}

	public Attribute setAuto(boolean auto)
	{
<span class="fc" id="L434">		set(IS_AUTO, auto);</span>
<span class="fc" id="L435">		return this;</span>
	}

	/**
	 * Should this attribute be visible to the user?
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if this attribute is visible
	 */
	public boolean isVisible()
	{
<span class="nc" id="L445">		return requireNonNull(getBoolean(IS_VISIBLE));</span>
	}

	public Attribute setVisible(boolean visible)
	{
<span class="fc" id="L450">		set(IS_VISIBLE, visible);</span>
<span class="fc" id="L451">		return this;</span>
	}

	/**
	 * Whether this attribute can be used to aggregate on. Default only attributes of type 'BOOL', 'XREF' and
	 * 'CATEGORICAL' are isAggregatable.
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if this attribute is isAggregatable
	 */
	public boolean isAggregatable()
	{
<span class="nc" id="L462">		return requireNonNull(getBoolean(IS_AGGREGATABLE));</span>
	}

	public Attribute setAggregatable(boolean isAggregatable)
	{
<span class="fc" id="L467">		set(IS_AGGREGATABLE, isAggregatable);</span>
<span class="fc" id="L468">		return this;</span>
	}

	/**
	 * For enum fields returns the possible enum values
	 *
	 * @return enum values
	 */
	public List&lt;String&gt; getEnumOptions()
	{
<span class="nc" id="L478">		String enumOptionsStr = getString(ENUM_OPTIONS);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">		return enumOptionsStr != null ? asList(enumOptionsStr.split(&quot;,&quot;)) : emptyList();</span>
	}

	public Attribute setEnumOptions(Class&lt;? extends Enum&lt;?&gt;&gt; e)
	{
<span class="nc" id="L484">		return setEnumOptions(stream(e.getEnumConstants()).map(Enum::name).collect(toList()));</span>
	}

	public Attribute setEnumOptions(List&lt;String&gt; enumOptions)
	{
<span class="fc" id="L489">		set(ENUM_OPTIONS, toEnumOptionsString(enumOptions));</span>
<span class="fc" id="L490">		return this;</span>
	}

	@Nullable
	public Long getRangeMin()
	{
<span class="nc" id="L496">		return getLong(RANGE_MIN);</span>
	}

	public Attribute setRangeMin(Long rangeMin)
	{
<span class="fc" id="L501">		set(RANGE_MIN, rangeMin);</span>
<span class="fc" id="L502">		return this;</span>
	}

	@Nullable
	public Long getRangeMax()
	{
<span class="nc" id="L508">		return getLong(RANGE_MAX);</span>
	}

	public Attribute setRangeMax(Long rangeMax)
	{
<span class="nc" id="L513">		set(RANGE_MAX, rangeMax);</span>
<span class="nc" id="L514">		return this;</span>
	}

	/**
	 * Whether attribute is readonly
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if this attribute is read-only
	 */
	public boolean isReadOnly()
	{
<span class="fc" id="L524">		return requireNonNull(getBoolean(IS_READ_ONLY));</span>
	}

	public Attribute setReadOnly(boolean readOnly)
	{
<span class="fc" id="L529">		set(IS_READ_ONLY, readOnly);</span>
<span class="fc" id="L530">		return this;</span>
	}

	/**
	 * Whether attribute should have an unique value for each entity
	 *
	 * @return &lt;tt&gt;true&lt;/tt&gt; if this attribute is unique
	 */
	public boolean isUnique()
	{
<span class="fc" id="L540">		return requireNonNull(getBoolean(IS_UNIQUE));</span>
	}

	public Attribute setUnique(boolean unique)
	{
<span class="fc" id="L545">		set(IS_UNIQUE, unique);</span>
<span class="fc" id="L546">		return this;</span>
	}

	/**
	 * JavaScript expression to determine at runtime if the attribute value is required
	 *
	 * @return expression
	 */
	@Nullable
	public String getNullableExpression()
	{
<span class="nc" id="L557">		return getString(NULLABLE_EXPRESSION);</span>
	}

	public Attribute setNullableExpression(String nullableExpression)
	{
<span class="nc" id="L562">		set(NULLABLE_EXPRESSION, nullableExpression);</span>
<span class="nc" id="L563">		return this;</span>
	}

	/**
	 * JavaScript expression to determine at runtime if the attribute must be visible or not in the form
	 *
	 * @return expression
	 */
	@Nullable
	public String getVisibleExpression()
	{
<span class="nc" id="L574">		return getString(VISIBLE_EXPRESSION);</span>
	}

	public Attribute setVisibleExpression(String visibleExpression)
	{
<span class="nc" id="L579">		set(VISIBLE_EXPRESSION, visibleExpression);</span>
<span class="nc" id="L580">		return this;</span>
	}

	/**
	 * JavaScript expression to validate the value of the attribute
	 */
	@Nullable
	public String getValidationExpression()
	{
<span class="nc" id="L589">		return getString(VALIDATION_EXPRESSION);</span>
	}

	public Attribute setValidationExpression(String validationExpression)
	{
<span class="fc" id="L594">		set(VALIDATION_EXPRESSION, validationExpression);</span>
<span class="fc" id="L595">		return this;</span>
	}

	public boolean hasDefaultValue()
	{
<span class="fc bfc" id="L600" title="All 2 branches covered.">		return getDefaultValue() != null;</span>
	}

	/**
	 * Default value expression
	 *
	 * @return attribute default value
	 */
	@Nullable
	public String getDefaultValue()
	{
<span class="fc" id="L611">		return getString(DEFAULT_VALUE);</span>
	}

	public Attribute setDefaultValue(String defaultValue)
	{
<span class="fc" id="L616">		set(DEFAULT_VALUE, defaultValue);</span>
<span class="fc" id="L617">		return this;</span>
	}

	/**
	 * For int and long fields, the value must be between min and max (included) of the range
	 *
	 * @return attribute value range
	 */
	public Range getRange()
	{
<span class="nc" id="L627">		Long rangeMin = getRangeMin();</span>
<span class="nc" id="L628">		Long rangeMax = getRangeMax();</span>
<span class="nc bnc" id="L629" title="All 4 branches missed.">		return rangeMin != null || rangeMax != null ? new Range(rangeMin, rangeMax) : null;</span>
	}

	public Attribute setRange(Range range)
	{
<span class="nc" id="L634">		set(RANGE_MIN, range.getMin());</span>
<span class="nc" id="L635">		set(RANGE_MAX, range.getMax());</span>
<span class="nc" id="L636">		return this;</span>
	}

	@Nullable
	public Attribute getParent()
	{
<span class="fc" id="L642">		return getEntity(PARENT, Attribute.class);</span>
	}

	public Attribute setParent(Attribute parentAttr)
	{
<span class="fc" id="L647">		Attribute currentParent = getParent();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">		if (currentParent != null)</span>
		{
<span class="fc" id="L650">			currentParent.removeChild(this);</span>
		}
<span class="fc" id="L652">		set(PARENT, parentAttr);</span>

<span class="fc bfc" id="L654" title="All 2 branches covered.">		if (parentAttr != null)</span>
		{
<span class="fc" id="L656">			parentAttr.addChild(this);</span>
		}
<span class="fc" id="L658">		return this;</span>
	}

	/**
	 * Get attribute part by name (case insensitive), returns null if not found
	 *
	 * @param attrName attribute name (case insensitive)
	 * @return attribute or null
	 */
	public Attribute getChild(String attrName)
	{
<span class="nc" id="L669">		Iterable&lt;Attribute&gt; attrParts = getEntities(CHILDREN, Attribute.class);</span>
<span class="nc" id="L670">		return stream(attrParts.spliterator(), false).filter(attrPart -&gt; attrPart.getName().equals(attrName))</span>
<span class="nc" id="L671">													 .findFirst()</span>
<span class="nc" id="L672">													 .orElse(null);</span>
	}

	void addChild(Attribute attrPart)
	{
<span class="nc" id="L677">		Iterable&lt;Attribute&gt; attrParts = getEntities(CHILDREN, Attribute.class);</span>
<span class="nc" id="L678">		set(CHILDREN, concat(attrParts, singletonList(attrPart)));</span>
<span class="nc" id="L679">	}</span>

	void removeChild(Attribute attrPart)
	{
<span class="nc" id="L683">		Iterable&lt;Attribute&gt; attrParts = getEntities(CHILDREN, Attribute.class);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		set(CHILDREN, stream(attrParts.spliterator(), false).filter(attr -&gt; !attr.getName().equals(attrPart.getName()))</span>
<span class="nc" id="L685">															.collect(toList()));</span>
<span class="nc" id="L686">	}</span>

	/**
	 * Get all tags for this attribute
	 *
	 * @return attribute tags
	 */
	public Iterable&lt;Tag&gt; getTags()
	{
<span class="nc" id="L695">		return getEntities(TAGS, Tag.class);</span>
	}

	/**
	 * Set tags for this attribute
	 *
	 * @param tags attribute tags
	 * @return this entity
	 */
	public Attribute setTags(Iterable&lt;Tag&gt; tags)
	{
<span class="nc" id="L706">		set(TAGS, tags);</span>
<span class="nc" id="L707">		return this;</span>
	}

	/**
	 * Add a tag for this attribute
	 *
	 * @param tag attribute tag
	 */
	public void addTag(Tag tag)
	{
<span class="nc" id="L717">		set(TAGS, concat(getTags(), singletonList(tag)));</span>
<span class="nc" id="L718">	}</span>

	/**
	 * Add a tag for this attribute
	 *
	 * @param tag attribute tag
	 */
	public void removeTag(Tag tag)
	{
<span class="nc" id="L727">		Iterable&lt;Tag&gt; tags = getTags();</span>
<span class="nc" id="L728">		removeAll(tags, singletonList(tag));</span>
<span class="nc" id="L729">		set(TAGS, tag);</span>
<span class="nc" id="L730">	}</span>

	public void setDefaultValues()
	{
<span class="fc" id="L734">		setDataType(STRING);</span>
<span class="fc" id="L735">		setNillable(true);</span>
<span class="fc" id="L736">		setAuto(false);</span>
<span class="fc" id="L737">		setVisible(true);</span>
<span class="fc" id="L738">		setAggregatable(false);</span>
<span class="fc" id="L739">		setReadOnly(false);</span>
<span class="fc" id="L740">		setUnique(false);</span>
<span class="fc" id="L741">	}</span>

	private static String toEnumOptionsString(List&lt;String&gt; enumOptions)
	{
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">		return !enumOptions.isEmpty() ? enumOptions.stream().collect(joining(&quot;,&quot;)) : null;</span>
	}

	private AttributeType getCachedDataType()
	{
<span class="fc bfc" id="L750" title="All 2 branches covered.">		if (cachedDataType == null)</span>
		{
<span class="fc" id="L752">			String dataTypeStr = getString(TYPE);</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">			cachedDataType = dataTypeStr != null ? AttributeType.toEnum(dataTypeStr) : null;</span>
		}
<span class="fc" id="L755">		return cachedDataType;</span>
	}

	private void invalidateCachedDataType()
	{
<span class="fc" id="L760">		cachedDataType = null;</span>
<span class="fc" id="L761">	}</span>

	@Override
	public String toString()
	{
<span class="nc" id="L766">		return &quot;Attribute{&quot; + &quot;name=&quot; + getName() + &quot; id=&quot; + getIdValue() + '}';</span>
	}

	/**
	 * For a reference type attribute, searches the referenced entity for its inversed attribute.
	 * This is the one-to-many attribute that has &quot;mappedBy&quot; set to this attribute.
	 * Returns null if this is not a reference type attribute, or no inverse attribute exists.
	 */
	public Attribute getInversedBy()
	{
		// FIXME besides checking mappedBy attr name also check attr.getRefEntity().getFullyQualifiedName
<span class="nc bnc" id="L777" title="All 2 branches missed.">		if (isReferenceType(this))</span>
		{
<span class="nc" id="L779">			return stream(getRefEntity().getAtomicAttributes().spliterator(), false).filter(Attribute::isMappedBy)</span>
<span class="nc" id="L780">																					.filter(attr -&gt; getName().equals(</span>
<span class="nc" id="L781">																							attr.getMappedBy()</span>
<span class="nc" id="L782">																								.getName()))</span>
<span class="nc" id="L783">																					.findFirst()</span>
<span class="nc" id="L784">																					.orElse(null);</span>
		}
		else
		{
<span class="nc" id="L788">			return null;</span>
		}
	}

	/**
	 * Determines if this is a reference type attribute whose refEntity has an attribute that has mappedBy set to this
	 * attribute.
	 */
	public boolean isInversedBy()
	{
<span class="nc bnc" id="L798" title="All 2 branches missed.">		return getInversedBy() != null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>