<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonPointer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: JSON</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.json</a> &gt; <span class="el_source">JsonPointer.java</span></div><h1>JsonPointer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.json;

import java.util.Optional;

import javax.annotation.Nonnull;

/**
 * A JSON pointer defines a path within a JSON object. This path is hierarchical like a file tree. Thus each element of
 * this path is a sub level of it predecessor beginning at the root and ending at the leaf. For example, given the
 * following JSON object
 * &lt;pre&gt;
 *    {
 *       &quot;thingId&quot;: &quot;myThing&quot;,
 *       &quot;attributes&quot;: {
 *          &quot;location&quot;: {
 *             &quot;latitude&quot;: 47.003215,
 *             &quot;longitude&quot;: 9.0815
 *          }
 *       },
 *       &quot;features&quot;: {}
 *    }
 * &lt;/pre&gt;
 * The root of the JSON pointer {@code &quot;/attributes/location/longitude&quot;} is {@code &quot;/attributes&quot;} and the leaf is
 * {@code &quot;longitude&quot;}. This pointer points to the field with key {@code &quot;longitude&quot;} and value {@code 9.0815} of the
 * aforementioned JSON object.
 * &lt;p&gt;
 * &lt;em&gt;Implementations of this interface are required to be immutable!&lt;/em&gt;
 * &lt;/p&gt;
 */
public interface JsonPointer extends CharSequence, Iterable&lt;JsonKey&gt; {

    /**
     * Returns an empty JSON pointer. An empty pointer is represented by string {@code &quot;/&quot;}.
     *
     * @return the pointer.
     */
    @Nonnull
    static JsonPointer empty() {
<span class="nc" id="L50">        return JsonFactory.emptyPointer();</span>
    }

    /**
     * Parses the given string to obtain a new JSON pointer. This method is the inverse of
     * {@link JsonPointer#toString()} with one exception: both strings {@code &quot;/&quot;} and {@code &quot;&quot;} lead to an empty
     * pointer while the string representation of an empty string is always {@code &quot;/&quot;}.
     * &lt;p&gt;
     * As a JsonPointer is a hierarchy of JsonKeys it has to support JsonKeys containing slashes. Because of this, a
     * JsonPointer string has to escape each slash of a JsonKey with {@code &quot;~1&quot;}. To support, tildes in JsonKeys,
     * too, they have to be escaped with {@code &quot;~0&quot;}. For example, parsing the string
     * {@code &quot;/foo/~0dum~1~0die~1~0dum/baz&quot;} would result in a JsonPointer consisting of the JsonKeys
     * &lt;ol&gt;
     *     &lt;li&gt;{@code &quot;foo&quot;},&lt;/li&gt;
     *     &lt;li&gt;{@code &quot;~dum/~die/~dum&quot;} and&lt;/li&gt;
     *     &lt;li&gt;{@code &quot;baz&quot;}.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param slashDelimitedCharSequence slash-delimited string representing of a JSON pointer. The leading slash may
     * be omitted.
     * @return a new JSON pointer consisting of the JSON keys which were extracted from
     * {@code slashDelimitedCharSequence}.
     * @throws NullPointerException if {@code slashDelimitedCharSequence} is {@code null}.
     */
    static JsonPointer of(final CharSequence slashDelimitedCharSequence) {
<span class="nc" id="L75">        return JsonFactory.newPointer(slashDelimitedCharSequence);</span>
    }

    /**
     * Creates a new JSON pointer by adding a level to this JSON pointer. For example, if this pointer is
     * {@code &quot;/foo/bar&quot;} and {@code addLevel()} is called with a JSON key {@code &quot;baz&quot;} then the new JSON pointer is
     * {@code &quot;/foo/bar/baz&quot;}.
     *
     * @param key the new level JSON key.
     * @return a &lt;em&gt;new&lt;/em&gt; JSON pointer consisting of the old pointer extended by {@code jsonField}.
     * @throws NullPointerException if {@code key} is {@code null}.
     */
    JsonPointer addLeaf(JsonKey key);

    /**
     * Creates a new JSON pointer by appending the given pointer to this pointer.
     *
     * @param pointer the pointer to be appended to this pointer.
     * @return a new JSON pointer with this pointer as root followed by {@code pointer}.
     * @throws NullPointerException if {@code pointer} is {@code null}.
     */
    JsonPointer append(JsonPointer pointer);

    /**
     * Returns the number of levels of this JSON pointer. For example, if the pointer is {@code &quot;foo/bar/baz&quot;} this
     * method will return the value {@literal 3}.
     *
     * @return the number of levels of this pointer.
     */
    int getLevelCount();

    /**
     * Indicates whether this pointer does contain any elements or not. If the level count is zero the pointer is
     * regarded to be empty.
     *
     * @return {@code true} if this pointer does &lt;em&gt;not&lt;/em&gt; contain any elements, {@code false} else.
     */
    boolean isEmpty();

    /**
     * Returns the JSON key at the specified level within this JSON pointer.
     *
     * @param level the level of the JSON key to return.
     * @return the JSON key at the specified level within this JSON pointer. If the level is outside the bounds of this
     * pointer the result is empty.
     */
    Optional&lt;JsonKey&gt; get(int level);

    /**
     * Returns the root JSON key of this pointer. If the level count of this pointer is {@code one} the root is the same
     * as the leaf.
     *
     * @return the root key if this pointer is not empty.
     */
    Optional&lt;JsonKey&gt; getRoot();

    /**
     * Returns the leaf JSON key of this pointer. If the level count of this pointer is {@code one} the leaf is the same
     * as the root.
     *
     * @return the leaf key if this pointer is not empty.
     */
    Optional&lt;JsonKey&gt; getLeaf();

    /**
     * Creates a new pointer by removing the leaf element of this pointer.
     *
     * @return a new pointer which does not contain the leaf element of this pointer. If this pointer is empty this
     * pointer instance is returned.
     */
    JsonPointer cutLeaf();

    /**
     * Goes to the next sub level of this pointer.
     *
     * @return a new pointer beginning with the element after the root of this pointer. If this pointer is empty this
     * pointer instance is returned.
     */
    JsonPointer nextLevel();

    /**
     * Returns a new JSON pointer including all JSON keys from to the passed level and upwards. For example, if this
     * pointer is {@code /foo/bar/baz} then calling this method with level {@literal 1} returns the pointer
     * {@code /bar/baz}.
     *
     * @param level the level from which (upwards) JSON keys should be included in the result. The key at the specified
     * level is part of the result.
     * @return the sub pointer starting from {@code level}. If the level is outside the bounds of this pointer the
     * result is empty.
     */
    Optional&lt;JsonPointer&gt; getSubPointer(int level);

    /**
     * Returns a new JSON pointer including all JSON keys from the root until the passed in level. For example, if this
     * pointer is {@code /foo/bar/baz} then calling this method with level {@literal 1} returns the pointer
     * {@code /foo/bar}.
     *
     * @param level the level from which (downwards) JSON keys should be included in the result. The key at the
     * specified level is part of the result.
     * @return the sub pointer starting from the root until {@code level}. If {@code level} is outside the bounds of
     * this pointer the result is empty.
     */
    Optional&lt;JsonPointer&gt; getPrefixPointer(int level);

    /**
     * Returns a new {@link JsonFieldSelector} containing this pointer as its only element.
     *
     * @return a new JSON field selector containing only this pointer.
     */
    JsonFieldSelector toFieldSelector();

    /**
     * The string representation of this pointer, i. e. all of its levels concatenated by {@code &quot;/&quot;}. For example,
     * if this pointer consists of the three levels {@code &quot;foo&quot;}, {@code &quot;bar&quot;} and {@code &quot;baz&quot;}, this method
     * will return the string {@code &quot;/foo/bar/baz&quot;}.
     *
     * @return the string representation of this pointer.
     */
    @Override
    String toString();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>