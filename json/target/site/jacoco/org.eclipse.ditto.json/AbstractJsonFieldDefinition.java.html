<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractJsonFieldDefinition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Eclipse Ditto :: JSON</a> &gt; <a href="index.source.html" class="el_package">org.eclipse.ditto.json</a> &gt; <span class="el_source">AbstractJsonFieldDefinition.java</span></div><h1>AbstractJsonFieldDefinition.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2017 Bosch Software Innovations GmbH.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/index.php
 *
 * Contributors:
 *    Bosch Software Innovations GmbH - initial contribution
 */
package org.eclipse.ditto.json;

import static java.util.Objects.requireNonNull;

import java.text.MessageFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;

/**
 * This abstract implementation of {@link org.eclipse.ditto.json.JsonFieldDefinition} is meant to be used for all value
 * types which are supported by {@link org.eclipse.ditto.json.JsonValue} to make parsing a JsonObject easier and most
 * notably, type safe.
 *
 * @param &lt;T&gt; the type of this definition's value type.
 */
@Immutable
abstract class AbstractJsonFieldDefinition&lt;T&gt; implements JsonFieldDefinition&lt;T&gt; {

    private final JsonPointer pointer;
    private final Class&lt;T&gt; valueType;
    private final Function&lt;JsonValue, Boolean&gt; checkJavaTypeFunction;
    private final Function&lt;JsonValue, T&gt; mappingFunction;
    private final Set&lt;JsonFieldMarker&gt; markers;

    /**
     * Constructs a new {@code AbstractJsonFieldDefinition} object.
     *
     * @param pointer a character sequence consisting of either a single JSON key or a slash delimited hierarchy of JSON
     * keys aka JSON pointer.
     * @param valueType the type of the value of the defined JSON field.
     * @param checkJavaTypeFunction the function which checks if a given JsonValue represents the expected Java type.
     * @param mappingFunction the function for converting a JsonValue into the value type.
     * @param markers optional markers which add user defined semantics to the defined JSON field.
     * @throws NullPointerException if any argument is {@code null}.
     * @throws IllegalArgumentException if {@code pointer} is empty.
     */
    protected AbstractJsonFieldDefinition(final CharSequence pointer,
            final Class&lt;T&gt; valueType,
            final Function&lt;JsonValue, Boolean&gt; checkJavaTypeFunction,
            final Function&lt;JsonValue, T&gt; mappingFunction,
<span class="fc" id="L59">            final JsonFieldMarker ... markers) {</span>

<span class="fc" id="L61">        requireNonNull(pointer, &quot;The JSON pointer of the field definition must not be null!&quot;);</span>
<span class="fc" id="L62">        requireNonNull(markers, &quot;The markers must not be null!&quot;);</span>

<span class="fc" id="L64">        this.pointer = JsonFactory.newPointer(pointer);</span>
<span class="fc" id="L65">        this.valueType = requireNonNull(valueType, &quot;The value type of the field definition must not be null!&quot;);</span>
<span class="fc" id="L66">        this.checkJavaTypeFunction =</span>
<span class="fc" id="L67">                requireNonNull(checkJavaTypeFunction, &quot;The Java type checking function must not be null!&quot;);</span>
<span class="fc" id="L68">        this.mappingFunction = requireNonNull(mappingFunction, &quot;The mapping function must not be null!&quot;);</span>

<span class="fc" id="L70">        final Set&lt;JsonFieldMarker&gt; mutableMarkersSet = new HashSet&lt;&gt;(markers.length);</span>
<span class="fc" id="L71">        Collections.addAll(mutableMarkersSet, markers);</span>

<span class="fc" id="L73">        this.markers = Collections.unmodifiableSet(mutableMarkersSet);</span>
<span class="fc" id="L74">    }</span>

    @Override
    public JsonPointer getPointer() {
<span class="fc" id="L78">        return pointer;</span>
    }

    @Override
    public Class&lt;T&gt; getValueType() {
<span class="fc" id="L83">        return valueType;</span>
    }

    @Override
    public Set&lt;JsonFieldMarker&gt; getMarkers() {
<span class="fc" id="L88">        return markers;</span>
    }

    @Override
    public boolean isMarkedAs(final JsonFieldMarker fieldMarker, final JsonFieldMarker... furtherFieldMarkers) {
<span class="fc" id="L93">        requireNonNull(fieldMarker, &quot;At least one marker has to be specified!&quot;);</span>
<span class="fc" id="L94">        requireNonNull(furtherFieldMarkers, &quot;The further field markers must not be null!&quot;);</span>

<span class="fc" id="L96">        final Collection&lt;JsonFieldMarker&gt; askedMarkers = new HashSet&lt;&gt;(1 + furtherFieldMarkers.length);</span>
<span class="fc" id="L97">        askedMarkers.add(fieldMarker);</span>
<span class="fc" id="L98">        Collections.addAll(askedMarkers, furtherFieldMarkers);</span>

<span class="fc" id="L100">        return markers.containsAll(askedMarkers);</span>
    }

    @Nullable
    @Override
    public T mapValue(final JsonValue jsonValue) {
<span class="fc" id="L106">        checkValueType(jsonValue);</span>
<span class="fc" id="L107">        return getAsJavaType(jsonValue, mappingFunction);</span>
    }

    private void checkValueType(final JsonValue jsonValue) {
<span class="fc" id="L111">        requireNonNull(jsonValue, &quot;The JsonValue to be mapped must not be (Java) null!&quot;);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (!hasExpectedValueType(jsonValue)) {</span>
<span class="fc" id="L113">            final String msgPattern = &quot;Value &lt;{0}&gt; for &lt;{1}&gt; is not of type &lt;{2}&gt;!&quot;;</span>
<span class="fc" id="L114">            final String message = MessageFormat.format(msgPattern, jsonValue, pointer, valueType.getSimpleName());</span>
<span class="fc" id="L115">            throw new JsonParseException(message);</span>
        }
<span class="fc" id="L117">    }</span>

    private boolean hasExpectedValueType(final JsonValue jsonValue) {
<span class="fc bfc" id="L120" title="All 4 branches covered.">        return jsonValue.isNull() || checkJavaTypeFunction.apply(jsonValue);</span>
    }

    @Nullable
    protected abstract T getAsJavaType(JsonValue jsonValue, Function&lt;JsonValue, T&gt; mappingFunction);

    @Override
    public boolean equals(final Object o) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (this == o) {</span>
<span class="fc" id="L129">            return true;</span>
        }
<span class="fc bfc" id="L131" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="fc" id="L132">            return false;</span>
        }
<span class="fc" id="L134">        final AbstractJsonFieldDefinition&lt;?&gt; that = (AbstractJsonFieldDefinition&lt;?&gt;) o;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        return Objects.equals(pointer, that.pointer) &amp;&amp;</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                Objects.equals(valueType, that.valueType) &amp;&amp;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                Objects.equals(checkJavaTypeFunction, that.checkJavaTypeFunction) &amp;&amp;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">                Objects.equals(mappingFunction, that.mappingFunction) &amp;&amp;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">                Objects.equals(markers, that.markers);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L144">        return Objects.hash(pointer, valueType, checkJavaTypeFunction, mappingFunction, markers);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L149">        return getClass().getSimpleName() + &quot; [&quot; +</span>
                &quot;pointer=&quot; + pointer +
                &quot;, valueType=&quot; + valueType +
                &quot;, checkJavaTypeFunction=&quot; + checkJavaTypeFunction +
                &quot;, mappingFunction=&quot; + mappingFunction +
                &quot;, markers=&quot; + markers +
                &quot;]&quot;;
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>