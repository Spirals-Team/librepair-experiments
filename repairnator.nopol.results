nopolinfo #0
location: FailureLocation{className='com.facebook.presto.sql.planner.optimizations.TestMergeWindows', failingMethods=[com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testMergeDifferentFramesWithDefault, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testIdenticalWindowSpecificationsAAcpA, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testIdenticalWindowSpecificationsABA, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testMergeDifferentFrames, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testMergeableWindowsAllOptimizers, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testIdenticalWindowSpecificationsDefaultFrame, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testNotMergeDifferentPartition, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testNotMergeDifferentNullOrdering, com.facebook.presto.sql.planner.optimizations.TestMergeWindows#testNotMergeDifferentOrdering], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=lag (QUANTITY, ONE, ZERO) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - node(ProjectNode)
            bind ONE -> CAST(1 AS bigint)
            bind ZERO -> 0.0
            - node(WindowNode)
                WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
                bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
                - node(TableScanNode)
                    TableScanMatcher{expectedTableName=lineitem}
                    bind QUANTITY -> Column lineitem:quantity
                    bind DISCOUNT -> Column lineitem:discount
                    bind SUPPKEY -> Column lineitem:suppkey
                    bind ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[sum_quantity_A, sum_quantity_B, sum_discount_A] => [sum:double, lag:double, sum_10:double]
        sum_quantity_A := sum
        sum_quantity_B := lag
        sum_discount_A := sum_10
    - Project[] => [sum:double, lag:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, expr:bigint, expr_4:double, lag:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, expr:bigint, expr_4:double, lag:double]
                    lag := lag("quantity", "expr", "expr_4") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, expr:bigint, expr_4:double]
                        expr := CAST(1 AS bigint)
                        expr_4 := 0.0
                    - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                            sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                        - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                                Cost: {rows: 60000, bytes: ?}
                                orderkey := tpch:orderkey
                                suppkey := tpch:suppkey
                                quantity := tpch:quantity
                                discount := tpch:discount

] which resolves to [

- Output[sum_quantity_A, sum_quantity_B, sum_discount_A] => [sum:double, lag:double, sum_10:double]
        sum_quantity_A := sum
        sum_quantity_B := lag
        sum_discount_A := sum_10
    - Project[] => [sum:double, lag:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, expr:bigint, expr_4:double, lag:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, expr:bigint, expr_4:double, lag:double]
                    lag := lag("quantity", "expr", "expr_4") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, expr:bigint, expr_4:double]
                        expr := CAST(1 AS bigint)
                        expr_4 := 0.0
                    - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                            sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                        - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                                Cost: {rows: 60000, bytes: ?}
                                orderkey := tpch:orderkey
                                suppkey := tpch:suppkey
                                quantity := tpch:quantity
                                discount := tpch:discount

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[ORDERKEY], orderBy=[SHIPDATE], orderings={SHIPDATE=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=lineitem}
                bind QUANTITY -> Column lineitem:quantity
                bind DISCOUNT -> Column lineitem:discount
                bind SUPPKEY -> Column lineitem:suppkey
                bind ORDERKEY -> Column lineitem:orderkey
                bind SHIPDATE -> Column lineitem:shipdate

] but found [

- Output[sum_quantity_A, sum_quantity_B, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_quantity_A := sum
        sum_quantity_B := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (orderkey), order by (shipdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double]
                    sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double]
                        sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount
                            shipdate := tpch:shipdate

] which resolves to [

- Output[sum_quantity_A, sum_quantity_B, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_quantity_A := sum
        sum_quantity_B := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (orderkey), order by (shipdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double]
                    sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double]
                        sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount
                            shipdate := tpch:shipdate

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (QUANTITY) }
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) }
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[ORDERKEY], orderBy=[SHIPDATE], orderings={SHIPDATE=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) }
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=lineitem}
                bind QUANTITY -> Column lineitem:quantity
                bind DISCOUNT -> Column lineitem:discount
                bind SUPPKEY -> Column lineitem:suppkey
                bind ORDERKEY -> Column lineitem:orderkey
                bind SHIPDATE -> Column lineitem:shipdate

] but found [

- Output[_col0, _col1, _col2] => [sum:double, sum_6:double, sum_10:double]
        _col0 := sum
        _col1 := sum_6
        _col2 := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") 
            - Window[partition by (orderkey), order by (shipdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double]
                    sum_6 := sum("quantity") 
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double]
                        sum := sum("quantity") 
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount
                            shipdate := tpch:shipdate

] which resolves to [

- Output[_col0, _col1, _col2] => [sum:double, sum_6:double, sum_10:double]
        _col0 := sum
        _col1 := sum_6
        _col2 := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") 
            - Window[partition by (orderkey), order by (shipdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double]
                    sum_6 := sum("quantity") 
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double]
                        sum := sum("quantity") 
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount
                            shipdate := tpch:shipdate

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=avg (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=CURRENT_ROW, value=Optional.empty}, end=Optional[FrameBound{type=UNBOUNDED_FOLLOWING, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - node(TableScanNode)
            TableScanMatcher{expectedTableName=lineitem}
            bind QUANTITY -> Column lineitem:quantity
            bind DISCOUNT -> Column lineitem:discount
            bind SUPPKEY -> Column lineitem:suppkey
            bind ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[sum_quantity_C, avg_quantity_D, sum_discount_C] => [sum:double, avg:double, sum_9:double]
        sum_quantity_C := sum
        avg_quantity_D := avg
        sum_discount_C := sum_9
    - Project[] => [sum:double, avg:double, sum_9:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double, sum_9:double]
                sum_9 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double]
                    avg := avg("quantity") ROWS CURRENT_ROW UNBOUNDED_FOLLOWING
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                        sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount

] which resolves to [

- Output[sum_quantity_C, avg_quantity_D, sum_discount_C] => [sum:double, avg:double, sum_9:double]
        sum_quantity_C := sum
        avg_quantity_D := avg
        sum_discount_C := sum_9
    - Project[] => [sum:double, avg:double, sum_9:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double, sum_9:double]
                sum_9 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double]
                    avg := avg("quantity") ROWS CURRENT_ROW UNBOUNDED_FOLLOWING
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                        sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=avg (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=CURRENT_ROW, value=Optional.empty}, end=Optional[FrameBound{type=UNBOUNDED_FOLLOWING, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) }
        bind WindowFunctionMatcher{callMaker=sum (QUANTITY) }
        - node(TableScanNode)
            TableScanMatcher{expectedTableName=lineitem}
            bind QUANTITY -> Column lineitem:quantity
            bind DISCOUNT -> Column lineitem:discount
            bind SUPPKEY -> Column lineitem:suppkey
            bind ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[sum_quantity_C, avg_quantity_D, sum_discount_C] => [sum:double, avg:double, sum_9:double]
        sum_quantity_C := sum
        avg_quantity_D := avg
        sum_discount_C := sum_9
    - Project[] => [sum:double, avg:double, sum_9:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double, sum_9:double]
                sum_9 := sum("discount") 
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double]
                    avg := avg("quantity") ROWS CURRENT_ROW UNBOUNDED_FOLLOWING
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                        sum := sum("quantity") 
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount

] which resolves to [

- Output[sum_quantity_C, avg_quantity_D, sum_discount_C] => [sum:double, avg:double, sum_9:double]
        sum_quantity_C := sum
        avg_quantity_D := avg
        sum_discount_C := sum_9
    - Project[] => [sum:double, avg:double, sum_9:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double, sum_9:double]
                sum_9 := sum("discount") 
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, avg:double]
                    avg := avg("quantity") ROWS CURRENT_ROW UNBOUNDED_FOLLOWING
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                        sum := sum("quantity") 
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - anyTree
            - node(WindowNode)
                WindowMatcher{specification=SpecificationProvider{partitionBy=[ORDERKEY], orderBy=[SHIPDATE], orderings={SHIPDATE=ASC_NULLS_LAST}}}
                bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
                - node
                    NotPlanNodeMatcher{excludedNodeClass=class com.facebook.presto.sql.planner.plan.WindowNode}
                    - node(TableScanNode)
                        TableScanMatcher{expectedTableName=lineitem}
                        bind QUANTITY -> Column lineitem:quantity
                        bind DISCOUNT -> Column lineitem:discount
                        bind SUPPKEY -> Column lineitem:suppkey
                        bind ORDERKEY -> Column lineitem:orderkey
                        bind SHIPDATE -> Column lineitem:shipdate

] but found [

- Output[sum_quantity_A, sum_quantity_B, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_quantity_A := sum
        sum_quantity_B := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)][$hashvalue_26] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, $hashvalue_26:bigint, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, $hashvalue_26:bigint]
                    $hashvalue_26 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                - Window[partition by (orderkey), order by (shipdate ASC_NULLS_LAST)][$hashvalue_25] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, $hashvalue_25:bigint, sum_6:double]
                        sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, $hashvalue_25:bigint]
                            $hashvalue_25 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("orderkey"), 0))
                        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)][$hashvalue] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue:bigint, sum:double]
                                sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                            - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue:bigint]
                                    Cost: {rows: 60000, bytes: ?}
                                - LocalExchange[SINGLE] () => orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue:bigint, $hashvalue_22:bigint
                                        Cost: {rows: 60000, bytes: ?}
                                    - ScanProject[table = local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue_23:bigint, $hashvalue_24:bigint]
                                            Cost: {rows: 60000, bytes: ?}/{rows: 60000, bytes: ?}
                                            $hashvalue_23 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                                            $hashvalue_24 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("orderkey"), 0))
                                            orderkey := tpch:orderkey
                                            suppkey := tpch:suppkey
                                            quantity := tpch:quantity
                                            discount := tpch:discount
                                            shipdate := tpch:shipdate

] which resolves to [

- Output[sum_quantity_A, sum_quantity_B, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_quantity_A := sum
        sum_quantity_B := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)][$hashvalue_26] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, $hashvalue_26:bigint, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, sum_6:double, $hashvalue_26:bigint]
                    $hashvalue_26 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                - Window[partition by (orderkey), order by (shipdate ASC_NULLS_LAST)][$hashvalue_25] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, $hashvalue_25:bigint, sum_6:double]
                        sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, sum:double, $hashvalue_25:bigint]
                            $hashvalue_25 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("orderkey"), 0))
                        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)][$hashvalue] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue:bigint, sum:double]
                                sum := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                            - Project[] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue:bigint]
                                    Cost: {rows: 60000, bytes: ?}
                                - LocalExchange[SINGLE] () => orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue:bigint, $hashvalue_22:bigint
                                        Cost: {rows: 60000, bytes: ?}
                                    - ScanProject[table = local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, shipdate:date, $hashvalue_23:bigint, $hashvalue_24:bigint]
                                            Cost: {rows: 60000, bytes: ?}/{rows: 60000, bytes: ?}
                                            $hashvalue_23 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                                            $hashvalue_24 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("orderkey"), 0))
                                            orderkey := tpch:orderkey
                                            suppkey := tpch:suppkey
                                            quantity := tpch:quantity
                                            discount := tpch:discount
                                            shipdate := tpch:shipdate

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (EXTENDEDPRICE) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_FIRST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=lineitem}
                bind QUANTITY -> Column lineitem:quantity
                bind SUPPKEY -> Column lineitem:suppkey
                bind ORDERKEY -> Column lineitem:orderkey
                bind DISCOUNT -> Column lineitem:discount
                bind EXTENDEDPRICE -> Column lineitem:extendedprice

] but found [

- Output[sum_extendedprice_A, sum_quantity_C, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_extendedprice_A := sum
        sum_quantity_C := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_FIRST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double]
                    sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double]
                        sum := sum("extendedprice") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            extendedprice := tpch:extendedprice
                            discount := tpch:discount

] which resolves to [

- Output[sum_extendedprice_A, sum_quantity_C, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_extendedprice_A := sum
        sum_quantity_C := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_FIRST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double]
                    sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double]
                        sum := sum("extendedprice") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            extendedprice := tpch:extendedprice
                            discount := tpch:discount

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=DESC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (EXTENDEDPRICE) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
            bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=lineitem}
                bind QUANTITY -> Column lineitem:quantity
                bind SUPPKEY -> Column lineitem:suppkey
                bind ORDERKEY -> Column lineitem:orderkey
                bind DISCOUNT -> Column lineitem:discount
                bind EXTENDEDPRICE -> Column lineitem:extendedprice

] but found [

- Output[sum_extendedprice_A, sum_quantity_C, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_extendedprice_A := sum
        sum_quantity_C := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey DESC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double]
                    sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double]
                        sum := sum("extendedprice") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            extendedprice := tpch:extendedprice
                            discount := tpch:discount

] which resolves to [

- Output[sum_extendedprice_A, sum_quantity_C, sum_discount_A] => [sum:double, sum_6:double, sum_10:double]
        sum_extendedprice_A := sum
        sum_quantity_C := sum_6
        sum_discount_A := sum_10
    - Project[] => [sum:double, sum_6:double, sum_10:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double, sum_10:double]
                sum_10 := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey DESC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double, sum_6:double]
                    sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double, sum:double]
                        sum := sum("extendedprice") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, extendedprice:double, discount:double]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            extendedprice := tpch:extendedprice
                            discount := tpch:discount

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[QUANTITY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) WindowFrame{type=ROWS, start=FrameBound{type=UNBOUNDED_PRECEDING, value=Optional.empty}, end=Optional[FrameBound{type=CURRENT_ROW, value=Optional.empty}]}}
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=lineitem}
                bind QUANTITY -> Column lineitem:quantity
                bind DISCOUNT -> Column lineitem:discount
                bind SUPPKEY -> Column lineitem:suppkey
                bind ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[sum_extendedprice_A, sum_quantity_C] => [sum:double, sum_6:double]
        sum_extendedprice_A := sum
        sum_quantity_C := sum_6
    - Project[] => [sum:double, sum_6:double]
        - Window[partition by (quantity), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, sum_6:double]
                sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                    sum := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                        Cost: {rows: 60000, bytes: ?}
                        orderkey := tpch:orderkey
                        suppkey := tpch:suppkey
                        quantity := tpch:quantity
                        discount := tpch:discount

] which resolves to [

- Output[sum_extendedprice_A, sum_quantity_C] => [sum:double, sum_6:double]
        sum_extendedprice_A := sum
        sum_quantity_C := sum_6
    - Project[] => [sum:double, sum_6:double]
        - Window[partition by (quantity), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double, sum_6:double]
                sum_6 := sum("quantity") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
            - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, sum:double]
                    sum := sum("discount") ROWS UNBOUNDED_PRECEDING CURRENT_ROW
                - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double]
                        Cost: {rows: 60000, bytes: ?}
                        orderkey := tpch:orderkey
                        suppkey := tpch:suppkey
                        quantity := tpch:quantity
                        discount := tpch:discount

]', isError=false}], nbFailures=9, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:11:02 CEST 2017
allocatedtime: 120minutes 
passingTime: 1minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@6fc3e1a4', projectTests=[com.facebook.presto.sql.planner.optimizations.TestMergeWindows], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #1
location: FailureLocation{className='com.facebook.presto.sql.planner.optimizations.TestReorderWindows', failingMethods=[com.facebook.presto.sql.planner.optimizations.TestReorderWindows#testPrefixOfPartitionComesFirstRegardlessOfTheirOrderInSQL, com.facebook.presto.sql.planner.optimizations.TestReorderWindows#testNonMergeableABAReordersToAABAllOptimizers, com.facebook.presto.sql.planner.optimizations.TestReorderWindows#testReorderBDAC, com.facebook.presto.sql.planner.optimizations.TestReorderWindows#testNonMergeableABAReordersToAAB], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[SHIPDATE], orderings={SHIPDATE=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=min (TAX) }
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) }
            - node(WindowNode)
                WindowMatcher{specification=SpecificationProvider{partitionBy=[PARTKEY], orderBy=[RECEIPTDATE], orderings={RECEIPTDATE=ASC_NULLS_LAST}}}
                bind WindowFunctionMatcher{callMaker=avg (DISCOUNT) }
                - node(TableScanNode)
                    TableScanMatcher{expectedTableName=lineitem}
                    bind DISCOUNT -> Column lineitem:discount
                    bind ORDERKEY -> Column lineitem:orderkey
                    bind QUANTITY -> Column lineitem:quantity
                    bind PARTKEY -> Column lineitem:partkey
                    bind RECEIPTDATE -> Column lineitem:receiptdate
                    bind SHIPDATE -> Column lineitem:shipdate
                    bind SUPPKEY -> Column lineitem:suppkey
                    bind TAX -> Column lineitem:tax

] but found [

- Output[sum_quantity_A, avg_discount_B, min_tax_A] => [sum:double, avg:double, min:double]
        sum_quantity_A := sum
        avg_discount_B := avg
        min_tax_A := min
    - Project[] => [sum:double, avg:double, min:double]
        - Window[partition by (suppkey), order by (shipdate ASC_NULLS_LAST)] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double, min:double]
                min := min("tax") 
            - Window[partition by (partkey), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double]
                    avg := avg("discount") 
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double]
                        sum := sum("quantity") 
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            partkey := tpch:partkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount
                            tax := tpch:tax
                            shipdate := tpch:shipdate
                            receiptdate := tpch:receiptdate

] which resolves to [

- Output[sum_quantity_A, avg_discount_B, min_tax_A] => [sum:double, avg:double, min:double]
        sum_quantity_A := sum
        avg_discount_B := avg
        min_tax_A := min
    - Project[] => [sum:double, avg:double, min:double]
        - Window[partition by (suppkey), order by (shipdate ASC_NULLS_LAST)] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double, min:double]
                min := min("tax") 
            - Window[partition by (partkey), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double]
                    avg := avg("discount") 
                - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double]
                        sum := sum("quantity") 
                    - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date]
                            Cost: {rows: 60000, bytes: ?}
                            orderkey := tpch:orderkey
                            partkey := tpch:partkey
                            suppkey := tpch:suppkey
                            quantity := tpch:quantity
                            discount := tpch:discount
                            tax := tpch:tax
                            shipdate := tpch:shipdate
                            receiptdate := tpch:receiptdate

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[SHIPDATE], orderings={SHIPDATE=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=min (TAX) }
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) }
            - anyTree
                - node(WindowNode)
                    WindowMatcher{specification=SpecificationProvider{partitionBy=[PARTKEY], orderBy=[RECEIPTDATE], orderings={RECEIPTDATE=ASC_NULLS_LAST}}}
                    bind WindowFunctionMatcher{callMaker=avg (DISCOUNT) }
                    - anyTree
                        - node(TableScanNode)
                            TableScanMatcher{expectedTableName=lineitem}
                            bind DISCOUNT -> Column lineitem:discount
                            bind ORDERKEY -> Column lineitem:orderkey
                            bind QUANTITY -> Column lineitem:quantity
                            bind PARTKEY -> Column lineitem:partkey
                            bind RECEIPTDATE -> Column lineitem:receiptdate
                            bind SHIPDATE -> Column lineitem:shipdate
                            bind SUPPKEY -> Column lineitem:suppkey
                            bind TAX -> Column lineitem:tax

] but found [

- Output[sum_quantity_A, avg_discount_B, min_tax_A] => [sum:double, avg:double, min:double]
        sum_quantity_A := sum
        avg_discount_B := avg
        min_tax_A := min
    - Project[] => [sum:double, avg:double, min:double]
        - Window[partition by (suppkey), order by (shipdate ASC_NULLS_LAST)][$hashvalue_24] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double, $hashvalue_24:bigint, min:double]
                min := min("tax") 
            - Project[] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double, $hashvalue_24:bigint]
                    $hashvalue_24 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                - Window[partition by (partkey), order by (receiptdate ASC_NULLS_LAST)][$hashvalue_23] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, $hashvalue_23:bigint, avg:double]
                        avg := avg("discount") 
                    - Project[] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, $hashvalue_23:bigint]
                            $hashvalue_23 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("partkey"), 0))
                        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)][$hashvalue] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue:bigint, sum:double]
                                sum := sum("quantity") 
                            - Project[] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue:bigint]
                                    Cost: {rows: 60000, bytes: ?}
                                - LocalExchange[SINGLE] () => orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue:bigint, $hashvalue_20:bigint
                                        Cost: {rows: 60000, bytes: ?}
                                    - ScanProject[table = local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue_21:bigint, $hashvalue_22:bigint]
                                            Cost: {rows: 60000, bytes: ?}/{rows: 60000, bytes: ?}
                                            $hashvalue_21 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                                            $hashvalue_22 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("partkey"), 0))
                                            orderkey := tpch:orderkey
                                            partkey := tpch:partkey
                                            suppkey := tpch:suppkey
                                            quantity := tpch:quantity
                                            discount := tpch:discount
                                            tax := tpch:tax
                                            shipdate := tpch:shipdate
                                            receiptdate := tpch:receiptdate

] which resolves to [

- Output[sum_quantity_A, avg_discount_B, min_tax_A] => [sum:double, avg:double, min:double]
        sum_quantity_A := sum
        avg_discount_B := avg
        min_tax_A := min
    - Project[] => [sum:double, avg:double, min:double]
        - Window[partition by (suppkey), order by (shipdate ASC_NULLS_LAST)][$hashvalue_24] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double, $hashvalue_24:bigint, min:double]
                min := min("tax") 
            - Project[] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, avg:double, $hashvalue_24:bigint]
                    $hashvalue_24 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                - Window[partition by (partkey), order by (receiptdate ASC_NULLS_LAST)][$hashvalue_23] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, $hashvalue_23:bigint, avg:double]
                        avg := avg("discount") 
                    - Project[] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, sum:double, $hashvalue_23:bigint]
                            $hashvalue_23 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("partkey"), 0))
                        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)][$hashvalue] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue:bigint, sum:double]
                                sum := sum("quantity") 
                            - Project[] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue:bigint]
                                    Cost: {rows: 60000, bytes: ?}
                                - LocalExchange[SINGLE] () => orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue:bigint, $hashvalue_20:bigint
                                        Cost: {rows: 60000, bytes: ?}
                                    - ScanProject[table = local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey:bigint, partkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, shipdate:date, receiptdate:date, $hashvalue_21:bigint, $hashvalue_22:bigint]
                                            Cost: {rows: 60000, bytes: ?}/{rows: 60000, bytes: ?}
                                            $hashvalue_21 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("suppkey"), 0))
                                            $hashvalue_22 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("partkey"), 0))
                                            orderkey := tpch:orderkey
                                            partkey := tpch:partkey
                                            suppkey := tpch:suppkey
                                            quantity := tpch:quantity
                                            discount := tpch:discount
                                            tax := tpch:tax
                                            shipdate := tpch:shipdate
                                            receiptdate := tpch:receiptdate

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY, TAX], orderBy=[RECEIPTDATE], orderings={RECEIPTDATE=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=avg (DISCOUNT) }
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=sum (QUANTITY) }
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=lineitem}
                bind DISCOUNT -> Column lineitem:discount
                bind ORDERKEY -> Column lineitem:orderkey
                bind QUANTITY -> Column lineitem:quantity
                bind RECEIPTDATE -> Column lineitem:receiptdate
                bind SUPPKEY -> Column lineitem:suppkey
                bind TAX -> Column lineitem:tax

] but found [

- Output[avg_discount_A, sum_quantity_A] => [avg:double, sum:double]
        avg_discount_A := avg
        sum_quantity_A := sum
    - Project[] => [avg:double, sum:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double]
                sum := sum("quantity") 
            - Window[partition by (suppkey, tax), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double]
                    avg := avg("discount") 
                - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date]
                        Cost: {rows: 60000, bytes: ?}
                        orderkey := tpch:orderkey
                        suppkey := tpch:suppkey
                        quantity := tpch:quantity
                        discount := tpch:discount
                        tax := tpch:tax
                        receiptdate := tpch:receiptdate

] which resolves to [

- Output[avg_discount_A, sum_quantity_A] => [avg:double, sum:double]
        avg_discount_A := avg
        sum_quantity_A := sum
    - Project[] => [avg:double, sum:double]
        - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double]
                sum := sum("quantity") 
            - Window[partition by (suppkey, tax), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double]
                    avg := avg("discount") 
                - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date]
                        Cost: {rows: 60000, bytes: ?}
                        orderkey := tpch:orderkey
                        suppkey := tpch:suppkey
                        quantity := tpch:quantity
                        discount := tpch:discount
                        tax := tpch:tax
                        receiptdate := tpch:receiptdate

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(WindowNode)
        WindowMatcher{specification=SpecificationProvider{partitionBy=[TAX], orderBy=[RECEIPTDATE], orderings={RECEIPTDATE=ASC_NULLS_LAST}}}
        bind WindowFunctionMatcher{callMaker=avg (QUANTITY) }
        - node(WindowNode)
            WindowMatcher{specification=SpecificationProvider{partitionBy=[SUPPKEY], orderBy=[ORDERKEY], orderings={ORDERKEY=ASC_NULLS_LAST}}}
            bind WindowFunctionMatcher{callMaker=avg (DISCOUNT) }
            - node(WindowNode)
                WindowMatcher{specification=SpecificationProvider{partitionBy=[RECEIPTDATE], orderBy=[SUPPKEY], orderings={SUPPKEY=ASC_NULLS_LAST}}}
                bind WindowFunctionMatcher{callMaker=sum (DISCOUNT) }
                - node(WindowNode)
                    WindowMatcher{specification=SpecificationProvider{partitionBy=[QUANTITY], orderBy=[RECEIPTDATE], orderings={RECEIPTDATE=ASC_NULLS_LAST}}}
                    bind WindowFunctionMatcher{callMaker=sum (TAX) }
                    - node(TableScanNode)
                        TableScanMatcher{expectedTableName=lineitem}
                        bind DISCOUNT -> Column lineitem:discount
                        bind ORDERKEY -> Column lineitem:orderkey
                        bind QUANTITY -> Column lineitem:quantity
                        bind RECEIPTDATE -> Column lineitem:receiptdate
                        bind SUPPKEY -> Column lineitem:suppkey
                        bind TAX -> Column lineitem:tax

] but found [

- Output[avg_discount_A, sum_tax_E, avg_quantity_D, sum_discount_C] => [avg:double, sum:double, avg_9:double, sum_13:double]
        avg_discount_A := avg
        sum_tax_E := sum
        avg_quantity_D := avg_9
        sum_discount_C := sum_13
    - Project[] => [avg:double, sum:double, avg_9:double, sum_13:double]
        - Window[partition by (receiptdate), order by (suppkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double, avg_9:double, sum_13:double]
                sum_13 := sum("discount") 
            - Window[partition by (tax), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double, avg_9:double]
                    avg_9 := avg("quantity") 
                - Window[partition by (quantity), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double]
                        sum := sum("tax") 
                    - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double]
                            avg := avg("discount") 
                        - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date]
                                Cost: {rows: 60000, bytes: ?}
                                orderkey := tpch:orderkey
                                suppkey := tpch:suppkey
                                quantity := tpch:quantity
                                discount := tpch:discount
                                tax := tpch:tax
                                receiptdate := tpch:receiptdate

] which resolves to [

- Output[avg_discount_A, sum_tax_E, avg_quantity_D, sum_discount_C] => [avg:double, sum:double, avg_9:double, sum_13:double]
        avg_discount_A := avg
        sum_tax_E := sum
        avg_quantity_D := avg_9
        sum_discount_C := sum_13
    - Project[] => [avg:double, sum:double, avg_9:double, sum_13:double]
        - Window[partition by (receiptdate), order by (suppkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double, avg_9:double, sum_13:double]
                sum_13 := sum("discount") 
            - Window[partition by (tax), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double, avg_9:double]
                    avg_9 := avg("quantity") 
                - Window[partition by (quantity), order by (receiptdate ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double, sum:double]
                        sum := sum("tax") 
                    - Window[partition by (suppkey), order by (orderkey ASC_NULLS_LAST)] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date, avg:double]
                            avg := avg("discount") 
                        - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = null] => [orderkey:bigint, suppkey:bigint, quantity:double, discount:double, tax:double, receiptdate:date]
                                Cost: {rows: 60000, bytes: ?}
                                orderkey := tpch:orderkey
                                suppkey := tpch:suppkey
                                quantity := tpch:quantity
                                discount := tpch:discount
                                tax := tpch:tax
                                receiptdate := tpch:receiptdate

]', isError=false}], nbFailures=4, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:12:01 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@7fb2e8d3', projectTests=[com.facebook.presto.sql.planner.optimizations.TestReorderWindows], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #2
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneMarkDistinctColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneMarkDistinctColumns#testMarkerSymbolNotReferenced, com.facebook.presto.sql.planner.iterative.rule.TestPruneMarkDistinctColumns#testSourceSymbolNotReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneMarkDistinctColumns did not fire for:
        - Project[] => [key2:bigint]
                key2 := "key"
            - MarkDistinct[distinct=key:bigint marker=mark] => [key:bigint, unused:bigint, mark:bigint]
                - Values => [key:bigint, unused:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneMarkDistinctColumns did not fire for:
        - Project[] => [mark:bigint]
            - MarkDistinct[distinct=key:bigint marker=mark][hash] => [key:bigint, hash:bigint, unused:bigint, mark:bigint]
                - Values => [key:bigint, hash:bigint, unused:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=2, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:12:59 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@1678dda4', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneMarkDistinctColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #3
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPushAggregationThroughOuterJoin', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPushAggregationThroughOuterJoin#testPushesAggregationThroughLeftJoin, com.facebook.presto.sql.planner.iterative.rule.TestPushAggregationThroughOuterJoin#testPushesAggregationThroughRightJoin], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushAggregationThroughOuterJoin did not fire for:
        - Aggregate[COL1] => [COL1:bigint, AVG:double]
                AVG := "avg"("COL2")
            - LeftJoin[("COL1" = "COL2")] => [COL1:bigint, COL2:bigint]
                    Cost: {rows: 2, bytes: ?}
                - Values => [COL1:bigint]
                        Cost: {rows: 1, bytes: ?}
                        (10)
                - Values => [COL2:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushAggregationThroughOuterJoin did not fire for:
        - Aggregate[COL1] => [COL1:bigint, AVG:double]
                AVG := "avg"("COL2")
            - RightJoin[("COL2" = "COL1")] => [COL2:bigint, COL1:bigint]
                    Cost: {rows: 2, bytes: ?}
                - Values => [COL2:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [COL1:bigint]
                        Cost: {rows: 1, bytes: ?}
                        (10)
', isError=false}], nbFailures=2, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:13:55 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@6a2138e2', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPushAggregationThroughOuterJoin], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #4
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughExchange', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughExchange#testSimpleMultipleInputs, com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughExchange#testPartitioningColumnAndHashWithoutIdentityMappingInProjection], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushProjectionThroughExchange did not fire for:
        - Project[] => [a_times_5:bigint, b_times_5:bigint, h_times_5:bigint]
                Cost: {rows: 0, bytes: ?}
                a_times_5 := ("a" * 5)
                b_times_5 := ("b" * 5)
                h_times_5 := ("h" * 5)
            - RemoteExchange[GATHER][h] => a:bigint, b:bigint, h:bigint
                    Cost: {rows: 0, bytes: ?}
                - Values => [a:bigint, b:bigint, h:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushProjectionThroughExchange did not fire for:
        - Project[] => [x:bigint, c2:bigint]
                Cost: {rows: 0, bytes: ?}
                x := 3
                c2 := "c"
            - RemoteExchange[GATHER] => c:bigint
                    Cost: {rows: 0, bytes: ?}
                - Values => [a:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [b:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=2, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:14:54 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@4e8300f3', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughExchange], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #5
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneSemiJoinColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneSemiJoinColumns#testSemiJoinNotNeeded, com.facebook.presto.sql.planner.iterative.rule.TestPruneSemiJoinColumns#testValueNotNeeded], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneSemiJoinColumns did not fire for:
        - Project[] => [leftValue:bigint]
                Cost: {rows: 0, bytes: ?}
            - SemiJoin[leftKey = rightKey][leftKeyHash] => [leftKey:bigint, leftKeyHash:bigint, leftValue:bigint, match:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [leftKey:bigint, leftKeyHash:bigint, leftValue:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [rightKey:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneSemiJoinColumns did not fire for:
        - Project[] => [match:bigint]
                Cost: {rows: 0, bytes: ?}
            - SemiJoin[leftKey = rightKey][leftKeyHash] => [leftKey:bigint, leftKeyHash:bigint, leftValue:bigint, match:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [leftKey:bigint, leftKeyHash:bigint, leftValue:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [rightKey:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=2, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:15:53 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@93a89ca', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneSemiJoinColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #6
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneCrossJoinColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneCrossJoinColumns#testLeftInputNotReferenced, com.facebook.presto.sql.planner.iterative.rule.TestPruneCrossJoinColumns#testRightInputNotReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneCrossJoinColumns did not fire for:
        - Project[] => [rightValue:bigint]
                Cost: {rows: 0, bytes: ?}
            - CrossJoin => [leftValue:bigint, rightValue:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [leftValue:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [rightValue:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneCrossJoinColumns did not fire for:
        - Project[] => [leftValue:bigint]
                Cost: {rows: 0, bytes: ?}
            - CrossJoin => [leftValue:bigint, rightValue:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [leftValue:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [rightValue:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=2, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:16:54 CEST 2017
allocatedtime: 119minutes 
passingTime: 1minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@e90ac26', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneCrossJoinColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #7
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPushTableWriteThroughUnion', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPushTableWriteThroughUnion#testPushThroughUnion], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushTableWriteThroughUnion did not fire for:
        - TableWriter => [partialrows:bigint, fragment:varbinary]
                a := A
                b := B
            - Union => [A:bigint, B:bigint]
                - Values => [A1:bigint, B1:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [A2:bigint, B2:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:17:53 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@72a0f185', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPushTableWriteThroughUnion], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #8
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPushLimitThroughMarkDistinct', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPushLimitThroughMarkDistinct#test], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushLimitThroughMarkDistinct did not fire for:
        - Limit[1] => [foo:bigint]
                Cost: {rows: 1, bytes: ?}
            - MarkDistinct[distinct= marker=foo] => [foo:bigint]
                - Values => []
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:18:53 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@3c4d62fd', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPushLimitThroughMarkDistinct], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #9
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughUnion', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughUnion#test], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PushProjectionThroughUnion did not fire for:
        - Project[] => [c_times_3:bigint]
                c_times_3 := ("c" * 3)
            - Union => [c:bigint]
                - Values => [a:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [b:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:19:50 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@6d975d2f', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPushProjectionThroughUnion], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #10
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneAggregationColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneAggregationColumns#testNotAllInputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneAggregationColumns did not fire for:
        - Project[] => [b:bigint]
            - Aggregate[key] => [key:bigint, a:bigint, b:bigint]
                    a := "count"(*)
                    b := "count"(*)
                - Values => [key:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:20:49 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@4c6d2714', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneAggregationColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #11
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestMergeAdjacentWindows', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestMergeAdjacentWindows#testIdenticalAdjacentWindowSpecifications], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.MergeAdjacentWindows did not fire for:
        - Window[partition by (a)] => [a:bigint, sum_1:bigint, avg_1:bigint]
                avg_1 := avg("a") 
            - Window[partition by (a)] => [a:bigint, sum_1:bigint]
                    sum_1 := sum("a") 
                - Values => [a:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:21:46 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@5dfeaba2', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestMergeAdjacentWindows], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #12
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneTopNColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneTopNColumns#testNotAllInputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneTopNColumns did not fire for:
        - Project[] => [b:bigint]
            - TopN[10 by (b ASC_NULLS_FIRST)] => [a:bigint, b:bigint]
                - Values => [a:bigint, b:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:22:44 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@37468926', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneTopNColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #13
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneIndexSourceColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneIndexSourceColumns#testNotAllOutputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneIndexSourceColumns did not fire for:
        - Project[] => [orderkey:integer]
            - IndexSource[local:INSTANCE:INSTANCE, lookup = [orderkey, custkey]] => [orderkey:integer, custkey:integer, totalprice:double]
                    orderkey := tpch:orderkey
                    custkey := tpch:custkey
                    totalprice := tpch:totalprice
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:23:42 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@40236e6c', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneIndexSourceColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #14
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestInlineProjections', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestInlineProjections#test], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.InlineProjections did not fire for:
        - Project[] => [identity:bigint, multi_complex_1:bigint, multi_complex_2:bigint, multi_literal_1:bigint, multi_literal_2:bigint, single_complex:bigint, try:bigint]
                Cost: {rows: 0, bytes: ?}
                identity := "symbol"
                multi_complex_1 := ("complex" + 1)
                multi_complex_2 := ("complex" + 2)
                multi_literal_1 := ("literal" + 1)
                multi_literal_2 := ("literal" + 2)
                single_complex := ("complex_2" + 2)
                try := TRY(("complex" / "literal"))
            - Project[] => [symbol:bigint, complex:bigint, literal:bigint, complex_2:bigint]
                    Cost: {rows: 0, bytes: ?}
                    symbol := "x"
                    complex := ("x" * 2)
                    literal := 1
                    complex_2 := ("x" - 1)
                - Values => [x:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:24:41 CEST 2017
allocatedtime: 119minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@6603486b', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestInlineProjections], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #15
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestSwapAdjacentWindowsBySpecifications', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestSwapAdjacentWindowsBySpecifications#subsetComesFirst], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.SwapAdjacentWindowsBySpecifications did not fire for:
        - Window[partition by (a)] => [a:bigint, b:bigint, avg_2:double, avg_1:double]
                avg_1 := avg("a") 
            - Window[partition by (a, b)] => [a:bigint, b:bigint, avg_2:double]
                    avg_2 := avg("b") 
                - Values => [a:bigint, b:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:25:41 CEST 2017
allocatedtime: 119minutes 
passingTime: 1minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@10145a7', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestSwapAdjacentWindowsBySpecifications], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #16
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneValuesColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneValuesColumns#testNotAllOutputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneValuesColumns did not fire for:
        - Project[] => [y:bigint]
                Cost: {rows: 2, bytes: ?}
                y := "x"
            - Values => [unused:bigint, x:bigint]
                    Cost: {rows: 2, bytes: ?}
                    (1, 2)
                    (3, 4)
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:26:39 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@3eed3295', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneValuesColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #17
location: FailureLocation{className='com.facebook.presto.sql.planner.optimizations.TestUnion', failingMethods=[com.facebook.presto.sql.planner.optimizations.TestUnion#testUnionUnderTopN], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='There should be exactly one RemoteExchange expected [1] but found [2]', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:27:39 CEST 2017
allocatedtime: 118minutes 
passingTime: 1minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@5c67361b', projectTests=[com.facebook.presto.sql.planner.optimizations.TestUnion], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #18
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneProjectColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneProjectColumns#testNotAllOutputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneProjectColumns did not fire for:
        - Project[] => [b:bigint]
                Cost: {rows: 0, bytes: ?}
            - Project[] => [a:bigint, b:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [a:bigint, b:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:28:37 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@1e6125cc', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneProjectColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #19
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneTableScanColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneTableScanColumns#testNotAllOutputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneTableScanColumns did not fire for:
        - ScanProject[table = local:tpch:orders:sf0.01, originalConstraint = null] => [x:bigint]
                Cost: {rows: 15000, bytes: ?}/{rows: 15000, bytes: ?}
                x := "totalprice"
                orderdate := tpch:orderdate
                totalprice := tpch:totalprice
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:29:35 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@430db170', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneTableScanColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #20
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestMergeFilters', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestMergeFilters#test], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.MergeFilters did not fire for:
        - Filter[filterPredicate = ("b" > 44)] => [a:bigint, b:bigint]
                Cost: {rows: 0, bytes: ?}
            - Filter[filterPredicate = ("a" < 42)] => [a:bigint, b:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [a:bigint, b:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:30:33 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@65969e87', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestMergeFilters], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #21
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestRemoveEmptyDelete', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestRemoveEmptyDelete#test], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.RemoveEmptyDelete did not fire for:
        - TableCommit[testConnector:com.facebook.presto.testing.TestingMetadata$TestingTableHandle@4ff61627] => [a:bigint]
            - RemoteExchange[GATHER] => a:bigint
                - Delete[testConnector:com.facebook.presto.testing.TestingMetadata$TestingTableHandle@4ff61627] => [a:bigint]
                    - Values => []
                            Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:31:29 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@76c78db2', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestRemoveEmptyDelete], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #22
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneFilterColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneFilterColumns#testNotAllInputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneFilterColumns did not fire for:
        - FilterProject[filterPredicate = ("b" > 5)] => [b:bigint]
                Cost: {rows: 0, bytes: ?}/{rows: 0, bytes: ?}
            - Values => [a:bigint, b:bigint]
                    Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:32:27 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@59fc88ab', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneFilterColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #23
location: FailureLocation{className='com.facebook.presto.sql.planner.iterative.rule.TestPruneJoinColumns', failingMethods=[com.facebook.presto.sql.planner.iterative.rule.TestPruneJoinColumns#testNotAllOutputsReferenced], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='com.facebook.presto.sql.planner.iterative.rule.PruneJoinColumns did not fire for:
        - Project[] => [rightValue:bigint]
                Cost: {rows: 0, bytes: ?}
            - InnerJoin[("leftKey" = "rightKey")] => [leftKey:bigint, leftValue:bigint, rightKey:bigint, rightValue:bigint]
                    Cost: {rows: 0, bytes: ?}
                - Values => [leftKey:bigint, leftValue:bigint]
                        Cost: {rows: 0, bytes: ?}
                - Values => [rightKey:bigint, rightValue:bigint]
                        Cost: {rows: 0, bytes: ?}
', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:33:24 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@260a3b48', projectTests=[com.facebook.presto.sql.planner.iterative.rule.TestPruneJoinColumns], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



nopolinfo #24
location: FailureLocation{className='com.facebook.presto.sql.planner.optimizations.TestUnionWithReplicatedJoin', failingMethods=[com.facebook.presto.sql.planner.optimizations.TestUnionWithReplicatedJoin#testUnionUnderTopN], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='There should be exactly one RemoteExchange expected [1] but found [2]', isError=false}], nbFailures=1, nbErrors=0}
status: NOPATCH
dateEnd: Tue Aug 08 17:34:20 CEST 2017
allocatedtime: 118minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/262238336/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@3a9567b8', projectTests=[com.facebook.presto.sql.planner.optimizations.TestUnionWithReplicatedJoin], complianceLevel=8, outputFolder=null, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



