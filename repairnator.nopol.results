nopolinfo #0
location: FailureLocation{className='com.facebook.presto.sql.planner.TestLogicalPlanner', failingMethods=[com.facebook.presto.sql.planner.TestLogicalPlanner#testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts, com.facebook.presto.sql.planner.TestLogicalPlanner#testDistinctLimitOverInequalityJoin, com.facebook.presto.sql.planner.TestLogicalPlanner#testInnerInequalityJoinNoEquiJoinConjuncts], erroringMethods=[], failures=[FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(DistinctLimitNode)
        - anyTree
            - node(FilterNode)
                FilterMatcher{predicate=("O_ORDERKEY" < "L_ORDERKEY")}
                - node(JoinNode)
                    JoinMatcher{equiCriteria=[]}
                    StrictSymbolsMatcher{exact outputs=[O_ORDERKEY, L_ORDERKEY]}
                    - node(TableScanNode)
                        TableScanMatcher{expectedTableName=orders}
                        bind O_ORDERKEY -> Column orders:orderkey
                    - node
                        - node(TableScanNode)
                            TableScanMatcher{expectedTableName=lineitem}
                            bind L_ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[orderkey] => [orderkey:bigint]
    - Project[] => [orderkey:bigint]
        - DistinctLimit[1][$hashvalue] => [orderkey:bigint, $hashvalue:bigint]
            - LocalExchange[SINGLE] () => orderkey:bigint, $hashvalue:bigint
                    Cost: {rows: 120350, bytes: ?}
                - Project[] => [orderkey:bigint, $hashvalue_8:bigint]
                        Cost: {rows: 120350, bytes: ?}
                        $hashvalue_8 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("orderkey"), 0))
                    - InnerJoin[("orderkey" < "orderkey_0")] => [orderkey:bigint]
                            SortExpression["orderkey_0"]
                            Cost: {rows: 120350, bytes: ?}
                        - TableScan[local:tpch:orders:sf0.01, originalConstraint = true] => [orderkey:bigint]
                                Cost: {rows: 15000, bytes: ?}
                                orderkey := tpch:orderkey
                        - LocalExchange[SINGLE] () => orderkey_0:bigint
                                Cost: {rows: 60175, bytes: ?}
                            - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey_0:bigint]
                                    Cost: {rows: 60175, bytes: ?}
                                    orderkey_0 := tpch:orderkey

] which resolves to [

- Output[orderkey] => [orderkey:bigint]
    - Project[] => [orderkey:bigint]
        - DistinctLimit[1][$hashvalue] => [orderkey:bigint, $hashvalue:bigint]
            - LocalExchange[SINGLE] () => orderkey:bigint, $hashvalue:bigint
                    Cost: {rows: 120350, bytes: ?}
                - Project[] => [orderkey:bigint, $hashvalue_8:bigint]
                        Cost: {rows: 120350, bytes: ?}
                        $hashvalue_8 := "combine_hash"(BIGINT '0', COALESCE("$operator$hash_code"("orderkey"), 0))
                    - InnerJoin[("orderkey" < "orderkey_0")] => [orderkey:bigint]
                            SortExpression["orderkey_0"]
                            Cost: {rows: 120350, bytes: ?}
                        - TableScan[local:tpch:orders:sf0.01, originalConstraint = true] => [orderkey:bigint]
                                Cost: {rows: 15000, bytes: ?}
                                orderkey := tpch:orderkey
                        - LocalExchange[SINGLE] () => orderkey_0:bigint
                                Cost: {rows: 60175, bytes: ?}
                            - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey_0:bigint]
                                    Cost: {rows: 60175, bytes: ?}
                                    orderkey_0 := tpch:orderkey

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(FilterNode)
        FilterMatcher{predicate=("O_ORDERKEY" < "L_ORDERKEY")}
        - node(JoinNode)
            JoinMatcher{equiCriteria=[]}
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=orders}
                bind O_ORDERKEY -> Column orders:orderkey
            - node
                - node(TableScanNode)
                    TableScanMatcher{expectedTableName=lineitem}
                    bind L_ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[_col0] => [expr_4:integer]
        Cost: {rows: 120350, bytes: ?}
        _col0 := expr_4
    - Project[] => [expr_4:integer]
            Cost: {rows: 120350, bytes: ?}
            expr_4 := 1
        - InnerJoin[("orderkey" < "orderkey_0")] => []
                SortExpression["orderkey_0"]
                Cost: {rows: 120350, bytes: ?}
            - TableScan[local:tpch:orders:sf0.01, originalConstraint = true] => [orderkey:bigint]
                    Cost: {rows: 15000, bytes: ?}
                    orderkey := tpch:orderkey
            - LocalExchange[SINGLE] () => orderkey_0:bigint
                    Cost: {rows: 60175, bytes: ?}
                - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey_0:bigint]
                        Cost: {rows: 60175, bytes: ?}
                        orderkey_0 := tpch:orderkey

] which resolves to [

- Output[_col0] => [expr_4:integer]
        Cost: {rows: 120350, bytes: ?}
        _col0 := expr_4
    - Project[] => [expr_4:integer]
            Cost: {rows: 120350, bytes: ?}
            expr_4 := 1
        - InnerJoin[("orderkey" < "orderkey_0")] => []
                SortExpression["orderkey_0"]
                Cost: {rows: 120350, bytes: ?}
            - TableScan[local:tpch:orders:sf0.01, originalConstraint = true] => [orderkey:bigint]
                    Cost: {rows: 15000, bytes: ?}
                    orderkey := tpch:orderkey
            - LocalExchange[SINGLE] () => orderkey_0:bigint
                    Cost: {rows: 60175, bytes: ?}
                - TableScan[local:tpch:lineitem:sf0.01, originalConstraint = true] => [orderkey_0:bigint]
                        Cost: {rows: 60175, bytes: ?}
                        orderkey_0 := tpch:orderkey

]', isError=false}, FailureType{failureName='java.lang.AssertionError', failureDetail='Plan does not match, expected [

- anyTree
    - node(FilterNode)
        FilterMatcher{predicate=("O_ORDERKEY" < "L_ORDERKEY")}
        - node(JoinNode)
            JoinMatcher{equiCriteria=[]}
            - node(TableScanNode)
                TableScanMatcher{expectedTableName=orders}
                bind O_ORDERKEY -> Column orders:orderkey
            - node
                - node(FilterNode)
                    FilterMatcher{predicate=(NOT ("L_ORDERKEY" IS NULL))}
                    - node(TableScanNode)
                        TableScanMatcher{expectedTableName=lineitem}
                        bind L_ORDERKEY -> Column lineitem:orderkey

] but found [

- Output[_col0] => [expr:integer]
        Cost: {rows: 60175, bytes: ?}
        _col0 := expr
    - Project[] => [expr:integer]
            Cost: {rows: 60175, bytes: ?}
            expr := 1
        - InnerJoin[("orderkey" < "orderkey_0")] => []
                SortExpression["orderkey_0"]
                Cost: {rows: 60175, bytes: ?}
            - TableScan[local:tpch:orders:sf0.01, originalConstraint = true] => [orderkey:bigint]
                    Cost: {rows: 15000, bytes: ?}
                    orderkey := tpch:orderkey
            - LocalExchange[SINGLE] () => orderkey_0:bigint
                    Cost: {rows: 30087, bytes: ?}
                - ScanFilter[table = local:tpch:lineitem:sf0.01, originalConstraint = (NOT ("orderkey_0" IS NULL)), filterPredicate = (NOT ("orderkey_0" IS NULL))] => [orderkey_0:bigint]
                        Cost: {rows: 60175, bytes: ?}/{rows: 30087, bytes: ?}
                        orderkey_0 := tpch:orderkey

] which resolves to [

- Output[_col0] => [expr:integer]
        Cost: {rows: 60175, bytes: ?}
        _col0 := expr
    - Project[] => [expr:integer]
            Cost: {rows: 60175, bytes: ?}
            expr := 1
        - InnerJoin[("orderkey" < "orderkey_0")] => []
                SortExpression["orderkey_0"]
                Cost: {rows: 60175, bytes: ?}
            - TableScan[local:tpch:orders:sf0.01, originalConstraint = true] => [orderkey:bigint]
                    Cost: {rows: 15000, bytes: ?}
                    orderkey := tpch:orderkey
            - LocalExchange[SINGLE] () => orderkey_0:bigint
                    Cost: {rows: 30087, bytes: ?}
                - ScanFilter[table = local:tpch:lineitem:sf0.01, originalConstraint = (NOT ("orderkey_0" IS NULL)), filterPredicate = (NOT ("orderkey_0" IS NULL))] => [orderkey_0:bigint]
                        Cost: {rows: 60175, bytes: ?}/{rows: 30087, bytes: ?}
                        orderkey_0 := tpch:orderkey

]', isError=false}], nbFailures=3, nbErrors=0}
status: NOPATCH
dateEnd: Tue Dec 05 05:41:19 CET 2017
allocatedtime: 120minutes 
passingTime: 0minutes 
nb patches: 0
nopol context: Config{synthesisDepth=3, collectStaticMethods=true, collectStaticFields=false, collectLiterals=false, onlyOneSynthesisResult=false, sortExpressions=true, maxLineInvocationPerTest=250, timeoutMethodInvocation=2000, dataCollectionTimeoutInSecondForSynthesis=900, addWeight=0.19478, subWeight=0.04554, mulWeight=0.0102, divWeight=0.00613, andWeight=0.10597, orWeight=0.05708, eqWeight=0.22798, nEqWeight=0.0, lessEqWeight=0.0255, lessWeight=0.0947, methodCallWeight=0.1, fieldAccessWeight=0.08099, constantWeight=0.14232, variableWeight=0.05195, mode=REPAIR, type=COND_THEN_PRE, synthesis=DYNAMOTH, oracle=ANGELIC, solver=Z3, solverPath='./z3_for_linux', projectSources=[/root/workspace/prestodb/presto/311642597/presto-main/src/main/java], projectClasspath='[Ljava.net.URL;@1b1d094a', projectTests=[com.facebook.presto.sql.planner.TestLogicalPlanner], complianceLevel=8, outputFolder=./, json=false}
exception: null
nbStatements: 0
nbAngelicValues: 0
ignoreStatus: NOTHING_TO_IGNORE
----------



