/**
 * Copyright (C) 2006-2017 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
package spoon.pattern;

import java.util.List;
import java.util.Map;

import spoon.pattern.matcher.Match;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtPackage;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeMember;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.chain.CtConsumer;
import spoon.template.TemplateMatcher;

/**
 * Represents a patter. It means an AST model, where some parts of that model are substituted by pattern parameters.
 * The {@link Pattern} can be used to process these two "itself opposite" operations
 * <ul>
 * <li>Generation of code from pattern. It means (Pattern) + (pattern parameters) => (copy of pattern where parameters are replaced by parameter values)
 * <li>Matching of code by pattern. It means (Pattern) + (code fitting to pattern) => (pattern parameters)
 * </ul>
 * Note: that code generated by pattern using some set of parameters ParamsA, matches with the same pattern and produces same set of ParametersA
 */
public class Pattern {
	private ModelValueResolver modelValueResolver;

	Pattern(ModelValueResolver modelValueResolver) {
		this.modelValueResolver = modelValueResolver;
	}

	/**
	 * @return a {@link ModelValueResolver} of this pattern
	 */
	public ModelValueResolver getModelValueResolver() {
		return modelValueResolver;
	}

	/**
	 * generates a new AST made by cloning of `patternModel` and by substitution of parameters by values in `params`
	 * @param valueType - the expected type of returned items
	 * @param params - the substitution parameters
	 * @return one generated element
	 */
	public <T extends CtElement> T substituteSingle(Class<T> valueType, Map<String, Object> params) {
		ResultHolder.Single<T> result = new ResultHolder.Single<>(valueType);
		modelValueResolver.resolveValues((ResultHolder.Single) result, PatternUtils.toParameterValueProvider(params));
		return result.getResult();
	}
	/**
	 * generates a new AST made by cloning of `patternModel` and by substitution of parameters by values in `params`
	 * @param valueType - the expected type of returned items
	 * @param params - the substitution parameters
	 * @return List of generated elements
	 */
	public <T extends CtElement> List<T> substituteList(Class<T> valueType, Map<String, Object> params) {
		ResultHolder.Multiple<T> result = new ResultHolder.Multiple<>(valueType);
		modelValueResolver.resolveValues((ResultHolder.Multiple) result, PatternUtils.toParameterValueProvider(params));
		return result.getResult();
	}


	/**
	 * Generates type with qualified name `typeQualifiedName` using this {@link Pattern} and provided `params`.
	 *
	 * Note: the root of pattern element must be one or more types.
	 *
	 * @param typeQualifiedName the qualified name of to be generated type
	 * @param params the pattern parameters
	 * @return the generated type
	 */
	public <T extends CtType<?>> T createType(String typeQualifiedName, Map<String, Object> params) {
		return createType(getFactory().Type().createReference(typeQualifiedName), params);
	}

	/**
	 * Generates type following `newTypeRef` using this {@link Pattern} and provided `params`
	 *
	 * Note: the root of pattern element must be one or more types.
	 *
	 * @param newTypeRef the type reference which refers to future generated type
	 * @param params the pattern parameters
	 * @return the generated type
	 */
	public <T extends CtType<?>> T createType(CtTypeReference<?> newTypeRef, Map<String, Object> params) {
		CtPackage ownerPackage = getFactory().Package().getOrCreate(newTypeRef.getPackage().getQualifiedName());
		return createType(ownerPackage, newTypeRef.getSimpleName(), params);
	}

	/**
	 * Generates type in the package `ownerPackage` with simple name `typeSimpleName` using this {@link Pattern} and provided `params`
	 *
	 * Note: the root of pattern element must be one or more types.
	 *
	 * @param ownerPackage the target package
	 * @param typeSimpleName the simple name of future generated type
	 * @param params the pattern parameters
	 * @return the generated type
	 */
	@SuppressWarnings("unchecked")
	public <T extends CtType<?>> T createType(CtPackage ownerPackage, String typeSimpleName, Map<String, Object> params) {
		@SuppressWarnings({ "rawtypes" })
		List<CtType> types = substituteList(CtType.class, new UnmodifiableParameterValueProvider(params,
				PatternBuilder.TARGET_TYPE, getFactory().Type().createReference(getQualifiedName(ownerPackage, typeSimpleName))));
		T result = null;
		for (CtType<?> type : types) {
			ownerPackage.addType(type);
			if (type.getSimpleName().equals(typeSimpleName)) {
				result = (T) type;
			}
		}
		return result;
	}

	/**
	 * generates elements following this template with expected target scope `targetType`
	 * If they are {@link CtTypeMember} then adds them into `targetType`.
	 *
	 * @param targetType the existing type, which will contain newly generates {@link CtElement}s
	 * @param valueType the type of generated elements
	 * @param params the pattern parameters
	 * @return List of generated elements
	 */
	public <T extends CtElement> List<T> applyToType(CtType<?> targetType, Class<T> valueType,  Map<String, Object> params) {
		List<T> results = substituteList(valueType, new UnmodifiableParameterValueProvider(params, PatternBuilder.TARGET_TYPE, targetType.getReference()));
		for (T result : results) {
			if (result instanceof CtTypeMember) {
				targetType.addTypeMember((CtTypeMember) result);
			}
		}
		return results;
	}

	/**
	 * Finds all target program sub-trees that correspond to a template
	 * and calls consumer.accept(matchingElement, parameterValues)
	 * @param rootElement the root of to be searched AST
	 * @param consumer the receiver of matches
	 */
	public void forEachMatch(CtElement rootElement, CtConsumer<Match> consumer) {
		new TemplateMatcher(this).forEachMatch(rootElement, consumer);
	}

	@Override
	public String toString() {
		return modelValueResolver.toString();
	}

	private Factory getFactory() {
		return modelValueResolver.getFactory();
	}

	private static String getQualifiedName(CtPackage pckg, String simpleName) {
		if (pckg.isUnnamedPackage()) {
			return simpleName;
		}
		return pckg.getQualifiedName() + CtPackage.PACKAGE_SEPARATOR + simpleName;
	}
}
