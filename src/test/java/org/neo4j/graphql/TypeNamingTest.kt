package org.neo4j.graphql

import org.junit.After
import org.junit.Before
import org.junit.Ignore
import org.junit.Test
import org.neo4j.graphdb.GraphDatabaseService
import org.neo4j.kernel.impl.proc.Procedures
import org.neo4j.kernel.internal.GraphDatabaseAPI
import org.neo4j.test.TestGraphDatabaseFactory
import kotlin.test.assertEquals

/**
 * @author mh
 * *
 * @since 05.05.17
 */
class TypeNamingTest {
    private var db: GraphDatabaseService? = null

    @Before
    @Throws(Exception::class)
    fun setUp() {
        db = TestGraphDatabaseFactory().newImpermanentDatabase()
        (db as GraphDatabaseAPI).dependencyResolver.resolveDependency(Procedures::class.java).let {
            it.registerFunction(GraphQLProcedure::class.java)
            it.registerProcedure(GraphQLProcedure::class.java)
        }
//        db?.execute("CREATE (:Person {name:'Jane'})-[:KNOWS]->(:Person {name:'John'})")?.close()
    }

    @After
    @Throws(Exception::class)
    fun tearDown() {
        db?.shutdown()
    }

    @Test @Ignore("Bug introduce BOTH relationship handling for generated graphs, esp in mergeRelationships")
    fun duplicatePropertyRelationshipBoth() {
        db?.execute("CREATE (:Person {name:'Jane'})-[:KNOWS]->(:Person {name:'John'})")?.close()
        val graphQL = GraphSchema.getGraphQL(db!!)

        val query = """query { Person { name, _knows { name } } }"""
        val result = graphQL.execute(query, GraphQLContext(db!!))
        assertEquals(mapOf("Person" to listOf(mapOf("name" to "Jane", "_knows" to listOf(mapOf("name" to "John"))), mapOf("name" to "John", "_knows" to emptyList<Map<String,Any>>()))), result.getData())
    }
    @Test
    fun duplicatePropertyRelationship() {
        db?.execute("CREATE (:Person {knows:'Jane'})-[:knows]->(:Friend {name:'John'}),(:Person {knows:'Alex'})")?.close()
        val graphQL = GraphSchema.getGraphQL(db!!)

        val query = """query { Person { knows, _knows { name } } }"""
        val result = graphQL.execute(query, GraphQLContext(db!!))
        assertEquals(mapOf("Person" to listOf(mapOf("knows" to "Jane", "_knows" to mapOf("name" to "John")), mapOf("knows" to "Alex", "_knows" to null))), result.getData())
    }

    @Test
    fun dynamicQueryTypeAccessAttributes() {
        val schema = """
type Order {
    sid: ID!
    name: String
    description: String
    date: Int
    position: [OrderPosition] @relation(name:"PART_OF",direction:"IN")
}

type OrderPosition {
    amount: Int
    order: Order @relation(name:"PART_OF")
    sid: ID!
}

schema {
   mutation: MutationType
   query: QueryType
}
type MutationType {
    setOrderPositionAmount(sid:ID!, amount:Int) : [OrderPosition] @cypher(statement:"MATCH (op:OrderPosition {sid:{sid}}) SET op.amount = {amount} RETURN op")

}

type QueryType {
    getOrderPosition(sid:ID!) : [OrderPosition] @cypher(statement:"MATCH (op:OrderPosition {sid: {sid}}) RETURN op")
}"""

        GraphSchemaScanner.storeIdl(db!!, schema)
        val graphQL = GraphSchema.getGraphQL(db!!)
        val query = """query { OrderPosition { amount } }"""
        val result = graphQL.execute(query, GraphQLContext(db!!))
        assertEquals(mapOf("OrderPosition" to emptyList<Long>()), result.getData())
    }
    @Test
    fun dynamicMutationConflictsWithAutoGenerated() {
        val schema = """
type Person {
    name: String
}
schema {
   mutation: MutationType
}
type MutationType {
    createPerson(name:String) : Person @cypher(statement:"CREATE (p:Person {name:\"Test\"+{name}}) RETURN p")
}
"""

        GraphSchemaScanner.storeIdl(db!!, schema)
        val graphQL = GraphSchema.getGraphQL(db!!)
        val query = """mutation { createPerson(name:"Jane") {name} }"""
        val result = graphQL.execute(query, GraphQLContext(db!!))
        assertEquals(mapOf("createPerson" to mapOf("name" to "TestJane")), result.getData())
    }
    @Test
    fun dynamicQueryConflictsWithAutoGenerated() {
        db?.execute("CREATE (:Person {name:'Jane'}), (:Person {name:'John'})")?.close()
        val schema = """
type Person {
    name: String
}
schema {
   query: QueryType
}
type QueryType {
    Person(name:String) : Person @cypher(statement:"MATCH (p:Person {name:{name}}) RETURN p")
}
"""

        GraphSchemaScanner.storeIdl(db!!, schema)
        val graphQL = GraphSchema.getGraphQL(db!!)
        val query = """query { Person(name:"Jane") {name} }"""
        val result = graphQL.execute(query, GraphQLContext(db!!))
        println(result)
        assertEquals(mapOf("Person" to mapOf("name" to "Jane")), result.getData())
    }
}
