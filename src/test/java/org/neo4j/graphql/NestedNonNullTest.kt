package org.neo4j.graphql

import org.junit.After
import org.junit.Before
import org.junit.Test
import org.neo4j.graphdb.GraphDatabaseService
import org.neo4j.kernel.impl.proc.Procedures
import org.neo4j.kernel.internal.GraphDatabaseAPI
import org.neo4j.test.TestGraphDatabaseFactory
import kotlin.test.assertEquals

/**
 * @author mh
 * *
 * @since 05.05.17
 */
class NestedNonNullTest {
    private var db: GraphDatabaseService? = null

    @Before
    @Throws(Exception::class)
    fun setUp() {
        db = TestGraphDatabaseFactory().newImpermanentDatabase()
        (db as GraphDatabaseAPI).dependencyResolver.resolveDependency(Procedures::class.java).let {
            it.registerFunction(GraphQLProcedure::class.java)
            it.registerProcedure(GraphQLProcedure::class.java)
        }
        db?.execute("CREATE (:Person {name:'Jane'})-[:WORKS_AT]->(:Company {name:'ACME'})")?.close()
    }

    @After
    @Throws(Exception::class)
    fun tearDown() {
        db?.shutdown()
    }

    @Test
    fun dynamicMutationConflictsWithAutoGenerated() {
        val schema = """
type Person {
    name: String
    company: Company @relation(name:"WORKS_AT")
    company2: Company! @relation(name:"WORKS_AT")
    companies: [Company]! @relation(name:"WORKS_AT")
    companies2: [Company!]! @relation(name:"WORKS_AT")
}
type Company {
    name: String
}
"""

        val ctx = GraphQLContext(db!!)
        GraphSchemaScanner.storeIdl(db!!, schema)
        val graphQL = GraphSchema.getGraphQL(db!!)

        fun assertResult(query:String, expected:Any) {
            val result = graphQL.execute(query, ctx)
            if (result.errors.isNotEmpty()) println(result.errors)
            assertEquals(expected, result.getData())
        }

        assertResult("""{ p: Person { company(name: "ACME") { name } } }""",
                mapOf("p" to listOf(mapOf("company" to mapOf("name" to "ACME")))))

        assertResult("""{ p: Person { company2(name: "ACME") { name } } }""",
                mapOf("p" to listOf(mapOf("company2" to mapOf("name" to "ACME")))))

        assertResult("""{ p: Person { companies(name: "ACME") { name } } }""",
                mapOf("p" to listOf(mapOf("companies" to listOf(mapOf("name" to "ACME"))))))

        assertResult("""{ p: Person { companies2(name: "ACME") { name } } }""",
                mapOf("p" to listOf(mapOf("companies2" to listOf(mapOf("name" to "ACME"))))))

        assertResult("""{ p: Person { company(name: "ACME2") { name } } }""",
                mapOf("p" to listOf(mapOf("company" to null))))

        assertResult("""{ p: Person { companies(name: "ACME2") { name } } }""",
                mapOf("p" to listOf(mapOf("companies" to emptyList<Map<String,Any>>()))))

        assertResult("""{ p: Person { companies2(name: "ACME2") { name } } }""",
                mapOf("p" to listOf(mapOf("companies2" to emptyList<Map<String,Any>>()))))

        // errors on non-null fields are propagated up to the first nullable field
        // and an error message is added
        assertResult("""{ p: Person { name, company2(name: "ACME2") { name } } }""",
                mapOf("p" to listOf(null)))

    }
}
