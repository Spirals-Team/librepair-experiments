#####################################################################################################
#
# This file is for reference only, changes have no effect on the generated interface implementations.
#
#####################################################################################################

# Id: 1
# Message: Unable to find a default identifier bridge implementation for type '%1$s'
# @param 1: sourceType - 
unableToResolveDefaultIdentifierBridgeFromSourceType=Unable to find a default identifier bridge implementation for type '%1$s'
# Id: 2
# Message: Unable to find a default value bridge implementation for type '%1$s'
# @param 1: sourceType - 
unableToResolveDefaultValueBridgeFromSourceType=Unable to find a default value bridge implementation for type '%1$s'
# Id: 3
# Message: Annotation type '%1$s' is annotated with @PropertyBridgeMapping, but the bridge builder reference is empty.
# @param 1: annotationType - 
missingBuilderReferenceInBridgeMapping=Annotation type '%1$s' is annotated with @PropertyBridgeMapping, but the bridge builder reference is empty.
# Id: 4
# Message: Annotation type '%1$s' is annotated with @MarkerMapping, but the marker builder reference is empty.
# @param 1: annotationType - 
missingBuilderReferenceInMarkerMapping=Annotation type '%1$s' is annotated with @MarkerMapping, but the marker builder reference is empty.
# Id: 5
# Message: Annotation @Field on property '%1$s' defines both valueBridge and valueBridgeBuilder. Only one of those can be defined, not both.
# @param 1: property - 
invalidFieldDefiningBothBridgeReferenceAndBridgeBuilderReference=Annotation @Field on property '%1$s' defines both valueBridge and valueBridgeBuilder. Only one of those can be defined, not both.
# Id: 6
# Message: Annotation @DocumentId on property '%1$s' defines both identifierBridge and identifierBridgeBuilder. Only one of those can be defined, not both.
# @param 1: property - 
invalidDocumentIdDefiningBothBridgeReferenceAndBridgeBuilderReference=Annotation @DocumentId on property '%1$s' defines both identifierBridge and identifierBridgeBuilder. Only one of those can be defined, not both.
# Id: 7
# Message: Cannot query on an empty target. If you want to target all indexes, put Object.class in the collection of target types, or use the method of the same name, but without Class<?> parameters.
cannotSearchOnEmptyTarget=Cannot query on an empty target. If you want to target all indexes, put Object.class in the collection of target types, or use the method of the same name, but without Class<?> parameters.
# Id: 8
# Message: Could not auto-detect the input type for value bridge %1$s; make sure the bridge uses generics.
# @param 1: bridge - 
unableToInferValueBridgeInputType=Could not auto-detect the input type for value bridge %1$s; make sure the bridge uses generics.
# Id: 9
# Message: Could not auto-detect the return type for value bridge %1$s; make sure the bridge uses generics or configure the field explicitly in the bridge's bind() method.
# @param 1: bridge - 
unableToInferValueBridgeIndexFieldType=Could not auto-detect the return type for value bridge %1$s; make sure the bridge uses generics or configure the field explicitly in the bridge's bind() method.
# Id: 10
# Message: Value bridge %1$s cannot be applied to input type %2$s.
# @param 1: bridge - 
# @param 2: typeModel - 
invalidInputTypeForValueBridge=Value bridge %1$s cannot be applied to input type %2$s.
# Id: 11
# Message: Missing field name for GeoPointBridge on type %1$s. The field name is mandatory when the bridge is applied on an type, optional when applied on a property.
# @param 1: typeName - 
missingFieldNameForGeoPointBridgeOnType=Missing field name for GeoPointBridge on type %1$s. The field name is mandatory when the bridge is applied on an type, optional when applied on a property.
# Id: 12
# Message: Requested type argument %3$s to type %2$s in implementing type %1$s, but %2$s doesn't declare any type parameter
# @param 1: type - 
# @param 2: rawSuperType - 
# @param 3: typeArgumentIndex - 
cannotRequestTypeParameterOfUnparameterizedType=Requested type argument %3$s to type %2$s in implementing type %1$s, but %2$s doesn't declare any type parameter
# Id: 13
# Message: Requested type argument %3$s to type %2$s in implementing type %1$s, but %2$s only declares %4$s type parameter(s)
# @param 1: type - 
# @param 2: rawSuperType - 
# @param 3: typeArgumentIndex - 
# @param 4: typeParametersLength - 
typeParameterIndexOutOfBound=Requested type argument %3$s to type %2$s in implementing type %1$s, but %2$s only declares %4$s type parameter(s)
# Id: 14
# Message: Requested type argument index %3$s to type %2$s in implementing type %1$s should be 0 or greater
# @param 1: type - 
# @param 2: rawSuperType - 
# @param 3: typeArgumentIndex - 
invalidTypeParameterIndex=Requested type argument index %3$s to type %2$s in implementing type %1$s should be 0 or greater
# Id: 15
# Message: Could not interpret the type arguments to the ContainerValueExtractor interface in  implementation '%1$s'. Only the following implementations of ContainerValueExtractor are valid:  1) implementations setting both type parameters to *raw* types, e.g. class MyExtractor implements ContainerValueExtractor<MyBean, String>; 2) implementations setting the first type parameter to an array of an unbounded type variable, and setting the second parameter to the same type variable, e.g. MyExtractor<T> implements ContainerValueExtractor<T[], T> 3) implementations setting the first type parameter to a parameterized type with one argument set to an unbounded type variable and the other to unbounded wildcards, and setting the second type parameter to the same type variable, e.g. MyExtractor<T> implements ContainerValueExtractor<MyParameterizedBean<?, T, ?>, T>
# @param 1: extractorClass - 
couldNotInferContainerValueExtractorClassTypePattern=Could not interpret the type arguments to the ContainerValueExtractor interface in  implementation '%1$s'. Only the following implementations of ContainerValueExtractor are valid:  1) implementations setting both type parameters to *raw* types, e.g. class MyExtractor implements ContainerValueExtractor<MyBean, String>; 2) implementations setting the first type parameter to an array of an unbounded type variable, and setting the second parameter to the same type variable, e.g. MyExtractor<T> implements ContainerValueExtractor<T[], T> 3) implementations setting the first type parameter to a parameterized type with one argument set to an unbounded type variable and the other to unbounded wildcards, and setting the second type parameter to the same type variable, e.g. MyExtractor<T> implements ContainerValueExtractor<MyParameterizedBean<?, T, ?>, T>
# Id: 16
# Message: Could not apply the requested container value extractor '%1$s' to type '%2$s'
# @param 1: extractorClass - 
# @param 2: extractedType - 
invalidContainerValueExtractorForType=Could not apply the requested container value extractor '%1$s' to type '%2$s'
# Id: 17
# Level: org.jboss.logging.Logger.Level.DEBUG
# Message: Created POJO indexed type manager: %1$s
# @param 1: typeManager - 
createdPojoIndexedTypeManager=Created POJO indexed type manager: %1$s
# Id: 18
# Level: org.jboss.logging.Logger.Level.DEBUG
# Message: Detected entity types: %1$s
# @param 1: entityTypes - 
detectedEntityTypes=Detected entity types: %1$s
# Id: 19
# Level: org.jboss.logging.Logger.Level.DEBUG
# Message: Created POJO contained type manager: %1$s
# @param 1: typeManager - 
createdPojoContainedTypeManager=Created POJO contained type manager: %1$s
# Id: 20
# Message: Could not find the inverse side of the association '%3$s' from type '%2$s' on type '%1$s'
# @param 1: inverseSideTypeModel - 
# @param 2: typeModel - 
# @param 3: associationPath - 
cannotInvertAssociation=Could not find the inverse side of the association '%3$s' from type '%2$s' on type '%1$s'
# Id: 21
# Message: Could not apply the path of the inverse association '%2$s' to type '%1$s'. Association on the original side (which was inverted) was '%4$s' on type '%3$s'. Error was: '%5$s'
# @param 1: inverseSideTypeModel - 
# @param 2: inverseSideAssociationPath - 
# @param 3: originalSideTypeModel - 
# @param 4: originalSideAssociationPath - 
# @param 5: errorMessage - 
cannotApplyInvertAssociationPath=Could not apply the path of the inverse association '%2$s' to type '%1$s'. Association on the original side (which was inverted) was '%4$s' on type '%3$s'. Error was: '%5$s'
# Id: 22
# Message: The inverse association targets type '%1$s', but a supertype or subtype of '%2$s' was expected.
# @param 1: inverseAssociationTargetType - 
# @param 2: entityType - 
incorrectTargetTypeForInverseAssociation=The inverse association targets type '%1$s', but a supertype or subtype of '%2$s' was expected.
# Id: 23
# Message: Property '%2$s' from type '%1$s' is annotated with @AnnotationInverseSide, but the inverse path is empty.
# @param 1: typeModel - 
# @param 2: propertyName - 
missingInversePathInAssociationInverseSideMapping=Property '%2$s' from type '%1$s' is annotated with @AnnotationInverseSide, but the inverse path is empty.
# Id: 24
# Message: Found an infinite embedded recursion involving path '%2$s' on type '%1$s'
# @param 1: typeModel - 
# @param 2: path - 
infiniteRecursionForAssociationEmbeddeds=Found an infinite embedded recursion involving path '%2$s' on type '%1$s'
# Id: 25
# Level: org.jboss.logging.Logger.Level.INFO
# Message: Cannot access the value of containing annotation '%1$s'. Ignoring annotation.
# @param 1: containingAnnotationType - 
cannotAccessRepeateableContainingAnnotationValue=Cannot access the value of containing annotation '%1$s'. Ignoring annotation.
