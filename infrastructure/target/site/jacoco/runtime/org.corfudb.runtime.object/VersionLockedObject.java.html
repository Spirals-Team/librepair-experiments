<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>VersionLockedObject.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">infrastructure</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.object</a> &gt; <span class="el_source">VersionLockedObject.java</span></div><h1>VersionLockedObject.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.object;

import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.StampedLock;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.logprotocol.SMREntry;
import org.corfudb.runtime.exceptions.NoRollbackException;
import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;
import org.corfudb.runtime.object.transactions.WriteSetSMRStream;
import org.corfudb.runtime.view.Address;
import org.corfudb.util.Utils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

//TODO Discard TransactionStream for building maps but not for constructing tails

/**
 * The VersionLockedObject maintains a versioned object which is
 * backed by an ISMRStream, and is optionally backed by an additional
 * optimistic update stream.
 *
 * &lt;p&gt;Users of the VersionLockedObject cannot access the versioned object
 * directly, rather they use the access() and update() methods to
 * read and manipulate the object.
 *
 * &lt;p&gt;access() and update() allow the user to provide functions to execute
 * under locks. These functions execute various &quot;unsafe&quot; methods provided
 * by this object which inspect and manipulate the object state.
 *
 * &lt;p&gt;syncObjectUnsafe() enables the user to bring the object to a given version,
 * and the VersionLockedObject manages any sync or rollback of updates
 * necessary.
 *
 * &lt;p&gt;Created by mwei on 11/13/16.
 */
<span class="nc" id="L46">@Slf4j</span>
public class VersionLockedObject&lt;T&gt; {

    /**
     * The actual underlying object.
     */
    T object;

    /**
     * A list of upcalls pending in the system. The proxy keeps this
     * set so it can remember to save the upcalls for pending requests.
     */
    final Set&lt;Long&gt; pendingUpcalls;

    // This enum is necessary because null cannot be inserted
    // into a ConcurrentHashMap.
<span class="nc" id="L62">    enum NullValue {</span>
<span class="nc" id="L63">        NULL_VALUE</span>
    }

    /**
     * A list of upcall results, keyed by the address they were
     * requested.
     */
    final Map&lt;Long, Object&gt; upcallResults;


    /**
     * A lock, which controls access to modifications to
     * the object. Any access to unsafe methods should
     * obtain the lock.
     */
    private final StampedLock lock;

    /**
     * The stream view this object is backed by.
     */
    private final ISMRStream smrStream;

    /**
     * The optimistic SMR stream on this object, if any.
     */
    private WriteSetSMRStream optimisticStream;

    /**
     * The upcall map for this object.
     */
    private final Map&lt;String, ICorfuSMRUpcallTarget&lt;T&gt;&gt; upcallTargetMap;

    /**
     * The undo record function map for this object.
     */
    private final Map&lt;String, IUndoRecordFunction&lt;T&gt;&gt; undoRecordFunctionMap;

    /**
     * The undo target map for this object.
     */
    private final Map&lt;String, IUndoFunction&lt;T&gt;&gt; undoFunctionMap;

    /**
     * The reset set for this object.
     */
    private final Set&lt;String&gt; resetSet;

    /**
     * A function that generates a new instance of this object.
     */
    private final Supplier&lt;T&gt; newObjectFn;

    /**
     * Correctness Logging
     */
<span class="nc" id="L118">    private final Logger correctnessLogger = LoggerFactory.getLogger(&quot;correctness&quot;);</span>

    /**
     * The VersionLockedObject maintains a versioned object which is backed by an ISMRStream,
     * and is optionally backed by an additional optimistic update stream.
     *
     * @param newObjectFn       A function passed to instantiate a new instance of this object.
     * @param smrStream         Stream View backing this object.
     * @param upcallTargets     UpCall map for this object.
     * @param undoRecordTargets Undo record function map for this object.
     * @param undoTargets       Undo functions map.
     * @param resetSet          Reset set for this object.
     */
    public VersionLockedObject(Supplier&lt;T&gt; newObjectFn,
                               StreamViewSMRAdapter smrStream,
                               Map&lt;String, ICorfuSMRUpcallTarget&lt;T&gt;&gt; upcallTargets,
                               Map&lt;String, IUndoRecordFunction&lt;T&gt;&gt; undoRecordTargets,
                               Map&lt;String, IUndoFunction&lt;T&gt;&gt; undoTargets,
<span class="nc" id="L136">                               Set&lt;String&gt; resetSet) {</span>
<span class="nc" id="L137">        this.smrStream = smrStream;</span>

<span class="nc" id="L139">        this.upcallTargetMap = upcallTargets;</span>
<span class="nc" id="L140">        this.undoRecordFunctionMap = undoRecordTargets;</span>
<span class="nc" id="L141">        this.undoFunctionMap = undoTargets;</span>
<span class="nc" id="L142">        this.resetSet = resetSet;</span>

<span class="nc" id="L144">        this.newObjectFn = newObjectFn;</span>
<span class="nc" id="L145">        this.object = newObjectFn.get();</span>
<span class="nc" id="L146">        this.pendingUpcalls = ConcurrentHashMap.newKeySet();</span>
<span class="nc" id="L147">        this.upcallResults = new ConcurrentHashMap&lt;&gt;();</span>

<span class="nc" id="L149">        lock = new StampedLock();</span>
<span class="nc" id="L150">    }</span>

    /**
     * Access the internal state of the object, trying first to optimistically access
     * the object, then obtaining a write lock the optimistic access fails.
     *
     * &lt;p&gt;If the directAccessCheckFunction returns true, then we execute the accessFunction
     * without running updateFunction. If false, we execute the updateFunction to
     * allow the user to modify the state of the object before calling accessFunction.
     *
     * &lt;p&gt;directAccessCheckFunction is executed under an optimistic read lock. Read-only
     * unsafe operations are permitted.
     *
     * &lt;p&gt;updateFunction is executed under a write lock. Both read and write unsafe operations
     * are permitted.
     *
     * &lt;p&gt;accessFunction is accessed either under a read lock or write lock depending on
     * whether an update was necessary or not.
     *
     * @param directAccessCheckFunction A function which returns True if the object can be
     *                                  accessed without being updated.
     * @param updateFunction            A function which is executed when direct access
     *                                  is not allowed and the object must be updated.
     * @param accessFunction            A function which allows the user to directly access
     *                                  the object while locked in the state enforced by
     *                                  either the directAccessCheckFunction or updateFunction.
     * @param &lt;R&gt;                       The type of the access function return.
     * @return Returns the access function.
     */
    public &lt;R&gt; R access(Function&lt;VersionLockedObject&lt;T&gt;, Boolean&gt; directAccessCheckFunction,
                        Consumer&lt;VersionLockedObject&lt;T&gt;&gt; updateFunction,
                        Function&lt;T, R&gt; accessFunction) {
        // First, we try to do an optimistic read on the object, in case it
        // meets the conditions for direct access.
<span class="nc" id="L184">        long ts = lock.tryOptimisticRead();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (ts != 0) {</span>
            try {
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (directAccessCheckFunction.apply(this)) {</span>
<span class="nc" id="L188">                log.trace(&quot;Access [{}] Direct (optimistic-read) access at {}&quot;,</span>
<span class="nc" id="L189">                        this, getVersionUnsafe());</span>
<span class="nc" id="L190">                    R ret = accessFunction.apply(object);</span>

<span class="nc" id="L192">                    long versionForCorrectness = getVersionUnsafe();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    if (lock.validate(ts)) {</span>
<span class="nc" id="L194">                        correctnessLogger.trace(&quot;Version, {}&quot;, versionForCorrectness);</span>
<span class="nc" id="L195">                        return ret;</span>
                    }
                }
<span class="nc" id="L198">            } catch (Exception e) {</span>
                // If we have an exception, we didn't get a chance to validate the lock.
                // If it's still valid, then we should re-throw the exception since it was
                // on a correct view of the object.
<span class="nc bnc" id="L202" title="All 2 branches missed.">                if (lock.validate(ts)) {</span>
<span class="nc" id="L203">                    throw e;</span>
                }
                // Otherwise, it is not on a correct view of the object (the object was
                // modified) and we should try again by upgrading the lock.
<span class="nc" id="L207">                log.warn(&quot;Access [{}] Direct (optimistic-read) exception, upgrading lock&quot;,</span>
                        this);
<span class="nc" id="L209">            }</span>
        }
        // Next, we just upgrade to a full write lock if the optimistic
        // read fails, since it means that the state of the object was
        // updated.
        try {
            // Attempt an upgrade
<span class="nc" id="L216">            ts = lock.tryConvertToWriteLock(ts);</span>
            // Upgrade failed, try conversion again
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (ts == 0) {</span>
<span class="nc" id="L219">                ts = lock.writeLock();</span>
            }
            // Check if direct access is possible (unlikely).
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (directAccessCheckFunction.apply(this)) {</span>
<span class="nc" id="L223">                log.trace(&quot;Access [{}] Direct (writelock) access at {}&quot;, this, getVersionUnsafe());</span>
<span class="nc" id="L224">                R ret = accessFunction.apply(object);</span>

<span class="nc" id="L226">                long versionForCorrectness = getVersionUnsafe();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                if (lock.validate(ts)) {</span>
<span class="nc" id="L228">                    correctnessLogger.trace(&quot;Version, {}&quot;, versionForCorrectness);</span>
<span class="nc" id="L229">                    return ret;</span>
                }
            }
            // If not, perform the update operations
<span class="nc" id="L233">            updateFunction.accept(this);</span>
<span class="nc" id="L234">            correctnessLogger.trace(&quot;Version, {}&quot;, getVersionUnsafe());</span>
<span class="nc" id="L235">            log.trace(&quot;Access [{}] Updated (writelock) access at {}&quot;, this, getVersionUnsafe());</span>
<span class="nc" id="L236">            return accessFunction.apply(object);</span>
            // And perform the access
        } finally {
<span class="nc" id="L239">            lock.unlock(ts);</span>
        }
    }

    /**
     * Update the object under a write lock.
     *
     * @param updateFunction A function to execute once the write lock has been acquired.
     * @param &lt;R&gt;            The type of the return of the updateFunction.
     * @return The return value of the update function.
     */
    public &lt;R&gt; R update(Function&lt;VersionLockedObject&lt;T&gt;, R&gt; updateFunction) {
<span class="nc" id="L251">        long ts = 0;</span>
        try {
<span class="nc" id="L253">            ts = lock.writeLock();</span>
<span class="nc" id="L254">            log.trace(&quot;Update[{}] (writelock)&quot;, this);</span>
<span class="nc" id="L255">            return updateFunction.apply(this);</span>
        } finally {
<span class="nc" id="L257">            lock.unlock(ts);</span>
        }
    }

    /**
     * Roll the object back to the supplied version if possible.
     * This function may roll back to a point prior to the requested version.
     * Otherwise, throws a NoRollbackException.
     *
     * &lt;p&gt;Unsafe, requires that the caller has acquired a write lock.
     *
     * @param rollbackVersion The version to rollback to.
     * @throws NoRollbackException If the object cannot be rolled back to
     *                             the supplied version.
     */
    public void rollbackObjectUnsafe(long rollbackVersion) {
<span class="nc" id="L273">        log.trace(&quot;Rollback[{}] to {}&quot;, this, rollbackVersion);</span>
<span class="nc" id="L274">        rollbackStreamUnsafe(smrStream, rollbackVersion);</span>
<span class="nc" id="L275">        log.trace(&quot;Rollback[{}] completed&quot;, this);</span>
<span class="nc" id="L276">    }</span>

    /**
     * Move the pointer for this object (effectively, forcefuly
     * change the version of this object without playing
     * any updates).
     *
     * @param globalAddress The global address to set the pointer to
     */
    public void seek(long globalAddress) {
<span class="nc" id="L286">        smrStream.seek(globalAddress);</span>
<span class="nc" id="L287">    }</span>

    /**
     * Bring the object to the requested version, rolling back or syncing
     * the object from the log if necessary to reach the requested version.
     *
     * @param timestamp The timestamp to update the object to.
     */
    public void syncObjectUnsafe(long timestamp) {
        // If there is an optimistic stream attached,
        // and it belongs to this thread use that
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (optimisticallyOwnedByThreadUnsafe()) {</span>
            // If there are no updates, ensure we are at the right snapshot
<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (optimisticStream.pos() == Address.NEVER_READ) {</span>
<span class="nc" id="L301">                final WriteSetSMRStream currentOptimisticStream =</span>
                        optimisticStream;
                // If we are too far ahead, roll back to the past
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (getVersionUnsafe() &gt; timestamp) {</span>
                    try {
<span class="nc" id="L306">                        rollbackObjectUnsafe(timestamp);</span>
<span class="nc" id="L307">                    } catch (NoRollbackException nre) {</span>
<span class="nc" id="L308">                        log.warn(&quot;SyncObjectUnsafe[{}] to {} failed {}&quot;, this, timestamp, nre);</span>
<span class="nc" id="L309">                        resetUnsafe();</span>
<span class="nc" id="L310">                    }</span>
                }
                // Now sync the regular log
<span class="nc" id="L313">                syncStreamUnsafe(smrStream, timestamp);</span>
                // It's possible that due to reset,
                // the optimistic stream is no longer
                // present. Restore it.
<span class="nc" id="L317">                optimisticStream = currentOptimisticStream;</span>
            }
<span class="nc" id="L319">            syncStreamUnsafe(optimisticStream, Address.OPTIMISTIC);</span>
        } else {
            // If there is an optimistic stream for another
            // transaction, remove it by rolling it back first
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (this.optimisticStream != null) {</span>
<span class="nc" id="L324">                optimisticRollbackUnsafe();</span>
<span class="nc" id="L325">                this.optimisticStream = null;</span>
            }
            // If we are too far ahead, roll back to the past
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (getVersionUnsafe() &gt; timestamp) {</span>
                try {
<span class="nc" id="L330">                    rollbackObjectUnsafe(timestamp);</span>
                    // Rollback successfully got us to the right
                    // version, we're done.
<span class="nc bnc" id="L333" title="All 2 branches missed.">                    if (getVersionUnsafe() == timestamp) {</span>
<span class="nc" id="L334">                        return;</span>
                    }
<span class="nc" id="L336">                } catch (NoRollbackException nre) {</span>
<span class="nc" id="L337">                    log.warn(&quot;Rollback[{}] to {} failed {}&quot;, this, timestamp, nre);</span>
<span class="nc" id="L338">                    resetUnsafe();</span>
<span class="nc" id="L339">                }</span>
            }
<span class="nc" id="L341">            syncStreamUnsafe(smrStream, timestamp);</span>
        }
<span class="nc" id="L343">    }</span>

    /**
     * Log an update to this object, noting a request to save the
     * upcall result if necessary.
     *
     * @param entry      The entry to log.
     * @param saveUpcall True, if the upcall result should be
     *                   saved, false otherwise.
     * @return The address the update was logged at.
     */
    public long logUpdate(SMREntry entry, boolean saveUpcall) {
<span class="nc" id="L355">        return smrStream.append(entry,</span>
                t -&gt; {
<span class="nc bnc" id="L357" title="All 2 branches missed.">                    if (saveUpcall) {</span>
<span class="nc" id="L358">                        pendingUpcalls.add(t.getToken().getTokenValue());</span>
                    }
<span class="nc" id="L360">                    return true;</span>
                },
                t -&gt; {
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    if (saveUpcall) {</span>
<span class="nc" id="L364">                        pendingUpcalls.remove(t.getToken().getTokenValue());</span>
                    }
<span class="nc" id="L366">                    return true;</span>
                });
    }

    /**
     * Get a handle to the optimistic stream.
     */
    public WriteSetSMRStream getOptimisticStreamUnsafe() {
<span class="nc" id="L374">        return optimisticStream;</span>
    }

    /**
     * Drop the optimistic stream, effectively making optimistic updates
     * to this object permanent.
     */
    public void optimisticCommitUnsafe() {
<span class="nc" id="L382">        optimisticStream = null;</span>
<span class="nc" id="L383">    }</span>

    /**
     * Check whether or not this object was modified by this thread.
     *
     * @return True, if the object was modified by this thread. False otherwise.
     */
    public boolean optimisticallyOwnedByThreadUnsafe() {
<span class="nc" id="L391">        WriteSetSMRStream optimisticStream = this.optimisticStream;</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">        return optimisticStream == null ? false : optimisticStream.isStreamForThisThread();</span>
    }

    /**
     * Set the optimistic stream for this thread, rolling back
     * any previous threads if they were present.
     *
     * @param optimisticStream The new optimistic stream to install.
     */
    public void setOptimisticStreamUnsafe(WriteSetSMRStream optimisticStream) {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (this.optimisticStream != null) {</span>
<span class="nc" id="L404">            optimisticRollbackUnsafe();</span>
        }
<span class="nc" id="L406">        this.optimisticStream = optimisticStream;</span>
<span class="nc" id="L407">    }</span>

    /**
     * Get the version of this object. This corresponds to the position
     * of the pointer into the SMR stream.
     *
     * @return Returns the pointer position to the object in the stream.
     */
    public long getVersionUnsafe() {
<span class="nc" id="L416">        return smrStream.pos();</span>
    }

    /**
     * Check whether this object is currently under optimistic modifications.
     */
    public boolean isOptimisticallyModifiedUnsafe() {
<span class="nc bnc" id="L423" title="All 4 branches missed.">        return optimisticStream != null &amp;&amp; optimisticStream.pos() != Address.NEVER_READ;</span>
    }

    /**
     * Reset this object to the uninitialized state.
     */
    public void resetUnsafe() {
<span class="nc" id="L430">        log.debug(&quot;Reset[{}]&quot;, this);</span>
<span class="nc" id="L431">        object = newObjectFn.get();</span>
<span class="nc" id="L432">        smrStream.reset();</span>
<span class="nc" id="L433">        optimisticStream = null;</span>
<span class="nc" id="L434">    }</span>

    /**
     * Get the ID of the stream backing this object.
     *
     * @return The ID of the stream backing this object.
     */
    @Deprecated // TODO: Add replacement method that conforms to style
    @SuppressWarnings(&quot;checkstyle:abbreviation&quot;) // Due to deprecation
    public UUID getID() {
<span class="nc" id="L444">        return smrStream.getID();</span>
    }

    /**
     * Generate the summary string for this version locked object.
     *
     * &lt;p&gt;The format of this string is [type]@[version][+]
     * (where + is the optimistic flag)
     *
     * @return The summary string for this version locked object
     */
    @Override
    public String toString() {
<span class="nc" id="L457">        WriteSetSMRStream optimisticStream = this.optimisticStream;</span>

<span class="nc" id="L459">        return object.getClass().getSimpleName()</span>
<span class="nc" id="L460">                + &quot;[&quot; + Utils.toReadableId(smrStream.getID()) + &quot;]@&quot;</span>
<span class="nc bnc" id="L461" title="All 4 branches missed.">                + (getVersionUnsafe() == Address.NEVER_READ ? &quot;NR&quot; : getVersionUnsafe())</span>
<span class="nc" id="L462">                + (optimisticStream == null ? &quot;&quot; : &quot;+&quot; + optimisticStream.pos());</span>
    }


    /**
     * Given a SMR entry with an undo record, undo the update.
     *
     * @param record The record to undo.
     */
    protected void applyUndoRecordUnsafe(SMREntry record) {
<span class="nc" id="L472">        log.trace(&quot;Undo[{}] of {}@{} ({})&quot;, this, record.getSMRMethod(),</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                record.getEntry() != null ? record.getEntry().getGlobalAddress() : &quot;OPT&quot;,</span>
<span class="nc" id="L474">                record.getUndoRecord());</span>
<span class="nc" id="L475">        IUndoFunction&lt;T&gt; undoFunction =</span>
<span class="nc" id="L476">                undoFunctionMap.get(record.getSMRMethod());</span>
        // If the undo function exists, apply it.
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (undoFunction != null) {</span>
<span class="nc" id="L479">            undoFunction.doUndo(object, record.getUndoRecord(),</span>
<span class="nc" id="L480">                    record.getSMRArguments());</span>
<span class="nc" id="L481">            return;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        } else if (resetSet.contains(record.getSMRMethod())) {</span>
            // If this is a reset, undo by restoring the
            // previous state.
<span class="nc" id="L485">            object = (T) record.getUndoRecord();</span>
            // clear the undo record, since it is now
            // consumed (the object may change)
<span class="nc" id="L488">            record.clearUndoRecord();</span>
<span class="nc" id="L489">            return;</span>
        }
        // Otherwise we don't know how to undo,
        // throw a runtime exception, because
        // this is a bug, undoRecords we don't know
        // how to process shouldn't be in the log.
<span class="nc" id="L495">        throw new RuntimeException(&quot;Unknown undo record in undo log&quot;);</span>
    }


    /**
     * Apply an SMR update to the object, possibly optimistically.
     *
     * @param entry The entry to apply.
     */
    public Object applyUpdateUnsafe(SMREntry entry) {
<span class="nc" id="L505">        log.trace(&quot;Apply[{}] of {}@{} ({})&quot;, this, entry.getSMRMethod(),</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                entry.getEntry() != null ? entry.getEntry().getGlobalAddress() : &quot;OPT&quot;,</span>
<span class="nc" id="L507">                entry.getSMRArguments());</span>

<span class="nc" id="L509">        ICorfuSMRUpcallTarget&lt;T&gt; target = upcallTargetMap.get(entry.getSMRMethod());</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L511">            throw new RuntimeException(&quot;Unknown upcall &quot; + entry.getSMRMethod());</span>
        }

        // No undo record is present
        // -OR- there this is an optimistic entry, calculate
        // an undo record.
        // (in the case of optimistic entries, the snapshot
        // may have changed since the last time they were
        // applied, so we need to recalculate undo) --- this
        // is the case without snapshot isolation
<span class="nc bnc" id="L521" title="All 4 branches missed.">        if (!entry.isUndoable() || entry.getEntry() == null) {</span>
            // Can we generate an undo record?
<span class="nc" id="L523">            IUndoRecordFunction&lt;T&gt; undoRecordTarget =</span>
                    undoRecordFunctionMap
<span class="nc" id="L525">                            .get(entry.getSMRMethod());</span>
            // If there was no previously calculated undo entry
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (undoRecordTarget != null) {</span>
                // calculate the undo record
<span class="nc" id="L529">                entry.setUndoRecord(undoRecordTarget</span>
<span class="nc" id="L530">                        .getUndoRecord(object, entry.getSMRArguments()));</span>
<span class="nc" id="L531">                log.trace(&quot;Apply[{}] Undo-&gt;{}&quot;, this, entry.getUndoRecord());</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            } else if (resetSet.contains(entry.getSMRMethod())) {</span>
                // This entry actually resets the object. So here
                // we can safely get a new instance, and add the
                // previous instance to the undo log.
<span class="nc" id="L536">                entry.setUndoRecord(object);</span>
<span class="nc" id="L537">                object = newObjectFn.get();</span>
<span class="nc" id="L538">                log.trace(&quot;Apply[{}] Undo-&gt;RESET&quot;, this);</span>
            }
        }

        // now invoke the upcall
<span class="nc" id="L543">        Object ret = target.upcall(object, entry.getSMRArguments());</span>
<span class="nc" id="L544">        return ret;</span>
    }

    /**
     * Roll back the given stream by applying undo records in reverse order
     * from the current stream position until rollbackVersion.
     *
     * @param stream          The stream of SMR updates to apply in
     *                        reverse order.
     * @param rollbackVersion The version to stop roll back at.
     * @throws NoRollbackException If an entry in the stream did not contain
     *                             undo information.
     */
    protected void rollbackStreamUnsafe(ISMRStream stream, long rollbackVersion) {
        // If we're already at or before the given version, there's
        // nothing to do
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (stream.pos() &lt;= rollbackVersion) {</span>
<span class="nc" id="L561">            return;</span>
        }

<span class="nc" id="L564">        List&lt;SMREntry&gt; entries = stream.current();</span>

<span class="nc bnc" id="L566" title="All 2 branches missed.">        while (entries != null) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            if (entries.stream().allMatch(x -&gt; x.isUndoable())) {</span>
                // start from the end, process one at a time
<span class="nc" id="L569">                ListIterator&lt;SMREntry&gt; it =</span>
<span class="nc" id="L570">                        entries.listIterator(entries.size());</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                while (it.hasPrevious()) {</span>
<span class="nc" id="L572">                    applyUndoRecordUnsafe(it.previous());</span>
                }
<span class="nc" id="L574">            } else {</span>
<span class="nc" id="L575">                Optional&lt;SMREntry&gt; entry = entries.stream().findFirst();</span>
<span class="nc" id="L576">                throw new NoRollbackException(entry, stream.pos(), rollbackVersion);</span>
            }

<span class="nc" id="L579">            entries = stream.previous();</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (stream.pos() &lt;= rollbackVersion) {</span>
<span class="nc" id="L582">                return;</span>
            }
        }

<span class="nc" id="L586">        throw new NoRollbackException(stream.pos(), rollbackVersion);</span>
    }

    /**
     * Sync this stream by playing updates forward in the stream until
     * the given timestamp. If Address.MAX is given, updates will be
     * applied until the current tail of the stream. If Address.OPTIMISTIC
     * is given, updates will be applied to the end of the stream, and
     * upcall results will be stored in the resulting entries.
     *
     * &lt;p&gt;When the stream is trimmed, this exception is passed up to the caller,
     * unless the timestamp was Address.MAX, in which the entire object is
     * reset and re-try the sync, which should pick up any checkpoint that
     * was inserted.
     *
     * @param stream    The stream to sync forward
     * @param timestamp The timestamp to sync up to.
     */
    protected void syncStreamUnsafe(ISMRStream stream, long timestamp) {
<span class="nc bnc" id="L605" title="All 2 branches missed.">        log.trace(&quot;Sync[{}] {}&quot;, this, (timestamp == Address.OPTIMISTIC)</span>
                ? &quot;Optimistic&quot; : &quot;to &quot; + timestamp);
<span class="nc bnc" id="L607" title="All 2 branches missed.">        long syncTo = (timestamp == Address.OPTIMISTIC) ? Address.MAX : timestamp;</span>
<span class="nc" id="L608">        stream.streamUpTo(syncTo)</span>
<span class="nc" id="L609">                .forEachOrdered(entry -&gt; {</span>
                    try {
<span class="nc" id="L611">                        Object res = applyUpdateUnsafe(entry);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                        if (timestamp == Address.OPTIMISTIC) {</span>
<span class="nc" id="L613">                            entry.setUpcallResult(res);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                        } else if (pendingUpcalls.contains(entry.getEntry().getGlobalAddress())) {</span>
<span class="nc" id="L615">                            log.debug(&quot;Sync[{}] Upcall Result {}&quot;,</span>
<span class="nc" id="L616">                                    this, entry.getEntry().getGlobalAddress());</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">                            upcallResults.put(entry.getEntry().getGlobalAddress(), res == null</span>
                                    ? NullValue.NULL_VALUE : res);
<span class="nc" id="L619">                            pendingUpcalls.remove(entry.getEntry().getGlobalAddress());</span>
                        }
<span class="nc" id="L621">                        entry.setUpcallResult(res);</span>
<span class="nc" id="L622">                    } catch (Exception e) {</span>
<span class="nc" id="L623">                        log.error(&quot;Sync[{}] Error: Couldn't execute upcall due to {}&quot;, this, e);</span>
<span class="nc" id="L624">                        throw new UnrecoverableCorfuError(e);</span>
<span class="nc" id="L625">                    }</span>
<span class="nc" id="L626">                });</span>
<span class="nc" id="L627">    }</span>

    /**
     * Roll back the optimistic stream, resetting the object if it can not
     * be restored.
     */
    protected void optimisticRollbackUnsafe() {
        try {
<span class="nc" id="L635">            log.trace(&quot;OptimisticRollback[{}] started&quot;, this);</span>
<span class="nc" id="L636">            rollbackStreamUnsafe(this.optimisticStream,</span>
                    Address.NEVER_READ);
<span class="nc" id="L638">            log.trace(&quot;OptimisticRollback[{}] complete&quot;, this);</span>
<span class="nc" id="L639">        } catch (NoRollbackException nre) {</span>
<span class="nc" id="L640">            log.warn(&quot;OptimisticRollback[{}] failed&quot;, this);</span>
<span class="nc" id="L641">            resetUnsafe();</span>
<span class="nc" id="L642">        }</span>
<span class="nc" id="L643">    }</span>

    /** Apply an SMREntry to the version object, while
     * doing bookkeeping for the underlying stream.
     *
     * @param entry
     */
    public void applyUpdateToStreamUnsafe(SMREntry entry, long globalAddress) {
<span class="nc" id="L651">        applyUpdateUnsafe(entry);</span>
<span class="nc" id="L652">        seek(globalAddress + 1);</span>
<span class="nc" id="L653">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>