<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ICorfuPayload.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">infrastructure</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.protocols.wireprotocol</a> &gt; <span class="el_source">ICorfuPayload.java</span></div><h1>ICorfuPayload.java</h1><pre class="source lang-java linenums">package org.corfudb.protocols.wireprotocol;

import com.google.common.collect.BoundType;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableRangeSet;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Range;
import com.google.common.collect.RangeSet;
import com.google.common.reflect.TypeToken;

import io.netty.buffer.ByteBuf;

import java.lang.invoke.LambdaMetafactory;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.nio.charset.StandardCharsets;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.corfudb.protocols.logprotocol.CheckpointEntry;
import org.corfudb.runtime.view.Layout;
import org.corfudb.util.JsonUtils;

/**
 * Created by mwei on 8/1/16.
 */
public interface ICorfuPayload&lt;T&gt; {

    @FunctionalInterface
    interface PayloadConstructor&lt;T&gt; {
        T construct(ByteBuf buf);
    }

    ConcurrentHashMap&lt;Class&lt;?&gt;, PayloadConstructor&lt;?&gt;&gt;
<span class="nc" id="L42">            constructorMap = new ConcurrentHashMap&lt;&gt;(</span>
<span class="nc" id="L43">                    ImmutableMap.&lt;Class&lt;?&gt;, PayloadConstructor&lt;?&gt;&gt;builder()</span>
<span class="nc" id="L44">                .put(Byte.class, ByteBuf::readByte)</span>
<span class="nc" id="L45">                .put(Integer.class, ByteBuf::readInt)</span>
<span class="nc" id="L46">                .put(Long.class, ByteBuf::readLong)</span>
<span class="nc" id="L47">                .put(Boolean.class, ByteBuf::readBoolean)</span>
<span class="nc" id="L48">                .put(Double.class, ByteBuf::readDouble)</span>
<span class="nc" id="L49">                .put(Float.class, ByteBuf::readFloat)</span>
<span class="nc" id="L50">                .put(String.class, x -&gt; {</span>
<span class="nc" id="L51">                    int numBytes = x.readInt();</span>
<span class="nc" id="L52">                    byte[] bytes = new byte[numBytes];</span>
<span class="nc" id="L53">                    x.readBytes(bytes);</span>
<span class="nc" id="L54">                    return new String(bytes);</span>
                })
<span class="nc" id="L56">                .put(Layout.class, x -&gt; {</span>
<span class="nc" id="L57">                    int length = x.readInt();</span>
<span class="nc" id="L58">                    byte[] byteArray = new byte[length];</span>
<span class="nc" id="L59">                    x.readBytes(byteArray, 0, length);</span>
<span class="nc" id="L60">                    String str = new String(byteArray, StandardCharsets.UTF_8);</span>
<span class="nc" id="L61">                    Layout layout = JsonUtils.parser.fromJson(str, Layout.class);</span>
<span class="nc" id="L62">                    return layout;</span>
                })
<span class="nc" id="L64">                .put(IMetadata.DataRank.class, x -&gt;</span>
<span class="nc" id="L65">                        new IMetadata.DataRank(x.readLong(), new UUID(x.readLong(), x.readLong())))</span>
<span class="nc" id="L66">                .put(CheckpointEntry.CheckpointEntryType.class, x -&gt;</span>
<span class="nc" id="L67">                    CheckpointEntry.CheckpointEntryType.typeMap.get(x.readByte()))</span>
<span class="nc" id="L68">                .put(UUID.class, x -&gt; new UUID(x.readLong(), x.readLong()))</span>
<span class="nc" id="L69">                .put(byte[].class, x -&gt; {</span>
<span class="nc" id="L70">                    int length = x.readInt();</span>
<span class="nc" id="L71">                    byte[] bytes = new byte[length];</span>
<span class="nc" id="L72">                    x.readBytes(bytes);</span>
<span class="nc" id="L73">                    return bytes;</span>
                })
<span class="nc" id="L75">                .put(ByteBuf.class, x -&gt; {</span>
<span class="nc" id="L76">                    int bytes = x.readInt();</span>
<span class="nc" id="L77">                    ByteBuf b = x.retainedSlice(x.readerIndex(), bytes);</span>
<span class="nc" id="L78">                    x.readerIndex(x.readerIndex() + bytes);</span>
<span class="nc" id="L79">                    return b;</span>
                })
<span class="nc" id="L81">                .build());</span>



    /** A lookup representing the context we'll use to do lookups. */
<span class="nc" id="L86">    java.lang.invoke.MethodHandles.Lookup lookup = MethodHandles.lookup();</span>

    /**
     * Build payload from Buffer
     * @param buf        The buffer to deserialize.
     * @param cls        The class of the payload.
     * @param &lt;T&gt;        The type of the payload.
     * @return payload
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; T fromBuffer(ByteBuf buf, Class&lt;T&gt; cls) {
<span class="nc bnc" id="L97" title="All 2 branches missed.">        if (constructorMap.containsKey(cls)) {</span>
<span class="nc" id="L98">            return (T) constructorMap.get(cls).construct(buf);</span>
        } else {
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (cls.isEnum()) {</span>
                // we only know how to deal with enums with a typemap
                try {
<span class="nc" id="L103">                    Map&lt;Byte, T&gt; enumMap = (Map&lt;Byte, T&gt;) cls.getDeclaredField(&quot;typeMap&quot;).get(null);</span>
<span class="nc" id="L104">                    constructorMap.put(cls, x -&gt; enumMap.get(x.readByte()));</span>
<span class="nc" id="L105">                    return (T) constructorMap.get(cls).construct(buf);</span>
<span class="nc" id="L106">                } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L107">                    throw new RuntimeException(&quot;only enums with a typeMap are supported!&quot;);</span>
<span class="nc" id="L108">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L109">                    throw new RuntimeException(e);</span>
                }
            }
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (ICorfuPayload.class.isAssignableFrom(cls)) {</span>
                // Grab the constructor and get convert it to a lambda.
                try {
<span class="nc" id="L115">                    Constructor t = cls.getConstructor(ByteBuf.class);</span>
<span class="nc" id="L116">                    MethodHandle mh = lookup.unreflectConstructor(t);</span>
<span class="nc" id="L117">                    MethodType mt = MethodType.methodType(Object.class, ByteBuf.class);</span>
                    try {
<span class="nc" id="L119">                        constructorMap.put(cls,</span>
<span class="nc" id="L120">                                (PayloadConstructor&lt;T&gt;) LambdaMetafactory.metafactory(lookup,</span>
                                        &quot;construct&quot;,
<span class="nc" id="L122">                                        MethodType.methodType(PayloadConstructor.class),</span>
<span class="nc" id="L123">                                        mt, mh, mh.type()).getTarget().invokeExact());</span>
<span class="nc" id="L124">                        return (T) constructorMap.get(cls).construct(buf);</span>
<span class="nc" id="L125">                    } catch (Throwable th) {</span>
<span class="nc" id="L126">                        throw new RuntimeException(th);</span>
                    }
<span class="nc" id="L128">                } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L129">                    throw new RuntimeException(&quot;CorfuPayloads must include a ByteBuf constructor!&quot;);</span>
<span class="nc" id="L130">                } catch (IllegalAccessException e) {</span>
<span class="nc" id="L131">                    throw new RuntimeException(e);</span>
                }
            }
        }

<span class="nc" id="L136">        throw new RuntimeException(&quot;Unknown class &quot; + cls + &quot; for deserialization&quot;);</span>
    }

    /**
     * Build payload from Buffer.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; T fromBuffer(ByteBuf buf, TypeToken&lt;T&gt; token) {
<span class="nc" id="L144">        Class&lt;?&gt; rawType = token.getRawType();</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (rawType.isAssignableFrom(Map.class)) {</span>
<span class="nc" id="L146">            return (T) mapFromBuffer(buf, token.resolveType(</span>
<span class="nc" id="L147">                    Map.class.getTypeParameters()[0]).getRawType(),</span>
<span class="nc" id="L148">                    token.resolveType(Map.class.getTypeParameters()[1]).getRawType());</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        } else if (rawType.isAssignableFrom(Set.class)) {</span>
<span class="nc" id="L150">            return (T) setFromBuffer(buf, token.resolveType(</span>
<span class="nc" id="L151">                    Set.class.getTypeParameters()[0]).getRawType());</span>
        }
<span class="nc" id="L153">        return (T) fromBuffer(buf, rawType);</span>
    }

    /** A really simple flat map implementation. The first entry is the size of the map as an int,
     * and the next entries are each key followed by its value.
     * Maps of maps are currently not supported.
     * @param buf           The buffer to deserialize.
     * @param keyClass      The class of the keys.
     * @param valueClass    The class of the values.
     * @param &lt;K&gt;           The type of the keys.
     * @param &lt;V&gt;           The type of the values.
     * @return Map
     */
    static &lt;K,V&gt; Map&lt;K,V&gt; mapFromBuffer(ByteBuf buf, Class&lt;K&gt; keyClass, Class&lt;V&gt; valueClass) {
<span class="nc" id="L167">        int numEntries = buf.readInt();</span>
<span class="nc" id="L168">        ImmutableMap.Builder&lt;K,V&gt; builder = ImmutableMap.builder();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L170">            builder.put(fromBuffer(buf, keyClass), fromBuffer(buf, valueClass));</span>
        }
<span class="nc" id="L172">        return builder.build();</span>
    }

    /** A really simple flat set implementation. The first entry is the size of the set as an int,
     * and the next entries are each value.
     * @param buf           The buffer to deserialize.
     * @param valueClass    The class of the values.
     * @param &lt;V&gt;           The type of the values.
     * @return Set of value types
     */
    static &lt;V&gt; Set&lt;V&gt; setFromBuffer(ByteBuf buf, Class&lt;V&gt; valueClass) {
<span class="nc" id="L183">        int numEntries = buf.readInt();</span>
<span class="nc" id="L184">        ImmutableSet.Builder&lt;V&gt; builder = ImmutableSet.builder();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L186">            builder.add(fromBuffer(buf, valueClass));</span>
        }
<span class="nc" id="L188">        return builder.build();</span>
    }

    /** A really simple flat list implementation. The first entry is the size of the set as an int,
     * and the next entries are each value.
     * @param &lt;V&gt;           The type of the values.
     * @param buf           The buffer to deserialize.
     * @param valueClass    The class of the values.
     * @return List of values types
     */
    static &lt;V&gt; List&lt;V&gt; listFromBuffer(ByteBuf buf, Class&lt;V&gt; valueClass) {
<span class="nc" id="L199">        int numEntries = buf.readInt();</span>
<span class="nc" id="L200">        ImmutableList.Builder&lt;V&gt; builder = ImmutableList.builder();</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L202">            builder.add(fromBuffer(buf, valueClass));</span>
        }
<span class="nc" id="L204">        return builder.build();</span>
    }

    /** A really simple flat set implementation. The first entry is the size of the set as an int,
     * and the next entries are each value.
     * @param buf           The buffer to deserialize.
     * @param valueClass    The class of the values.
     * @param &lt;V&gt;           The type of the values.
     * @return Set of values type
     */
    static &lt;V extends Comparable&lt;V&gt;&gt; RangeSet&lt;V&gt; rangeSetFromBuffer(ByteBuf buf,
                                                                    Class&lt;V&gt; valueClass) {
<span class="nc" id="L216">        int numEntries = buf.readInt();</span>
<span class="nc" id="L217">        ImmutableRangeSet.Builder&lt;V&gt; rs = ImmutableRangeSet.builder();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            BoundType upperType = buf.readBoolean() ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc" id="L220">            V upper = fromBuffer(buf, valueClass);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            BoundType lowerType = buf.readBoolean() ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc" id="L222">            V lower = fromBuffer(buf, valueClass);</span>
<span class="nc" id="L223">            rs.add(Range.range(lower, lowerType, upper, upperType));</span>
        }
<span class="nc" id="L225">        return rs.build();</span>
    }

    /** A really simple flat set implementation. The first entry is the size of the set as an int,
     * and the next entries are each value.
     * @param buf           The buffer to deserialize.
     * @param valueClass    The class of the values.
     * @param &lt;V&gt;           The type of the values.
     * @return Set of values type
     */
    static &lt;V extends Comparable&lt;V&gt;&gt; Range&lt;V&gt; rangeFromBuffer(ByteBuf buf, Class&lt;V&gt; valueClass) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        BoundType upperType = buf.readBoolean() ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc" id="L237">        V upper = fromBuffer(buf, valueClass);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        BoundType lowerType = buf.readBoolean() ? BoundType.CLOSED : BoundType.OPEN;</span>
<span class="nc" id="L239">        V lower = fromBuffer(buf, valueClass);</span>
<span class="nc" id="L240">        return Range.range(lower, lowerType, upper, upperType);</span>
    }

    /** A really simple flat map implementation. The first entry is the size of the map as an int,
     * and the next entries are each value.
     * @param buf           The buffer to deserialize.
     * @param keyClass      The class of the keys.
     * @param objClass      The class of the values.
     * @param &lt;K&gt;           The type of the keys
     * @param &lt;V&gt;           The type of the values.
     * @return Map for use with enum type keys
     * */
    static &lt;K extends Enum&lt;K&gt; &amp; ITypedEnum&lt;K&gt;,V&gt; EnumMap&lt;K,V&gt; enumMapFromBuffer(ByteBuf buf,
                                                                                Class&lt;K&gt; keyClass,
                                                                                Class&lt;V&gt; objClass) {
<span class="nc" id="L255">        EnumMap&lt;K, V&gt; metadataMap =</span>
                new EnumMap&lt;&gt;(keyClass);
<span class="nc" id="L257">        byte numEntries = buf.readByte();</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">        while (numEntries &gt; 0 &amp;&amp; buf.isReadable()) {</span>
<span class="nc" id="L259">            K type = fromBuffer(buf, keyClass);</span>
<span class="nc" id="L260">            V value = (V)fromBuffer(buf, type.getComponentType());</span>
<span class="nc" id="L261">            metadataMap.put(type, value);</span>
<span class="nc" id="L262">            numEntries--;</span>
<span class="nc" id="L263">        }</span>
<span class="nc" id="L264">        return metadataMap;</span>
    }

    /**
     * Serialize a payload into a given byte buffer.
     * @param payload       The Payload to serialize.
     * @param buffer        The buffer to serialize it into.
     * @param &lt;T&gt;           The type of the payload.
     * */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; void serialize(ByteBuf buffer, T payload) {
        // If it's an ICorfuPayload, use the defined serializer.
        // Otherwise serialize the primitive type.
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (payload instanceof ICorfuPayload) {</span>
<span class="nc" id="L278">            ((ICorfuPayload) payload).doSerialize(buffer);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        } else if (payload instanceof Byte) {</span>
<span class="nc" id="L280">            buffer.writeByte((Byte) payload);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        } else if (payload instanceof Short) {</span>
<span class="nc" id="L282">            buffer.writeShort((Short) payload);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        } else if (payload instanceof Integer) {</span>
<span class="nc" id="L284">            buffer.writeInt((Integer) payload);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        } else if (payload instanceof Long) {</span>
<span class="nc" id="L286">            buffer.writeLong((Long) payload);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        } else if (payload instanceof Boolean) {</span>
<span class="nc" id="L288">            buffer.writeBoolean((Boolean) payload);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        } else if (payload instanceof Double) {</span>
<span class="nc" id="L290">            buffer.writeDouble((Double) payload);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        } else if (payload instanceof Float) {</span>
<span class="nc" id="L292">            buffer.writeFloat((Float) payload);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        } else if (payload instanceof byte[]) {</span>
<span class="nc" id="L294">            buffer.writeInt(((byte[]) payload).length);</span>
<span class="nc" id="L295">            buffer.writeBytes((byte[]) payload);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        } else if (payload instanceof String) {</span>
            // and some standard non prims as well
<span class="nc" id="L298">            byte[] s = ((String) payload).getBytes();</span>
<span class="nc" id="L299">            buffer.writeInt(s.length);</span>
<span class="nc" id="L300">            buffer.writeBytes(s);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        } else if (payload instanceof UUID) {</span>
<span class="nc" id="L302">            buffer.writeLong(((UUID) payload).getMostSignificantBits());</span>
<span class="nc" id="L303">            buffer.writeLong(((UUID) payload).getLeastSignificantBits());</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        } else if (payload instanceof EnumMap) {</span>
            // and some collection types
<span class="nc" id="L306">            EnumMap&lt;?,?&gt; map = (EnumMap&lt;?,?&gt;) payload;</span>
<span class="nc" id="L307">            buffer.writeByte(map.size());</span>
<span class="nc" id="L308">            map.entrySet().stream().forEach(x -&gt; {</span>
<span class="nc" id="L309">                serialize(buffer, x.getKey());</span>
<span class="nc" id="L310">                serialize(buffer, x.getValue());</span>
<span class="nc" id="L311">            });</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        } else if (payload instanceof RangeSet) {</span>
<span class="nc" id="L313">            Set&lt;Range&lt;?&gt;&gt; rs = (((RangeSet) payload).asRanges());</span>
<span class="nc" id="L314">            buffer.writeInt(rs.size());</span>
<span class="nc" id="L315">            rs.stream().forEach(x -&gt; {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                buffer.writeBoolean(x.upperBoundType() == BoundType.CLOSED);</span>
<span class="nc" id="L317">                serialize(buffer, x.upperEndpoint());</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                buffer.writeBoolean(x.upperBoundType() == BoundType.CLOSED);</span>
<span class="nc" id="L319">                serialize(buffer, x.lowerEndpoint());</span>
<span class="nc" id="L320">            });</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        } else if (payload instanceof Range) {</span>
<span class="nc" id="L322">            Range&lt;?&gt; r = (Range) payload;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            buffer.writeBoolean(r.upperBoundType() == BoundType.CLOSED);</span>
<span class="nc" id="L324">            serialize(buffer, r.upperEndpoint());</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            buffer.writeBoolean(r.upperBoundType() == BoundType.CLOSED);</span>
<span class="nc" id="L326">            serialize(buffer, r.lowerEndpoint());</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        } else if (payload instanceof Map) {</span>
<span class="nc" id="L328">            Map&lt;?,?&gt; map = (Map&lt;?,?&gt;) payload;</span>
<span class="nc" id="L329">            buffer.writeInt(map.size());</span>
<span class="nc" id="L330">            map.entrySet().stream().forEach(x -&gt; {</span>
<span class="nc" id="L331">                serialize(buffer, x.getKey());</span>
<span class="nc" id="L332">                serialize(buffer, x.getValue());</span>
<span class="nc" id="L333">            });</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        } else if (payload instanceof Set) {</span>
<span class="nc" id="L335">            Set&lt;?&gt; set = (Set&lt;?&gt;) payload;</span>
<span class="nc" id="L336">            buffer.writeInt(set.size());</span>
<span class="nc" id="L337">            set.stream().forEach(x -&gt; {</span>
<span class="nc" id="L338">                serialize(buffer, x);</span>
<span class="nc" id="L339">            });</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        } else if (payload instanceof List) {</span>
<span class="nc" id="L341">            List&lt;?&gt; list = (List&lt;?&gt;) payload;</span>
<span class="nc" id="L342">            buffer.writeInt(list.size());</span>
<span class="nc" id="L343">            list.stream().forEach(x -&gt; {</span>
<span class="nc" id="L344">                serialize(buffer, x);</span>
<span class="nc" id="L345">            });</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        } else if (payload instanceof Layout) {</span>
<span class="nc" id="L347">            byte[] b = JsonUtils.parser.toJson(payload).getBytes();</span>
<span class="nc" id="L348">            buffer.writeInt(b.length);</span>
<span class="nc" id="L349">            buffer.writeBytes(b);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        } else if (payload instanceof ByteBuf) {</span>
<span class="nc" id="L351">            ByteBuf b = ((ByteBuf) payload).slice();</span>
<span class="nc" id="L352">            b.resetReaderIndex();</span>
<span class="nc" id="L353">            int bytes = b.readableBytes();</span>
<span class="nc" id="L354">            buffer.writeInt(bytes);</span>
<span class="nc" id="L355">            buffer.writeBytes(b, bytes);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        } else if (payload instanceof IMetadata.DataRank) {</span>
<span class="nc" id="L357">            IMetadata.DataRank rank = (IMetadata.DataRank)payload;</span>
<span class="nc" id="L358">            buffer.writeLong(rank.getRank());</span>
<span class="nc" id="L359">            buffer.writeLong(rank.getUuid().getMostSignificantBits());</span>
<span class="nc" id="L360">            buffer.writeLong(rank.getUuid().getLeastSignificantBits());</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        } else if (payload instanceof CheckpointEntry.CheckpointEntryType) {</span>
<span class="nc" id="L362">            buffer.writeByte(((CheckpointEntry.CheckpointEntryType) payload).asByte());</span>
        } else {
<span class="nc" id="L364">            throw new RuntimeException(&quot;Unknown class &quot; + payload.getClass()</span>
                    + &quot; for serialization&quot;);
        }
<span class="nc" id="L367">    }</span>

    void doSerialize(ByteBuf buf);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>