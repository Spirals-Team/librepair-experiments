<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractContextStreamView.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">infrastructure</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.view.stream</a> &gt; <span class="el_source">AbstractContextStreamView.java</span></div><h1>AbstractContextStreamView.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.view.stream;

import java.util.ArrayList;
import java.util.List;
import java.util.NavigableSet;
import java.util.TreeSet;
import java.util.UUID;
import java.util.function.BiFunction;
import java.util.function.Function;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.logprotocol.StreamCOWEntry;
import org.corfudb.protocols.wireprotocol.DataType;
import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.view.Address;
import org.corfudb.util.Utils;


/** An abstract context stream view maintains contexts, which are used to
 * implement copy-on-write entries.
 *
 *  &lt;p&gt;This implementation uses &quot;contexts&quot; to properly deal with copy-on-write
 * streams. Every time a stream is copied, a new context is created which
 * redirects requests to the source stream for the copy - each context
 * contains its own queue and pointers. Implementers of fillReadQueue() and
 * readAndUpdatePointers should be careful to use the id of the context,
 * rather than that of the stream view itself.
 *
 * &lt;p&gt;Created by mwei on 1/6/17.
 */
<span class="nc" id="L32">@Slf4j</span>
public abstract class AbstractContextStreamView&lt;T extends AbstractStreamContext&gt;
        implements IStreamView, AutoCloseable {

    /**
     * The ID of the stream.
     */
<span class="nc" id="L39">    @Getter</span>
    final UUID id;

    /**
     * The runtime the stream view was created with.
     */
    final CorfuRuntime runtime;

    /**
     * An ordered set of stream contexts, which store information
     * about a stream copied via copy-on-write entries. Streams which
     * have never been copied have only a single context.
     */
    final NavigableSet&lt;T&gt; streamContexts;

    /** A function which creates a context, given the stream ID and max global.
     */
    final BiFunction&lt;UUID, Long, T&gt; contextFactory;

    /** The base context, which is always preserved. */
    final T baseContext;

    /** Create a new abstract context stream view.
     *
     * @param runtime               The runtime.
     * @param id                    The id of the stream.
     * @param contextFactory        A function which generates a context,
     *                              given the stream id and a maximum global
     *                              address.
     */
    public AbstractContextStreamView(final CorfuRuntime runtime,
                                     final UUID id,
                                     final BiFunction&lt;UUID, Long, T&gt;
<span class="nc" id="L72">                                             contextFactory) {</span>
<span class="nc" id="L73">        this.id = id;</span>
<span class="nc" id="L74">        this.runtime = runtime;</span>
<span class="nc" id="L75">        this.streamContexts = new TreeSet&lt;&gt;();</span>
<span class="nc" id="L76">        this.contextFactory = contextFactory;</span>
<span class="nc" id="L77">        this.baseContext = contextFactory.apply(id, Address.MAX);</span>
<span class="nc" id="L78">        this.streamContexts.add(baseContext);</span>
<span class="nc" id="L79">    }</span>

    /**
     * {@inheritDoc}
     */
    public synchronized void reset() {
<span class="nc" id="L85">        this.streamContexts.clear();</span>
<span class="nc" id="L86">        baseContext.reset();</span>
<span class="nc" id="L87">        this.streamContexts.add(baseContext);</span>
<span class="nc" id="L88">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public synchronized void seek(long globalAddress) {
        // pop any stream context which has a max address
        // less than the global address
<span class="nc bnc" id="L97" title="All 2 branches missed.">        while (this.streamContexts.size() &gt; 1) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if (this.streamContexts.first().maxGlobalAddress &lt; globalAddress) {</span>
<span class="nc" id="L99">                this.streamContexts.pollFirst();</span>
            }
        }

        // now request a seek on the context
<span class="nc" id="L104">        this.streamContexts.first().seek(globalAddress);</span>
<span class="nc" id="L105">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
<span class="nc" id="L111">    public void close() {}</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public final synchronized ILogData nextUpTo(final long maxGlobal) {
        // Don't do anything if we've already exceeded the global
        // pointer.
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (getCurrentContext().globalPointer &gt; maxGlobal) {</span>
<span class="nc" id="L121">            return null;</span>
        }

        // Pop the context if it has changed.
<span class="nc" id="L125">        if (getCurrentContext().globalPointer</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                &gt;= getCurrentContext().maxGlobalAddress) {</span>
<span class="nc" id="L127">            final T last = streamContexts.pollFirst();</span>
<span class="nc" id="L128">            log.trace(&quot;Completed context {}@{}, removing.&quot;,</span>
<span class="nc" id="L129">                    last.id, last.maxGlobalAddress);</span>
        }

        // Get the next entry from the underlying implementation.
<span class="nc" id="L133">        final ILogData entry =</span>
<span class="nc" id="L134">                getNextEntry(getCurrentContext(), maxGlobal);</span>

<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (entry != null) {</span>
            // Update the pointer.
<span class="nc" id="L138">            updatePointer(entry);</span>

            // Process the next entry, checking if the context has changed.
            // If the context has changed, we read again, since this entry
            // does not contain any data, and we need to follow the new
            // context.
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (processEntryForContext(entry)) {</span>
<span class="nc" id="L145">                return nextUpTo(maxGlobal);</span>
            }
        }

        // Return the entry.
<span class="nc" id="L150">        return entry;</span>
    }

    /** {@inheritDoc}
     */
    @Override
    public final synchronized List&lt;ILogData&gt; remainingUpTo(long maxGlobal) {

        // Pop the context if it has changed.
<span class="nc" id="L159">        if (getCurrentContext().globalPointer</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                &gt;= getCurrentContext().maxGlobalAddress) {</span>
<span class="nc" id="L161">            final T last = streamContexts.pollFirst();</span>
<span class="nc" id="L162">            log.trace(&quot;Completed context {}@{}, removing.&quot;,</span>
<span class="nc" id="L163">                    last.id, last.maxGlobalAddress);</span>
        }

<span class="nc" id="L166">        final List&lt;ILogData&gt; entries = getNextEntries(getCurrentContext(), maxGlobal,</span>
                this::doesEntryUpdateContext);

        // Nothing read, nothing to process.
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (entries.size() == 0) {</span>
            // We've resolved up to maxGlobal, so remember it. (if it wasn't max)
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if (maxGlobal != Address.MAX) {</span>
<span class="nc" id="L173">                getCurrentContext().globalPointer = maxGlobal;</span>
            }
<span class="nc" id="L175">            return entries;</span>
        }

        // Check if the last entry updates the context.
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (doesEntryUpdateContext(entries.get(entries.size() - 1))) {</span>
            // The entry which updates the context must be the last one, so
            // process it
<span class="nc" id="L182">            processEntryForContext(entries.get(entries.size() - 1));</span>

            // Remove the entry which updates the context
<span class="nc" id="L185">            entries.remove(entries.size() - 1);</span>

            // do a read again, which will consume the inner context
<span class="nc" id="L188">            entries.addAll(remainingUpTo(maxGlobal));</span>

            // and now read again, in case the context returned, to make
            // sure we get up to maxGlobal.
<span class="nc" id="L192">            entries.addAll(remainingUpTo(maxGlobal));</span>
        }

        // Otherwise update the pointer
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (maxGlobal != Address.MAX) {</span>
<span class="nc" id="L197">            getCurrentContext().globalPointer = maxGlobal;</span>
        } else {
<span class="nc" id="L199">            updatePointer(entries.get(entries.size() - 1));</span>
        }

        // And return the entries.
<span class="nc" id="L203">        return entries;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean hasNext() {
<span class="nc" id="L211">        return getHasNext(getCurrentContext());</span>
    }

    /** Return whether calling getNextEntry() may return more
     * entries, given the context.
     * @param context       The context to retrieve the next entry from.
     * @return              True, if getNextEntry() may return an entry.
     *                      False otherwise.
     */
    protected abstract boolean getHasNext(T context);

    /** Retrieve the next entry in the stream, given the context.
     *
     * @param context       The context to retrieve the next entry from.
     * @param maxGlobal     The maximum global address to read to.
     * @return              Next ILogData for this context
     */
    protected abstract ILogData getNextEntry(T context, long maxGlobal);

    /** Retrieve the next entries in the stream, given the context.
     *
     * &lt;p&gt;This function is designed to implement a bulk read. In a bulk read,
     * one of the entries may cause the context to change - the implementation
     * should check if the entry changes the context and stop reading
     * if this occurs, returning the entry that caused contextCheckFn to return
     * true.
     *
     * &lt;p&gt;The default implementation simply calls getNextEntry.
     *
     * @param context           The context to retrieve the next entry from.
     * @param maxGlobal         The maximum global address to read to.
     * @param contextCheckFn    A function which returns true if the entry changes the
     *                          stream context.
     * @return                  A list of the next entries for this context
     */
    protected List&lt;ILogData&gt; getNextEntries(T context, long maxGlobal,
                                                     Function&lt;ILogData, Boolean&gt; contextCheckFn) {
<span class="nc" id="L248">        final List&lt;ILogData&gt; dataList = new ArrayList&lt;&gt;();</span>
        ILogData thisData;
<span class="nc bnc" id="L250" title="All 2 branches missed.">        while ((thisData = getNextEntry(context, maxGlobal)) != null) {</span>
            // Add this read to the list of reads to return.
<span class="nc" id="L252">            dataList.add(thisData);</span>

            // Update the pointer, because the underlying implementation
            // will expect it to be updated when we call getNextEntry() again.
<span class="nc" id="L256">            updatePointer(thisData);</span>

            // If this entry changes the context, don't continue reading.
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (contextCheckFn.apply(thisData)) {</span>
<span class="nc" id="L260">                break;</span>
            }
        }
<span class="nc" id="L263">        return dataList;</span>
    }

    /** Check whether the given entry updates the context.
     *
     * @param data  The entry to check.
     * @return      True, if the entry will update the context.
     */
    protected boolean doesEntryUpdateContext(final ILogData data) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        return data.hasBackpointer(getCurrentContext().id)</span>
<span class="nc" id="L273">                &amp;&amp; data.getBackpointer(getCurrentContext().id)</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                        .equals(Address.COW_BACKPOINTER);</span>
    }

    /** Update the global pointer, given an entry.
     *
     * @param data  The entry to use to update the pointer.
     */
    protected void updatePointer(final ILogData data) {
        // Update the global pointer, if it is non-checkpoint data.
<span class="nc bnc" id="L283" title="All 4 branches missed.">        if (data.getType() == DataType.DATA &amp;&amp; !data.hasCheckpointMetadata()) {</span>
<span class="nc" id="L284">            getCurrentContext().globalPointer =</span>
<span class="nc" id="L285">                    data.getGlobalAddress();</span>
        }
<span class="nc" id="L287">    }</span>

    /** Check if the given entry adds a new context, and update
     * the global pointer.
     *
     * &lt;p&gt;If it does, add it to the context stack. Otherwise,
     * pop the context.
     *
     * &lt;p&gt;It is important that this method be called in order, since
     * it updates the global pointer and can change the global pointer.
     *
     * @param data  The entry to process.
     * @return      True, if this entry adds a context.
     */
    protected boolean processEntryForContext(final ILogData data) {
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc" id="L303">            final Object payload = data.getPayload(runtime);</span>
            // If this is a COW entry, we update the context as well.
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (payload instanceof StreamCOWEntry) {</span>
<span class="nc" id="L306">                StreamCOWEntry ce = (StreamCOWEntry) payload;</span>
<span class="nc" id="L307">                pushNewContext(ce.getOriginalStream(),</span>
<span class="nc" id="L308">                                ce.getFollowUntil());</span>
<span class="nc" id="L309">                return true;</span>
            }
        }
<span class="nc" id="L312">        return false;</span>
    }

    /** Get the current context.
     *
     * &lt;p&gt;Should never throw a NoSuchElement exception because streamContexts should
     * always at least have one element.
     *
     * */
    protected T getCurrentContext() {
<span class="nc" id="L322">        return streamContexts.first();</span>
    }

    /** Add a new context. */
    protected void pushNewContext(UUID id, long maxGlobal) {
<span class="nc" id="L327">        streamContexts.add(contextFactory.apply(id, maxGlobal));</span>
<span class="nc" id="L328">    }</span>

    protected void popContext() {
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (streamContexts.size() &lt;= 1) {</span>
<span class="nc" id="L332">            throw new RuntimeException(&quot;Attempted to pop context with less&quot;</span>
                    + &quot; than 1 context remaining!&quot;);
        }
<span class="nc" id="L335">        streamContexts.pollFirst();</span>
<span class="nc" id="L336">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L340">        return Utils.toReadableId(baseContext.id) + &quot;@&quot; + getCurrentContext().globalPointer;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>