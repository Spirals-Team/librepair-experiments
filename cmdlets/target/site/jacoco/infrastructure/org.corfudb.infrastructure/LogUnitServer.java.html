<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LogUnitServer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cmdlets</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">LogUnitServer.java</span></div><h1>LogUnitServer.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import com.codahale.metrics.MetricRegistry;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import com.github.benmanes.caffeine.cache.RemovalCause;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import io.netty.channel.ChannelHandlerContext;

import java.lang.invoke.MethodHandles;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.infrastructure.log.InMemoryStreamLog;
import org.corfudb.infrastructure.log.StreamLog;
import org.corfudb.infrastructure.log.StreamLogFiles;
import org.corfudb.protocols.wireprotocol.CorfuMsg;
import org.corfudb.protocols.wireprotocol.CorfuMsgType;
import org.corfudb.protocols.wireprotocol.CorfuPayloadMsg;
import org.corfudb.protocols.wireprotocol.ILogData;
import org.corfudb.protocols.wireprotocol.LogData;
import org.corfudb.protocols.wireprotocol.MultipleReadRequest;
import org.corfudb.protocols.wireprotocol.RangeWriteMsg;
import org.corfudb.protocols.wireprotocol.ReadRequest;
import org.corfudb.protocols.wireprotocol.ReadResponse;
import org.corfudb.protocols.wireprotocol.TrimRequest;
import org.corfudb.protocols.wireprotocol.WriteRequest;
import org.corfudb.runtime.exceptions.DataCorruptionException;
import org.corfudb.runtime.exceptions.DataOutrankedException;
import org.corfudb.runtime.exceptions.OverwriteException;
import org.corfudb.runtime.exceptions.TrimmedException;
import org.corfudb.runtime.exceptions.ValueAdoptedException;
import org.corfudb.util.Utils;


/**
 * Created by mwei on 12/10/15.
 *
 * &lt;p&gt;A Log Unit Server, which is responsible for providing the persistent storage for the Corfu
 * Distributed Shared Log.
 *
 * &lt;p&gt;All reads and writes go through a cache. For persistence, every 10,000 log entries are written
 * to individual
 * files (logs), which are represented as FileHandles. Each FileHandle contains a pointer to the
 * tail of the file, a
 * memory-mapped file channel, and a set of addresses known to be in the file. To append an
 * entry, the pointer to the
 * tail is first extended to the length of the entry, and the entry is added to the set of known
 * addresses. A header
 * is written, which consists of the ASCII characters LE, followed by a set of flags, the log
 * unit address, the size
 * of the entry, then the metadata size, metadata and finally the entry itself. When the entry is
 * complete, a written
 * flag is set in the flags field.
 */
<span class="nc" id="L67">@Slf4j</span>
public class LogUnitServer extends AbstractServer {
    /**
     * A scheduler, which is used to schedule periodic tasks like garbage collection.
     */
<span class="nc" id="L72">    private final ScheduledExecutorService scheduler =</span>
<span class="nc" id="L73">            Executors.newScheduledThreadPool(</span>
                    1,
                    new ThreadFactoryBuilder()
<span class="nc" id="L76">                            .setDaemon(true)</span>
<span class="nc" id="L77">                            .setNameFormat(&quot;LogUnit-Maintenance-%d&quot;)</span>
<span class="nc" id="L78">                            .build());</span>

<span class="nc" id="L80">    ThreadFactory threadFactory = new ServerThreadFactory(&quot;Logunit-&quot;,</span>
            new ServerThreadFactory.ExceptionHandler());

<span class="nc" id="L83">    ExecutorService executor = Executors.newFixedThreadPool(BatchWriter.BATCH_SIZE, threadFactory);</span>

    private ScheduledFuture&lt;?&gt; compactor;

    /**
     * The options map.
     */
    private final Map&lt;String, Object&gt; opts;

    /**
     * Handler for this server.
     */
<span class="nc" id="L95">    @Getter</span>
    private final CorfuMsgHandler handler =
<span class="nc" id="L97">        CorfuMsgHandler.generateHandler(MethodHandles.lookup(), this);</span>

    /**
     * This cache services requests for data at various addresses. In a memory implementation,
     * it is not backed by anything, but in a disk implementation it is backed by persistent
     * storage.
     */
    private final LoadingCache&lt;Long, ILogData&gt; dataCache;
    private final long maxCacheSize;

    private final StreamLog streamLog;

    private final BatchWriter&lt;Long, ILogData&gt; batchWriter;

    /**
     * Returns a new LogUnitServer.
     * @param serverContext context object providing settings and objects
     */
<span class="nc" id="L115">    public LogUnitServer(ServerContext serverContext) {</span>
<span class="nc" id="L116">        this.opts = serverContext.getServerConfig();</span>
<span class="nc" id="L117">        double cacheSizeHeapRatio = Double.parseDouble((String) opts.get(&quot;--cache-heap-ratio&quot;));</span>

<span class="nc" id="L119">        maxCacheSize = (long) (Runtime.getRuntime().maxMemory() * cacheSizeHeapRatio);</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">        if ((Boolean) opts.get(&quot;--memory&quot;)) {</span>
<span class="nc" id="L122">            log.warn(&quot;Log unit opened in-memory mode (Maximum size={}). &quot;</span>
                    + &quot;This should be run for testing purposes only. &quot;
                    + &quot;If you exceed the maximum size of the unit, old entries will be &quot;
                    + &quot;AUTOMATICALLY trimmed. &quot;
                    + &quot;The unit WILL LOSE ALL DATA if it exits.&quot;, Utils
<span class="nc" id="L127">                    .convertToByteStringRepresentation(maxCacheSize));</span>
<span class="nc" id="L128">            streamLog = new InMemoryStreamLog();</span>
        } else {
<span class="nc" id="L130">            streamLog = new StreamLogFiles(serverContext, (Boolean) opts.get(&quot;--no-verify&quot;));</span>
        }

<span class="nc" id="L133">        batchWriter = new BatchWriter(streamLog);</span>

<span class="nc" id="L135">        dataCache = Caffeine.&lt;Long, ILogData&gt;newBuilder()</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                .&lt;Long, ILogData&gt;weigher((k, v) -&gt; ((LogData) v).getData() == null ? 1 : (</span>
<span class="nc" id="L137">                        (LogData) v).getData().length)</span>
<span class="nc" id="L138">                .maximumWeight(maxCacheSize)</span>
<span class="nc" id="L139">                .removalListener(this::handleEviction)</span>
<span class="nc" id="L140">                .writer(batchWriter)</span>
<span class="nc" id="L141">                .build(this::handleRetrieval);</span>

<span class="nc" id="L143">        MetricRegistry metrics = serverContext.getMetrics();</span>
//        MetricsUtils.addCacheGauges(metrics, metricsPrefix + &quot;cache.&quot;, dataCache);

<span class="nc" id="L146">        Runnable task = () -&gt; streamLog.compact();</span>
<span class="nc" id="L147">        compactor = scheduler.scheduleAtFixedRate(task, 10, 45, TimeUnit.MINUTES);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Service an incoming request for maximum global address the log unit server has written.
     */
    @ServerHandler(type = CorfuMsgType.TAIL_REQUEST)
    public void handleTailRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L155">        r.sendResponse(ctx, msg, CorfuMsgType.TAIL_RESPONSE.payloadMsg(streamLog.getGlobalTail()));</span>
<span class="nc" id="L156">    }</span>

    /**
     * Service an incoming request to retrieve the starting address of this logging unit.
     */
    @ServerHandler(type = CorfuMsgType.TRIM_MARK_REQUEST)
    public void handleHeadRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L163">        r.sendResponse(ctx, msg, CorfuMsgType.TRIM_MARK_RESPONSE.payloadMsg(streamLog.getTrimMark()));</span>
<span class="nc" id="L164">    }</span>

    /**
     * Service an incoming write request.
     */
    @ServerHandler(type = CorfuMsgType.WRITE)
    public void write(CorfuPayloadMsg&lt;WriteRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L171">        log.debug(&quot;log write: global: {}, streams: {}, backpointers: {}&quot;, msg</span>
<span class="nc" id="L172">                .getPayload().getGlobalAddress(), msg.getPayload().getData().getBackpointerMap());</span>

        try {
<span class="nc" id="L175">            dataCache.put(msg.getPayload().getGlobalAddress(), msg.getPayload().getData());</span>
<span class="nc" id="L176">            r.sendResponse(ctx, msg, CorfuMsgType.WRITE_OK.msg());</span>

<span class="nc" id="L178">        } catch (OverwriteException ex) {</span>
<span class="nc" id="L179">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_OVERWRITE.msg());</span>
<span class="nc" id="L180">        } catch (DataOutrankedException e) {</span>
<span class="nc" id="L181">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_OUTRANKED.msg());</span>
<span class="nc" id="L182">        } catch (ValueAdoptedException e) {</span>
<span class="nc" id="L183">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_VALUE_ADOPTED.payloadMsg(e</span>
<span class="nc" id="L184">                    .getReadResponse()));</span>
<span class="nc" id="L185">        }</span>
<span class="nc" id="L186">    }</span>

    @ServerHandler(type = CorfuMsgType.READ_REQUEST)
    private void read(CorfuPayloadMsg&lt;ReadRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L190">        log.trace(&quot;read: {}&quot;, msg.getPayload().getRange());</span>
<span class="nc" id="L191">        ReadResponse rr = new ReadResponse();</span>
        try {
<span class="nc" id="L193">            for (Long l = msg.getPayload().getRange().lowerEndpoint();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                    l &lt; msg.getPayload().getRange().upperEndpoint() + 1L; l++) {</span>
<span class="nc" id="L195">                ILogData e = dataCache.get(l);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (e == null) {</span>
<span class="nc" id="L197">                    rr.put(l, LogData.getEmpty(l));</span>
                } else {
<span class="nc" id="L199">                    rr.put(l, (LogData) e);</span>
                }
            }
<span class="nc" id="L202">            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));</span>
<span class="nc" id="L203">        } catch (DataCorruptionException e) {</span>
<span class="nc" id="L204">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());</span>
<span class="nc" id="L205">        }</span>
<span class="nc" id="L206">    }</span>

    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)
    private void multiRead(CorfuPayloadMsg&lt;MultipleReadRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L210">        log.trace(&quot;multiRead: {}&quot;, msg.getPayload().getAddresses());</span>

<span class="nc" id="L212">        ReadResponse rr = new ReadResponse();</span>
        try {
<span class="nc bnc" id="L214" title="All 2 branches missed.">            for (Long l : msg.getPayload().getAddresses()) {</span>
<span class="nc" id="L215">                ILogData e = dataCache.get(l);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                if (e == null) {</span>
<span class="nc" id="L217">                    rr.put(l, LogData.getEmpty(l));</span>
                } else {
<span class="nc" id="L219">                    rr.put(l, (LogData) e);</span>
                }
<span class="nc" id="L221">            }</span>
<span class="nc" id="L222">            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));</span>
<span class="nc" id="L223">        } catch (DataCorruptionException e) {</span>
<span class="nc" id="L224">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());</span>
<span class="nc" id="L225">        }</span>
<span class="nc" id="L226">    }</span>

    @ServerHandler(type = CorfuMsgType.FILL_HOLE)
    private void fillHole(CorfuPayloadMsg&lt;TrimRequest&gt; msg, ChannelHandlerContext ctx,
        IServerRouter r) {
        try {
<span class="nc" id="L232">            long address = msg.getPayload().getAddress();</span>
<span class="nc" id="L233">            dataCache.put(address, LogData.getHole(address));</span>
<span class="nc" id="L234">            r.sendResponse(ctx, msg, CorfuMsgType.WRITE_OK.msg());</span>

<span class="nc" id="L236">        } catch (OverwriteException e) {</span>
<span class="nc" id="L237">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_OVERWRITE.msg());</span>
<span class="nc" id="L238">        } catch (DataOutrankedException e) {</span>
<span class="nc" id="L239">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_OUTRANKED.msg());</span>
<span class="nc" id="L240">        } catch (ValueAdoptedException e) {</span>

<span class="nc" id="L242">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_VALUE_ADOPTED.payloadMsg(e</span>
<span class="nc" id="L243">                    .getReadResponse()));</span>
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">    }</span>

    @ServerHandler(type = CorfuMsgType.TRIM)
    private void trim(CorfuPayloadMsg&lt;TrimRequest&gt; msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L249">        batchWriter.trim(msg.getPayload().getAddress());</span>
        //TODO(Maithem): should we return an error if the write fails
<span class="nc" id="L251">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L252">    }</span>

    @ServerHandler(type = CorfuMsgType.PREFIX_TRIM)
    private void prefixTrim(CorfuPayloadMsg&lt;TrimRequest&gt; msg, ChannelHandlerContext ctx,
                            IServerRouter r) {
        try {
<span class="nc" id="L258">            batchWriter.prefixTrim(msg.getPayload().getAddress());</span>
<span class="nc" id="L259">            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L260">        } catch (TrimmedException ex) {</span>
<span class="nc" id="L261">            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_TRIMMED.msg());</span>
<span class="nc" id="L262">        }</span>
<span class="nc" id="L263">    }</span>

    @ServerHandler(type = CorfuMsgType.COMPACT_REQUEST)
    private void compact(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
        try {
<span class="nc" id="L268">            streamLog.compact();</span>
<span class="nc" id="L269">            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L270">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L271">            log.error(&quot;Internal Error&quot;);</span>
            //TODO(Maithem) Need an internal error return type
<span class="nc" id="L273">            r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L274">        }</span>
<span class="nc" id="L275">    }</span>

    @ServerHandler(type = CorfuMsgType.FLUSH_CACHE)
    private void flushCache(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
        try {
<span class="nc" id="L280">            dataCache.invalidateAll();</span>
<span class="nc" id="L281">        } catch (RuntimeException e) {</span>
<span class="nc" id="L282">            log.error(&quot;Encountered error while flushing cache {}&quot;, e);</span>
<span class="nc" id="L283">        }</span>
<span class="nc" id="L284">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L285">    }</span>


    /**
     * Services incoming range write calls.
     */
    @ServerHandler(type = CorfuMsgType.RANGE_WRITE)
    private void rangeWrite(CorfuPayloadMsg&lt;RangeWriteMsg&gt; msg,
                                  ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L294">        List&lt;LogData&gt; entries = msg.getPayload().getEntries();</span>
<span class="nc" id="L295">        batchWriter.bulkWrite(entries);</span>
<span class="nc" id="L296">        r.sendResponse(ctx, msg, CorfuMsgType.WRITE_OK.msg());</span>
<span class="nc" id="L297">    }</span>

    /**
     * Resets the log unit server.
     * Warning: Clears all data.
     */
    @ServerHandler(type = CorfuMsgType.RESET_LOGUNIT)
    private void resetLogUnit(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L305">        streamLog.reset();</span>
<span class="nc" id="L306">        dataCache.invalidateAll();</span>
<span class="nc" id="L307">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L308">    }</span>

    /**
     * Retrieve the LogUnitEntry from disk, given an address.
     *
     * @param address The address to retrieve the entry from.
     * @return The log unit entry to retrieve into the cache.
     *
     *     This function should not care about trimmed addresses, as that is handled in
     *     the read() and append(). Any address that cannot be retrieved should be returned as
     *     unwritten (null).
     */
    public synchronized ILogData handleRetrieval(long address) {
<span class="nc" id="L321">        LogData entry = streamLog.read(address);</span>
<span class="nc" id="L322">        log.trace(&quot;Retrieved[{} : {}]&quot;, address, entry);</span>
<span class="nc" id="L323">        return entry;</span>
    }


    public synchronized void handleEviction(long address, ILogData entry, RemovalCause cause) {
<span class="nc" id="L328">        log.trace(&quot;Eviction[{}]: {}&quot;, address, cause);</span>
<span class="nc" id="L329">        streamLog.release(address, (LogData) entry);</span>
<span class="nc" id="L330">    }</span>

    @Override
    public ExecutorService getExecutor() {
<span class="nc" id="L334">        return executor;</span>
    }

    /**
     * Shutdown the server.
     */
    @Override
    public void shutdown() {
<span class="nc" id="L342">        compactor.cancel(true);</span>
<span class="nc" id="L343">        scheduler.shutdownNow();</span>
<span class="nc" id="L344">        batchWriter.close();</span>
<span class="nc" id="L345">        executor.shutdownNow();</span>
<span class="nc" id="L346">    }</span>

    @VisibleForTesting
    public LoadingCache&lt;Long, ILogData&gt; getDataCache() {
<span class="nc" id="L350">        return dataCache;</span>
    }

    @VisibleForTesting
    long getMaxCacheSize() {
<span class="nc" id="L355">        return maxCacheSize;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>