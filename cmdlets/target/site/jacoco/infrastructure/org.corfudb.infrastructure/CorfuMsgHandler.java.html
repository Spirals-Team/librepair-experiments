<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CorfuMsgHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cmdlets</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">CorfuMsgHandler.java</span></div><h1>CorfuMsgHandler.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import com.codahale.metrics.Timer;
import io.netty.channel.ChannelHandlerContext;
import lombok.extern.slf4j.Slf4j;
import org.corfudb.protocols.wireprotocol.CorfuMsg;
import org.corfudb.protocols.wireprotocol.CorfuMsgType;
import org.corfudb.protocols.wireprotocol.ExceptionMsg;
import org.corfudb.runtime.exceptions.unrecoverable.UnrecoverableCorfuError;
import org.corfudb.util.MetricsUtils;

import javax.annotation.Nonnull;
import java.lang.invoke.LambdaMetafactory;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;

/**
 * This class implements message handlers for {@link AbstractServer} implementations.
 * Servers define methods with signatures which follow the signature of the {@link Handler}
 * functional interface, and generate a handler using the
 * {@link this#generateHandler(MethodHandles.Lookup, AbstractServer)} method.
 *
 * &lt;p&gt;For maximum performance, make the handlers static whenever possible.
 * Handlers should be as short as possible (not block), since handler threads come from a
 * shared pool used by all servers. Blocking operations should be offloaded to I/O threads.
 *
 * &lt;p&gt;Created by mwei on 7/26/16.
 */
<span class="nc" id="L36">@Slf4j</span>
public class CorfuMsgHandler {

    private static final String CORFU_INFRASTRUCTURE_PREFIX = &quot;corfu.infrastructure.message-handler.&quot;;

    /**
     * A functional interface for server message handlers. Server message handlers should
     * be fast and not block. If a handler blocks for an extended period of time, it will
     * exhaust the server's thread pool. I/O and other long operations should be handled
     * on another thread.
     */
    @FunctionalInterface
    interface Handler&lt;T extends CorfuMsg&gt; {
        void handle(@Nonnull T corfuMsg,
                    @Nonnull ChannelHandlerContext ctx,
                    @Nonnull IServerRouter r);
    }

    /** The handler map. */
    private Map&lt;CorfuMsgType, Handler&gt; handlerMap;

    /** Get the types this handler will handle.
     *
     * @return  A set containing the types this handler will handle.
     */
    public Set&lt;CorfuMsgType&gt; getHandledTypes() {
<span class="nc" id="L62">        return handlerMap.keySet();</span>
    }

    /** Get a handler for a specific message type.
     *
     * @param type  The type to retrieve a handler for.
     * @return      A handler for the requested message type.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Handler&lt;CorfuMsg&gt; getHandler(CorfuMsgType type) {
<span class="nc" id="L72">        return handlerMap.get(type);</span>
    }

    /** Construct a new instance of CorfuMsgHandler. */
<span class="nc" id="L76">    public CorfuMsgHandler() {</span>
<span class="nc" id="L77">        handlerMap = new EnumMap&lt;&gt;(CorfuMsgType.class);</span>
<span class="nc" id="L78">    }</span>

    /** Add a handler to this message handler.
     *
     * @param messageType       The type of CorfuMsg this handler will handle.
     * @param handler           The handler itself.
     * @param &lt;T&gt;               A CorfuMsg type.
     * @return                  This handler, to support chaining.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends CorfuMsg&gt; CorfuMsgHandler addHandler(CorfuMsgType messageType,
                                                           Handler&lt;T&gt; handler) {
<span class="nc" id="L90">        handlerMap.put(messageType, handler);</span>
<span class="nc" id="L91">        return this;</span>
    }

    /** Handle an incoming CorfuMsg.
     *
     * @param message   The message to handle.
     * @param ctx       The channel handler context.
     * @param r         The server router.
     * @return          True, if the message was handled.
     *                  False otherwise.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public boolean handle(CorfuMsg message, ChannelHandlerContext ctx, IServerRouter r) {
        // Get the handler for the message type
<span class="nc" id="L105">        final Handler&lt;CorfuMsg&gt; handler = handlerMap.get(message.getMsgType());</span>
        // If present...
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (handler != null) {</span>
            try {
<span class="nc" id="L109">                handler.handle(message, ctx, r);</span>
<span class="nc" id="L110">            } catch (Exception ex) {</span>
                // Log the exception during handling
<span class="nc" id="L112">                log.error(&quot;handle: Unhandled exception processing {} message&quot;,</span>
<span class="nc" id="L113">                        message.getMsgType(), ex);</span>
<span class="nc" id="L114">                r.sendResponse(ctx, message,</span>
<span class="nc" id="L115">                        CorfuMsgType.ERROR_SERVER_EXCEPTION.payloadMsg(new ExceptionMsg(ex)));</span>
<span class="nc" id="L116">            }</span>
            // Otherwise log the unexpected message.
        } else {
<span class="nc" id="L119">            log.error(&quot;handle: Unregistered message type {}&quot;, message.getMsgType());</span>
        }

<span class="nc bnc" id="L122" title="All 2 branches missed.">        return handler != null;</span>
    }

    /** Generate handlers for a particular server.
     *
     * @param caller    The context that is being used. Call MethodHandles.lookup() to obtain.
     * @param server    The object that implements the server.
     * @return          New message handler for caller class
     */
    public static CorfuMsgHandler generateHandler(@Nonnull final MethodHandles.Lookup caller,
            @Nonnull final AbstractServer server) {
<span class="nc" id="L133">        CorfuMsgHandler handler = new CorfuMsgHandler();</span>
<span class="nc" id="L134">        Arrays.stream(server.getClass().getDeclaredMethods())</span>
<span class="nc" id="L135">            .filter(method -&gt; method.isAnnotationPresent(ServerHandler.class))</span>
<span class="nc" id="L136">            .forEach(method -&gt; handler.registerMethod(caller, server, method));</span>
<span class="nc" id="L137">        return handler;</span>
    }



    /** Takes a method annotated with the {@link org.corfudb.infrastructure.ServerHandler}
     *  annotation, converts it into a lambda, and registers it in the {@code handlerMap}.
     * @param caller   The context that is being used. Call MethodHandles.lookup() to obtain.
     * @param server   The object that implements the server.
     * @param method   The method to be registered. Must be annotated with the
     *                 {@link ServerHandler} annotation.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void registerMethod(@Nonnull final MethodHandles.Lookup caller,
            @Nonnull final AbstractServer server,
            @Nonnull final Method method) {
<span class="nc" id="L153">        final ServerHandler annotation = method.getAnnotation(ServerHandler.class);</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (!method.getParameterTypes()[0].isAssignableFrom(annotation.type().messageType</span>
<span class="nc" id="L156">                .getRawType())) {</span>
<span class="nc" id="L157">            throw new UnrecoverableCorfuError(&quot;Incorrect message type, expected &quot;</span>
<span class="nc" id="L158">                + annotation.type().messageType.getRawType() + &quot; but provided &quot;</span>
<span class="nc" id="L159">                + method.getParameterTypes()[0]);</span>
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (handlerMap.containsKey(annotation.type())) {</span>
<span class="nc" id="L162">            throw new UnrecoverableCorfuError(&quot;Handler for &quot; + annotation.type()</span>
                + &quot; already registered!&quot;);
        }
        // convert the method into a Java8 Lambda for maximum execution speed...
        try {
            Handler&lt;CorfuMsg&gt; h;
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (Modifier.isStatic(method.getModifiers())) {</span>
<span class="nc" id="L169">                MethodHandle mh = caller.unreflect(method);</span>
<span class="nc" id="L170">                MethodType mt = mh.type().changeParameterType(0, CorfuMsg.class);</span>
<span class="nc" id="L171">                h = (Handler&lt;CorfuMsg&gt;) LambdaMetafactory.metafactory(caller,</span>
<span class="nc" id="L172">                    &quot;handle&quot;, MethodType.methodType(Handler.class),</span>
<span class="nc" id="L173">                    mt, mh, mh.type())</span>
<span class="nc" id="L174">                    .getTarget().invokeExact();</span>

<span class="nc" id="L176">            } else {</span>
                // instance method, so we need to capture the type.
<span class="nc" id="L178">                MethodType mt = MethodType.methodType(method.getReturnType(),</span>
<span class="nc" id="L179">                        method.getParameterTypes());</span>
<span class="nc" id="L180">                MethodHandle mh = caller.findVirtual(server.getClass(), method.getName(), mt);</span>
<span class="nc" id="L181">                MethodType mtGeneric = mh.type().changeParameterType(1, CorfuMsg.class);</span>
<span class="nc" id="L182">                h = (Handler&lt;CorfuMsg&gt;) LambdaMetafactory.metafactory(caller,</span>
                    &quot;handle&quot;,
<span class="nc" id="L184">                    MethodType.methodType(Handler.class, server.getClass()),</span>
<span class="nc" id="L185">                    mtGeneric.dropParameterTypes(0, 1), mh,</span>
<span class="nc" id="L186">                    mh.type().dropParameterTypes(0, 1)).getTarget()</span>
<span class="nc" id="L187">                    .bindTo(server).invoke();</span>
            }
            // Install pre-conditions on handler
<span class="nc" id="L190">            final Handler&lt;CorfuMsg&gt; handler =</span>
<span class="nc" id="L191">                    generateConditionalHandler(server, annotation.type(), h);</span>
            // Install the handler in the map
<span class="nc" id="L193">            handlerMap.put(annotation.type(), handler);</span>
<span class="nc" id="L194">        } catch (Throwable e) {</span>
<span class="nc" id="L195">            log.error(&quot;Exception during message handler registration&quot;, e);</span>
<span class="nc" id="L196">            throw new UnrecoverableCorfuError(e);</span>

<span class="nc" id="L198">        }</span>
<span class="nc" id="L199">    }</span>

    /** Generate a conditional handler, which instruments the handler with metrics if enabled
     *  and checks whether the server is shutdown and ready.
     * @param server        The {@link AbstractServer} the message is being handled for.
     * @param type          The {@link CorfuMsgType} the message is being handled for.
     * @param handler       The {@link Handler} which handles the message.
     * @return              A new {@link Handler} which conditionally executes the handler
     *                      based on preconditions (whether the server is shutdown/ready).
     */
    private Handler&lt;CorfuMsg&gt; generateConditionalHandler(@Nonnull final AbstractServer server,
            @Nonnull final CorfuMsgType type,
            @Nonnull final Handler&lt;CorfuMsg&gt; handler) {
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (!MetricsUtils.isMetricsCollectionEnabled()) {</span>
            // If metrics are disabled, register the handler without instrumentation.
<span class="nc" id="L214">            return (msg, ctx, r) -&gt; {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (server.isShutdown()) {</span>
<span class="nc" id="L216">                    log.warn(&quot;Server received {} but is shutdown.&quot;, msg.getMsgType().toString());</span>
<span class="nc" id="L217">                    r.sendResponse(ctx, msg, CorfuMsgType.ERROR_SHUTDOWN_EXCEPTION.msg());</span>
<span class="nc" id="L218">                    return;</span>
                }

<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (!server.isServerReadyToHandleMsg(msg)) {</span>
<span class="nc" id="L222">                    r.sendResponse(ctx, msg, CorfuMsgType.NOT_READY.msg());</span>
<span class="nc" id="L223">                    return;</span>
                }

<span class="nc" id="L226">                handler.handle(msg, ctx, r);</span>
<span class="nc" id="L227">            };</span>
        } else {
            // Otherwise, generate a timer based on the operation name
<span class="nc" id="L230">            final Timer timer = ServerContext.getMetrics()</span>
<span class="nc" id="L231">                    .timer(CORFU_INFRASTRUCTURE_PREFIX + type.toString().toLowerCase());</span>
            // And wrap the handler around a new lambda which measures the execution time.
<span class="nc" id="L233">            return (msg, ctx, r) -&gt; {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (server.isShutdown()) {</span>
<span class="nc" id="L235">                    log.warn(&quot;Server received {} but is shutdown.&quot;, msg.getMsgType().toString());</span>
<span class="nc" id="L236">                    r.sendResponse(ctx, msg, CorfuMsgType.ERROR_SHUTDOWN_EXCEPTION.msg());</span>
<span class="nc" id="L237">                    return;</span>
                }

<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (!server.isServerReadyToHandleMsg(msg)) {</span>
<span class="nc" id="L241">                    r.sendResponse(ctx, msg, CorfuMsgType.NOT_READY.msg());</span>
<span class="nc" id="L242">                    return;</span>
                }

<span class="nc" id="L245">                try (Timer.Context context = MetricsUtils.getConditionalContext(timer)) {</span>
<span class="nc" id="L246">                    handler.handle(msg, ctx, r);</span>
<span class="nc bnc" id="L247" title="All 8 branches missed.">                }</span>
<span class="nc" id="L248">            };</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>