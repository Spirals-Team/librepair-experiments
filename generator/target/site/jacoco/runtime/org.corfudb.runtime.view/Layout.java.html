<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Layout.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">generator</a> &gt; <a href="../index.html" class="el_bundle">runtime</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.runtime.view</a> &gt; <span class="el_source">Layout.java</span></div><h1>Layout.java</h1><pre class="source lang-java linenums">package org.corfudb.runtime.view;

import static java.util.Objects.requireNonNull;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

import javax.annotation.Nullable;
import lombok.Data;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.exceptions.QuorumUnreachableException;
import org.corfudb.runtime.view.ClusterStatusReport.ClusterStatus;
import org.corfudb.runtime.view.replication.ChainReplicationProtocol;
import org.corfudb.runtime.view.replication.IReplicationProtocol;
import org.corfudb.runtime.view.replication.NeverHoleFillPolicy;
import org.corfudb.runtime.view.replication.QuorumReplicationProtocol;
import org.corfudb.runtime.view.replication.ReadWaitHoleFillPolicy;
import org.corfudb.runtime.view.stream.BackpointerStreamView;
import org.corfudb.runtime.view.stream.IStreamView;

/**
 * This class represents the layout of a Corfu instance.
 * Created by mwei on 12/8/15.
 */
<span class="nc bnc" id="L40" title="All 48 branches missed.">@Data</span>
public class Layout {
    /**
     * A Gson parser.
     */
<span class="nc" id="L45">    @Getter</span>
<span class="nc" id="L46">    static final Gson parser = new GsonBuilder()</span>
<span class="nc" id="L47">            .registerTypeAdapter(Layout.class, new LayoutDeserializer())</span>
<span class="nc" id="L48">            .create();</span>
    /**
     * A list of layout servers in the layout.
     */
<span class="nc" id="L52">    @Getter</span>
    List&lt;String&gt; layoutServers;
    /**
     * A list of sequencers in the layout.
     */
<span class="nc" id="L57">    @Getter</span>
    List&lt;String&gt; sequencers;
    /**
     * A list of the segments in the layout.
     */
<span class="nc" id="L62">    @Getter</span>
    List&lt;LayoutSegment&gt; segments;
    /**
     * A list of unresponsive nodes in the layout.
     */
<span class="nc" id="L67">    @Getter</span>
    List&lt;String&gt; unresponsiveServers;
    /**
     * The epoch of this layout.
     */
<span class="nc" id="L72">    @Getter</span>
<span class="nc" id="L73">    @Setter</span>
    long epoch;

    /**
     * Invalid epoch value.
     * Is used to fetch layout(epoch agnostic request) by the corfuRuntime.
     */
    public static final long INVALID_EPOCH = -1L;

    /** The unique Id for the Corfu cluster represented by this layout.
     *  Should remain consistent for the lifetime of the layout. May be
     *  {@code null} in a legacy layout.
     */
<span class="nc" id="L86">    @Getter</span>
    UUID clusterId;

    /**
     * Defensive constructor since we can create a Layout from a JSON file.
     * JSON deserialize is forced through this constructor.
     */
<span class="nc bnc" id="L93" title="All 4 branches missed.">    public Layout(@NonNull List&lt;String&gt; layoutServers, @NonNull List&lt;String&gt; sequencers,</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">                  @NonNull List&lt;LayoutSegment&gt; segments, @NonNull List&lt;String&gt; unresponsiveServers,</span>
<span class="nc" id="L95">                  long epoch, @Nullable UUID clusterId) {</span>

<span class="nc" id="L97">        this.layoutServers = layoutServers;</span>
<span class="nc" id="L98">        this.sequencers = sequencers;</span>
<span class="nc" id="L99">        this.segments = segments;</span>
<span class="nc" id="L100">        this.unresponsiveServers = unresponsiveServers;</span>
<span class="nc" id="L101">        this.epoch = epoch;</span>
<span class="nc" id="L102">        this.clusterId = clusterId;</span>

        /* Assert that we constructed a valid Layout */
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (this.layoutServers.size() == 0) {</span>
<span class="nc" id="L106">            throw new IllegalArgumentException(&quot;Empty list of LayoutServers&quot;);</span>
        }
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (this.sequencers.size() == 0) {</span>
<span class="nc" id="L109">            throw new IllegalArgumentException(&quot;Empty list of Sequencers&quot;);</span>
        }
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (this.segments.size() == 0) {</span>
<span class="nc" id="L112">            throw new IllegalArgumentException(&quot;Empty list of segments&quot;);</span>
        }
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for (Layout.LayoutSegment segment : segments) {</span>
<span class="nc" id="L115">            requireNonNull(segment.stripes);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (segment.stripes.size() == 0) {</span>
<span class="nc" id="L117">                throw new IllegalArgumentException(&quot;One segment has an empty list of stripes&quot;);</span>
            }
<span class="nc" id="L119">        }</span>
<span class="nc" id="L120">    }</span>

    public Layout(List&lt;String&gt; layoutServers, List&lt;String&gt; sequencers, List&lt;LayoutSegment&gt; segments,
                  long epoch, UUID clusterId) {
<span class="nc" id="L124">        this(layoutServers, sequencers, segments, new ArrayList&lt;String&gt;(), epoch, clusterId);</span>
<span class="nc" id="L125">    }</span>

    /**
     * Get a layout from a JSON string.
     */
    @SuppressWarnings({&quot;checkstyle:abbreviation&quot;})
    public static Layout fromJSONString(String json) {
        /* Empty Json file creates an null Layout */
<span class="nc" id="L133">        return requireNonNull(parser.fromJson(json, Layout.class));</span>
    }

    /**
     * Return all the segments that an endpoint participates in.
     * @param endpoint the endpoint to return all the segments for
     * @return a set of segments that contain the endpoint
     */
    public List&lt;LayoutSegment&gt; getSegmentsForEndpoint(@Nonnull String endpoint) {
<span class="nc" id="L142">        List&lt;LayoutSegment&gt; res = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">        for (LayoutSegment segment : getSegments()) {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">            for (LayoutStripe stripe : segment.getStripes()) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                if (stripe.getLogServers().contains(endpoint)) {</span>
<span class="nc" id="L147">                    res.add(segment);</span>
                }
<span class="nc" id="L149">            }</span>
<span class="nc" id="L150">        }</span>

<span class="nc" id="L152">        return res;</span>
    }

    /**
     * This function returns a set of all active servers in the layout.
     *
     * @return A set containing all servers in the layout.
     */
    public Set&lt;String&gt; getAllActiveServers() {
<span class="nc" id="L161">        Set&lt;String&gt; activeServers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L162">        activeServers.addAll(layoutServers);</span>
<span class="nc" id="L163">        activeServers.addAll(sequencers);</span>
<span class="nc" id="L164">        segments.forEach(x -&gt;</span>
<span class="nc" id="L165">                x.getStripes().forEach(y -&gt;</span>
<span class="nc" id="L166">                        activeServers.addAll(y.getLogServers())));</span>
<span class="nc" id="L167">        activeServers.removeAll(unresponsiveServers);</span>
<span class="nc" id="L168">        return activeServers;</span>
    }

    /**
     * This function returns a set of all servers in the layout.
     *
     * @return A set of all servers in the layout.
     */
    public Set&lt;String&gt; getAllServers() {
<span class="nc" id="L177">        Set&lt;String&gt; allServers = new HashSet&lt;&gt;();</span>
<span class="nc" id="L178">        allServers.addAll(getAllActiveServers());</span>
<span class="nc" id="L179">        allServers.addAll(unresponsiveServers);</span>
<span class="nc" id="L180">        return allServers;</span>
    }

    /**
     * Returns the primary sequencer.
     *
     * @return The primary sequencer.
     */
    public String getPrimarySequencer() {
<span class="nc" id="L189">        return sequencers.get(0);</span>
    }

    /**
     * Given the log's global address, return equivalent local address for a striped log segment.
     *
     * @param globalAddress The global address
     */
    public long getLocalAddress(long globalAddress) {
<span class="nc bnc" id="L198" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L199" title="All 6 branches missed.">            if (ls.start &lt;= globalAddress &amp;&amp; (ls.end &gt; globalAddress || ls.end == -1)) {</span>
                // TODO: this does not account for shifting segments.
<span class="nc" id="L201">                return globalAddress / ls.getNumberOfStripes();</span>
            }
<span class="nc" id="L203">        }</span>
<span class="nc" id="L204">        throw new RuntimeException(&quot;Unmapped address!&quot;);</span>
    }

    /**
     * Return global address for a given stripe.
     *
     * @param stripe The layout stripe.
     * @param localAddress The local address.
     */
    public long getGlobalAddress(LayoutStripe stripe, long localAddress) {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (ls.getStripes().contains(stripe)) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                for (int i = 0; i &lt; ls.getNumberOfStripes(); i++) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                    if (ls.getStripes().get(i).equals(stripe)) {</span>
<span class="nc" id="L218">                        return (localAddress * ls.getNumberOfStripes()) + i;</span>
                    }
                }
            }
<span class="nc" id="L222">        }</span>
<span class="nc" id="L223">        throw new RuntimeException(&quot;Unmapped address!&quot;);</span>
    }

    /** Return a list of segments which contain global
     * addresses less than or equal to the given address
     * (known as the prefix).
     *
     * @param globalAddress The global address prefix
     *                      to use.
     * @return              A list of segments which
     *                      contain addresses less than
     *                      or equal to the global
     *                      address.
     */
    public @Nonnull List&lt;LayoutSegment&gt; getPrefixSegments(long globalAddress) {
<span class="nc" id="L238">        return segments.stream()</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                .filter(p -&gt; p.getEnd() &lt;= globalAddress)</span>
<span class="nc" id="L240">                .collect(Collectors.toList());</span>
    }

    /**
     * Return layout segment stripe.
     *
     * @param globalAddress The global address.
     */
    public LayoutStripe getStripe(long globalAddress) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L250" title="All 6 branches missed.">            if (ls.start &lt;= globalAddress &amp;&amp; (ls.end &gt; globalAddress || ls.end == -1)) {</span>
                // TODO: this does not account for shifting segments.
<span class="nc" id="L252">                return ls.getStripes().get((int) (globalAddress % ls.getNumberOfStripes()));</span>
            }
<span class="nc" id="L254">        }</span>
<span class="nc" id="L255">        throw new RuntimeException(&quot;Unmapped address!&quot;);</span>
    }

    /**
     * Return layout segment.
     *
     * @param globalAddress The global address.
     */
    public LayoutSegment getSegment(long globalAddress) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L265" title="All 6 branches missed.">            if (ls.start &lt;= globalAddress &amp;&amp; (ls.end &gt; globalAddress || ls.end == -1)) {</span>
<span class="nc" id="L266">                return ls;</span>
            }
<span class="nc" id="L268">        }</span>
<span class="nc" id="L269">        throw new RuntimeException(&quot;Unmapped address &quot; + Long.toString(globalAddress) + &quot;!&quot;);</span>
    }

    /**
     * Get the length of a segment at a particular address.
     *
     * @param address The address to check.
     * @return The length (number of servers) of that segment, or 0 if empty.
     */
    public int getSegmentLength(long address) {
<span class="nc" id="L279">        return getStripe(address).getLogServers().size();</span>
    }

    /**
     * Get the replication mode of a segment at a particular address.
     *
     * @param address The address to check.
     * @return The replication mode of the segment, or null if empty.
     */
    public ReplicationMode getReplicationMode(long address) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (LayoutSegment ls : segments) {</span>
<span class="nc bnc" id="L290" title="All 6 branches missed.">            if (ls.start &lt;= address &amp;&amp; (ls.end &gt; address || ls.end == -1)) {</span>
<span class="nc" id="L291">                return ls.getReplicationMode();</span>
            }
<span class="nc" id="L293">        }</span>
<span class="nc" id="L294">        return null;</span>
    }

    /**
     * Get the layout as a JSON string.
     */
    @SuppressWarnings({&quot;checkstyle:abbreviation&quot;})
    public String asJSONString() {
<span class="nc" id="L302">        return parser.toJson(this);</span>
    }

    /**
     *
     * Layout copy constructor.
     *
     * @param layout layout to copy
     */
<span class="nc" id="L311">    public Layout(@Nonnull Layout layout) {</span>
<span class="nc" id="L312">        Layout layoutCopy = parser.fromJson(layout.asJSONString(), Layout.class);</span>
<span class="nc" id="L313">        this.layoutServers = layoutCopy.getLayoutServers();</span>
<span class="nc" id="L314">        this.sequencers = layoutCopy.getSequencers();</span>
<span class="nc" id="L315">        this.segments = layoutCopy.getSegments();</span>
<span class="nc" id="L316">        this.unresponsiveServers = layoutCopy.getUnresponsiveServers();</span>
<span class="nc" id="L317">        this.epoch = layoutCopy.getEpoch();</span>
<span class="nc" id="L318">        this.clusterId = layoutCopy.clusterId;</span>
<span class="nc" id="L319">    }</span>

<span class="nc" id="L321">    public enum ReplicationMode {</span>
<span class="nc" id="L322">        CHAIN_REPLICATION {</span>
            @Override
            public void validateSegmentSeal(LayoutSegment layoutSegment,
                                            Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                    completableFutureMap)
                    throws QuorumUnreachableException {
<span class="nc" id="L328">                SealServersHelper.waitForChainSegmentSeal(layoutSegment, completableFutureMap);</span>
<span class="nc" id="L329">            }</span>

            @Override
            public int getMinReplicationFactor(Layout layout) {
<span class="nc" id="L333">                return 2;</span>
            }

            @Override
            public IStreamView  getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L338">                return new BackpointerStreamView(r, streamId, options);</span>
            }

            @Override
            public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (r.getParameters().isHoleFillingDisabled()) {</span>
<span class="nc" id="L344">                    return new ChainReplicationProtocol(new NeverHoleFillPolicy(100));</span>
                } else {
<span class="nc" id="L346">                    return new ChainReplicationProtocol(new ReadWaitHoleFillPolicy(100,</span>
<span class="nc" id="L347">                            r.getParameters().getHoleFillRetry()));</span>
                }
            }

            @Override
            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,
                                                            Set&lt;String&gt; responsiveNodes) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">                return !responsiveNodes.containsAll(layoutSegment.getAllLogServers())</span>
                        ? ClusterStatus.UNAVAILABLE : ClusterStatus.STABLE;
            }
        },
<span class="nc" id="L358">        QUORUM_REPLICATION {</span>
            @Override
            public void validateSegmentSeal(LayoutSegment layoutSegment,
                                            Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                    completableFutureMap)
                    throws QuorumUnreachableException {
                //TODO: Take care of log unit servers which were not sealed.
<span class="nc" id="L365">                SealServersHelper.waitForQuorumSegmentSeal(layoutSegment, completableFutureMap);</span>
<span class="nc" id="L366">            }</span>

            @Override
            public int getMinReplicationFactor(Layout layout) {
<span class="nc" id="L370">                return (layout.getLayoutServers().size() / 2) + 1;</span>
            }

            @Override
            public IStreamView getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L375">                return new BackpointerStreamView(r, streamId, options);</span>
            }

            @Override
            public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {
<span class="nc bnc" id="L380" title="All 2 branches missed.">                if (r.getParameters().isHoleFillingDisabled()) {</span>
<span class="nc" id="L381">                    return new QuorumReplicationProtocol(new NeverHoleFillPolicy(100));</span>
                } else {
<span class="nc" id="L383">                    return new QuorumReplicationProtocol(new ReadWaitHoleFillPolicy(100,</span>
<span class="nc" id="L384">                            r.getParameters().getHoleFillRetry()));</span>
                }
            }

            @Override
            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,
                                                            Set&lt;String&gt; responsiveNodes) {
<span class="nc" id="L391">                ClusterStatus clusterStatus = ClusterStatus.STABLE;</span>
                // At least a quorum of nodes should be reachable in every stripe for the cluster
                // to be STABLE.
<span class="nc bnc" id="L394" title="All 2 branches missed.">                for (LayoutStripe layoutStripe : layoutSegment.getStripes()) {</span>
<span class="nc" id="L395">                    List&lt;String&gt; responsiveLogServers</span>
<span class="nc" id="L396">                            = new ArrayList&lt;&gt;(layoutStripe.getLogServers());</span>
                    // Retain only the responsive servers.
<span class="nc" id="L398">                    responsiveLogServers.retainAll(responsiveNodes);</span>

<span class="nc bnc" id="L400" title="All 2 branches missed.">                    if (!responsiveLogServers.containsAll(layoutStripe.getLogServers())) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                        if (clusterStatus.equals(ClusterStatus.STABLE)) {</span>
<span class="nc" id="L402">                            clusterStatus = ClusterStatus.DEGRADED;</span>
                        }
<span class="nc" id="L404">                        int quorumSize = (layoutStripe.getLogServers().size() / 2) + 1;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                        if (responsiveLogServers.size() &lt; quorumSize) {</span>
<span class="nc" id="L406">                            clusterStatus = ClusterStatus.UNAVAILABLE;</span>
<span class="nc" id="L407">                            break;</span>
                        }
                    }
<span class="nc" id="L410">                }</span>
<span class="nc" id="L411">                return clusterStatus;</span>
            }

<span class="nc" id="L414">        }, NO_REPLICATION {</span>
            @Override
            public void validateSegmentSeal(LayoutSegment layoutSegment,
                                            Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                    completableFutureMap)
                    throws QuorumUnreachableException {
<span class="nc" id="L420">                throw new UnsupportedOperationException(&quot;unsupported seal&quot;);</span>
            }

            @Override
            public int getMinReplicationFactor(Layout layout) {
<span class="nc" id="L425">                return 1;</span>
            }

            @Override
            public IStreamView getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options) {
<span class="nc" id="L430">                throw new UnsupportedOperationException(&quot;Stream view used without a&quot;</span>
                        + &quot; replication mode&quot;);
            }

            @Override
            public ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment,
                                                            Set&lt;String&gt; responsiveNodes) {
<span class="nc" id="L437">                throw new UnsupportedOperationException(&quot;Unsupported cluster health check.&quot;);</span>
            }
        };

        /**
         * Seals the layout segment.
         */
        public abstract void validateSegmentSeal(LayoutSegment layoutSegment,
                                                 Map&lt;String, CompletableFuture&lt;Boolean&gt;&gt;
                                                         completableFutureMap)
                throws QuorumUnreachableException;

        /**
         * Compute the min replication factor for replication protocol
         *
         * @param layout the layout to compute the min replication factor for
         * @return the minimum amount of nodes required to maintain replication
         */
        public abstract int getMinReplicationFactor(Layout layout);

        public abstract IStreamView getStreamView(CorfuRuntime r, UUID streamId, StreamOptions options);

        public IReplicationProtocol getReplicationProtocol(CorfuRuntime r) {
<span class="nc" id="L460">            throw new UnsupportedOperationException();</span>
        }

        /**
         * Returns the health of the cluster for a given segment.
         *
         * @param layoutSegment   Layout Segment
         * @param responsiveNodes Set of all responsive nodes.
         * @return Cluster Health.
         */
        public abstract ClusterStatus getClusterHealthForSegment(LayoutSegment layoutSegment, Set&lt;String&gt; responsiveNodes);
    }


<span class="nc bnc" id="L474" title="All 26 branches missed.">    @Data</span>
    @Getter
<span class="nc" id="L476">    @Setter</span>
    public static class LayoutSegment {
        /**
         * The replication mode of the segment.
         */
<span class="nc" id="L481">        ReplicationMode replicationMode;</span>

        /**
         * The address the layout segment starts at. (included in the segment)
         */
<span class="nc" id="L486">        long start;</span>

        /**
         * The address the layout segment ends at. (excluded from the segment)
         */
<span class="nc" id="L491">        long end;</span>

        /**
         * A list of log servers for this segment.
         */
<span class="nc" id="L496">        List&lt;LayoutStripe&gt; stripes;</span>

        /**
         * Constructor Layout Segment, contiguous partition in a Corfu Log.
         *
         * &lt;p&gt;For example, [1...100], [101...200], [201...), where the last segment is active and
         * open ended.&lt;/p&gt;
         *
         * @param replicationMode The layout segment replication mode.
         * @param start The start address for layout segment (e.g., 1).
         * @param end  The end address for layout segment. (e.g., 100)
         * @param stripes List of stripes for layout segment.
         */
<span class="nc bnc" id="L509" title="All 2 branches missed.">        public LayoutSegment(@NonNull ReplicationMode replicationMode, long start, long end,</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                             @NonNull List&lt;LayoutStripe&gt; stripes) {</span>
<span class="nc" id="L511">            this.replicationMode = replicationMode;</span>
<span class="nc" id="L512">            this.start = start;</span>
<span class="nc" id="L513">            this.end = end;</span>
<span class="nc" id="L514">            this.stripes = stripes;</span>

<span class="nc" id="L516">        }</span>

        public int getNumberOfStripes() {
<span class="nc" id="L519">            return stripes.size();</span>
        }

        /**
         * Get all servers from all stripes present in this segment.
         *
         * @return Set of log unit servers.
         */
        public Set&lt;String&gt; getAllLogServers() {
<span class="nc" id="L528">            return this.getStripes().stream()</span>
<span class="nc" id="L529">                    .flatMap(layoutStripe -&gt; layoutStripe.getLogServers().stream())</span>
<span class="nc" id="L530">                    .collect(Collectors.toSet());</span>
        }
    }

<span class="nc bnc" id="L534" title="All 14 branches missed.">    @Data</span>
    @Getter
    public static class LayoutStripe {
<span class="nc" id="L537">        final List&lt;String&gt; logServers;</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">        public LayoutStripe(@NonNull List&lt;String&gt; logServers) {</span>
<span class="nc" id="L540">            this.logServers = logServers;</span>
<span class="nc" id="L541">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>