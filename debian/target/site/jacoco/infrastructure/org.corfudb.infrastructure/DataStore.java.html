<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DataStore.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">DataStore.java</span></div><h1>DataStore.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.CacheWriter;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import com.github.benmanes.caffeine.cache.RemovalCause;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.Map;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import lombok.Getter;

import org.corfudb.runtime.exceptions.DataCorruptionException;
import org.corfudb.util.JsonUtils;

import static org.corfudb.infrastructure.utils.Persistence.syncDirectory;

/**
 * Stores data as JSON.
 *
 * &lt;p&gt;Handle in-memory and persistent case differently:
 *
 * &lt;p&gt;In in-memory mode, the &quot;cache&quot; is actually the store, so we never evict anything from it.
 *
 * &lt;p&gt;In persistent mode, we use a {@link LoadingCache}, where an in-memory map is backed by disk.
 * In this scheme, the key for each value is also the name of the file where the value is stored.
 * The key is determined as (prefix + &quot;_&quot; + key).
 * The cache here serves mostly for easily managed synchronization of in-memory/file.
 *
 * &lt;p&gt;If 'opts' either has '--memory=true' or a log-path for storing files is not provided,
 * the store is just an in memory cache.
 *
 * &lt;p&gt;Created by mdhawan on 7/27/16.
 */

public class DataStore implements IDataStore {

<span class="nc" id="L52">    static String EXTENSION = &quot;.ds&quot;;</span>

<span class="nc" id="L54">    @Getter</span>
    private final Cache&lt;String, Object&gt; cache;
    private final String logDir;

<span class="nc" id="L58">    @Getter</span>
    private final long dsCacheSize = 1_000; // size bound for in-memory cache for dataStore

    private final boolean inMem;

    /**
     * Return a new DataStore object.
     * @param opts  map of option strings
     */
<span class="nc" id="L67">    public DataStore(Map&lt;String, Object&gt; opts) {</span>

<span class="nc bnc" id="L69" title="All 4 branches missed.">        if ((opts.get(&quot;--memory&quot;) != null &amp;&amp; (Boolean) opts.get(&quot;--memory&quot;))</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">                || opts.get(&quot;--log-path&quot;) == null) {</span>
<span class="nc" id="L71">            this.logDir = null;</span>
<span class="nc" id="L72">            cache = buildMemoryDs();</span>
<span class="nc" id="L73">            inMem = true;</span>
        } else {
<span class="nc" id="L75">            this.logDir = (String) opts.get(&quot;--log-path&quot;);</span>
<span class="nc" id="L76">            cache = buildPersistentDs();</span>
<span class="nc" id="L77">            inMem = false;</span>
        }
<span class="nc" id="L79">    }</span>

    /**
     * obtain an in-memory cache, no content loader, no writer, no size limit.
     * @return  new LoadingCache for the DataStore
     */
    private Cache&lt;String, Object&gt; buildMemoryDs() {
<span class="nc" id="L86">        return Caffeine.newBuilder().build(k -&gt; null);</span>
    }


    public static int getChecksum(byte[] bytes) {
<span class="nc" id="L91">        Hasher hasher = Hashing.crc32c().newHasher();</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        for (byte a : bytes) {</span>
<span class="nc" id="L93">            hasher.putByte(a);</span>
        }

<span class="nc" id="L96">        return hasher.hash().asInt();</span>
    }

    /**
     * obtain a {@link LoadingCache}.
     * The cache is backed up by file-per-key uner {@link DataStore::logDir}.
     * The cache size is bounded by {@link DataStore::dsCacheSize}.
     *
     * @return the cache object
     */
    private Cache&lt;String, Object&gt; buildPersistentDs() {
<span class="nc" id="L107">        return Caffeine.newBuilder()</span>
<span class="nc" id="L108">                .recordStats()</span>
<span class="nc" id="L109">                .writer(new CacheWriter&lt;String, Object&gt;() {</span>
                    @Override
                    public synchronized void write(@Nonnull String key, @Nonnull Object value) {

<span class="nc bnc" id="L113" title="All 2 branches missed.">                        if (value == NullValue.NULL_VALUE) {</span>
<span class="nc" id="L114">                            return;</span>
                        }

                        try {
<span class="nc" id="L118">                            Path path = Paths.get(logDir + File.separator + key + EXTENSION);</span>
<span class="nc" id="L119">                            Path tmpPath = Paths.get(logDir + File.separator + key + EXTENSION + &quot;.tmp&quot;);</span>

<span class="nc" id="L121">                            String jsonPayload = JsonUtils.parser.toJson(value, value.getClass());</span>
<span class="nc" id="L122">                            byte[] bytes = jsonPayload.getBytes();</span>

<span class="nc" id="L124">                            ByteBuffer buffer = ByteBuffer.allocate(bytes.length</span>
                                    + Integer.BYTES);
<span class="nc" id="L126">                            buffer.putInt(getChecksum(bytes));</span>
<span class="nc" id="L127">                            buffer.put(bytes);</span>
<span class="nc" id="L128">                            Files.write(tmpPath, buffer.array(), StandardOpenOption.CREATE,</span>
                                    StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.SYNC);
<span class="nc" id="L130">                            Files.move(tmpPath, path, StandardCopyOption.REPLACE_EXISTING,</span>
                                    StandardCopyOption.ATOMIC_MOVE);
<span class="nc" id="L132">                            syncDirectory(logDir);</span>
<span class="nc" id="L133">                        } catch (IOException e) {</span>
<span class="nc" id="L134">                            throw new RuntimeException(e);</span>
<span class="nc" id="L135">                        }</span>
<span class="nc" id="L136">                    }</span>

                    @Override
                    public synchronized void delete(@Nonnull String key,
                                                    @Nullable Object value,
                                                    @Nonnull RemovalCause cause) {
                        try {
<span class="nc" id="L143">                            Path path = Paths.get(logDir + File.separator + key);</span>
<span class="nc" id="L144">                            Files.deleteIfExists(path);</span>
<span class="nc" id="L145">                        } catch (IOException e) {</span>
<span class="nc" id="L146">                            throw new RuntimeException(e);</span>
<span class="nc" id="L147">                        }</span>
<span class="nc" id="L148">                    }</span>
                })
<span class="nc" id="L150">                .maximumSize(dsCacheSize)</span>
<span class="nc" id="L151">                .build();</span>
    }

    @Override
    public synchronized  &lt;T&gt; void put(Class&lt;T&gt; tclass, String prefix, String key, T value) {
<span class="nc" id="L156">        cache.put(getKey(prefix, key), value);</span>
<span class="nc" id="L157">    }</span>

    private &lt;T&gt; T load(Class&lt;T&gt; tClass, String key) {
        try {
<span class="nc" id="L161">            Path path = Paths.get(logDir + File.separator + key + EXTENSION);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (Files.notExists(path)) {</span>
<span class="nc" id="L163">                return null;</span>
            }
<span class="nc" id="L165">            byte[] bytes = Files.readAllBytes(path);</span>
<span class="nc" id="L166">            ByteBuffer buf = ByteBuffer.wrap(bytes);</span>
<span class="nc" id="L167">            int checksum = buf.getInt();</span>
<span class="nc" id="L168">            byte[] strBytes = Arrays.copyOfRange(bytes, 4, bytes.length);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (checksum != getChecksum(strBytes)) {</span>
<span class="nc" id="L170">                throw new DataCorruptionException();</span>
            }

<span class="nc" id="L173">            String json = new String(strBytes);</span>
<span class="nc" id="L174">            T val = JsonUtils.parser.fromJson(json, tClass);</span>
<span class="nc" id="L175">            return val;</span>
<span class="nc" id="L176">        } catch (IOException e) {</span>
<span class="nc" id="L177">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Since the cache can't maintain key-&gt;null mappings, this enum
     * is a place holder for null to allow keys to map to null.
     */
<span class="nc" id="L185">    private enum NullValue {</span>
<span class="nc" id="L186">        NULL_VALUE</span>
    }

    @Override
    public synchronized &lt;T&gt; T get(Class&lt;T&gt; tclass, String prefix, String key) {
<span class="nc" id="L191">        String path = getKey(prefix, key);</span>
<span class="nc" id="L192">        Object val = cache.get(path, k -&gt; {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (!inMem) {</span>
<span class="nc" id="L194">                T loadedVal = load(tclass, path);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (loadedVal != null) {</span>
<span class="nc" id="L196">                    return loadedVal;</span>
                }
            }

            // We need to maintain a path -&gt; null mapping for keys that were loaded, but
            // were empty. This is required to prevent loading an empty key more than once, which is expensive.
<span class="nc" id="L202">            return NullValue.NULL_VALUE;</span>
        });
        
<span class="nc bnc" id="L205" title="All 2 branches missed.">        return val == NullValue.NULL_VALUE ? null : (T) val;</span>
    }

    @Override
    public synchronized &lt;T&gt; void delete(Class&lt;T&gt; tclass, String prefix, String key) {
<span class="nc" id="L210">        cache.invalidate(getKey(prefix, key));</span>
<span class="nc" id="L211">    }</span>

    private String getKey(String prefix, String key) {
<span class="nc" id="L214">        return prefix + &quot;_&quot; + key;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>