<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SequencerServer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure</a> &gt; <span class="el_source">SequencerServer.java</span></div><h1>SequencerServer.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure;

import static org.corfudb.protocols.wireprotocol.TokenType.TX_ABORT_SEQ_OVERFLOW;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.RemovalCause;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import io.netty.channel.ChannelHandlerContext;
import java.lang.invoke.MethodHandles;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.protocols.wireprotocol.CorfuMsg;
import org.corfudb.protocols.wireprotocol.CorfuMsgType;
import org.corfudb.protocols.wireprotocol.CorfuPayloadMsg;
import org.corfudb.protocols.wireprotocol.SequencerMetrics;
import org.corfudb.protocols.wireprotocol.SequencerMetrics.SequencerStatus;
import org.corfudb.protocols.wireprotocol.SequencerTailsRecoveryMsg;
import org.corfudb.protocols.wireprotocol.Token;
import org.corfudb.protocols.wireprotocol.TokenRequest;
import org.corfudb.protocols.wireprotocol.TokenResponse;
import org.corfudb.protocols.wireprotocol.TokenType;
import org.corfudb.protocols.wireprotocol.TxResolutionInfo;
import org.corfudb.runtime.view.Address;
import org.corfudb.runtime.view.Layout;
import org.corfudb.util.Utils;

/**
 * This server implements the sequencer functionality of Corfu.
 *
 * &lt;p&gt;It currently supports a single operation, which is a incoming request:
 *
 * &lt;p&gt;TOKEN_REQ - Request the next address.
 *
 * &lt;p&gt;The sequencer server maintains the current tail of the log, the current
 * tail of every stream, and a cache of timestamps of updates on recent
 * conflict-parameters.
 *
 * &lt;p&gt;A token request can be of several sub-types, which are defined in
 * {@link TokenRequest}:
 *
 * &lt;p&gt;{@link TokenRequest::TK_QUERY} - used for only querying the current tail
 * of the log and/or the tails of specific streams
 *
 * &lt;p&gt;{@link TokenRequest::TK_RAW} - reserved for getting a &quot;raw&quot; token in the
 * global log
 *
 * &lt;p&gt;{@link TokenRequest::TK_MULTI_STREAM} - used for logging across one or
 * more streams
 *
 * &lt;p&gt;{@link TokenRequest::TK_TX} - used for reserving an address for transaction
 * commit.
 *
 * &lt;p&gt;The transaction commit is the most sophisticated functaionality of the
 * sequencer. The sequencer reserves an address for the transaction
 * only on if it knows that it can commit.
 *
 * &lt;p&gt;The TK_TX request contains a conflict-set and a write-set. The sequencer
 * checks the conflict-set against the stream-tails and against the
 * conflict-parameters timestamp cache it maintains. If the transaction
 * commits, the sequencer updates the tails of all the streams and the cache
 * of conflict parameters.
 *
 * &lt;p&gt;Created by mwei on 12/8/15.
 */
<span class="nc" id="L79">@Slf4j</span>
public class SequencerServer extends AbstractServer {

    /**
     * Inherit from CorfuServer a server context.
     */
    private final ServerContext serverContext;

    /**
     * Our options.
     */
    private final Map&lt;String, Object&gt; opts;

    /**
     * - {@link SequencerServer::globalLogTail}:
     * global log first available position (initially, 0).
     */
<span class="nc" id="L96">    @Getter</span>
    private final AtomicLong globalLogTail = new AtomicLong(Address
<span class="nc" id="L98">            .getMinAddress());</span>

<span class="nc" id="L100">    private long trimMark = Address.NON_ADDRESS;</span>

    /**
     * - {@link SequencerServer::streamTailToGlobalTailMap}:
     * per streams map to last issued global-log position. used for
     * backpointers.
     */
<span class="nc" id="L107">    private final ConcurrentHashMap&lt;UUID, Long&gt; streamTailToGlobalTailMap = new</span>
            ConcurrentHashMap&lt;&gt;();

    /**
     * TX conflict-resolution information:
     *
     * {@link SequencerServer::conflictToGlobalTailCache}:
     * a cache of recent conflict keys and their latest global-log
     * position.
     *
     * {@link SequencerServer::maxConflictWildcard} :
     * a &quot;wildcard&quot; representing the maximal update timestamp of
     * all the confict keys which were evicted from the cache
     */
<span class="nc" id="L121">    private long maxConflictWildcard = Address.NOT_FOUND;</span>

    private final Cache&lt;String, Long&gt; conflictToGlobalTailCache;

    /**
     * Handler for this server.
     */
<span class="nc" id="L128">    @Getter</span>
    private final CorfuMsgHandler handler =
<span class="nc" id="L130">            CorfuMsgHandler.generateHandler(MethodHandles.lookup(), this);</span>


<span class="nc" id="L133">    @Getter</span>
<span class="nc" id="L134">    @Setter</span>
    private volatile long bootstrapEpoch = Layout.INVALID_EPOCH;

    @Override
    public boolean isServerReadyToHandleMsg(CorfuMsg msg) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if ((bootstrapEpoch != serverContext.getServerEpoch())</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                &amp;&amp; (!msg.getMsgType().equals(CorfuMsgType.BOOTSTRAP_SEQUENCER))) {</span>
<span class="nc" id="L141">            log.warn(&quot;Rejecting msg at sequencer : sequencerStateEpoch:{}, serverEpoch:{}, &quot;</span>
<span class="nc" id="L142">                    + &quot;msg:{}&quot;, bootstrapEpoch, serverContext.getServerEpoch(), msg);</span>
<span class="nc" id="L143">            return false;</span>
        }
<span class="nc" id="L145">        return true;</span>
    }

<span class="nc" id="L148">    ThreadFactory threadFactory = new ServerThreadFactory(&quot;sequencer-&quot;,</span>
            new ServerThreadFactory.ExceptionHandler());

<span class="nc" id="L151">    ExecutorService executor = Executors.newSingleThreadExecutor(threadFactory);</span>

    @Override
    public ExecutorService getExecutor() {
<span class="nc" id="L155">        return executor;</span>
    }

    /**
     * Returns a new SequencerServer.
     * @param serverContext context object providing parameters and objects
     */
<span class="nc" id="L162">    public SequencerServer(ServerContext serverContext) {</span>
<span class="nc" id="L163">        this.serverContext = serverContext;</span>
<span class="nc" id="L164">        this.opts = serverContext.getServerConfig();</span>

<span class="nc" id="L166">        long initialToken = Utils.parseLong(opts.get(&quot;--initial-token&quot;));</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (Address.nonAddress(initialToken)) {</span>
<span class="nc" id="L168">            globalLogTail.set(0L);</span>
        } else {
<span class="nc" id="L170">            globalLogTail.set(initialToken);</span>
        }

<span class="nc" id="L173">        long cacheSize = 250_000;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (opts.get(&quot;--sequencer-cache-size&quot;) != null) {</span>
<span class="nc" id="L175">            cacheSize = Long.parseLong((String) opts.get(&quot;--sequencer-cache-size&quot;));</span>

        }

<span class="nc" id="L179">        conflictToGlobalTailCache = Caffeine.newBuilder()</span>
<span class="nc" id="L180">                .maximumSize(cacheSize)</span>
<span class="nc" id="L181">                .removalListener((String k, Long v, RemovalCause cause) -&gt; {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">                    if (!RemovalCause.REPLACED.equals(cause)) {</span>
<span class="nc" id="L183">                        log.trace(&quot;Updating maxConflictWildcard. Old value = '{}', new value='{}'&quot;</span>
                                        + &quot; conflictParam = '{}'. Removal cause = '{}'&quot;,
<span class="nc" id="L185">                                maxConflictWildcard, v, k, cause);</span>
<span class="nc" id="L186">                        maxConflictWildcard = Math.max(v, maxConflictWildcard);</span>
                    }
<span class="nc" id="L188">                })</span>
<span class="nc" id="L189">                .recordStats()</span>
<span class="nc" id="L190">                .build();</span>
<span class="nc" id="L191">    }</span>

    /**
    * Get the conflict hash code for a stream ID and conflict param.
    *
    * @param streamId      The stream ID.
    * @param conflictParam The conflict parameter.
    * @return A conflict hash code.
    */
    private String getConflictHashCode(UUID streamId, byte[] conflictParam) {
<span class="nc" id="L201">        return streamId.toString() + Utils.bytesToHex(conflictParam);</span>
    }

    /**
     * If the request submits a timestamp (a global offset) that is less than one of the
     * global offsets of a streams specified in the request, then abort; otherwise commit.
     *
     * @param txInfo      info provided by corfuRuntime for conflict resolultion:
     *                    - timestamp : the snapshot (global) offset that this TX reads
     *                    - conflictSet: conflict set of the txn.
     *                    if any conflict-param (or stream, if empty) in this set has a later
     *                    timestamp than the snapshot, abort
     * @param conflictKey is a return parameter that signals to the consumer which key was
     *                    responsible for unsuccessful allocation af a token.
     * @return Returns the type of token reponse based on whether the txn commits, or the abort
     *     cause.
     */
    private TokenType txnCanCommit(TxResolutionInfo txInfo, /** Input. */
                                  AtomicReference&lt;byte[]&gt; conflictKey /** Output. */) {
<span class="nc" id="L220">        log.trace(&quot;Commit-req[{}]&quot;, txInfo);</span>
<span class="nc" id="L221">        final long txSnapshotTimestamp = txInfo.getSnapshotTimestamp();</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (txSnapshotTimestamp &lt; trimMark) {</span>
<span class="nc" id="L224">            log.debug(&quot;ABORT[{}] snapshot-ts[{}] trimMark-ts[{}]&quot;, txInfo,</span>
<span class="nc" id="L225">                    txSnapshotTimestamp, trimMark);</span>
<span class="nc" id="L226">            return TokenType.TX_ABORT_SEQ_TRIM;</span>
        }

<span class="nc" id="L229">        AtomicReference&lt;TokenType&gt; response = new AtomicReference&lt;&gt;(TokenType.NORMAL);</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">        for (Map.Entry&lt;UUID, Set&lt;byte[]&gt;&gt; entry : txInfo.getConflictSet().entrySet()) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (response.get() != TokenType.NORMAL) {</span>
<span class="nc" id="L233">                break;</span>
            }

            // if conflict-parameters are present, check for conflict based on conflict-parameter
            // updates
<span class="nc" id="L238">            Set&lt;byte[]&gt; conflictParamSet = entry.getValue();</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">            if (conflictParamSet != null &amp;&amp; conflictParamSet.size() &gt; 0) {</span>
                // for each key pair, check for conflict;
                // if not present, check against the wildcard
<span class="nc bnc" id="L242" title="All 2 branches missed.">                for (byte[] conflictParam : conflictParamSet) {</span>

<span class="nc" id="L244">                    String conflictKeyHash = getConflictHashCode(entry.getKey(),</span>
                            conflictParam);
<span class="nc" id="L246">                    Long v = conflictToGlobalTailCache.getIfPresent(conflictKeyHash);</span>

<span class="nc" id="L248">                    log.trace(&quot;Commit-ck[{}] conflict-key[{}](ts={})&quot;, txInfo, conflictParam, v);</span>

<span class="nc bnc" id="L250" title="All 4 branches missed.">                    if (v != null &amp;&amp; v &gt; txSnapshotTimestamp) {</span>
<span class="nc" id="L251">                        log.debug(&quot;ABORT[{}] conflict-key[{}](ts={})&quot;, txInfo, conflictParam, v);</span>
<span class="nc" id="L252">                        conflictKey.set(conflictParam);</span>
<span class="nc" id="L253">                        response.set(TokenType.TX_ABORT_CONFLICT);</span>
<span class="nc" id="L254">                        break;</span>
                    }

<span class="nc bnc" id="L257" title="All 2 branches missed.">                    if (txSnapshotTimestamp &lt; maxConflictWildcard) {</span>
<span class="nc" id="L258">                        log.debug(&quot;ABORT[{}] snapshot-ts[{}] WILDCARD ts=[{}]&quot;,</span>
<span class="nc" id="L259">                                txInfo, txSnapshotTimestamp, maxConflictWildcard);</span>
<span class="nc" id="L260">                        response.set(TX_ABORT_SEQ_OVERFLOW);</span>
<span class="nc" id="L261">                        break;</span>
                    }
<span class="nc" id="L263">                }</span>
            } else { // otherwise, check for conflict based on streams updates
<span class="nc" id="L265">                UUID streamId = entry.getKey();</span>
<span class="nc" id="L266">                streamTailToGlobalTailMap.compute(streamId, (k, v) -&gt; {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                    if (v == null) {</span>
<span class="nc" id="L268">                        return null;</span>
                    }
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    if (v &gt; txSnapshotTimestamp) {</span>
<span class="nc" id="L271">                        log.debug(&quot;ABORT[{}] conflict-stream[{}](ts={})&quot;,</span>
<span class="nc" id="L272">                                txInfo, Utils.toReadableId(streamId), v);</span>
<span class="nc" id="L273">                        response.set(TokenType.TX_ABORT_CONFLICT);</span>
                    }
<span class="nc" id="L275">                    return v;</span>
                });
            }
<span class="nc" id="L278">        }</span>

<span class="nc" id="L280">        return response.get();</span>
    }

    /**
     * Service a query request.
     *
     * &lt;p&gt;This returns information about the tail of the
     * log and/or streams without changing/allocating anything.
     *
     * @param msg corfu message containing token query
     * @param ctx netty ChannelHandlerContext
     * @param r   server router
     */
    private void handleTokenQuery(CorfuPayloadMsg&lt;TokenRequest&gt; msg,
                                 ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L295">        TokenRequest req = msg.getPayload();</span>

        // sanity backward-compatibility assertion; TODO: remove
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (req.getStreams().size() &gt; 1) {</span>
<span class="nc" id="L299">            log.error(&quot;TOKEN-QUERY[{}]&quot;, req.getStreams());</span>
        }

<span class="nc" id="L302">        long maxStreamGlobalTail = Address.NON_EXIST;</span>

        // see if this query is for a specific stream-tail
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (req.getStreams().size() == 1) {</span>
<span class="nc" id="L306">            UUID streamId = req.getStreams().iterator().next();</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (streamTailToGlobalTailMap.get(streamId) != null) {</span>
<span class="nc" id="L309">                maxStreamGlobalTail = streamTailToGlobalTailMap.get(streamId);</span>
            }
        }

        // If no streams are specified in the request, this value returns the last global token
        // issued.
<span class="nc bnc" id="L315" title="All 2 branches missed.">        long responseGlobalTail = (req.getStreams().size() == 0) ? globalLogTail.get() - 1 :</span>
                maxStreamGlobalTail;
<span class="nc" id="L317">        Token token = new Token(responseGlobalTail, bootstrapEpoch);</span>
<span class="nc" id="L318">        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(</span>
<span class="nc" id="L319">                TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY, token, Collections.emptyMap())));</span>
<span class="nc" id="L320">    }</span>

    @ServerHandler(type = CorfuMsgType.SEQUENCER_TRIM_REQ)
    public synchronized void trimCache(CorfuPayloadMsg&lt;Long&gt; msg,
                                       ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L325">        log.info(&quot;trimCache: Starting cache eviction&quot;);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (trimMark &lt; msg.getPayload()) {</span>
            // Advance the trim mark, if the new trim request has a higher trim mark.
<span class="nc" id="L328">            trimMark = msg.getPayload();</span>
        }

<span class="nc" id="L331">        long entries = 0;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        for (Map.Entry&lt;String, Long&gt; entry : conflictToGlobalTailCache.asMap().entrySet()) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (entry.getValue() &lt; trimMark) {</span>
<span class="nc" id="L334">                conflictToGlobalTailCache.invalidate(entry.getKey());</span>
<span class="nc" id="L335">                entries++;</span>
            }
<span class="nc" id="L337">        }</span>
<span class="nc" id="L338">        log.info(&quot;trimCache: Evicted {} entries&quot;, entries);</span>
<span class="nc" id="L339">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L340">    }</span>

    /**
     * Service an incoming request to reset the sequencer.
     */
    @ServerHandler(type = CorfuMsgType.BOOTSTRAP_SEQUENCER)
    public synchronized void resetServer(CorfuPayloadMsg&lt;SequencerTailsRecoveryMsg&gt; msg,
                                         ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L348">        long initialToken = msg.getPayload().getGlobalTail();</span>
<span class="nc" id="L349">        final Map&lt;UUID, Long&gt; streamTails = msg.getPayload().getStreamTails();</span>
<span class="nc" id="L350">        final long readyEpoch = msg.getPayload().getReadyStateEpoch();</span>

        // Boolean flag to denote whether this bootstrap message is just updating an existing
        // primary sequencer with the new epoch (if set to true) or bootstrapping a currently
        // NOT_READY sequencer.
<span class="nc" id="L355">        final boolean bootstrapWithoutTailsUpdate = msg.getPayload()</span>
<span class="nc" id="L356">                .getBootstrapWithoutTailsUpdate();</span>

        // If bootstrapEpoch is -1 (startup), the sequencer should not accept
        // bootstrapWithoutTailsUpdate bootstrap messages.
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (bootstrapEpoch == Layout.INVALID_EPOCH &amp;&amp; bootstrapWithoutTailsUpdate) {</span>
<span class="nc" id="L361">            log.warn(&quot;Cannot update existing sequencer. Require full bootstrap.&quot;);</span>
<span class="nc" id="L362">            r.sendResponse(ctx, msg, CorfuMsgType.NACK.msg());</span>
<span class="nc" id="L363">            return;</span>
        }

        // Stale bootstrap request should be discarded.
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (serverContext.getSequencerEpoch() &gt;= readyEpoch) {</span>
<span class="nc" id="L368">            log.info(&quot;Sequencer already bootstrapped at epoch {}. &quot;</span>
<span class="nc" id="L369">                    + &quot;Discarding bootstrap request with epoch {}&quot;, bootstrapEpoch, readyEpoch);</span>
<span class="nc" id="L370">            r.sendResponse(ctx, msg, CorfuMsgType.NACK.msg());</span>
<span class="nc" id="L371">            return;</span>
        }

        //
        // if the sequencer is reset, then we can't know when was
        // the latest update to any stream or conflict parameter.
        // hence, we will accept any bootstrap message with a higher epoch and forget any existing
        // token count or stream tails.
        //
        // Note, this is correct, but conservative (may lead to false abort).
        // It is necessary because we reset the sequencer.
        //
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (!bootstrapWithoutTailsUpdate) {</span>
<span class="nc" id="L384">            globalLogTail.set(initialToken);</span>
<span class="nc" id="L385">            maxConflictWildcard = initialToken - 1;</span>
<span class="nc" id="L386">            conflictToGlobalTailCache.invalidateAll();</span>

            // Clear the existing map as it could have been populated by an earlier reset.
<span class="nc" id="L389">            streamTailToGlobalTailMap.clear();</span>
<span class="nc" id="L390">            streamTailToGlobalTailMap.putAll(streamTails);</span>
        }

        // Mark the sequencer as ready after the tails have been populated.
<span class="nc" id="L394">        bootstrapEpoch = readyEpoch;</span>
<span class="nc" id="L395">        serverContext.setSequencerEpoch(readyEpoch);</span>

<span class="nc" id="L397">        log.info(&quot;Sequencer reset with token = {}, streamTailToGlobalTailMap = {},&quot;</span>
                        + &quot; bootstrapEpoch = {}&quot;,
<span class="nc" id="L399">                initialToken, streamTailToGlobalTailMap, bootstrapEpoch);</span>
<span class="nc" id="L400">        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());</span>
<span class="nc" id="L401">    }</span>

    /**
     * Service an incoming metrics request with the metrics response.
     */
    @ServerHandler(type = CorfuMsgType.SEQUENCER_METRICS_REQUEST)
    public void handleMetricsRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {
        // Sequencer Ready flag is set to true as this message will be responded to only if the
        // sequencer is in a ready state.
<span class="nc" id="L410">        SequencerMetrics sequencerMetrics = new SequencerMetrics(SequencerStatus.READY);</span>
<span class="nc" id="L411">        r.sendResponse(ctx, msg, new CorfuPayloadMsg&lt;&gt;(CorfuMsgType.SEQUENCER_METRICS_RESPONSE,</span>
                sequencerMetrics));
<span class="nc" id="L413">    }</span>

    /**
     * Service an incoming token request.
     */
    @ServerHandler(type = CorfuMsgType.TOKEN_REQ)
    public synchronized void tokenRequest(CorfuPayloadMsg&lt;TokenRequest&gt; msg,
                                          ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L421">        TokenRequest req = msg.getPayload();</span>

        // dispatch request handler according to request type
<span class="nc bnc" id="L424" title="All 4 branches missed.">        switch (req.getReqType()) {</span>
            case TokenRequest.TK_QUERY:
<span class="nc" id="L426">                handleTokenQuery(msg, ctx, r);</span>
<span class="nc" id="L427">                return;</span>

            case TokenRequest.TK_RAW:
<span class="nc" id="L430">                handleRawToken(msg, ctx, r);</span>
<span class="nc" id="L431">                return;</span>

            case TokenRequest.TK_TX:
<span class="nc" id="L434">                handleTxToken(msg, ctx, r);</span>
<span class="nc" id="L435">                return;</span>

            default:
<span class="nc" id="L438">                handleAllocation(msg, ctx, r);</span>
<span class="nc" id="L439">                return;</span>
        }
    }

    /**
     * this method serves log-tokens for a raw log implementation.
     * it simply extends the global log tail and returns the global-log token
     *
     * @param msg corfu message containing raw token
     * @param ctx netty ChannelHandlerContext
     * @param r   server router
     */
    private void handleRawToken(CorfuPayloadMsg&lt;TokenRequest&gt; msg,
                                ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L453">        final TokenRequest req = msg.getPayload();</span>

<span class="nc" id="L455">        Token token = new Token(globalLogTail.getAndAdd(req.getNumTokens()), bootstrapEpoch);</span>
<span class="nc" id="L456">        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(</span>
<span class="nc" id="L457">                TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY, token, Collections.emptyMap())));</span>

<span class="nc" id="L459">    }</span>

    /**
     * this method serves token-requests for transaction-commit entries.
     *
     * &lt;p&gt;it checks if the transaction can commit.
     * - if the transction must abort,
     * then a 'error token' containing an Address.ABORTED address is returned.
     * - if the transaction may commit,
     * then a normal allocation of log position(s) is pursued.
     *
     * @param msg corfu message containing transaction token
     * @param ctx netty ChannelHandlerContext
     * @param r   server router
     */
    private void handleTxToken(CorfuPayloadMsg&lt;TokenRequest&gt; msg,
                               ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L476">        final TokenRequest req = msg.getPayload();</span>

        // Since Java does not allow an easy way for a function to return multiple values, this
        // variable is passed to the consumer that will use it to indicate to us if/what key was
        // responsible for an aborted transaction.
<span class="nc" id="L481">        AtomicReference&lt;byte[]&gt; conflictKey = new AtomicReference(TokenResponse.NO_CONFLICT_KEY);</span>

        // in the TK_TX request type, the sequencer is utilized for transaction conflict-resolution.
        // Token allocation is conditioned on commit.
        // First, we check if the transaction can commit.
<span class="nc" id="L486">        TokenType tokenType = txnCanCommit(req.getTxnResolution(), conflictKey);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (tokenType != TokenType.NORMAL) {</span>
            // If the txn aborts, then DO NOT hand out a token.
<span class="nc" id="L489">            Token token = new Token(Address.ABORTED, bootstrapEpoch);</span>
<span class="nc" id="L490">            r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(tokenType,</span>
<span class="nc" id="L491">                    conflictKey.get(), token, Collections.emptyMap())));</span>
<span class="nc" id="L492">            return;</span>
        }

        // if we get here, this means the transaction can commit.
        // handleAllocation() does the actual allocation of log position(s)
        // and returns the reponse
<span class="nc" id="L498">        handleAllocation(msg, ctx, r);</span>
<span class="nc" id="L499">    }</span>

    /**
     * this method does the actual allocation of log addresses,
     * it also maintains stream-tails, returns a map of stream-tails for backpointers,
     * and maintains a conflict-parameters map.
     *
     * @param msg corfu message containing allocation
     * @param ctx netty ChannelHandlerContext
     * @param r   server router
     */
    private void handleAllocation(CorfuPayloadMsg&lt;TokenRequest&gt; msg,
                                  ChannelHandlerContext ctx, IServerRouter r) {
<span class="nc" id="L512">        final TokenRequest req = msg.getPayload();</span>

        // extend the tail of the global log by the requested # of tokens
        // currentTail is the first available position in the global log
<span class="nc" id="L516">        long currentTail = globalLogTail.getAndAdd(req.getNumTokens());</span>
<span class="nc" id="L517">        long newTail = currentTail + req.getNumTokens();</span>

        // for each streams:
        //   1. obtain the last back-pointer for this streams, if exists; -1L otherwise.
        //   2. record the new global tail as back-pointer for this streams.
        //   3. extend the tail by the requested # tokens.
<span class="nc" id="L523">        ImmutableMap.Builder&lt;UUID, Long&gt; backPointerMap = ImmutableMap.builder();</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        for (UUID id : req.getStreams()) {</span>

            // step 1. and 2. (comment above)
<span class="nc" id="L527">            streamTailToGlobalTailMap.compute(id, (k, v) -&gt; {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                if (v == null) {</span>
<span class="nc" id="L529">                    backPointerMap.put(k, Address.NON_EXIST);</span>
<span class="nc" id="L530">                    return newTail - 1;</span>
                } else {
<span class="nc" id="L532">                    backPointerMap.put(k, v);</span>
<span class="nc" id="L533">                    return newTail - 1;</span>
                }
            });
<span class="nc" id="L536">        }</span>

        // update the cache of conflict parameters
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (req.getTxnResolution() != null) {</span>
<span class="nc" id="L540">            req.getTxnResolution().getWriteConflictParams().entrySet()</span>
<span class="nc" id="L541">                    .stream()</span>
                    // for each entry
<span class="nc" id="L543">                    .forEach(txEntry -&gt;</span>
                            // and for each conflict param
<span class="nc" id="L545">                            txEntry.getValue().stream().forEach(conflictParam -&gt;</span>
                                    // insert an entry with the new timestamp
                                    // using the hash code based on the param
                                    // and the stream id.
<span class="nc" id="L549">                                    conflictToGlobalTailCache.put(</span>
<span class="nc" id="L550">                                            getConflictHashCode(txEntry</span>
<span class="nc" id="L551">                                                    .getKey(), conflictParam),</span>
<span class="nc" id="L552">                                            newTail - 1)));</span>
        }

<span class="nc" id="L555">        log.trace(&quot;token {} backpointers {}&quot;,</span>
<span class="nc" id="L556">                currentTail, backPointerMap.build());</span>
        // return the token response with the new global tail
        // and the streams backpointers
<span class="nc" id="L559">        Token token = new Token(currentTail, bootstrapEpoch);</span>
<span class="nc" id="L560">        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(</span>
                TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY, token,
<span class="nc" id="L562">                backPointerMap.build())));</span>
<span class="nc" id="L563">    }</span>

    @Override
    public void shutdown() {
<span class="nc" id="L567">        super.shutdown();</span>
<span class="nc" id="L568">        executor.shutdownNow();</span>
<span class="nc" id="L569">    }</span>

    @VisibleForTesting
    public Cache&lt;String, Long&gt; getConflictToGlobalTailCache() {
<span class="nc" id="L573">        return conflictToGlobalTailCache;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>