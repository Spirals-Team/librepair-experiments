<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FailureDetector.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">debian</a> &gt; <a href="../index.html" class="el_bundle">infrastructure</a> &gt; <a href="index.source.html" class="el_package">org.corfudb.infrastructure.management</a> &gt; <span class="el_source">FailureDetector.java</span></div><h1>FailureDetector.java</h1><pre class="source lang-java linenums">package org.corfudb.infrastructure.management;

import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.corfudb.protocols.wireprotocol.NodeView;
import org.corfudb.runtime.CorfuRuntime;
import org.corfudb.runtime.clients.IClientRouter;
import org.corfudb.runtime.clients.ManagementClient;
import org.corfudb.runtime.exceptions.NetworkException;
import org.corfudb.runtime.exceptions.WrongEpochException;
import org.corfudb.runtime.view.Layout;
import org.corfudb.util.CFUtils;
import org.corfudb.util.Sleep;

/**
 * FailureDetector polls all the &quot;responsive members&quot; in the layout.
 * Responsive members: All endpoints that are responding to heartbeats. This list can be derived by
 * excluding unresponsiveServers from all endpoints.
 * For every poll method call invoked, it starts a polling round and generates a poll report.
 * Each polling round comprises of &quot;failureThreshold&quot; number of iterations.
 * - We asynchronously poll every known responsive member in the layout.
 * - Poll result aggregation.
 * - If we complete an iteration without detecting failures, we end the round successfully.
 * The management Server ensures only one instance of this class and hence this is NOT thread safe.
 * Created by zlokhandwala on 11/29/17.
 */
<span class="nc" id="L41">@Slf4j</span>
<span class="nc" id="L42">public class FailureDetector implements IDetector {</span>


    /**
     * Number of iterations to execute to detect a failure in a round.
     */
<span class="nc" id="L48">    @Getter</span>
<span class="nc" id="L49">    @Setter</span>
    private int failureThreshold = 3;

    /**
     * Max duration for the responseTimeouts of the routers.
     * In the worst case scenario or in case of failed servers, their response timeouts will be
     * set to a maximum value of maxPeriodDuration.
     */
<span class="nc" id="L57">    @Getter</span>
<span class="nc" id="L58">    @Setter</span>
    private long maxPeriodDuration = 8_000L;

    /**
     * Minimum duration for the responseTimeouts of the routers.
     * Under ideal conditions the routers will have a response timeout set to this.
     */
<span class="nc" id="L65">    @Getter</span>
<span class="nc" id="L66">    @Setter</span>
    private long initPeriodDuration = 5_000L;

    /**
     * Response timeout for every router.
     */
<span class="nc" id="L72">    @Getter</span>
    private long period = initPeriodDuration;

    /**
     * Interval between iterations in a pollRound.
     */
<span class="nc" id="L78">    @Getter</span>
<span class="nc" id="L79">    @Setter</span>
    private long interIterationInterval = 1_000;

    /**
     * Increments in which the period moves towards the maxPeriodDuration in every failed
     * iteration.
     */
<span class="nc" id="L86">    @Getter</span>
<span class="nc" id="L87">    @Setter</span>
    private long periodDelta = 1_000L;

    /**
     * Executes the policy once.
     * Checks for changes in the layout.
     * Then polls all the servers generates pollReport.
     *
     * @param layout Current Layout
     */
    public PollReport poll(@Nonnull Layout layout,
                           @Nonnull CorfuRuntime corfuRuntime) {

        Map&lt;String, IClientRouter&gt; routerMap;

        // Collect and set all responsive servers in the members array.
<span class="nc" id="L103">        Set&lt;String&gt; allResponsiveServersSet = layout.getAllServers();</span>
<span class="nc" id="L104">        allResponsiveServersSet.removeAll(layout.getUnresponsiveServers());</span>
<span class="nc" id="L105">        List&lt;String&gt; members = new ArrayList&lt;&gt;(allResponsiveServersSet);</span>

<span class="nc" id="L107">        log.debug(&quot;Responsive members to poll, {}&quot;, members);</span>

        // Set up arrays for routers to the endpoints.
<span class="nc" id="L110">        routerMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L111">        members.forEach(s -&gt; {</span>
            try {
<span class="nc" id="L113">                IClientRouter router = corfuRuntime.getRouter(s);</span>
<span class="nc" id="L114">                router.setTimeoutResponse(period);</span>
<span class="nc" id="L115">                routerMap.put(s, router);</span>
<span class="nc" id="L116">            } catch (NetworkException ne) {</span>
<span class="nc" id="L117">                log.error(&quot;Error creating router for {}&quot;, s);</span>
<span class="nc" id="L118">            }</span>
<span class="nc" id="L119">        });</span>
        // Perform polling of all responsive servers.
<span class="nc" id="L121">        return pollRound(layout.getEpoch(), members, routerMap);</span>

    }

    /**
     * PollRound consists of iterations. In each iteration, the FailureDetector pings all the
     * responsive nodes in the layout. If a node fails to respond in an iteration, the failure
     * detector increments the ping timeout period and starts a new iteration. If one or more nodes
     * are still failing to respond after running a predefined max number of iterations,
     * the FailureDetector generates poll report, suggesting those nodes to be unresponsive.
     * If all nodes respond within an iteration, Failure Detector generates poll report with all
     * nodes responsive.
     *
     * @return Poll Report with detected failed nodes and out of phase epoch nodes.
     */
    private PollReport pollRound(long epoch,
                                 List&lt;String&gt; members,
                                 Map&lt;String, IClientRouter&gt; routerMap) {

<span class="nc" id="L140">        Map&lt;String, Integer&gt; responsesMap = new HashMap&lt;&gt;();</span>
        // The out of phase epoch nodes are all those nodes which responded to the pings with a
        // wrong epoch exception. This is due to the pinged node being at a different epoch and
        // either this runtime needs to be updated or the node needs to catchup.
<span class="nc" id="L144">        Map&lt;String, Long&gt; expectedEpoch = new HashMap&lt;&gt;();</span>
<span class="nc" id="L145">        boolean failuresDetected = false;</span>

        // Node View map for analysis.
<span class="nc" id="L148">        Map&lt;String, NodeView&gt; nodeViewMap = new HashMap&lt;&gt;();</span>

        // In each iteration we poll all the servers in the members list.
<span class="nc bnc" id="L151" title="All 2 branches missed.">        for (int iteration = 0; iteration &lt; failureThreshold; iteration++) {</span>

            // Ping all nodes and await their responses.
<span class="nc" id="L154">            Map&lt;String, CompletableFuture&lt;NodeView&gt;&gt; pollCompletableFutures =</span>
<span class="nc" id="L155">                    pollOnceAsync(members, routerMap, epoch);</span>

            // Collect responses and increment response counters for successful pings.
            // Gather all nodeViews received in the responses in the nodeViewMap.
<span class="nc" id="L159">            Set&lt;String&gt; responses = collectResponsesAndVerifyEpochs(</span>
                    members,
                    pollCompletableFutures,
                    expectedEpoch,
                    nodeViewMap);

            // Aggregate the responses.
            // Return false if we received responses from all the members - failure NOT present.
<span class="nc bnc" id="L167" title="All 2 branches missed.">            failuresDetected = !responses.equals(new HashSet&lt;&gt;(members));</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">            if (!failuresDetected &amp;&amp; expectedEpoch.isEmpty()) {</span>
<span class="nc" id="L169">                break;</span>
            } else {
                // Timeout is increased anytime a failure is encountered.
                // Failure includes both, unresponsive and outOfPhaseEpoch nodes.
<span class="nc bnc" id="L173" title="All 2 branches missed.">                if (failuresDetected) {</span>
<span class="nc" id="L174">                    period = getIncreasedPeriod();</span>
<span class="nc" id="L175">                    tuneRoutersResponseTimeout(members, routerMap, new HashSet&lt;&gt;(members), period);</span>
                }
<span class="nc" id="L177">                final int pollIteration = iteration;</span>
<span class="nc" id="L178">                responses.forEach(s -&gt; responsesMap.put(s, pollIteration));</span>
            }
<span class="nc" id="L180">            Sleep.MILLISECONDS.sleepUninterruptibly(interIterationInterval);</span>
        }

        // End round and generate report.

<span class="nc" id="L185">        Set&lt;String&gt; failed = new HashSet&lt;&gt;();</span>

        // We can try to scale back the network latency time after every poll round.
        // If there are no failures, after a few rounds our polling period converges back to
        // initPeriodDuration.
<span class="nc" id="L190">        period = Math.max(initPeriodDuration, (period - periodDelta));</span>
<span class="nc" id="L191">        tuneRoutersResponseTimeout(members, routerMap, new HashSet&lt;&gt;(members), period);</span>

        // Check all responses and collect all failures.
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (failuresDetected) {</span>
<span class="nc" id="L195">            failed = members.stream()</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                    .filter(s -&gt; responsesMap.get(s) == null</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">                            || responsesMap.get(s) != (failureThreshold - 1))</span>
<span class="nc" id="L198">                    .collect(Collectors.toSet());</span>
        }
        // Reset the timeout of all the failed nodes to the max value to set a longer
        // timeout period to detect their response.
<span class="nc" id="L202">        tuneRoutersResponseTimeout(members, routerMap, failed, maxPeriodDuration);</span>

<span class="nc" id="L204">        return new PollReport.PollReportBuilder()</span>
<span class="nc" id="L205">                .pollEpoch(epoch)</span>
<span class="nc" id="L206">                .failingNodes(failed)</span>
<span class="nc" id="L207">                .outOfPhaseEpochNodes(expectedEpoch)</span>
<span class="nc" id="L208">                .nodeViewMap(nodeViewMap)</span>
<span class="nc" id="L209">                .build();</span>
    }

    /**
     * Poll all members servers once asynchronously and store their futures in
     * pollCompletableFutures.
     *
     * @param members   All active members in the layout.
     * @param routerMap Map of routers for all active members.
     * @param epoch     Current epoch for the polling round to stamp the ping messages.
     * @return Map of Completable futures for the pings.
     */
    private Map&lt;String, CompletableFuture&lt;NodeView&gt;&gt; pollOnceAsync(List&lt;String&gt; members,
                                                                   Map&lt;String, IClientRouter&gt;
                                                                           routerMap,
                                                                   final long epoch) {
        // Poll servers for health.  All ping activity will happen in the background.
<span class="nc" id="L226">        Map&lt;String, CompletableFuture&lt;NodeView&gt;&gt; pollCompletableFutures = new HashMap&lt;&gt;();</span>
<span class="nc" id="L227">        members.forEach(s -&gt; {</span>
            try {
<span class="nc" id="L229">                pollCompletableFutures.put(s, new ManagementClient(routerMap.get(s), epoch)</span>
<span class="nc" id="L230">                        .sendHeartbeatRequest());</span>
<span class="nc" id="L231">            } catch (Exception e) {</span>
<span class="nc" id="L232">                CompletableFuture&lt;NodeView&gt; cf = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L233">                cf.completeExceptionally(e);</span>
<span class="nc" id="L234">                pollCompletableFutures.put(s, cf);</span>
<span class="nc" id="L235">            }</span>
<span class="nc" id="L236">        });</span>
<span class="nc" id="L237">        return pollCompletableFutures;</span>
    }

    /**
     * Block on all poll futures and collect the responses. There are 3 possible cases.
     * 1. Receive a PONG. We set the responses[i] to the polling iteration number.
     * 2. WrongEpochException is thrown. We mark as a successful response but also record the
     * expected epoch.
     * 3. Other Exception is thrown. We do nothing. (The response[i] in this case is left behind.)
     */
    private Set&lt;String&gt; collectResponsesAndVerifyEpochs(
            List&lt;String&gt; members,
            Map&lt;String, CompletableFuture&lt;NodeView&gt;&gt; pollCompletableFutures,
            Map&lt;String, Long&gt; expectedEpoch,
            Map&lt;String, NodeView&gt; nodeViewMap) {
        // Collect responses and increment response counters for successful pings.
<span class="nc" id="L253">        Set&lt;String&gt; responses = new HashSet&lt;&gt;();</span>
<span class="nc" id="L254">        members.forEach(s -&gt; {</span>
            try {
<span class="nc" id="L256">                NodeView nodeView = CFUtils</span>
<span class="nc" id="L257">                        .within(pollCompletableFutures.get(s), Duration.ofMillis(period)).get();</span>
<span class="nc" id="L258">                responses.add(s);</span>
<span class="nc" id="L259">                expectedEpoch.remove(s);</span>
<span class="nc" id="L260">                nodeViewMap.put(s, nodeView);</span>
<span class="nc" id="L261">            } catch (Exception e) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (e.getCause() instanceof WrongEpochException) {</span>
<span class="nc" id="L263">                    responses.add(s);</span>
<span class="nc" id="L264">                    expectedEpoch.put(s, ((WrongEpochException) e.getCause()).getCorrectEpoch());</span>
                }
<span class="nc" id="L266">            }</span>
<span class="nc" id="L267">        });</span>
<span class="nc" id="L268">        return responses;</span>
    }

    /**
     * Function to increment the existing response timeout period.
     *
     * @return The new calculated timeout value.
     */
    private long getIncreasedPeriod() {
<span class="nc" id="L277">        return Math.min(maxPeriodDuration, (period + periodDelta));</span>
    }

    /**
     * Set the timeoutResponse for all the routers connected to the given endpoints with the
     * given value.
     *
     * @param endpoints Router endpoints.
     * @param timeout   New timeout value.
     */
    private void tuneRoutersResponseTimeout(List&lt;String&gt; members,
                                            Map&lt;String, IClientRouter&gt; routerMap,
                                            Set&lt;String&gt; endpoints,
                                            long timeout) {
<span class="nc" id="L291">        log.trace(&quot;Tuning router timeout responses for endpoints:{} to {}ms&quot;, endpoints, timeout);</span>
<span class="nc" id="L292">        members.forEach(s -&gt; {</span>
            // Change timeout delay of routers of members list.
<span class="nc bnc" id="L294" title="All 4 branches missed.">            if (endpoints.contains(s) &amp;&amp; routerMap.get(s) != null) {</span>
<span class="nc" id="L295">                routerMap.get(s).setTimeoutResponse(timeout);</span>
            }
<span class="nc" id="L297">        });</span>
<span class="nc" id="L298">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>